#define _IOSTREAM_
// yvals_core.h internal header (core)

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#ifndef _YVALS_CORE_H_
#define _YVALS_CORE_H_
#ifndef _STL_COMPILER_PREPROCESSOR
// All STL headers avoid exposing their contents when included by various
// non-C++-compiler tools to avoid breaking builds when we use newer language
// features in the headers than such tools understand.
#if defined(RC_INVOKED) || defined(Q_MOC_RUN) || defined(__midl)
#define _STL_COMPILER_PREPROCESSOR 0
#else
#define _STL_COMPILER_PREPROCESSOR 1
#endif
#endif // !defined(_STL_COMPILER_PREPROCESSOR)

#if _STL_COMPILER_PREPROCESSOR

// This does not use `_EMIT_STL_ERROR`, as it is checking the language itself.
#ifndef __cplusplus
#error error STL1003: Unexpected compiler, expected C++ compiler.
#endif // !defined(__cplusplus)

// Implemented unconditionally:
// N3911 void_t
// N4089 Safe Conversions In unique_ptr<T[]>
// N4169 invoke()
// N4258 noexcept Cleanups
// N4259 uncaught_exceptions()
// N4277 Trivially Copyable reference_wrapper
// N4279 insert_or_assign()/try_emplace() For map/unordered_map
// N4280 size(), empty(), data()
// N4366 Precisely Constraining unique_ptr Assignment
// N4387 Improving pair And tuple
// N4389 bool_constant
// N4508 shared_mutex (Untimed)
// N4510 Supporting Incomplete Types In vector/list/forward_list
// P0006R0 Variable Templates For Type Traits (is_same_v, etc.)
// P0007R1 as_const()
// P0013R1 Logical Operator Type Traits (conjunction, etc.)
// P0033R1 Rewording enable_shared_from_this
// P0063R3 C11 Standard Library
// P0074R0 owner_less<>
// P0092R1 <chrono> floor(), ceil(), round(), abs()
// P0340R3 SFINAE-Friendly underlying_type
// P0414R2 shared_ptr<T[]>, shared_ptr<T[N]>
// P0418R2 atomic compare_exchange memory_order Requirements
// P0435R1 Overhauling common_type
// P0497R0 Fixing shared_ptr For Arrays
// P0513R0 Poisoning hash
// P0516R0 Marking shared_future Copying As noexcept
// P0517R0 Constructing future_error From future_errc
// P0548R1 Tweaking common_type And duration
// P0558R1 Resolving atomic<T> Named Base Class Inconsistencies
// P0599R1 noexcept hash
// P0738R2 istream_iterator Cleanup
// P0771R1 noexcept For std::function's Move Constructor
// P0777R1 Avoiding Unnecessary decay
// P0809R0 Comparing Unordered Containers
// P0883R2 Fixing Atomic Initialization
// P0935R0 Eradicating Unnecessarily Explicit Default Constructors
// P0941R2 Feature-Test Macros
// P0972R0 noexcept For <chrono> zero(), min(), max()
// P1065R2 constexpr INVOKE
//     (the std::invoke function only; other components like bind and reference_wrapper are C++20 only)
// P1164R1 Making create_directory() Intuitive
// P1165R1 Consistently Propagating Stateful Allocators In basic_string's operator+()
// P1902R1 Missing Feature-Test Macros 2017-2019
// P2013R5 Freestanding Language: Optional ::operator new
//     (no change is needed for our hosted implementation)
// P2198R7 Freestanding Feature-Test Macros And Implementation-Defined Extensions
//     (except for __cpp_lib_freestanding_ranges)
// P2338R4 Freestanding Library: Character Primitives And The C Library
//     (except for __cpp_lib_freestanding_charconv)
// P2401R0 Conditional noexcept For exchange()
// P2937R0 Freestanding Library: Remove strtok

// _HAS_CXX17 directly controls:
// P0005R4 not_fn()
// P0024R2 Parallel Algorithms
// P0025R1 clamp()
// P0030R1 hypot(x, y, z)
// P0031R0 constexpr For <array> (Again) And <iterator>
// P0032R3 Homogeneous Interface For variant/any/optional
// P0040R3 Extending Memory Management Tools
// P0067R5 Elementary String Conversions
// P0083R3 Splicing Maps And Sets
// P0084R2 Emplace Return Type
// P0088R3 <variant>
// P0137R1 launder()
// P0152R1 atomic::is_always_lock_free
// P0154R1 hardware_destructive_interference_size, etc.
// P0156R2 scoped_lock
// P0163R0 shared_ptr::weak_type
// P0185R1 is_swappable, is_nothrow_swappable
// P0209R2 make_from_tuple()
// P0218R1 <filesystem>
// P0220R1 <any>, <memory_resource>, <optional>, <string_view>, apply(), sample(), Boyer-Moore search()
// P0226R1 Mathematical Special Functions
// P0253R1 Fixing Searcher Return Types
// P0254R2 Integrating string_view And std::string
// P0258R2 has_unique_object_representations
// P0272R1 Non-const basic_string::data()
// P0295R0 gcd(), lcm()
// P0307R2 Making Optional Greater Equal Again
// P0336R1 Renaming Parallel Execution Policies
// P0337R0 Deleting polymorphic_allocator Assignment
// P0358R1 Fixes For not_fn()
// P0393R3 Making Variant Greater Equal
// P0394R4 Parallel Algorithms Should terminate() For Exceptions
// P0403R1 UDLs For <string_view> ("meow"sv, etc.)
// P0426R1 constexpr For char_traits
// P0433R2 Deduction Guides For The STL
// P0452R1 Unifying <numeric> Parallel Algorithms
// P0504R0 Revisiting in_place_t/in_place_type_t<T>/in_place_index_t<I>
// P0505R0 constexpr For <chrono> (Again)
// P0508R0 Clarifying insert_return_type
// P0510R0 Rejecting variants Of Nothing, Arrays, References, And Incomplete Types
// P0602R4 Propagating Copy/Move Triviality In variant/optional
// P0604R0 invoke_result, is_invocable, is_nothrow_invocable
// P0607R0 Inline Variables For The STL
// P0682R1 Repairing Elementary String Conversions
// P0739R0 Improving Class Template Argument Deduction For The STL
// P0858R0 Constexpr Iterator Requirements
// P1169R4 static operator()
// P1518R2 Stop Overconstraining Allocators In Container Deduction Guides
// P2162R2 Inheriting From variant
// P2251R1 Require span And basic_string_view To Be Trivially Copyable
//     (basic_string_view always provides this behavior)
// P2338R4 Freestanding Library: Character Primitives And The C Library
//     (including __cpp_lib_freestanding_charconv)
// P2517R1 Conditional noexcept For apply()

// _HAS_CXX17 indirectly controls:
// N4190 Removing auto_ptr, random_shuffle(), And Old <functional> Stuff
// P0003R5 Removing Dynamic Exception Specifications
// P0004R1 Removing Deprecated Iostreams Aliases
// P0298R3 std::byte
// P0302R1 Removing Allocator Support In std::function
// LWG-2385 function::assign allocator argument doesn't make sense
// LWG-2921 packaged_task and type-erased allocators
// LWG-2976 Dangling uses_allocator specialization for packaged_task
// The non-Standard std::tr1 namespace and TR1-only machinery
// Enforcement of matching allocator value_types

// _HAS_CXX17 and _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS control:
// P0174R2 Deprecating Vestigial Library Parts
// P0521R0 Deprecating shared_ptr::unique()
// P0618R0 Deprecating <codecvt>
// Other C++17 deprecation warnings

// Implemented when char8_t is available (C++14/17 with /Zc:char8_t, C++20 without /Zc:char8_t-):
// P0482R6 Library Support For char8_t
//     (mbrtoc8 and c8rtomb not yet implemented, see GH-2207)

// _HAS_CXX20 directly controls:
// P0019R8 atomic_ref
// P0020R6 atomic<float>, atomic<double>, atomic<long double>
// P0053R7 <syncstream>
// P0122R7 <span>
// P0202R3 constexpr For <algorithm> And exchange()
// P0318R1 unwrap_reference, unwrap_ref_decay
// P0325R4 to_array()
// P0339R6 polymorphic_allocator<>
// P0355R7 <chrono> Calendars And Time Zones
// P0356R5 bind_front()
// P0357R3 Supporting Incomplete Types In reference_wrapper
// P0408R7 Efficient Access To basic_stringbuf's Buffer
// P0415R1 constexpr For <complex> (Again)
// P0439R0 enum class memory_order
// P0457R2 starts_with()/ends_with() For basic_string/basic_string_view
// P0458R2 contains() For Ordered And Unordered Associative Containers
// P0463R1 endian
// P0466R5 Layout-Compatibility And Pointer-Interconvertibility Traits
// P0475R1 Guaranteed Copy Elision For Piecewise Construction
// P0476R2 <bit> bit_cast
// P0487R1 Fixing operator>>(basic_istream&, CharT*)
// P0528R3 Atomic Compare-And-Exchange With Padding Bits
// P0550R2 remove_cvref
// P0553R4 <bit> Rotating And Counting Functions
// P0556R3 <bit> Integral Power-Of-2 Operations (renamed by P1956R1)
// P0586R2 Integer Comparison Functions
// P0591R4 Utility Functions For Uses-Allocator Construction
// P0595R2 is_constant_evaluated()
// P0608R3 Improving variant's Converting Constructor/Assignment
// P0616R0 Using move() In <numeric>
// P0631R8 <numbers> Math Constants
// P0645R10 <format> Text Formatting
// P0646R1 list/forward_list remove()/remove_if()/unique() Return size_type
// P0653R2 to_address()
// P0655R1 visit<R>()
// P0660R10 <stop_token> And jthread
// P0674R1 make_shared() For Arrays
// P0718R2 atomic<shared_ptr<T>>, atomic<weak_ptr<T>>
// P0753R2 osyncstream Manipulators
// P0758R1 is_nothrow_convertible
// P0768R1 Library Support For The Spaceship Comparison Operator <=>
// P0769R2 shift_left(), shift_right()
// P0784R7 Library Support For More constexpr Containers
// P0811R3 midpoint(), lerp()
// P0849R8 auto(x): decay-copy In The Language
//     (library part only)
// P0879R0 constexpr For Swapping Functions
// P0887R1 type_identity
// P0896R4 Ranges
// P0898R3 Standard Library Concepts
// P0912R5 Library Support For Coroutines
// P0919R3 Heterogeneous Lookup For Unordered Containers
// P0966R1 string::reserve() Should Not Shrink
// P0980R1 constexpr std::string
// P1001R2 execution::unseq
// P1004R2 constexpr std::vector
// P1006R1 constexpr For pointer_traits<T*>::pointer_to()
// P1007R3 assume_aligned()
// P1020R1 Smart Pointer Creation With Default Initialization
// P1023R0 constexpr For std::array Comparisons
// P1024R3 Enhancing span Usability
// P1032R1 Miscellaneous constexpr
// P1035R7 Input Range Adaptors
// P1065R2 constexpr INVOKE
//     (except the std::invoke function which is implemented unconditionally)
// P1085R2 Removing span Comparisons
// P1115R3 erase()/erase_if() Return size_type
// P1123R0 Atomic Compare-And-Exchange With Padding Bits For atomic_ref
// P1135R6 The C++20 Synchronization Library
// P1207R4 Movability Of Single-Pass Iterators
// P1208R6 <source_location>
// P1209R0 erase_if(), erase()
// P1227R2 Signed std::ssize(), Unsigned span::size()
// P1243R4 Rangify New Algorithms
// P1248R1 Fixing Relations
// P1252R2 Ranges Design Cleanup
// P1357R1 is_bounded_array, is_unbounded_array
// P1391R4 Range Constructor For string_view
// P1394R4 Range Constructor For span
// P1423R3 char8_t Backward Compatibility Remediation
// P1456R1 Move-Only Views
// P1474R1 Helpful Pointers For contiguous_iterator
// P1522R1 Iterator Difference Type And Integer Overflow
// P1523R1 Views And Size Types
// P1612R1 Relocating endian To <bit>
// P1614R2 Adding Spaceship <=> To The Library
// P1638R1 basic_istream_view::iterator Should Not Be Copyable
// P1645R1 constexpr For <numeric> Algorithms
// P1651R0 bind_front() Should Not Unwrap reference_wrapper
// P1690R1 Refining Heterogeneous Lookup For Unordered Containers
// P1716R3 Range Comparison Algorithms Are Over-Constrained
// P1739R4 Avoiding Template Bloat For Ranges
// P1754R1 Rename Concepts To standard_case
// P1862R1 Range Adaptors For Non-Copyable Iterators
// P1865R1 Adding max() To latch And barrier
// P1870R1 Rename forwarding-range To borrowed_range (Was safe_range before LWG-3379)
// P1871R1 disable_sized_sentinel_for
// P1872R0 span Should Have size_type, Not index_type
// P1878R1 Constraining Readable Types
// P1907R2 ranges::ssize
// P1956R1 <bit> has_single_bit(), bit_ceil(), bit_floor(), bit_width()
// P1959R0 Removing weak_equality And strong_equality
// P1960R0 atomic_ref Cleanup
// P1964R2 Replacing boolean With boolean-testable
// P1973R1 Renaming default_init To for_overwrite
// P1976R2 Explicit Constructors For Fixed-Extent span From Dynamic-Extent Ranges
// P1983R0 Fixing Minor Ranges Issues
// P1994R1 elements_view Needs Its Own sentinel
// P2017R1 Conditionally Borrowed Ranges
// P2091R0 Fixing Issues With Range Access CPOs
// P2102R0 Making "Implicit Expression Variations" More Explicit
// P2106R0 Range Algorithm Result Types
// P2116R0 Removing tuple-Like Protocol Support From Fixed-Extent span
// P2167R3 Improving boolean-testable Usage
// P2198R7 Freestanding Feature-Test Macros And Implementation-Defined Extensions
//     (including __cpp_lib_freestanding_ranges)
// P2210R2 Superior String Splitting
// P2216R3 std::format Improvements
// P2231R1 Completing constexpr In optional And variant
// P2251R1 Require span And basic_string_view To Be Trivially Copyable
//     (span always provides this behavior)
// P2259R1 Repairing Input Range Adaptors And counted_iterator
// P2281R1 Clarifying Range Adaptor Objects
// P2325R3 Views Should Not Be Required To Be Default Constructible
// P2328R1 join_view Should Join All views Of ranges
// P2367R0 Remove Misuses Of List-Initialization From Clause 24 Ranges
// P2372R3 Fixing Locale Handling In chrono Formatters
// P2393R1 Cleaning Up Integer-Class Types
// P2408R5 Ranges Iterators As Inputs To Non-Ranges Algorithms
// P2415R2 What Is A view?
// P2418R2 Add Support For std::generator-like Types To std::format
// P2419R2 Clarify Handling Of Encodings In Localized Formatting Of chrono Types
// P2432R1 Fix istream_view
// P2465R3 Standard Library Modules std And std.compat
// P2508R1 basic_format_string, format_string, wformat_string
// P2510R3 Formatting Pointers
// P2520R0 move_iterator<T*> Should Be A Random-Access Iterator
// P2538R1 ADL-Proof projected
// P2572R1 std::format Fill Character Allowances
// P2588R3 barrier's Phase Completion Guarantees
// P2602R2 Poison Pills Are Too Toxic
// P2609R3 Relaxing Ranges Just A Smidge
// P2655R3 common_reference_t Of reference_wrapper Should Be A Reference Type
// P2675R1 Improving std::format's Width Estimation
// P2711R1 Making Multi-Param Constructors Of Views explicit
// P2736R2 Referencing The Unicode Standard
// P2770R0 Stashing Stashing Iterators For Proper Flattening
// P2905R2 Runtime Format Strings
// P2909R4 Fix Formatting Of Code Units As Integers

// _HAS_CXX20 indirectly controls:
// P0619R4 Removing C++17-Deprecated Features

// _HAS_CXX20 and _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS control:
// P0767R1 Deprecating is_pod
// P1831R1 Deprecating volatile In The Standard Library
// Other C++20 deprecation warnings

// _HAS_CXX23 directly controls:
// P0009R18 <mdspan>
// P0288R9 move_only_function
// P0323R12 <expected>
// P0401R6 Providing Size Feedback In The Allocator Interface
// P0448R4 <spanstream>
// P0627R6 unreachable()
// P0798R8 Monadic Operations For optional
// P0881R7 <stacktrace>
// P0943R6 Supporting C Atomics In C++
// P1048R1 is_scoped_enum
// P1072R10 basic_string::resize_and_overwrite
// P1132R7 out_ptr(), inout_ptr()
// P1147R1 Printing volatile Pointers
// P1206R7 Conversions From Ranges To Containers
// P1223R5 ranges::find_last, ranges::find_last_if, ranges::find_last_if_not
// P1272R4 byteswap()
// P1328R1 constexpr type_info::operator==()
// P1425R4 Iterator Pair Constructors For stack And queue
// P1467R9 Extended Floating-Point Types
//     (only the <stdfloat> header; we don't support any optional extended floating-point types)
// P1659R3 ranges::starts_with, ranges::ends_with
// P1679R3 contains() For basic_string/basic_string_view
// P1682R3 to_underlying() For Enumerations
// P1899R3 views::stride
// P1951R1 Default Template Arguments For pair's Forwarding Constructor
// P1989R2 Range Constructor For string_view
// P2077R3 Heterogeneous Erasure Overloads For Associative Containers
// P2093R14 <print>: Formatted Output
// P2136R3 invoke_r()
// P2164R9 views::enumerate
// P2165R4 Compatibility Between tuple, pair, And tuple-like Objects
// P2166R1 Prohibiting basic_string And basic_string_view Construction From nullptr
// P2186R2 Removing Garbage Collection Support
// P2273R3 constexpr unique_ptr
// P2278R4 cbegin Should Always Return A Constant Iterator
// P2286R8 Formatting Ranges
//     (only the '?' format specifier for strings and characters)
// P2291R3 constexpr Integral <charconv>
// P2302R4 ranges::contains, ranges::contains_subrange
// P2321R2 zip
// P2322R6 ranges::fold_left, ranges::fold_right, Etc.
// P2374R4 views::cartesian_product
// P2387R3 Pipe Support For User-Defined Range Adaptors
// P2404R3 Move-Only Types For Comparison Concepts
// P2417R2 More constexpr bitset
// P2438R2 string::substr() &&
// P2440R1 ranges::iota, ranges::shift_left, ranges::shift_right
// P2441R2 views::join_with
// P2442R1 Windowing Range Adaptors: views::chunk, views::slide
// P2443R1 views::chunk_by
// P2445R1 forward_like()
// P2446R2 views::as_rvalue
// P2467R1 ios_base::noreplace: Exclusive Mode For fstreams
// P2474R2 views::repeat
// P2494R2 Relaxing Range Adaptors To Allow Move-Only Types
// P2499R0 string_view Range Constructor Should Be explicit
// P2505R5 Monadic Functions For expected
// P2539R4 Synchronizing print() With The Underlying Stream
// P2540R1 Empty Product For Certain Views
// P2549R1 unexpected<E>::error()
// P2599R2 mdspan: index_type, size_type
// P2604R0 mdspan: data_handle_type, data_handle(), exhaustive
// P2613R1 mdspan: empty()
// P2652R2 Disallowing User Specialization Of allocator_traits
// P2693R1 Formatting thread::id And stacktrace
// P2713R1 Escaping Improvements In std::format
// P2763R1 Fixing layout_stride's Default Constructor For Fully Static Extents
// P2836R1 basic_const_iterator Should Follow Its Underlying Type's Convertibility

// _HAS_CXX23 and _SILENCE_ALL_CXX23_DEPRECATION_WARNINGS control:
// P1413R3 Deprecate aligned_storage And aligned_union
// P2614R2 Deprecating float_denorm_style, numeric_limits::has_denorm, numeric_limits::has_denorm_loss
// Other C++23 deprecation warnings

// Parallel Algorithms Notes
// C++ allows an implementation to implement parallel algorithms as calls to the serial algorithms.
// This implementation parallelizes several common algorithm calls, but not all.
//
// std::execution::unseq has no direct analogue for any optimizer we target as of 2020-07-29,
// though we will map it to #pragma loop(ivdep) for the for_each algorithms only as these are the only algorithms where
// the library does not need to introduce inter-loop-body dependencies to accomplish the algorithm's goals.
//
// The following algorithms are parallelized.
// * adjacent_difference
// * adjacent_find
// * all_of
// * any_of
// * count
// * count_if
// * destroy
// * destroy_n
// * equal
// * exclusive_scan
// * find
// * find_end
// * find_first_of
// * find_if
// * find_if_not
// * for_each
// * for_each_n
// * inclusive_scan
// * is_heap
// * is_heap_until
// * is_partitioned
// * is_sorted
// * is_sorted_until
// * mismatch
// * none_of
// * partition
// * reduce
// * remove
// * remove_if
// * replace
// * replace_if
// * search
// * search_n
// * set_difference
// * set_intersection
// * sort
// * stable_sort
// * transform
// * transform_exclusive_scan
// * transform_inclusive_scan
// * transform_reduce
// * uninitialized_default_construct
// * uninitialized_default_construct_n
// * uninitialized_value_construct
// * uninitialized_value_construct_n
//
// The following are not presently parallelized:
//
// No apparent parallelism performance improvement on target hardware; all algorithms which
// merely copy or permute elements with no branches are typically memory bandwidth limited.
// * copy
// * copy_n
// * fill
// * fill_n
// * move
// * reverse
// * reverse_copy
// * rotate
// * rotate_copy
// * shift_left
// * shift_right
// * swap_ranges
//
// Possibly same as above, but not yet tested.
// * uninitialized_copy
// * uninitialized_copy_n
// * uninitialized_fill
// * uninitialized_fill_n
// * uninitialized_move
// * uninitialized_move_n
//
// Confusion over user parallelism requirements exists; likely in the above category anyway.
// * generate
// * generate_n
//
// Effective parallelism suspected to be infeasible.
// * partial_sort
// * partial_sort_copy
//
// Not yet evaluated; parallelism may be implemented in a future release and is suspected to be beneficial.
// * copy_if
// * includes
// * inplace_merge
// * lexicographical_compare
// * max_element
// * merge
// * min_element
// * minmax_element
// * nth_element
// * partition_copy
// * remove_copy
// * remove_copy_if
// * replace_copy
// * replace_copy_if
// * set_symmetric_difference
// * set_union
// * stable_partition
// * unique
// * unique_copy

//
// vcruntime.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Declarations used throughout the VCRuntime library.
//
#pragma once
//
// Note on use of "deprecate":
//
// Various places in this header and other headers use
// __declspec(deprecate) or macros that have the term DEPRECATE in them.
// We use "deprecate" here ONLY to signal the compiler to emit a warning
// about these items. The use of "deprecate" should NOT be taken to imply
// that any standard committee has deprecated these functions from the
// relevant standards.  In fact, these functions are NOT deprecated from
// the standard.
//
// Full details can be found in our documentation by searching for
// "Security Enhancements in the CRT".
//
#ifndef _VCRUNTIME_H
#define _VCRUNTIME_H

#ifndef _VCRT_COMPILER_PREPROCESSOR
// Many VCRuntime headers avoid exposing their contents to non-compilers like
// the Windows resource compiler and Qt's meta-object compiler (moc).
#if defined(RC_INVOKED) || defined(Q_MOC_RUN)
#define _VCRT_COMPILER_PREPROCESSOR 0
#else
#define _VCRT_COMPILER_PREPROCESSOR 1
#endif
#endif // _VCRT_COMPILER_PREPROCESSOR

#ifndef _UCRT
#define _UCRT
#endif

// The _CRTIMP macro is not used in the VCRuntime or the CoreCRT anymore, but
// there is a lot of existing code that declares CRT functions using this macro,
// and if we remove its definition, we break that existing code.  It is thus
// defined here only for compatibility.
#ifndef _CRTIMP
#define _VCRT_DEFINED_CRTIMP
#if defined CRTDLL && defined _CRTBLD
#define _CRTIMP __declspec(dllexport)
#else
#ifdef _DLL
#define _CRTIMP __declspec(dllimport)
#else
#define _CRTIMP
#endif
#endif
#endif

/***
*sal.h - markers for documenting the semantics of APIs
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       sal.h provides a set of annotations to describe how a function uses its
*       parameters - the assumptions it makes about them, and the guarantees it makes
*       upon finishing.
*
*       [Public]
*
****/
#pragma once

/*==========================================================================

   The comments in this file are intended to give basic understanding of
   the usage of SAL, the Microsoft Source Code Annotation Language.
   For more details, please see https://go.microsoft.com/fwlink/?LinkID=242134

   The macros are defined in 3 layers, plus the structural set:

   _In_/_Out_/_Ret_ Layer:
   ----------------------
   This layer provides the highest abstraction and its macros should be used
   in most cases. These macros typically start with:
      _In_     : input parameter to a function, unmodified by called function
      _Out_    : output parameter, written to by called function, pointed-to
                 location not expected to be initialized prior to call
      _Outptr_ : like _Out_ when returned variable is a pointer type
                 (so param is pointer-to-pointer type). Called function
                 provides/allocated space.
      _Outref_ : like _Outptr_, except param is reference-to-pointer type.
      _Inout_  : inout parameter, read from and potentially modified by
                 called function.
      _Ret_    : for return values
      _Field_  : class/struct field invariants
   For common usage, this class of SAL provides the most concise annotations.
   Note that _In_/_Out_/_Inout_/_Outptr_ annotations are designed to be used
   with a parameter target. Using them with _At_ to specify non-parameter
   targets may yield unexpected results.

   This layer also includes a number of other properties that can be specified
   to extend the ability of code analysis, most notably:
      -- Designating parameters as format strings for printf/scanf/scanf_s
      -- Requesting stricter type checking for C enum parameters

   _Pre_/_Post_ Layer:
   ------------------
   The macros of this layer only should be used when there is no suitable macro
   in the _In_/_Out_ layer. Its macros start with _Pre_ or _Post_.
   This layer provides the most flexibility for annotations.

   Implementation Abstraction Layer:
   --------------------------------
   Macros from this layer should never be used directly. The layer only exists
   to hide the implementation of the annotation macros.

   Structural Layer:
   ----------------
   These annotations, like _At_ and _When_, are used with annotations from
   any of the other layers as modifiers, indicating exactly when and where
   the annotations apply.


   Common syntactic conventions:
   ----------------------------

   Usage:
   -----
   _In_, _Out_, _Inout_, _Pre_, _Post_, are for formal parameters.
   _Ret_, _Deref_ret_ must be used for return values.

   Nullness:
   --------
   If the parameter can be NULL as a precondition to the function, the
   annotation contains _opt. If the macro does not contain '_opt' the
   parameter cannot be NULL.

   If an out/inout parameter returns a null pointer as a postcondition, this is
   indicated by _Ret_maybenull_ or _result_maybenull_. If the macro is not
   of this form, then the result will not be NULL as a postcondition.
     _Outptr_ - output value is not NULL
     _Outptr_result_maybenull_ - output value might be NULL

   String Type:
   -----------
   _z: NullTerminated string
   for _In_ parameters the buffer must have the specified stringtype before the call
   for _Out_ parameters the buffer must have the specified stringtype after the call
   for _Inout_ parameters both conditions apply

   Extent Syntax:
   -------------
   Buffer sizes are expressed as element counts, unless the macro explicitly
   contains _byte_ or _bytes_. Some annotations specify two buffer sizes, in
   which case the second is used to indicate how much of the buffer is valid
   as a postcondition. This table outlines the precondition buffer allocation
   size, precondition number of valid elements, postcondition allocation size,
   and postcondition number of valid elements for representative buffer size
   annotations:
                                     Pre    |  Pre    |  Post   |  Post
                                     alloc  |  valid  |  alloc  |  valid
      Annotation                     elems  |  elems  |  elems  |  elems
      ----------                     ------------------------------------
      _In_reads_(s)                    s    |   s     |   s     |   s
      _Inout_updates_(s)               s    |   s     |   s     |   s
      _Inout_updates_to_(s,c)          s    |   s     |   s     |   c
      _Out_writes_(s)                  s    |   0     |   s     |   s
      _Out_writes_to_(s,c)             s    |   0     |   s     |   c
      _Outptr_result_buffer_(s)        ?    |   ?     |   s     |   s
      _Outptr_result_buffer_to_(s,c)   ?    |   ?     |   s     |   c

   For the _Outptr_ annotations, the buffer in question is at one level of
   dereference. The called function is responsible for supplying the buffer.

   Success and failure:
   -------------------
   The SAL concept of success allows functions to define expressions that can
   be tested by the caller, which if it evaluates to non-zero, indicates the
   function succeeded, which means that its postconditions are guaranteed to
   hold.  Otherwise, if the expression evaluates to zero, the function is
   considered to have failed, and the postconditions are not guaranteed.

   The success criteria can be specified with the _Success_(expr) annotation:
     _Success_(return != FALSE) BOOL
     PathCanonicalizeA(_Out_writes_(MAX_PATH) LPSTR pszBuf, LPCSTR pszPath) :
        pszBuf is only guaranteed to be NULL-terminated when TRUE is returned,
        and FALSE indicates failure. In common practice, callers check for zero
        vs. non-zero returns, so it is preferable to express the success
        criteria in terms of zero/non-zero, not checked for exactly TRUE.

   Functions can specify that some postconditions will still hold, even when
   the function fails, using _On_failure_(anno-list), or postconditions that
   hold regardless of success or failure using _Always_(anno-list).

   The annotation _Return_type_success_(expr) may be used with a typedef to
   give a default _Success_ criteria to all functions returning that type.
   This is the case for common Windows API status types, including
   HRESULT and NTSTATUS.  This may be overridden on a per-function basis by
   specifying a _Success_ annotation locally.

============================================================================*/

#define __ATTR_SAL

#ifndef _SAL_VERSION
#define _SAL_VERSION 20
#endif

#ifndef __SAL_H_VERSION
#define __SAL_H_VERSION 180000000
#endif

#ifdef _PREFAST_ // [

// choose attribute or __declspec implementation
#ifndef _USE_DECLSPECS_FOR_SAL // [
#define _USE_DECLSPECS_FOR_SAL 1
#endif // ]

#if _USE_DECLSPECS_FOR_SAL // [
#undef _USE_ATTRIBUTES_FOR_SAL
#define _USE_ATTRIBUTES_FOR_SAL 0
#elif !defined(_USE_ATTRIBUTES_FOR_SAL) // ][
#define _USE_ATTRIBUTES_FOR_SAL 1
#endif // ]


#if !_USE_DECLSPECS_FOR_SAL // [
#if !_USE_ATTRIBUTES_FOR_SAL // [
#undef _USE_ATTRIBUTES_FOR_SAL
#define _USE_ATTRIBUTES_FOR_SAL 1
#endif // ]
#endif // ]

#else

// Disable expansion of SAL macros in non-Prefast mode to
// improve compiler throughput.
#ifndef _USE_DECLSPECS_FOR_SAL // [
#define _USE_DECLSPECS_FOR_SAL 0
#endif // ]
#ifndef _USE_ATTRIBUTES_FOR_SAL // [
#define _USE_ATTRIBUTES_FOR_SAL 0
#endif // ]

#endif // ]

// safeguard for MIDL and RC builds
#if _USE_DECLSPECS_FOR_SAL && ( defined( MIDL_PASS ) || defined(__midl) || defined(RC_INVOKED) || !defined(_PREFAST_) ) // [
#undef _USE_DECLSPECS_FOR_SAL
#define _USE_DECLSPECS_FOR_SAL 0
#endif // ]
#if _USE_ATTRIBUTES_FOR_SAL && ( !defined(_MSC_EXTENSIONS) || defined( MIDL_PASS ) || defined(__midl) || defined(RC_INVOKED) ) // [
#undef _USE_ATTRIBUTES_FOR_SAL
#define _USE_ATTRIBUTES_FOR_SAL 0
#endif // ]

#if _USE_DECLSPECS_FOR_SAL || _USE_ATTRIBUTES_FOR_SAL

// Special enum type for Y/N/M
enum __SAL_YesNo { _SAL_notpresent, _SAL_no, _SAL_maybe, _SAL_yes, _SAL_default };

#endif

#if defined(UNDOCKED_WINDOWS_UCRT) && !_USE_ATTRIBUTES_FOR_SAL
#define _SAL1_Source_(Name, args, annotes) _SA_annotes3(SAL_name, #Name, "", "1") _GrouP_(annotes _SAL_nop_impl_)
#define _SAL1_1_Source_(Name, args, annotes) _SA_annotes3(SAL_name, #Name, "", "1.1") _GrouP_(annotes _SAL_nop_impl_)
#define _SAL1_2_Source_(Name, args, annotes) _SA_annotes3(SAL_name, #Name, "", "1.2") _GrouP_(annotes _SAL_nop_impl_)
#define _SAL2_Source_(Name, args, annotes) _SA_annotes3(SAL_name, #Name, "", "2") _GrouP_(annotes _SAL_nop_impl_)

#ifndef _SAL_L_Source_
// Some annotations aren't officially SAL2 yet.
#define _SAL_L_Source_(Name, args, annotes) _SA_annotes3(SAL_name, #Name, "", "2") _GrouP_(annotes _SAL_nop_impl_)
#endif
#else
#define _SAL1_Source_(Name, args, annotes) _SA_annotes3(SAL_name, #Name, "", "1") _Group_(annotes _SAL_nop_impl_)
#define _SAL1_1_Source_(Name, args, annotes) _SA_annotes3(SAL_name, #Name, "", "1.1") _Group_(annotes _SAL_nop_impl_)
#define _SAL1_2_Source_(Name, args, annotes) _SA_annotes3(SAL_name, #Name, "", "1.2") _Group_(annotes _SAL_nop_impl_)
#define _SAL2_Source_(Name, args, annotes) _SA_annotes3(SAL_name, #Name, "", "2") _Group_(annotes _SAL_nop_impl_)

#ifndef _SAL_L_Source_
// Some annotations aren't officially SAL2 yet.
#define _SAL_L_Source_(Name, args, annotes) _SA_annotes3(SAL_name, #Name, "", "2") _Group_(annotes _SAL_nop_impl_)
#endif
#endif


//============================================================================
//   Structural SAL:
//     These annotations modify the use of other annotations.  They may
//     express the annotation target (i.e. what parameter/field the annotation
//     applies to) or the condition under which the annotation is applicable.
//============================================================================

// _At_(target, annos) specifies that the annotations listed in 'annos' is to
// be applied to 'target' rather than to the identifier which is the current
// lexical target.
#define _At_(target, annos)            _At_impl_(target, annos _SAL_nop_impl_)

// _At_buffer_(target, iter, bound, annos) is similar to _At_, except that
// target names a buffer, and each annotation in annos is applied to each
// element of target up to bound, with the variable named in iter usable
// by the annotations to refer to relevant offsets within target.
#define _At_buffer_(target, iter, bound, annos)  _At_buffer_impl_(target, iter, bound, annos _SAL_nop_impl_)

// _When_(expr, annos) specifies that the annotations listed in 'annos' only
// apply when 'expr' evaluates to non-zero.
#define _When_(expr, annos)            _When_impl_(expr, annos _SAL_nop_impl_)
#define _Group_(annos)                 _Group_impl_(annos _SAL_nop_impl_)
#define _GrouP_(annos)                 _GrouP_impl_(annos _SAL_nop_impl_)

// <expr> indicates whether normal post conditions apply to a function
#define _Success_(expr)                  _SAL2_Source_(_Success_, (expr), _Success_impl_(expr))

// <expr> indicates whether post conditions apply to a function returning
// the type that this annotation is applied to
#define _Return_type_success_(expr)      _SAL2_Source_(_Return_type_success_, (expr), _Success_impl_(expr))

// Establish postconditions that apply only if the function does not succeed
#define _On_failure_(annos)              _On_failure_impl_(annos _SAL_nop_impl_)

// Establish postconditions that apply in both success and failure cases.
// Only applicable with functions that have  _Success_ or _Return_type_succss_.
#define _Always_(annos)                  _Always_impl_(annos _SAL_nop_impl_)

// Usable on a function defintion. Asserts that a function declaration is
// in scope, and its annotations are to be used. There are no other annotations
// allowed on the function definition.
#define _Use_decl_annotations_         _Use_decl_anno_impl_

// _Notref_ may precede a _Deref_ or "real" annotation, and removes one
// level of dereference if the parameter is a C++ reference (&).  If the
// net deref on a "real" annotation is negative, it is simply discarded.
#define _Notref_                       _Notref_impl_

// Annotations for defensive programming styles.
#define _Pre_defensive_             _SA_annotes0(SAL_pre_defensive)
#define _Post_defensive_            _SA_annotes0(SAL_post_defensive)

#define _In_defensive_(annotes)     _Pre_defensive_ _Group_(annotes)
#define _Out_defensive_(annotes)    _Post_defensive_ _Group_(annotes)
#define _Inout_defensive_(annotes)  _Pre_defensive_ _Post_defensive_ _Group_(annotes)

//============================================================================
//   _In_/_Out_ Layer:
//============================================================================

// Reserved pointer parameters, must always be NULL.
#define _Reserved_                      _SAL2_Source_(_Reserved_, (), _Pre1_impl_(__null_impl))

// _Const_ allows specification that any namable memory location is considered
// readonly for a given call.
#define _Const_                         _SAL2_Source_(_Const_, (), _Pre1_impl_(__readaccess_impl_notref))


// Input parameters --------------------------

//   _In_ - Annotations for parameters where data is passed into the function, but not modified.
//          _In_ by itself can be used with non-pointer types (although it is redundant).

// e.g. void SetPoint( _In_ const POINT* pPT );
#define _In_                            _SAL2_Source_(_In_, (), _Pre1_impl_(__notnull_impl_notref) _Pre_valid_impl_ _Deref_pre1_impl_(__readaccess_impl_notref))
#define _In_opt_                        _SAL2_Source_(_In_opt_, (), _Pre1_impl_(__maybenull_impl_notref) _Pre_valid_impl_ _Deref_pre_readonly_)

// nullterminated 'in' parameters.
// e.g. void CopyStr( _In_z_ const char* szFrom, _Out_z_cap_(cchTo) char* szTo, size_t cchTo );
#define _In_z_                          _SAL2_Source_(_In_z_, (),     _In_     _Pre1_impl_(__zterm_impl))
#define _In_opt_z_                      _SAL2_Source_(_In_opt_z_, (), _In_opt_ _Pre1_impl_(__zterm_impl))


// 'input' buffers with given size

#define _In_reads_(size)               _SAL2_Source_(_In_reads_, (size), _Pre_count_(size)          _Deref_pre_readonly_)
#define _In_reads_opt_(size)           _SAL2_Source_(_In_reads_opt_, (size), _Pre_opt_count_(size)      _Deref_pre_readonly_)
#define _In_reads_bytes_(size)         _SAL2_Source_(_In_reads_bytes_, (size), _Pre_bytecount_(size)      _Deref_pre_readonly_)
#define _In_reads_bytes_opt_(size)     _SAL2_Source_(_In_reads_bytes_opt_, (size), _Pre_opt_bytecount_(size)  _Deref_pre_readonly_)
#define _In_reads_z_(size)             _SAL2_Source_(_In_reads_z_, (size), _In_reads_(size)     _Pre_z_)
#define _In_reads_opt_z_(size)         _SAL2_Source_(_In_reads_opt_z_, (size), _Pre_opt_count_(size)      _Deref_pre_readonly_     _Pre_opt_z_)
#define _In_reads_or_z_(size)          _SAL2_Source_(_In_reads_or_z_, (size), _In_ _When_(_String_length_(_Curr_) < (size), _Pre_z_) _When_(_String_length_(_Curr_) >= (size), _Pre1_impl_(__count_impl(size))))
#define _In_reads_or_z_opt_(size)      _SAL2_Source_(_In_reads_or_z_opt_, (size), _In_opt_ _When_(_String_length_(_Curr_) < (size), _Pre_z_) _When_(_String_length_(_Curr_) >= (size), _Pre1_impl_(__count_impl(size))))


// 'input' buffers valid to the given end pointer

#define _In_reads_to_ptr_(ptr)         _SAL2_Source_(_In_reads_to_ptr_, (ptr), _Pre_ptrdiff_count_(ptr)     _Deref_pre_readonly_)
#define _In_reads_to_ptr_opt_(ptr)     _SAL2_Source_(_In_reads_to_ptr_opt_, (ptr), _Pre_opt_ptrdiff_count_(ptr) _Deref_pre_readonly_)
#define _In_reads_to_ptr_z_(ptr)       _SAL2_Source_(_In_reads_to_ptr_z_, (ptr), _In_reads_to_ptr_(ptr) _Pre_z_)
#define _In_reads_to_ptr_opt_z_(ptr)   _SAL2_Source_(_In_reads_to_ptr_opt_z_, (ptr), _Pre_opt_ptrdiff_count_(ptr) _Deref_pre_readonly_  _Pre_opt_z_)



// Output parameters --------------------------

//   _Out_ - Annotations for pointer or reference parameters where data passed back to the caller.
//           These are mostly used where the pointer/reference is to a non-pointer type.
//           _Outptr_/_Outref) (see below) are typically used to return pointers via parameters.

// e.g. void GetPoint( _Out_ POINT* pPT );
#define _Out_                                  _SAL2_Source_(_Out_, (),     _Out_impl_)
#define _Out_opt_                              _SAL2_Source_(_Out_opt_, (), _Out_opt_impl_)

#define _Out_writes_(size)                     _SAL2_Source_(_Out_writes_, (size), _Pre_cap_(size)            _Post_valid_impl_)
#define _Out_writes_opt_(size)                 _SAL2_Source_(_Out_writes_opt_, (size), _Pre_opt_cap_(size)        _Post_valid_impl_)
#define _Out_writes_bytes_(size)               _SAL2_Source_(_Out_writes_bytes_, (size), _Pre_bytecap_(size)        _Post_valid_impl_)
#define _Out_writes_bytes_opt_(size)           _SAL2_Source_(_Out_writes_bytes_opt_, (size), _Pre_opt_bytecap_(size)    _Post_valid_impl_)
#define _Out_writes_z_(size)                   _SAL2_Source_(_Out_writes_z_, (size), _Pre_cap_(size)            _Post_valid_impl_ _Post_z_)
#define _Out_writes_opt_z_(size)               _SAL2_Source_(_Out_writes_opt_z_, (size), _Pre_opt_cap_(size)        _Post_valid_impl_ _Post_z_)

#define _Out_writes_to_(size,count)            _SAL2_Source_(_Out_writes_to_, (size,count), _Pre_cap_(size)            _Post_valid_impl_ _Post_count_(count))
#define _Out_writes_to_opt_(size,count)        _SAL2_Source_(_Out_writes_to_opt_, (size,count), _Pre_opt_cap_(size)        _Post_valid_impl_ _Post_count_(count))
#define _Out_writes_all_(size)                 _SAL2_Source_(_Out_writes_all_, (size), _Out_writes_to_(_Old_(size), _Old_(size)))
#define _Out_writes_all_opt_(size)             _SAL2_Source_(_Out_writes_all_opt_, (size), _Out_writes_to_opt_(_Old_(size), _Old_(size)))

#define _Out_writes_bytes_to_(size,count)      _SAL2_Source_(_Out_writes_bytes_to_, (size,count), _Pre_bytecap_(size)        _Post_valid_impl_ _Post_bytecount_(count))
#define _Out_writes_bytes_to_opt_(size,count)  _SAL2_Source_(_Out_writes_bytes_to_opt_, (size,count), _Pre_opt_bytecap_(size) _Post_valid_impl_ _Post_bytecount_(count))
#define _Out_writes_bytes_all_(size)           _SAL2_Source_(_Out_writes_bytes_all_, (size), _Out_writes_bytes_to_(_Old_(size), _Old_(size)))
#define _Out_writes_bytes_all_opt_(size)       _SAL2_Source_(_Out_writes_bytes_all_opt_, (size), _Out_writes_bytes_to_opt_(_Old_(size), _Old_(size)))

#define _Out_writes_to_ptr_(ptr)               _SAL2_Source_(_Out_writes_to_ptr_, (ptr), _Pre_ptrdiff_cap_(ptr)     _Post_valid_impl_)
#define _Out_writes_to_ptr_opt_(ptr)           _SAL2_Source_(_Out_writes_to_ptr_opt_, (ptr), _Pre_opt_ptrdiff_cap_(ptr) _Post_valid_impl_)
#define _Out_writes_to_ptr_z_(ptr)             _SAL2_Source_(_Out_writes_to_ptr_z_, (ptr), _Pre_ptrdiff_cap_(ptr)     _Post_valid_impl_ Post_z_)
#define _Out_writes_to_ptr_opt_z_(ptr)         _SAL2_Source_(_Out_writes_to_ptr_opt_z_, (ptr), _Pre_opt_ptrdiff_cap_(ptr) _Post_valid_impl_ Post_z_)


// Inout parameters ----------------------------

//   _Inout_ - Annotations for pointer or reference parameters where data is passed in and
//        potentially modified.
//          void ModifyPoint( _Inout_ POINT* pPT );
//          void ModifyPointByRef( _Inout_ POINT& pPT );

#define _Inout_                                _SAL2_Source_(_Inout_, (), _Prepost_valid_)
#define _Inout_opt_                            _SAL2_Source_(_Inout_opt_, (), _Prepost_opt_valid_)

// For modifying string buffers
//   void toupper( _Inout_z_ char* sz );
#define _Inout_z_                              _SAL2_Source_(_Inout_z_, (), _Prepost_z_)
#define _Inout_opt_z_                          _SAL2_Source_(_Inout_opt_z_, (), _Prepost_opt_z_)

// For modifying buffers with explicit element size
#define _Inout_updates_(size)                  _SAL2_Source_(_Inout_updates_, (size), _Pre_cap_(size)         _Pre_valid_impl_ _Post_valid_impl_)
#define _Inout_updates_opt_(size)              _SAL2_Source_(_Inout_updates_opt_, (size), _Pre_opt_cap_(size)     _Pre_valid_impl_ _Post_valid_impl_)
#define _Inout_updates_z_(size)                _SAL2_Source_(_Inout_updates_z_, (size), _Pre_cap_(size)         _Pre_valid_impl_ _Post_valid_impl_ _Pre1_impl_(__zterm_impl) _Post1_impl_(__zterm_impl))
#define _Inout_updates_opt_z_(size)            _SAL2_Source_(_Inout_updates_opt_z_, (size), _Pre_opt_cap_(size)     _Pre_valid_impl_ _Post_valid_impl_ _Pre1_impl_(__zterm_impl) _Post1_impl_(__zterm_impl))

#define _Inout_updates_to_(size,count)         _SAL2_Source_(_Inout_updates_to_, (size,count), _Out_writes_to_(size,count) _Pre_valid_impl_ _Pre1_impl_(__count_impl(size)))
#define _Inout_updates_to_opt_(size,count)     _SAL2_Source_(_Inout_updates_to_opt_, (size,count), _Out_writes_to_opt_(size,count) _Pre_valid_impl_ _Pre1_impl_(__count_impl(size)))

#define _Inout_updates_all_(size)              _SAL2_Source_(_Inout_updates_all_, (size), _Inout_updates_to_(_Old_(size), _Old_(size)))
#define _Inout_updates_all_opt_(size)          _SAL2_Source_(_Inout_updates_all_opt_, (size), _Inout_updates_to_opt_(_Old_(size), _Old_(size)))

// For modifying buffers with explicit byte size
#define _Inout_updates_bytes_(size)            _SAL2_Source_(_Inout_updates_bytes_, (size), _Pre_bytecap_(size)     _Pre_valid_impl_ _Post_valid_impl_)
#define _Inout_updates_bytes_opt_(size)        _SAL2_Source_(_Inout_updates_bytes_opt_, (size), _Pre_opt_bytecap_(size) _Pre_valid_impl_ _Post_valid_impl_)

#define _Inout_updates_bytes_to_(size,count)       _SAL2_Source_(_Inout_updates_bytes_to_, (size,count), _Out_writes_bytes_to_(size,count) _Pre_valid_impl_ _Pre1_impl_(__bytecount_impl(size)))
#define _Inout_updates_bytes_to_opt_(size,count)   _SAL2_Source_(_Inout_updates_bytes_to_opt_, (size,count), _Out_writes_bytes_to_opt_(size,count) _Pre_valid_impl_ _Pre1_impl_(__bytecount_impl(size)))

#define _Inout_updates_bytes_all_(size)        _SAL2_Source_(_Inout_updates_bytes_all_, (size), _Inout_updates_bytes_to_(_Old_(size), _Old_(size)))
#define _Inout_updates_bytes_all_opt_(size)    _SAL2_Source_(_Inout_updates_bytes_all_opt_, (size), _Inout_updates_bytes_to_opt_(_Old_(size), _Old_(size)))


// Pointer to pointer parameters -------------------------

//   _Outptr_ - Annotations for output params returning pointers
//      These describe parameters where the called function provides the buffer:
//        HRESULT SHStrDupW(_In_ LPCWSTR psz, _Outptr_ LPWSTR *ppwsz);
//      The caller passes the address of an LPWSTR variable as ppwsz, and SHStrDupW allocates
//      and initializes memory and returns the pointer to the new LPWSTR in *ppwsz.
//
//    _Outptr_opt_ - describes parameters that are allowed to be NULL.
//    _Outptr_*_result_maybenull_ - describes parameters where the called function might return NULL to the caller.
//
//    Example:
//       void MyFunc(_Outptr_opt_ int **ppData1, _Outptr_result_maybenull_ int **ppData2);
//    Callers:
//       MyFunc(NULL, NULL);           // error: parameter 2, ppData2, should not be NULL
//       MyFunc(&pData1, &pData2);     // ok: both non-NULL
//       if (*pData1 == *pData2) ...   // error: pData2 might be NULL after call

#define _Outptr_                         _SAL2_Source_(_Outptr_, (),                      _Out_impl_     _Deref_post2_impl_(__notnull_impl_notref,   __count_impl(1)))
#define _Outptr_result_maybenull_        _SAL2_Source_(_Outptr_result_maybenull_, (),     _Out_impl_     _Deref_post2_impl_(__maybenull_impl_notref, __count_impl(1)))
#define _Outptr_opt_                     _SAL2_Source_(_Outptr_opt_, (),                  _Out_opt_impl_ _Deref_post2_impl_(__notnull_impl_notref,   __count_impl(1)))
#define _Outptr_opt_result_maybenull_    _SAL2_Source_(_Outptr_opt_result_maybenull_, (), _Out_opt_impl_ _Deref_post2_impl_(__maybenull_impl_notref, __count_impl(1)))

// Annotations for _Outptr_ parameters returning pointers to null terminated strings.

#define _Outptr_result_z_                _SAL2_Source_(_Outptr_result_z_, (),               _Out_impl_     _Deref_post_z_)
#define _Outptr_opt_result_z_            _SAL2_Source_(_Outptr_opt_result_z_, (),           _Out_opt_impl_ _Deref_post_z_)
#define _Outptr_result_maybenull_z_      _SAL2_Source_(_Outptr_result_maybenull_z_, (),     _Out_impl_     _Deref_post_opt_z_)
#define _Outptr_opt_result_maybenull_z_  _SAL2_Source_(_Outptr_opt_result_maybenull_z_, (), _Out_opt_impl_ _Deref_post_opt_z_)

// Annotations for _Outptr_ parameters where the output pointer is set to NULL if the function fails.

#define _Outptr_result_nullonfailure_       _SAL2_Source_(_Outptr_result_nullonfailure_, (),     _Outptr_      _On_failure_(_Deref_post_null_))
#define _Outptr_opt_result_nullonfailure_   _SAL2_Source_(_Outptr_opt_result_nullonfailure_, (), _Outptr_opt_  _On_failure_(_Deref_post_null_))

// Annotations for _Outptr_ parameters which return a pointer to a ref-counted COM object,
// following the COM convention of setting the output to NULL on failure.
// The current implementation is identical to _Outptr_result_nullonfailure_.
// For pointers to types that are not COM objects, _Outptr_result_nullonfailure_ is preferred.

#define _COM_Outptr_                        _SAL2_Source_(_COM_Outptr_, (),                      _Outptr_                      _On_failure_(_Deref_post_null_))
#define _COM_Outptr_result_maybenull_       _SAL2_Source_(_COM_Outptr_result_maybenull_, (),     _Outptr_result_maybenull_     _On_failure_(_Deref_post_null_))
#define _COM_Outptr_opt_                    _SAL2_Source_(_COM_Outptr_opt_, (),                  _Outptr_opt_                  _On_failure_(_Deref_post_null_))
#define _COM_Outptr_opt_result_maybenull_   _SAL2_Source_(_COM_Outptr_opt_result_maybenull_, (), _Outptr_opt_result_maybenull_ _On_failure_(_Deref_post_null_))

// Annotations for _Outptr_ parameters returning a pointer to buffer with a specified number of elements/bytes

#define _Outptr_result_buffer_(size)                      _SAL2_Source_(_Outptr_result_buffer_, (size),               _Out_impl_     _Deref_post2_impl_(__notnull_impl_notref, __cap_impl(size)))
#define _Outptr_opt_result_buffer_(size)                  _SAL2_Source_(_Outptr_opt_result_buffer_, (size),           _Out_opt_impl_ _Deref_post2_impl_(__notnull_impl_notref, __cap_impl(size)))
#define _Outptr_result_buffer_to_(size, count)            _SAL2_Source_(_Outptr_result_buffer_to_, (size, count),     _Out_impl_     _Deref_post3_impl_(__notnull_impl_notref, __cap_impl(size), __count_impl(count)))
#define _Outptr_opt_result_buffer_to_(size, count)        _SAL2_Source_(_Outptr_opt_result_buffer_to_, (size, count), _Out_opt_impl_ _Deref_post3_impl_(__notnull_impl_notref, __cap_impl(size), __count_impl(count)))

#define _Outptr_result_buffer_all_(size)                  _SAL2_Source_(_Outptr_result_buffer_all_, (size),           _Out_impl_     _Deref_post2_impl_(__notnull_impl_notref, __count_impl(size)))
#define _Outptr_opt_result_buffer_all_(size)              _SAL2_Source_(_Outptr_opt_result_buffer_all_, (size),       _Out_opt_impl_ _Deref_post2_impl_(__notnull_impl_notref, __count_impl(size)))

#define _Outptr_result_buffer_maybenull_(size)               _SAL2_Source_(_Outptr_result_buffer_maybenull_, (size),               _Out_impl_     _Deref_post2_impl_(__maybenull_impl_notref, __cap_impl(size)))
#define _Outptr_opt_result_buffer_maybenull_(size)           _SAL2_Source_(_Outptr_opt_result_buffer_maybenull_, (size),           _Out_opt_impl_ _Deref_post2_impl_(__maybenull_impl_notref, __cap_impl(size)))
#define _Outptr_result_buffer_to_maybenull_(size, count)     _SAL2_Source_(_Outptr_result_buffer_to_maybenull_, (size, count),     _Out_impl_     _Deref_post3_impl_(__maybenull_impl_notref, __cap_impl(size), __count_impl(count)))
#define _Outptr_opt_result_buffer_to_maybenull_(size, count) _SAL2_Source_(_Outptr_opt_result_buffer_to_maybenull_, (size, count), _Out_opt_impl_ _Deref_post3_impl_(__maybenull_impl_notref, __cap_impl(size), __count_impl(count)))

#define _Outptr_result_buffer_all_maybenull_(size)           _SAL2_Source_(_Outptr_result_buffer_all_maybenull_, (size),           _Out_impl_     _Deref_post2_impl_(__maybenull_impl_notref, __count_impl(size)))
#define _Outptr_opt_result_buffer_all_maybenull_(size)       _SAL2_Source_(_Outptr_opt_result_buffer_all_maybenull_, (size),       _Out_opt_impl_ _Deref_post2_impl_(__maybenull_impl_notref, __count_impl(size)))

#define _Outptr_result_bytebuffer_(size)                     _SAL2_Source_(_Outptr_result_bytebuffer_, (size),                     _Out_impl_     _Deref_post2_impl_(__notnull_impl_notref, __bytecap_impl(size)))
#define _Outptr_opt_result_bytebuffer_(size)                 _SAL2_Source_(_Outptr_opt_result_bytebuffer_, (size),                 _Out_opt_impl_ _Deref_post2_impl_(__notnull_impl_notref, __bytecap_impl(size)))
#define _Outptr_result_bytebuffer_to_(size, count)           _SAL2_Source_(_Outptr_result_bytebuffer_to_, (size, count),           _Out_impl_     _Deref_post3_impl_(__notnull_impl_notref, __bytecap_impl(size), __bytecount_impl(count)))
#define _Outptr_opt_result_bytebuffer_to_(size, count)       _SAL2_Source_(_Outptr_opt_result_bytebuffer_to_, (size, count),       _Out_opt_impl_ _Deref_post3_impl_(__notnull_impl_notref, __bytecap_impl(size), __bytecount_impl(count)))

#define _Outptr_result_bytebuffer_all_(size)                 _SAL2_Source_(_Outptr_result_bytebuffer_all_, (size),                 _Out_impl_     _Deref_post2_impl_(__notnull_impl_notref, __bytecount_impl(size)))
#define _Outptr_opt_result_bytebuffer_all_(size)             _SAL2_Source_(_Outptr_opt_result_bytebuffer_all_, (size),             _Out_opt_impl_ _Deref_post2_impl_(__notnull_impl_notref, __bytecount_impl(size)))

#define _Outptr_result_bytebuffer_maybenull_(size)                 _SAL2_Source_(_Outptr_result_bytebuffer_maybenull_, (size),               _Out_impl_     _Deref_post2_impl_(__maybenull_impl_notref, __bytecap_impl(size)))
#define _Outptr_opt_result_bytebuffer_maybenull_(size)             _SAL2_Source_(_Outptr_opt_result_bytebuffer_maybenull_, (size),           _Out_opt_impl_ _Deref_post2_impl_(__maybenull_impl_notref, __bytecap_impl(size)))
#define _Outptr_result_bytebuffer_to_maybenull_(size, count)       _SAL2_Source_(_Outptr_result_bytebuffer_to_maybenull_, (size, count),     _Out_impl_     _Deref_post3_impl_(__maybenull_impl_notref, __bytecap_impl(size), __bytecount_impl(count)))
#define _Outptr_opt_result_bytebuffer_to_maybenull_(size, count)   _SAL2_Source_(_Outptr_opt_result_bytebuffer_to_maybenull_, (size, count), _Out_opt_impl_ _Deref_post3_impl_(__maybenull_impl_notref, __bytecap_impl(size), __bytecount_impl(count)))

#define _Outptr_result_bytebuffer_all_maybenull_(size)         _SAL2_Source_(_Outptr_result_bytebuffer_all_maybenull_, (size),               _Out_impl_     _Deref_post2_impl_(__maybenull_impl_notref, __bytecount_impl(size)))
#define _Outptr_opt_result_bytebuffer_all_maybenull_(size)     _SAL2_Source_(_Outptr_opt_result_bytebuffer_all_maybenull_, (size),           _Out_opt_impl_ _Deref_post2_impl_(__maybenull_impl_notref, __bytecount_impl(size)))

// Annotations for output reference to pointer parameters.

#define _Outref_                                               _SAL2_Source_(_Outref_, (),                  _Out_impl_ _Post_notnull_)
#define _Outref_result_maybenull_                              _SAL2_Source_(_Outref_result_maybenull_, (), _Pre2_impl_(__notnull_impl_notref, __cap_c_one_notref_impl) _Post_maybenull_ _Post_valid_impl_)

#define _Outref_result_buffer_(size)                           _SAL2_Source_(_Outref_result_buffer_, (size),                         _Outref_ _Post1_impl_(__cap_impl(size)))
#define _Outref_result_bytebuffer_(size)                       _SAL2_Source_(_Outref_result_bytebuffer_, (size),                     _Outref_ _Post1_impl_(__bytecap_impl(size)))
#define _Outref_result_buffer_to_(size, count)                 _SAL2_Source_(_Outref_result_buffer_to_, (size, count),               _Outref_result_buffer_(size) _Post1_impl_(__count_impl(count)))
#define _Outref_result_bytebuffer_to_(size, count)             _SAL2_Source_(_Outref_result_bytebuffer_to_, (size, count),           _Outref_result_bytebuffer_(size) _Post1_impl_(__bytecount_impl(count)))
#define _Outref_result_buffer_all_(size)                       _SAL2_Source_(_Outref_result_buffer_all_, (size),                     _Outref_result_buffer_to_(size, _Old_(size)))
#define _Outref_result_bytebuffer_all_(size)                   _SAL2_Source_(_Outref_result_bytebuffer_all_, (size),                 _Outref_result_bytebuffer_to_(size, _Old_(size)))

#define _Outref_result_buffer_maybenull_(size)                 _SAL2_Source_(_Outref_result_buffer_maybenull_, (size),               _Outref_result_maybenull_ _Post1_impl_(__cap_impl(size)))
#define _Outref_result_bytebuffer_maybenull_(size)             _SAL2_Source_(_Outref_result_bytebuffer_maybenull_, (size),           _Outref_result_maybenull_ _Post1_impl_(__bytecap_impl(size)))
#define _Outref_result_buffer_to_maybenull_(size, count)       _SAL2_Source_(_Outref_result_buffer_to_maybenull_, (size, count),     _Outref_result_buffer_maybenull_(size) _Post1_impl_(__count_impl(count)))
#define _Outref_result_bytebuffer_to_maybenull_(size, count)   _SAL2_Source_(_Outref_result_bytebuffer_to_maybenull_, (size, count), _Outref_result_bytebuffer_maybenull_(size) _Post1_impl_(__bytecount_impl(count)))
#define _Outref_result_buffer_all_maybenull_(size)             _SAL2_Source_(_Outref_result_buffer_all_maybenull_, (size),           _Outref_result_buffer_to_maybenull_(size, _Old_(size)))
#define _Outref_result_bytebuffer_all_maybenull_(size)         _SAL2_Source_(_Outref_result_bytebuffer_all_maybenull_, (size),       _Outref_result_bytebuffer_to_maybenull_(size, _Old_(size)))

// Annotations for output reference to pointer parameters that guarantee
// that the pointer is set to NULL on failure.
#define _Outref_result_nullonfailure_                          _SAL2_Source_(_Outref_result_nullonfailure_, (), _Outref_    _On_failure_(_Post_null_))

// Generic annotations to set output value of a by-pointer or by-reference parameter to null/zero on failure.
#define _Result_nullonfailure_                                 _SAL2_Source_(_Result_nullonfailure_, (), _On_failure_(_Notref_impl_ _Deref_impl_ _Post_null_))
#define _Result_zeroonfailure_                                 _SAL2_Source_(_Result_zeroonfailure_, (), _On_failure_(_Notref_impl_ _Deref_impl_ _Out_range_(==, 0)))


// return values -------------------------------

//
// _Ret_ annotations
//
// describing conditions that hold for return values after the call

// e.g. _Ret_z_ CString::operator const wchar_t*() const noexcept;
#define _Ret_z_                             _SAL2_Source_(_Ret_z_, (), _Ret2_impl_(__notnull_impl,  __zterm_impl) _Ret_valid_impl_)
#define _Ret_maybenull_z_                   _SAL2_Source_(_Ret_maybenull_z_, (), _Ret2_impl_(__maybenull_impl,__zterm_impl) _Ret_valid_impl_)

// used with allocated but not yet initialized objects
#define _Ret_notnull_                       _SAL2_Source_(_Ret_notnull_, (), _Ret1_impl_(__notnull_impl))
#define _Ret_maybenull_                     _SAL2_Source_(_Ret_maybenull_, (), _Ret1_impl_(__maybenull_impl))
#define _Ret_null_                          _SAL2_Source_(_Ret_null_, (), _Ret1_impl_(__null_impl))

// used with allocated and initialized objects
//    returns single valid object
#define _Ret_valid_                         _SAL2_Source_(_Ret_valid_, (), _Ret1_impl_(__notnull_impl_notref)   _Ret_valid_impl_)

//    returns pointer to initialized buffer of specified size
#define _Ret_writes_(size)                  _SAL2_Source_(_Ret_writes_, (size), _Ret2_impl_(__notnull_impl,  __count_impl(size))          _Ret_valid_impl_)
#define _Ret_writes_z_(size)                _SAL2_Source_(_Ret_writes_z_, (size), _Ret3_impl_(__notnull_impl,  __count_impl(size), __zterm_impl) _Ret_valid_impl_)
#define _Ret_writes_bytes_(size)            _SAL2_Source_(_Ret_writes_bytes_, (size), _Ret2_impl_(__notnull_impl,  __bytecount_impl(size))      _Ret_valid_impl_)
#define _Ret_writes_maybenull_(size)        _SAL2_Source_(_Ret_writes_maybenull_, (size), _Ret2_impl_(__maybenull_impl,__count_impl(size))          _Ret_valid_impl_)
#define _Ret_writes_maybenull_z_(size)      _SAL2_Source_(_Ret_writes_maybenull_z_, (size), _Ret3_impl_(__maybenull_impl,__count_impl(size),__zterm_impl)  _Ret_valid_impl_)
#define _Ret_writes_bytes_maybenull_(size)  _SAL2_Source_(_Ret_writes_bytes_maybenull_, (size), _Ret2_impl_(__maybenull_impl,__bytecount_impl(size))      _Ret_valid_impl_)

//    returns pointer to partially initialized buffer, with total size 'size' and initialized size 'count'
#define _Ret_writes_to_(size,count)                   _SAL2_Source_(_Ret_writes_to_, (size,count), _Ret3_impl_(__notnull_impl,  __cap_impl(size),     __count_impl(count))     _Ret_valid_impl_)
#define _Ret_writes_bytes_to_(size,count)             _SAL2_Source_(_Ret_writes_bytes_to_, (size,count), _Ret3_impl_(__notnull_impl,  __bytecap_impl(size), __bytecount_impl(count)) _Ret_valid_impl_)
#define _Ret_writes_to_maybenull_(size,count)         _SAL2_Source_(_Ret_writes_to_maybenull_, (size,count), _Ret3_impl_(__maybenull_impl,  __cap_impl(size),     __count_impl(count))     _Ret_valid_impl_)
#define _Ret_writes_bytes_to_maybenull_(size,count)   _SAL2_Source_(_Ret_writes_bytes_to_maybenull_, (size,count), _Ret3_impl_(__maybenull_impl,  __bytecap_impl(size), __bytecount_impl(count)) _Ret_valid_impl_)


// Annotations for strict type checking
#define _Points_to_data_        _SAL2_Source_(_Points_to_data_, (), _Pre_ _Points_to_data_impl_)
#define _Literal_               _SAL2_Source_(_Literal_, (), _Pre_ _Literal_impl_)
#define _Notliteral_            _SAL2_Source_(_Notliteral_, (), _Pre_ _Notliteral_impl_)

// Check the return value of a function e.g. _Check_return_ ErrorCode Foo();
#define _Check_return_           _SAL2_Source_(_Check_return_, (), _Check_return_impl_)
#define _Must_inspect_result_    _SAL2_Source_(_Must_inspect_result_, (), _Must_inspect_impl_ _Check_return_impl_)

// e.g. MyPrintF( _Printf_format_string_ const wchar_t* wzFormat, ... );
#define _Printf_format_string_  _SAL2_Source_(_Printf_format_string_, (), _Printf_format_string_impl_)
#define _Scanf_format_string_   _SAL2_Source_(_Scanf_format_string_, (), _Scanf_format_string_impl_)
#define _Scanf_s_format_string_  _SAL2_Source_(_Scanf_s_format_string_, (), _Scanf_s_format_string_impl_)

#define _Format_string_impl_(kind,where)  _SA_annotes2(SAL_IsFormatString2, kind, where)
#define _Printf_format_string_params_(x)  _SAL2_Source_(_Printf_format_string_params_, (x), _Format_string_impl_("printf", x))
#define _Scanf_format_string_params_(x)   _SAL2_Source_(_Scanf_format_string_params_, (x), _Format_string_impl_("scanf", x))
#define _Scanf_s_format_string_params_(x) _SAL2_Source_(_Scanf_s_format_string_params_, (x), _Format_string_impl_("scanf_s", x))

// annotations to express value of integral or pointer parameter
#define _In_range_(lb,ub)           _SAL2_Source_(_In_range_, (lb,ub), _In_range_impl_(lb,ub))
#define _Out_range_(lb,ub)          _SAL2_Source_(_Out_range_, (lb,ub), _Out_range_impl_(lb,ub))
#define _Ret_range_(lb,ub)          _SAL2_Source_(_Ret_range_, (lb,ub), _Ret_range_impl_(lb,ub))
#define _Deref_in_range_(lb,ub)     _SAL2_Source_(_Deref_in_range_, (lb,ub), _Deref_in_range_impl_(lb,ub))
#define _Deref_out_range_(lb,ub)    _SAL2_Source_(_Deref_out_range_, (lb,ub), _Deref_out_range_impl_(lb,ub))
#define _Deref_ret_range_(lb,ub)    _SAL2_Source_(_Deref_ret_range_, (lb,ub), _Deref_ret_range_impl_(lb,ub))
#define _Pre_equal_to_(expr)        _SAL2_Source_(_Pre_equal_to_, (expr), _In_range_(==, expr))
#define _Post_equal_to_(expr)       _SAL2_Source_(_Post_equal_to_, (expr), _Out_range_(==, expr))

// annotation to express that a value (usually a field of a mutable class)
// is not changed by a function call
#define _Unchanged_(e)              _SAL2_Source_(_Unchanged_, (e), _At_(e, _Post_equal_to_(_Old_(e)) _Const_))

// Annotations to allow expressing generalized pre and post conditions.
// 'cond' may be any valid SAL expression that is considered to be true as a precondition
// or postcondition (respectively).
#define _Pre_satisfies_(cond)       _SAL2_Source_(_Pre_satisfies_, (cond), _Pre_satisfies_impl_(cond))
#define _Post_satisfies_(cond)      _SAL2_Source_(_Post_satisfies_, (cond), _Post_satisfies_impl_(cond))

// Annotations to express struct, class and field invariants
#define _Struct_size_bytes_(size)                  _SAL2_Source_(_Struct_size_bytes_, (size), _Writable_bytes_(size))

#define _Field_size_(size)                         _SAL2_Source_(_Field_size_, (size), _Notnull_   _Writable_elements_(size))
#define _Field_size_opt_(size)                     _SAL2_Source_(_Field_size_opt_, (size), _Maybenull_ _Writable_elements_(size))
#define _Field_size_part_(size, count)             _SAL2_Source_(_Field_size_part_, (size, count), _Notnull_   _Writable_elements_(size) _Readable_elements_(count))
#define _Field_size_part_opt_(size, count)         _SAL2_Source_(_Field_size_part_opt_, (size, count), _Maybenull_ _Writable_elements_(size) _Readable_elements_(count))
#define _Field_size_full_(size)                    _SAL2_Source_(_Field_size_full_, (size), _Field_size_part_(size, size))
#define _Field_size_full_opt_(size)                _SAL2_Source_(_Field_size_full_opt_, (size), _Field_size_part_opt_(size, size))

#define _Field_size_bytes_(size)                   _SAL2_Source_(_Field_size_bytes_, (size), _Notnull_   _Writable_bytes_(size))
#define _Field_size_bytes_opt_(size)               _SAL2_Source_(_Field_size_bytes_opt_, (size), _Maybenull_ _Writable_bytes_(size))
#define _Field_size_bytes_part_(size, count)       _SAL2_Source_(_Field_size_bytes_part_, (size, count), _Notnull_   _Writable_bytes_(size) _Readable_bytes_(count))
#define _Field_size_bytes_part_opt_(size, count)   _SAL2_Source_(_Field_size_bytes_part_opt_, (size, count), _Maybenull_ _Writable_bytes_(size) _Readable_bytes_(count))
#define _Field_size_bytes_full_(size)              _SAL2_Source_(_Field_size_bytes_full_, (size), _Field_size_bytes_part_(size, size))
#define _Field_size_bytes_full_opt_(size)          _SAL2_Source_(_Field_size_bytes_full_opt_, (size), _Field_size_bytes_part_opt_(size, size))

#define _Field_z_                                  _SAL2_Source_(_Field_z_, (), _Null_terminated_)

#define _Field_range_(min,max)                     _SAL2_Source_(_Field_range_, (min,max), _Field_range_impl_(min,max))

//============================================================================
//   _Pre_/_Post_ Layer:
//============================================================================

//
// Raw Pre/Post for declaring custom pre/post conditions
//

#define _Pre_                             _Pre_impl_
#define _Post_                            _Post_impl_

//
// Validity property
//

#define _Valid_                           _Valid_impl_
#define _Notvalid_                        _Notvalid_impl_
#define _Maybevalid_                      _Maybevalid_impl_

//
// Buffer size properties
//

// Expressing buffer sizes without specifying pre or post condition
#define _Readable_bytes_(size)            _SAL2_Source_(_Readable_bytes_, (size), _Readable_bytes_impl_(size))
#define _Readable_elements_(size)         _SAL2_Source_(_Readable_elements_, (size), _Readable_elements_impl_(size))
#define _Writable_bytes_(size)            _SAL2_Source_(_Writable_bytes_, (size), _Writable_bytes_impl_(size))
#define _Writable_elements_(size)         _SAL2_Source_(_Writable_elements_, (size), _Writable_elements_impl_(size))

#define _Null_terminated_                 _SAL2_Source_(_Null_terminated_, (), _Null_terminated_impl_)
#define _NullNull_terminated_             _SAL2_Source_(_NullNull_terminated_, (), _NullNull_terminated_impl_)

// Expressing buffer size as pre or post condition
#define _Pre_readable_size_(size)         _SAL2_Source_(_Pre_readable_size_, (size), _Pre1_impl_(__count_impl(size))      _Pre_valid_impl_)
#define _Pre_writable_size_(size)         _SAL2_Source_(_Pre_writable_size_, (size), _Pre1_impl_(__cap_impl(size)))
#define _Pre_readable_byte_size_(size)    _SAL2_Source_(_Pre_readable_byte_size_, (size), _Pre1_impl_(__bytecount_impl(size))  _Pre_valid_impl_)
#define _Pre_writable_byte_size_(size)    _SAL2_Source_(_Pre_writable_byte_size_, (size), _Pre1_impl_(__bytecap_impl(size)))

#define _Post_readable_size_(size)        _SAL2_Source_(_Post_readable_size_, (size), _Post1_impl_(__count_impl(size))     _Post_valid_impl_)
#define _Post_writable_size_(size)        _SAL2_Source_(_Post_writable_size_, (size), _Post1_impl_(__cap_impl(size)))
#define _Post_readable_byte_size_(size)   _SAL2_Source_(_Post_readable_byte_size_, (size), _Post1_impl_(__bytecount_impl(size)) _Post_valid_impl_)
#define _Post_writable_byte_size_(size)   _SAL2_Source_(_Post_writable_byte_size_, (size), _Post1_impl_(__bytecap_impl(size)))

//
// Pointer null-ness properties
//
#define _Null_                            _SAL2_Source_(_Null_, (), _Null_impl_)
#define _Notnull_                         _SAL2_Source_(_Notnull_, (), _Notnull_impl_)
#define _Maybenull_                       _SAL2_Source_(_Maybenull_, (), _Maybenull_impl_)

//
// _Pre_ annotations ---
//
// describing conditions that must be met before the call of the function

// e.g. int strlen( _Pre_z_ const char* sz );
// buffer is a zero terminated string
#define _Pre_z_                           _SAL2_Source_(_Pre_z_, (), _Pre1_impl_(__zterm_impl) _Pre_valid_impl_)

// valid size unknown or indicated by type (e.g.:LPSTR)
#define _Pre_valid_                       _SAL2_Source_(_Pre_valid_, (), _Pre1_impl_(__notnull_impl_notref)   _Pre_valid_impl_)
#define _Pre_opt_valid_                   _SAL2_Source_(_Pre_opt_valid_, (), _Pre1_impl_(__maybenull_impl_notref) _Pre_valid_impl_)

#define _Pre_invalid_                     _SAL2_Source_(_Pre_invalid_, (), _Deref_pre1_impl_(__notvalid_impl))

// Overrides recursive valid when some field is not yet initialized when using _Inout_
#define _Pre_unknown_                     _SAL2_Source_(_Pre_unknown_, (), _Pre1_impl_(__maybevalid_impl))

// used with allocated but not yet initialized objects
#define _Pre_notnull_                     _SAL2_Source_(_Pre_notnull_, (), _Pre1_impl_(__notnull_impl_notref))
#define _Pre_maybenull_                   _SAL2_Source_(_Pre_maybenull_, (), _Pre1_impl_(__maybenull_impl_notref))
#define _Pre_null_                        _SAL2_Source_(_Pre_null_, (), _Pre1_impl_(__null_impl_notref))

//
// _Post_ annotations ---
//
// describing conditions that hold after the function call

// void CopyStr( _In_z_ const char* szFrom, _Pre_cap_(cch) _Post_z_ char* szFrom, size_t cchFrom );
// buffer will be a zero-terminated string after the call
#define _Post_z_                         _SAL2_Source_(_Post_z_, (), _Post1_impl_(__zterm_impl) _Post_valid_impl_)

// e.g. HRESULT InitStruct( _Post_valid_ Struct* pobj );
#define _Post_valid_                     _SAL2_Source_(_Post_valid_, (), _Post_valid_impl_)
#define _Post_invalid_                   _SAL2_Source_(_Post_invalid_, (), _Deref_post1_impl_(__notvalid_impl))

// e.g. void free( _Post_ptr_invalid_ void* pv );
#define _Post_ptr_invalid_               _SAL2_Source_(_Post_ptr_invalid_, (), _Post1_impl_(__notvalid_impl))

// e.g. void ThrowExceptionIfNull( _Post_notnull_ const void* pv );
#define _Post_notnull_                   _SAL2_Source_(_Post_notnull_, (), _Post1_impl_(__notnull_impl))

// e.g. HRESULT GetObject(_Outptr_ _On_failure_(_At_(*p, _Post_null_)) T **p);
#define _Post_null_                      _SAL2_Source_(_Post_null_, (), _Post1_impl_(__null_impl))

#define _Post_maybenull_                 _SAL2_Source_(_Post_maybenull_, (), _Post1_impl_(__maybenull_impl))

#define _Prepost_z_                      _SAL2_Source_(_Prepost_z_, (), _Pre_z_      _Post_z_)


#pragma region Input Buffer SAL 1 compatibility macros

/*==========================================================================

   This section contains definitions for macros defined for VS2010 and earlier.
   Usage of these macros is still supported, but the SAL 2 macros defined above
   are recommended instead.  This comment block is retained to assist in
   understanding SAL that still uses the older syntax.

   The macros are defined in 3 layers:

   _In_/_Out_ Layer:
   ----------------
   This layer provides the highest abstraction and its macros should be used
   in most cases. Its macros start with _In_, _Out_ or _Inout_. For the
   typical case they provide the most concise annotations.

   _Pre_/_Post_ Layer:
   ------------------
   The macros of this layer only should be used when there is no suitable macro
   in the _In_/_Out_ layer. Its macros start with _Pre_, _Post_, _Ret_,
   _Deref_pre_ _Deref_post_ and _Deref_ret_. This layer provides the most
   flexibility for annotations.

   Implementation Abstraction Layer:
   --------------------------------
   Macros from this layer should never be used directly. The layer only exists
   to hide the implementation of the annotation macros.


   Annotation Syntax:
   |--------------|----------|----------------|-----------------------------|
   |   Usage      | Nullness | ZeroTerminated |  Extent                     |
   |--------------|----------|----------------|-----------------------------|
   | _In_         | <>       | <>             | <>                          |
   | _Out_        | opt_     | z_             | [byte]cap_[c_|x_]( size )   |
   | _Inout_      |          |                | [byte]count_[c_|x_]( size ) |
   | _Deref_out_  |          |                | ptrdiff_cap_( ptr )         |
   |--------------|          |                | ptrdiff_count_( ptr )       |
   | _Ret_        |          |                |                             |
   | _Deref_ret_  |          |                |                             |
   |--------------|          |                |                             |
   | _Pre_        |          |                |                             |
   | _Post_       |          |                |                             |
   | _Deref_pre_  |          |                |                             |
   | _Deref_post_ |          |                |                             |
   |--------------|----------|----------------|-----------------------------|

   Usage:
   -----
   _In_, _Out_, _Inout_, _Pre_, _Post_, _Deref_pre_, _Deref_post_ are for
   formal parameters.
   _Ret_, _Deref_ret_ must be used for return values.

   Nullness:
   --------
   If the pointer can be NULL the annotation contains _opt. If the macro
   does not contain '_opt' the pointer may not be NULL.

   String Type:
   -----------
   _z: NullTerminated string
   for _In_ parameters the buffer must have the specified stringtype before the call
   for _Out_ parameters the buffer must have the specified stringtype after the call
   for _Inout_ parameters both conditions apply

   Extent Syntax:
   |------|---------------|---------------|
   | Unit | Writ/Readable | Argument Type |
   |------|---------------|---------------|
   |  <>  | cap_          | <>            |
   | byte | count_        | c_            |
   |      |               | x_            |
   |------|---------------|---------------|

   'cap' (capacity) describes the writable size of the buffer and is typically used
   with _Out_. The default unit is elements. Use 'bytecap' if the size is given in bytes
   'count' describes the readable size of the buffer and is typically used with _In_.
   The default unit is elements. Use 'bytecount' if the size is given in bytes.

   Argument syntax for cap_, bytecap_, count_, bytecount_:
   (<parameter>|return)[+n]  e.g. cch, return, cb+2

   If the buffer size is a constant expression use the c_ postfix.
   E.g. cap_c_(20), count_c_(MAX_PATH), bytecount_c_(16)

   If the buffer size is given by a limiting pointer use the ptrdiff_ versions
   of the macros.

   If the buffer size is neither a parameter nor a constant expression use the x_
   postfix. e.g. bytecount_x_(num*size) x_ annotations accept any arbitrary string.
   No analysis can be done for x_ annotations but they at least tell the tool that
   the buffer has some sort of extent description. x_ annotations might be supported
   by future compiler versions.

============================================================================*/

// e.g. void SetCharRange( _In_count_(cch) const char* rgch, size_t cch )
// valid buffer extent described by another parameter
#define _In_count_(size)               _SAL1_1_Source_(_In_count_, (size), _Pre_count_(size)         _Deref_pre_readonly_)
#define _In_opt_count_(size)           _SAL1_1_Source_(_In_opt_count_, (size), _Pre_opt_count_(size)     _Deref_pre_readonly_)
#define _In_bytecount_(size)           _SAL1_1_Source_(_In_bytecount_, (size), _Pre_bytecount_(size)     _Deref_pre_readonly_)
#define _In_opt_bytecount_(size)       _SAL1_1_Source_(_In_opt_bytecount_, (size), _Pre_opt_bytecount_(size) _Deref_pre_readonly_)

// valid buffer extent described by a constant extression
#define _In_count_c_(size)             _SAL1_1_Source_(_In_count_c_, (size), _Pre_count_c_(size)         _Deref_pre_readonly_)
#define _In_opt_count_c_(size)         _SAL1_1_Source_(_In_opt_count_c_, (size), _Pre_opt_count_c_(size)     _Deref_pre_readonly_)
#define _In_bytecount_c_(size)         _SAL1_1_Source_(_In_bytecount_c_, (size), _Pre_bytecount_c_(size)     _Deref_pre_readonly_)
#define _In_opt_bytecount_c_(size)     _SAL1_1_Source_(_In_opt_bytecount_c_, (size), _Pre_opt_bytecount_c_(size) _Deref_pre_readonly_)

// nullterminated  'input' buffers with given size

// e.g. void SetCharRange( _In_count_(cch) const char* rgch, size_t cch )
// nullterminated valid buffer extent described by another parameter
#define _In_z_count_(size)               _SAL1_1_Source_(_In_z_count_, (size), _Pre_z_ _Pre_count_(size)         _Deref_pre_readonly_)
#define _In_opt_z_count_(size)           _SAL1_1_Source_(_In_opt_z_count_, (size), _Pre_opt_z_ _Pre_opt_count_(size)     _Deref_pre_readonly_)
#define _In_z_bytecount_(size)           _SAL1_1_Source_(_In_z_bytecount_, (size), _Pre_z_ _Pre_bytecount_(size)     _Deref_pre_readonly_)
#define _In_opt_z_bytecount_(size)       _SAL1_1_Source_(_In_opt_z_bytecount_, (size), _Pre_opt_z_ _Pre_opt_bytecount_(size) _Deref_pre_readonly_)

// nullterminated valid buffer extent described by a constant extression
#define _In_z_count_c_(size)             _SAL1_1_Source_(_In_z_count_c_, (size), _Pre_z_ _Pre_count_c_(size)         _Deref_pre_readonly_)
#define _In_opt_z_count_c_(size)         _SAL1_1_Source_(_In_opt_z_count_c_, (size), _Pre_opt_z_ _Pre_opt_count_c_(size)     _Deref_pre_readonly_)
#define _In_z_bytecount_c_(size)         _SAL1_1_Source_(_In_z_bytecount_c_, (size), _Pre_z_ _Pre_bytecount_c_(size)     _Deref_pre_readonly_)
#define _In_opt_z_bytecount_c_(size)     _SAL1_1_Source_(_In_opt_z_bytecount_c_, (size), _Pre_opt_z_ _Pre_opt_bytecount_c_(size) _Deref_pre_readonly_)

// buffer capacity is described by another pointer
// e.g. void Foo( _In_ptrdiff_count_(pchMax) const char* pch, const char* pchMax ) { while pch < pchMax ) pch++; }
#define _In_ptrdiff_count_(size)       _SAL1_1_Source_(_In_ptrdiff_count_, (size), _Pre_ptrdiff_count_(size)     _Deref_pre_readonly_)
#define _In_opt_ptrdiff_count_(size)   _SAL1_1_Source_(_In_opt_ptrdiff_count_, (size), _Pre_opt_ptrdiff_count_(size) _Deref_pre_readonly_)

// 'x' version for complex expressions that are not supported by the current compiler version
// e.g. void Set3ColMatrix( _In_count_x_(3*cRows) const Elem* matrix, int cRows );
#define _In_count_x_(size)             _SAL1_1_Source_(_In_count_x_, (size), _Pre_count_x_(size)         _Deref_pre_readonly_)
#define _In_opt_count_x_(size)         _SAL1_1_Source_(_In_opt_count_x_, (size), _Pre_opt_count_x_(size)     _Deref_pre_readonly_)
#define _In_bytecount_x_(size)         _SAL1_1_Source_(_In_bytecount_x_, (size), _Pre_bytecount_x_(size)     _Deref_pre_readonly_)
#define _In_opt_bytecount_x_(size)     _SAL1_1_Source_(_In_opt_bytecount_x_, (size), _Pre_opt_bytecount_x_(size) _Deref_pre_readonly_)


// 'out' with buffer size
// e.g. void GetIndices( _Out_cap_(cIndices) int* rgIndices, size_t cIndices );
// buffer capacity is described by another parameter
#define _Out_cap_(size)                   _SAL1_1_Source_(_Out_cap_, (size), _Pre_cap_(size)           _Post_valid_impl_)
#define _Out_opt_cap_(size)               _SAL1_1_Source_(_Out_opt_cap_, (size), _Pre_opt_cap_(size)       _Post_valid_impl_)
#define _Out_bytecap_(size)               _SAL1_1_Source_(_Out_bytecap_, (size), _Pre_bytecap_(size)       _Post_valid_impl_)
#define _Out_opt_bytecap_(size)           _SAL1_1_Source_(_Out_opt_bytecap_, (size), _Pre_opt_bytecap_(size)   _Post_valid_impl_)

// buffer capacity is described by a constant expression
#define _Out_cap_c_(size)                 _SAL1_1_Source_(_Out_cap_c_, (size), _Pre_cap_c_(size)         _Post_valid_impl_)
#define _Out_opt_cap_c_(size)             _SAL1_1_Source_(_Out_opt_cap_c_, (size), _Pre_opt_cap_c_(size)     _Post_valid_impl_)
#define _Out_bytecap_c_(size)             _SAL1_1_Source_(_Out_bytecap_c_, (size), _Pre_bytecap_c_(size)     _Post_valid_impl_)
#define _Out_opt_bytecap_c_(size)         _SAL1_1_Source_(_Out_opt_bytecap_c_, (size), _Pre_opt_bytecap_c_(size) _Post_valid_impl_)

// buffer capacity is described by another parameter multiplied by a constant expression
#define _Out_cap_m_(mult,size)            _SAL1_1_Source_(_Out_cap_m_, (mult,size), _Pre_cap_m_(mult,size)     _Post_valid_impl_)
#define _Out_opt_cap_m_(mult,size)        _SAL1_1_Source_(_Out_opt_cap_m_, (mult,size), _Pre_opt_cap_m_(mult,size) _Post_valid_impl_)
#define _Out_z_cap_m_(mult,size)          _SAL1_1_Source_(_Out_z_cap_m_, (mult,size), _Pre_cap_m_(mult,size)     _Post_valid_impl_ _Post_z_)
#define _Out_opt_z_cap_m_(mult,size)      _SAL1_1_Source_(_Out_opt_z_cap_m_, (mult,size), _Pre_opt_cap_m_(mult,size) _Post_valid_impl_ _Post_z_)

// buffer capacity is described by another pointer
// e.g. void Foo( _Out_ptrdiff_cap_(pchMax) char* pch, const char* pchMax ) { while pch < pchMax ) pch++; }
#define _Out_ptrdiff_cap_(size)           _SAL1_1_Source_(_Out_ptrdiff_cap_, (size), _Pre_ptrdiff_cap_(size)     _Post_valid_impl_)
#define _Out_opt_ptrdiff_cap_(size)       _SAL1_1_Source_(_Out_opt_ptrdiff_cap_, (size), _Pre_opt_ptrdiff_cap_(size) _Post_valid_impl_)

// buffer capacity is described by a complex expression
#define _Out_cap_x_(size)                 _SAL1_1_Source_(_Out_cap_x_, (size), _Pre_cap_x_(size)         _Post_valid_impl_)
#define _Out_opt_cap_x_(size)             _SAL1_1_Source_(_Out_opt_cap_x_, (size), _Pre_opt_cap_x_(size)     _Post_valid_impl_)
#define _Out_bytecap_x_(size)             _SAL1_1_Source_(_Out_bytecap_x_, (size), _Pre_bytecap_x_(size)     _Post_valid_impl_)
#define _Out_opt_bytecap_x_(size)         _SAL1_1_Source_(_Out_opt_bytecap_x_, (size), _Pre_opt_bytecap_x_(size) _Post_valid_impl_)

// a zero terminated string is filled into a buffer of given capacity
// e.g. void CopyStr( _In_z_ const char* szFrom, _Out_z_cap_(cchTo) char* szTo, size_t cchTo );
// buffer capacity is described by another parameter
#define _Out_z_cap_(size)                 _SAL1_1_Source_(_Out_z_cap_, (size), _Pre_cap_(size)           _Post_valid_impl_ _Post_z_)
#define _Out_opt_z_cap_(size)             _SAL1_1_Source_(_Out_opt_z_cap_, (size), _Pre_opt_cap_(size)       _Post_valid_impl_ _Post_z_)
#define _Out_z_bytecap_(size)             _SAL1_1_Source_(_Out_z_bytecap_, (size), _Pre_bytecap_(size)       _Post_valid_impl_ _Post_z_)
#define _Out_opt_z_bytecap_(size)         _SAL1_1_Source_(_Out_opt_z_bytecap_, (size), _Pre_opt_bytecap_(size)   _Post_valid_impl_ _Post_z_)

// buffer capacity is described by a constant expression
#define _Out_z_cap_c_(size)               _SAL1_1_Source_(_Out_z_cap_c_, (size), _Pre_cap_c_(size)         _Post_valid_impl_ _Post_z_)
#define _Out_opt_z_cap_c_(size)           _SAL1_1_Source_(_Out_opt_z_cap_c_, (size), _Pre_opt_cap_c_(size)     _Post_valid_impl_ _Post_z_)
#define _Out_z_bytecap_c_(size)           _SAL1_1_Source_(_Out_z_bytecap_c_, (size), _Pre_bytecap_c_(size)     _Post_valid_impl_ _Post_z_)
#define _Out_opt_z_bytecap_c_(size)       _SAL1_1_Source_(_Out_opt_z_bytecap_c_, (size), _Pre_opt_bytecap_c_(size) _Post_valid_impl_ _Post_z_)

// buffer capacity is described by a complex expression
#define _Out_z_cap_x_(size)               _SAL1_1_Source_(_Out_z_cap_x_, (size), _Pre_cap_x_(size)         _Post_valid_impl_ _Post_z_)
#define _Out_opt_z_cap_x_(size)           _SAL1_1_Source_(_Out_opt_z_cap_x_, (size), _Pre_opt_cap_x_(size)     _Post_valid_impl_ _Post_z_)
#define _Out_z_bytecap_x_(size)           _SAL1_1_Source_(_Out_z_bytecap_x_, (size), _Pre_bytecap_x_(size)     _Post_valid_impl_ _Post_z_)
#define _Out_opt_z_bytecap_x_(size)       _SAL1_1_Source_(_Out_opt_z_bytecap_x_, (size), _Pre_opt_bytecap_x_(size) _Post_valid_impl_ _Post_z_)

// a zero terminated string is filled into a buffer of given capacity
// e.g. size_t CopyCharRange( _In_count_(cchFrom) const char* rgchFrom, size_t cchFrom, _Out_cap_post_count_(cchTo,return)) char* rgchTo, size_t cchTo );
#define _Out_cap_post_count_(cap,count)                _SAL1_1_Source_(_Out_cap_post_count_, (cap,count), _Pre_cap_(cap)         _Post_valid_impl_ _Post_count_(count))
#define _Out_opt_cap_post_count_(cap,count)            _SAL1_1_Source_(_Out_opt_cap_post_count_, (cap,count), _Pre_opt_cap_(cap)     _Post_valid_impl_ _Post_count_(count))
#define _Out_bytecap_post_bytecount_(cap,count)        _SAL1_1_Source_(_Out_bytecap_post_bytecount_, (cap,count), _Pre_bytecap_(cap)     _Post_valid_impl_ _Post_bytecount_(count))
#define _Out_opt_bytecap_post_bytecount_(cap,count)    _SAL1_1_Source_(_Out_opt_bytecap_post_bytecount_, (cap,count), _Pre_opt_bytecap_(cap) _Post_valid_impl_ _Post_bytecount_(count))

// a zero terminated string is filled into a buffer of given capacity
// e.g. size_t CopyStr( _In_z_ const char* szFrom, _Out_z_cap_post_count_(cchTo,return+1) char* szTo, size_t cchTo );
#define _Out_z_cap_post_count_(cap,count)               _SAL1_1_Source_(_Out_z_cap_post_count_, (cap,count), _Pre_cap_(cap)         _Post_valid_impl_ _Post_z_count_(count))
#define _Out_opt_z_cap_post_count_(cap,count)           _SAL1_1_Source_(_Out_opt_z_cap_post_count_, (cap,count), _Pre_opt_cap_(cap)     _Post_valid_impl_ _Post_z_count_(count))
#define _Out_z_bytecap_post_bytecount_(cap,count)       _SAL1_1_Source_(_Out_z_bytecap_post_bytecount_, (cap,count), _Pre_bytecap_(cap)     _Post_valid_impl_ _Post_z_bytecount_(count))
#define _Out_opt_z_bytecap_post_bytecount_(cap,count)   _SAL1_1_Source_(_Out_opt_z_bytecap_post_bytecount_, (cap,count), _Pre_opt_bytecap_(cap) _Post_valid_impl_ _Post_z_bytecount_(count))

// only use with dereferenced arguments e.g. '*pcch'
#define _Out_capcount_(capcount)             _SAL1_1_Source_(_Out_capcount_, (capcount), _Pre_cap_(capcount)         _Post_valid_impl_ _Post_count_(capcount))
#define _Out_opt_capcount_(capcount)         _SAL1_1_Source_(_Out_opt_capcount_, (capcount), _Pre_opt_cap_(capcount)     _Post_valid_impl_ _Post_count_(capcount))
#define _Out_bytecapcount_(capcount)         _SAL1_1_Source_(_Out_bytecapcount_, (capcount), _Pre_bytecap_(capcount)     _Post_valid_impl_ _Post_bytecount_(capcount))
#define _Out_opt_bytecapcount_(capcount)     _SAL1_1_Source_(_Out_opt_bytecapcount_, (capcount), _Pre_opt_bytecap_(capcount) _Post_valid_impl_ _Post_bytecount_(capcount))

#define _Out_capcount_x_(capcount)           _SAL1_1_Source_(_Out_capcount_x_, (capcount), _Pre_cap_x_(capcount)         _Post_valid_impl_ _Post_count_x_(capcount))
#define _Out_opt_capcount_x_(capcount)       _SAL1_1_Source_(_Out_opt_capcount_x_, (capcount), _Pre_opt_cap_x_(capcount)     _Post_valid_impl_ _Post_count_x_(capcount))
#define _Out_bytecapcount_x_(capcount)       _SAL1_1_Source_(_Out_bytecapcount_x_, (capcount), _Pre_bytecap_x_(capcount)     _Post_valid_impl_ _Post_bytecount_x_(capcount))
#define _Out_opt_bytecapcount_x_(capcount)   _SAL1_1_Source_(_Out_opt_bytecapcount_x_, (capcount), _Pre_opt_bytecap_x_(capcount) _Post_valid_impl_ _Post_bytecount_x_(capcount))

// e.g. GetString( _Out_z_capcount_(*pLen+1) char* sz, size_t* pLen );
#define _Out_z_capcount_(capcount)           _SAL1_1_Source_(_Out_z_capcount_, (capcount), _Pre_cap_(capcount)         _Post_valid_impl_ _Post_z_count_(capcount))
#define _Out_opt_z_capcount_(capcount)       _SAL1_1_Source_(_Out_opt_z_capcount_, (capcount), _Pre_opt_cap_(capcount)     _Post_valid_impl_ _Post_z_count_(capcount))
#define _Out_z_bytecapcount_(capcount)       _SAL1_1_Source_(_Out_z_bytecapcount_, (capcount), _Pre_bytecap_(capcount)     _Post_valid_impl_ _Post_z_bytecount_(capcount))
#define _Out_opt_z_bytecapcount_(capcount)   _SAL1_1_Source_(_Out_opt_z_bytecapcount_, (capcount), _Pre_opt_bytecap_(capcount) _Post_valid_impl_ _Post_z_bytecount_(capcount))


// 'inout' buffers with initialized elements before and after the call
// e.g. void ModifyIndices( _Inout_count_(cIndices) int* rgIndices, size_t cIndices );
#define _Inout_count_(size)               _SAL1_1_Source_(_Inout_count_, (size), _Prepost_count_(size))
#define _Inout_opt_count_(size)           _SAL1_1_Source_(_Inout_opt_count_, (size), _Prepost_opt_count_(size))
#define _Inout_bytecount_(size)           _SAL1_1_Source_(_Inout_bytecount_, (size), _Prepost_bytecount_(size))
#define _Inout_opt_bytecount_(size)       _SAL1_1_Source_(_Inout_opt_bytecount_, (size), _Prepost_opt_bytecount_(size))

#define _Inout_count_c_(size)             _SAL1_1_Source_(_Inout_count_c_, (size), _Prepost_count_c_(size))
#define _Inout_opt_count_c_(size)         _SAL1_1_Source_(_Inout_opt_count_c_, (size), _Prepost_opt_count_c_(size))
#define _Inout_bytecount_c_(size)         _SAL1_1_Source_(_Inout_bytecount_c_, (size), _Prepost_bytecount_c_(size))
#define _Inout_opt_bytecount_c_(size)     _SAL1_1_Source_(_Inout_opt_bytecount_c_, (size), _Prepost_opt_bytecount_c_(size))

// nullterminated 'inout' buffers with initialized elements before and after the call
// e.g. void ModifyIndices( _Inout_count_(cIndices) int* rgIndices, size_t cIndices );
#define _Inout_z_count_(size)               _SAL1_1_Source_(_Inout_z_count_, (size), _Prepost_z_ _Prepost_count_(size))
#define _Inout_opt_z_count_(size)           _SAL1_1_Source_(_Inout_opt_z_count_, (size), _Prepost_z_ _Prepost_opt_count_(size))
#define _Inout_z_bytecount_(size)           _SAL1_1_Source_(_Inout_z_bytecount_, (size), _Prepost_z_ _Prepost_bytecount_(size))
#define _Inout_opt_z_bytecount_(size)       _SAL1_1_Source_(_Inout_opt_z_bytecount_, (size), _Prepost_z_ _Prepost_opt_bytecount_(size))

#define _Inout_z_count_c_(size)             _SAL1_1_Source_(_Inout_z_count_c_, (size), _Prepost_z_ _Prepost_count_c_(size))
#define _Inout_opt_z_count_c_(size)         _SAL1_1_Source_(_Inout_opt_z_count_c_, (size), _Prepost_z_ _Prepost_opt_count_c_(size))
#define _Inout_z_bytecount_c_(size)         _SAL1_1_Source_(_Inout_z_bytecount_c_, (size), _Prepost_z_ _Prepost_bytecount_c_(size))
#define _Inout_opt_z_bytecount_c_(size)     _SAL1_1_Source_(_Inout_opt_z_bytecount_c_, (size), _Prepost_z_ _Prepost_opt_bytecount_c_(size))

#define _Inout_ptrdiff_count_(size)       _SAL1_1_Source_(_Inout_ptrdiff_count_, (size), _Pre_ptrdiff_count_(size))
#define _Inout_opt_ptrdiff_count_(size)   _SAL1_1_Source_(_Inout_opt_ptrdiff_count_, (size), _Pre_opt_ptrdiff_count_(size))

#define _Inout_count_x_(size)             _SAL1_1_Source_(_Inout_count_x_, (size), _Prepost_count_x_(size))
#define _Inout_opt_count_x_(size)         _SAL1_1_Source_(_Inout_opt_count_x_, (size), _Prepost_opt_count_x_(size))
#define _Inout_bytecount_x_(size)         _SAL1_1_Source_(_Inout_bytecount_x_, (size), _Prepost_bytecount_x_(size))
#define _Inout_opt_bytecount_x_(size)     _SAL1_1_Source_(_Inout_opt_bytecount_x_, (size), _Prepost_opt_bytecount_x_(size))

// e.g. void AppendToLPSTR( _In_ LPCSTR szFrom, _Inout_cap_(cchTo) LPSTR* szTo, size_t cchTo );
#define _Inout_cap_(size)                 _SAL1_1_Source_(_Inout_cap_, (size), _Pre_valid_cap_(size)           _Post_valid_)
#define _Inout_opt_cap_(size)             _SAL1_1_Source_(_Inout_opt_cap_, (size), _Pre_opt_valid_cap_(size)       _Post_valid_)
#define _Inout_bytecap_(size)             _SAL1_1_Source_(_Inout_bytecap_, (size), _Pre_valid_bytecap_(size)       _Post_valid_)
#define _Inout_opt_bytecap_(size)         _SAL1_1_Source_(_Inout_opt_bytecap_, (size), _Pre_opt_valid_bytecap_(size)   _Post_valid_)

#define _Inout_cap_c_(size)               _SAL1_1_Source_(_Inout_cap_c_, (size), _Pre_valid_cap_c_(size)         _Post_valid_)
#define _Inout_opt_cap_c_(size)           _SAL1_1_Source_(_Inout_opt_cap_c_, (size), _Pre_opt_valid_cap_c_(size)     _Post_valid_)
#define _Inout_bytecap_c_(size)           _SAL1_1_Source_(_Inout_bytecap_c_, (size), _Pre_valid_bytecap_c_(size)     _Post_valid_)
#define _Inout_opt_bytecap_c_(size)       _SAL1_1_Source_(_Inout_opt_bytecap_c_, (size), _Pre_opt_valid_bytecap_c_(size) _Post_valid_)

#define _Inout_cap_x_(size)               _SAL1_1_Source_(_Inout_cap_x_, (size), _Pre_valid_cap_x_(size)         _Post_valid_)
#define _Inout_opt_cap_x_(size)           _SAL1_1_Source_(_Inout_opt_cap_x_, (size), _Pre_opt_valid_cap_x_(size)     _Post_valid_)
#define _Inout_bytecap_x_(size)           _SAL1_1_Source_(_Inout_bytecap_x_, (size), _Pre_valid_bytecap_x_(size)     _Post_valid_)
#define _Inout_opt_bytecap_x_(size)       _SAL1_1_Source_(_Inout_opt_bytecap_x_, (size), _Pre_opt_valid_bytecap_x_(size) _Post_valid_)

// inout string buffers with writable size
// e.g. void AppendStr( _In_z_ const char* szFrom, _Inout_z_cap_(cchTo) char* szTo, size_t cchTo );
#define _Inout_z_cap_(size)                  _SAL1_1_Source_(_Inout_z_cap_, (size), _Pre_z_cap_(size)            _Post_z_)
#define _Inout_opt_z_cap_(size)              _SAL1_1_Source_(_Inout_opt_z_cap_, (size), _Pre_opt_z_cap_(size)        _Post_z_)
#define _Inout_z_bytecap_(size)              _SAL1_1_Source_(_Inout_z_bytecap_, (size), _Pre_z_bytecap_(size)        _Post_z_)
#define _Inout_opt_z_bytecap_(size)          _SAL1_1_Source_(_Inout_opt_z_bytecap_, (size), _Pre_opt_z_bytecap_(size)    _Post_z_)

#define _Inout_z_cap_c_(size)                _SAL1_1_Source_(_Inout_z_cap_c_, (size), _Pre_z_cap_c_(size)          _Post_z_)
#define _Inout_opt_z_cap_c_(size)            _SAL1_1_Source_(_Inout_opt_z_cap_c_, (size), _Pre_opt_z_cap_c_(size)      _Post_z_)
#define _Inout_z_bytecap_c_(size)            _SAL1_1_Source_(_Inout_z_bytecap_c_, (size), _Pre_z_bytecap_c_(size)      _Post_z_)
#define _Inout_opt_z_bytecap_c_(size)        _SAL1_1_Source_(_Inout_opt_z_bytecap_c_, (size), _Pre_opt_z_bytecap_c_(size)  _Post_z_)

#define _Inout_z_cap_x_(size)                _SAL1_1_Source_(_Inout_z_cap_x_, (size), _Pre_z_cap_x_(size)          _Post_z_)
#define _Inout_opt_z_cap_x_(size)            _SAL1_1_Source_(_Inout_opt_z_cap_x_, (size), _Pre_opt_z_cap_x_(size)      _Post_z_)
#define _Inout_z_bytecap_x_(size)            _SAL1_1_Source_(_Inout_z_bytecap_x_, (size), _Pre_z_bytecap_x_(size)      _Post_z_)
#define _Inout_opt_z_bytecap_x_(size)        _SAL1_1_Source_(_Inout_opt_z_bytecap_x_, (size), _Pre_opt_z_bytecap_x_(size)  _Post_z_)


// returning pointers to valid objects
#define _Ret_                   _SAL1_1_Source_(_Ret_, (), _Ret_valid_)
#define _Ret_opt_               _SAL1_1_Source_(_Ret_opt_, (), _Ret_opt_valid_)

// annotations to express 'boundedness' of integral value parameter
#define _In_bound_           _SAL1_1_Source_(_In_bound_, (), _In_bound_impl_)
#define _Out_bound_          _SAL1_1_Source_(_Out_bound_, (), _Out_bound_impl_)
#define _Ret_bound_          _SAL1_1_Source_(_Ret_bound_, (), _Ret_bound_impl_)
#define _Deref_in_bound_     _SAL1_1_Source_(_Deref_in_bound_, (), _Deref_in_bound_impl_)
#define _Deref_out_bound_    _SAL1_1_Source_(_Deref_out_bound_, (), _Deref_out_bound_impl_)
#define _Deref_inout_bound_  _SAL1_1_Source_(_Deref_inout_bound_, (), _Deref_in_bound_ _Deref_out_bound_)
#define _Deref_ret_bound_    _SAL1_1_Source_(_Deref_ret_bound_, (), _Deref_ret_bound_impl_)

// e.g.  HRESULT HrCreatePoint( _Deref_out_opt_ POINT** ppPT );
#define _Deref_out_             _SAL1_1_Source_(_Deref_out_, (), _Out_ _Deref_post_valid_)
#define _Deref_out_opt_         _SAL1_1_Source_(_Deref_out_opt_, (), _Out_ _Deref_post_opt_valid_)
#define _Deref_opt_out_         _SAL1_1_Source_(_Deref_opt_out_, (), _Out_opt_ _Deref_post_valid_)
#define _Deref_opt_out_opt_     _SAL1_1_Source_(_Deref_opt_out_opt_, (), _Out_opt_ _Deref_post_opt_valid_)

// e.g.  void CloneString( _In_z_ const wchar_t* wzFrom, _Deref_out_z_ wchar_t** pWzTo );
#define _Deref_out_z_           _SAL1_1_Source_(_Deref_out_z_, (), _Out_ _Deref_post_z_)
#define _Deref_out_opt_z_       _SAL1_1_Source_(_Deref_out_opt_z_, (), _Out_ _Deref_post_opt_z_)
#define _Deref_opt_out_z_       _SAL1_1_Source_(_Deref_opt_out_z_, (), _Out_opt_ _Deref_post_z_)
#define _Deref_opt_out_opt_z_   _SAL1_1_Source_(_Deref_opt_out_opt_z_, (), _Out_opt_ _Deref_post_opt_z_)

//
// _Deref_pre_ ---
//
// describing conditions for array elements of dereferenced pointer parameters that must be met before the call

// e.g. void SaveStringArray( _In_count_(cStrings) _Deref_pre_z_ const wchar_t* const rgpwch[] );
#define _Deref_pre_z_                           _SAL1_1_Source_(_Deref_pre_z_, (), _Deref_pre1_impl_(__notnull_impl_notref) _Deref_pre1_impl_(__zterm_impl) _Pre_valid_impl_)
#define _Deref_pre_opt_z_                       _SAL1_1_Source_(_Deref_pre_opt_z_, (), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__zterm_impl) _Pre_valid_impl_)

// e.g. void FillInArrayOfStr32( _In_count_(cStrings) _Deref_pre_cap_c_(32) _Deref_post_z_ wchar_t* const rgpwch[] );
// buffer capacity is described by another parameter
#define _Deref_pre_cap_(size)                   _SAL1_1_Source_(_Deref_pre_cap_, (size), _Deref_pre1_impl_(__notnull_impl_notref)   _Deref_pre1_impl_(__cap_impl(size)))
#define _Deref_pre_opt_cap_(size)               _SAL1_1_Source_(_Deref_pre_opt_cap_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__cap_impl(size)))
#define _Deref_pre_bytecap_(size)               _SAL1_1_Source_(_Deref_pre_bytecap_, (size), _Deref_pre1_impl_(__notnull_impl_notref)   _Deref_pre1_impl_(__bytecap_impl(size)))
#define _Deref_pre_opt_bytecap_(size)           _SAL1_1_Source_(_Deref_pre_opt_bytecap_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__bytecap_impl(size)))

// buffer capacity is described by a constant expression
#define _Deref_pre_cap_c_(size)                 _SAL1_1_Source_(_Deref_pre_cap_c_, (size), _Deref_pre1_impl_(__notnull_impl_notref)   _Deref_pre1_impl_(__cap_c_impl(size)))
#define _Deref_pre_opt_cap_c_(size)             _SAL1_1_Source_(_Deref_pre_opt_cap_c_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__cap_c_impl(size)))
#define _Deref_pre_bytecap_c_(size)             _SAL1_1_Source_(_Deref_pre_bytecap_c_, (size), _Deref_pre1_impl_(__notnull_impl_notref)   _Deref_pre1_impl_(__bytecap_c_impl(size)))
#define _Deref_pre_opt_bytecap_c_(size)         _SAL1_1_Source_(_Deref_pre_opt_bytecap_c_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__bytecap_c_impl(size)))

// buffer capacity is described by a complex condition
#define _Deref_pre_cap_x_(size)                 _SAL1_1_Source_(_Deref_pre_cap_x_, (size), _Deref_pre1_impl_(__notnull_impl_notref)   _Deref_pre1_impl_(__cap_x_impl(size)))
#define _Deref_pre_opt_cap_x_(size)             _SAL1_1_Source_(_Deref_pre_opt_cap_x_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__cap_x_impl(size)))
#define _Deref_pre_bytecap_x_(size)             _SAL1_1_Source_(_Deref_pre_bytecap_x_, (size), _Deref_pre1_impl_(__notnull_impl_notref)   _Deref_pre1_impl_(__bytecap_x_impl(size)))
#define _Deref_pre_opt_bytecap_x_(size)         _SAL1_1_Source_(_Deref_pre_opt_bytecap_x_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__bytecap_x_impl(size)))

// convenience macros for nullterminated buffers with given capacity
#define _Deref_pre_z_cap_(size)                 _SAL1_1_Source_(_Deref_pre_z_cap_, (size), _Deref_pre1_impl_(__notnull_impl_notref)   _Deref_pre2_impl_(__zterm_impl,__cap_impl(size))     _Pre_valid_impl_)
#define _Deref_pre_opt_z_cap_(size)             _SAL1_1_Source_(_Deref_pre_opt_z_cap_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre2_impl_(__zterm_impl,__cap_impl(size))     _Pre_valid_impl_)
#define _Deref_pre_z_bytecap_(size)             _SAL1_1_Source_(_Deref_pre_z_bytecap_, (size), _Deref_pre1_impl_(__notnull_impl_notref)   _Deref_pre2_impl_(__zterm_impl,__bytecap_impl(size)) _Pre_valid_impl_)
#define _Deref_pre_opt_z_bytecap_(size)         _SAL1_1_Source_(_Deref_pre_opt_z_bytecap_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre2_impl_(__zterm_impl,__bytecap_impl(size)) _Pre_valid_impl_)

#define _Deref_pre_z_cap_c_(size)               _SAL1_1_Source_(_Deref_pre_z_cap_c_, (size), _Deref_pre1_impl_(__notnull_impl_notref)   _Deref_pre2_impl_(__zterm_impl,__cap_c_impl(size))     _Pre_valid_impl_)
#define _Deref_pre_opt_z_cap_c_(size)           _SAL1_1_Source_(_Deref_pre_opt_z_cap_c_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre2_impl_(__zterm_impl,__cap_c_impl(size))     _Pre_valid_impl_)
#define _Deref_pre_z_bytecap_c_(size)           _SAL1_1_Source_(_Deref_pre_z_bytecap_c_, (size), _Deref_pre1_impl_(__notnull_impl_notref)   _Deref_pre2_impl_(__zterm_impl,__bytecap_c_impl(size)) _Pre_valid_impl_)
#define _Deref_pre_opt_z_bytecap_c_(size)       _SAL1_1_Source_(_Deref_pre_opt_z_bytecap_c_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre2_impl_(__zterm_impl,__bytecap_c_impl(size)) _Pre_valid_impl_)

#define _Deref_pre_z_cap_x_(size)               _SAL1_1_Source_(_Deref_pre_z_cap_x_, (size), _Deref_pre1_impl_(__notnull_impl_notref)   _Deref_pre2_impl_(__zterm_impl,__cap_x_impl(size))     _Pre_valid_impl_)
#define _Deref_pre_opt_z_cap_x_(size)           _SAL1_1_Source_(_Deref_pre_opt_z_cap_x_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre2_impl_(__zterm_impl,__cap_x_impl(size))     _Pre_valid_impl_)
#define _Deref_pre_z_bytecap_x_(size)           _SAL1_1_Source_(_Deref_pre_z_bytecap_x_, (size), _Deref_pre1_impl_(__notnull_impl_notref)   _Deref_pre2_impl_(__zterm_impl,__bytecap_x_impl(size)) _Pre_valid_impl_)
#define _Deref_pre_opt_z_bytecap_x_(size)       _SAL1_1_Source_(_Deref_pre_opt_z_bytecap_x_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre2_impl_(__zterm_impl,__bytecap_x_impl(size)) _Pre_valid_impl_)

// known capacity and valid but unknown readable extent
#define _Deref_pre_valid_cap_(size)             _SAL1_1_Source_(_Deref_pre_valid_cap_, (size), _Deref_pre1_impl_(__notnull_impl_notref)   _Deref_pre1_impl_(__cap_impl(size))     _Pre_valid_impl_)
#define _Deref_pre_opt_valid_cap_(size)         _SAL1_1_Source_(_Deref_pre_opt_valid_cap_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__cap_impl(size))     _Pre_valid_impl_)
#define _Deref_pre_valid_bytecap_(size)         _SAL1_1_Source_(_Deref_pre_valid_bytecap_, (size), _Deref_pre1_impl_(__notnull_impl_notref)   _Deref_pre1_impl_(__bytecap_impl(size)) _Pre_valid_impl_)
#define _Deref_pre_opt_valid_bytecap_(size)     _SAL1_1_Source_(_Deref_pre_opt_valid_bytecap_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__bytecap_impl(size)) _Pre_valid_impl_)

#define _Deref_pre_valid_cap_c_(size)           _SAL1_1_Source_(_Deref_pre_valid_cap_c_, (size), _Deref_pre1_impl_(__notnull_impl_notref)   _Deref_pre1_impl_(__cap_c_impl(size))     _Pre_valid_impl_)
#define _Deref_pre_opt_valid_cap_c_(size)       _SAL1_1_Source_(_Deref_pre_opt_valid_cap_c_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__cap_c_impl(size))     _Pre_valid_impl_)
#define _Deref_pre_valid_bytecap_c_(size)       _SAL1_1_Source_(_Deref_pre_valid_bytecap_c_, (size), _Deref_pre1_impl_(__notnull_impl_notref)   _Deref_pre1_impl_(__bytecap_c_impl(size)) _Pre_valid_impl_)
#define _Deref_pre_opt_valid_bytecap_c_(size)   _SAL1_1_Source_(_Deref_pre_opt_valid_bytecap_c_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__bytecap_c_impl(size)) _Pre_valid_impl_)

#define _Deref_pre_valid_cap_x_(size)           _SAL1_1_Source_(_Deref_pre_valid_cap_x_, (size), _Deref_pre1_impl_(__notnull_impl_notref)   _Deref_pre1_impl_(__cap_x_impl(size))     _Pre_valid_impl_)
#define _Deref_pre_opt_valid_cap_x_(size)       _SAL1_1_Source_(_Deref_pre_opt_valid_cap_x_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__cap_x_impl(size))     _Pre_valid_impl_)
#define _Deref_pre_valid_bytecap_x_(size)       _SAL1_1_Source_(_Deref_pre_valid_bytecap_x_, (size), _Deref_pre1_impl_(__notnull_impl_notref)   _Deref_pre1_impl_(__bytecap_x_impl(size)) _Pre_valid_impl_)
#define _Deref_pre_opt_valid_bytecap_x_(size)   _SAL1_1_Source_(_Deref_pre_opt_valid_bytecap_x_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__bytecap_x_impl(size)) _Pre_valid_impl_)

// e.g. void SaveMatrix( _In_count_(n) _Deref_pre_count_(n) const Elem** matrix, size_t n );
// valid buffer extent is described by another parameter
#define _Deref_pre_count_(size)                 _SAL1_1_Source_(_Deref_pre_count_, (size), _Deref_pre1_impl_(__notnull_impl_notref)   _Deref_pre1_impl_(__count_impl(size))     _Pre_valid_impl_)
#define _Deref_pre_opt_count_(size)             _SAL1_1_Source_(_Deref_pre_opt_count_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__count_impl(size))     _Pre_valid_impl_)
#define _Deref_pre_bytecount_(size)             _SAL1_1_Source_(_Deref_pre_bytecount_, (size), _Deref_pre1_impl_(__notnull_impl_notref)   _Deref_pre1_impl_(__bytecount_impl(size)) _Pre_valid_impl_)
#define _Deref_pre_opt_bytecount_(size)         _SAL1_1_Source_(_Deref_pre_opt_bytecount_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__bytecount_impl(size)) _Pre_valid_impl_)

// valid buffer extent is described by a constant expression
#define _Deref_pre_count_c_(size)               _SAL1_1_Source_(_Deref_pre_count_c_, (size), _Deref_pre1_impl_(__notnull_impl_notref)   _Deref_pre1_impl_(__count_c_impl(size))     _Pre_valid_impl_)
#define _Deref_pre_opt_count_c_(size)           _SAL1_1_Source_(_Deref_pre_opt_count_c_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__count_c_impl(size))     _Pre_valid_impl_)
#define _Deref_pre_bytecount_c_(size)           _SAL1_1_Source_(_Deref_pre_bytecount_c_, (size), _Deref_pre1_impl_(__notnull_impl_notref)   _Deref_pre1_impl_(__bytecount_c_impl(size)) _Pre_valid_impl_)
#define _Deref_pre_opt_bytecount_c_(size)       _SAL1_1_Source_(_Deref_pre_opt_bytecount_c_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__bytecount_c_impl(size)) _Pre_valid_impl_)

// valid buffer extent is described by a complex expression
#define _Deref_pre_count_x_(size)               _SAL1_1_Source_(_Deref_pre_count_x_, (size), _Deref_pre1_impl_(__notnull_impl_notref)   _Deref_pre1_impl_(__count_x_impl(size))     _Pre_valid_impl_)
#define _Deref_pre_opt_count_x_(size)           _SAL1_1_Source_(_Deref_pre_opt_count_x_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__count_x_impl(size))     _Pre_valid_impl_)
#define _Deref_pre_bytecount_x_(size)           _SAL1_1_Source_(_Deref_pre_bytecount_x_, (size), _Deref_pre1_impl_(__notnull_impl_notref)   _Deref_pre1_impl_(__bytecount_x_impl(size)) _Pre_valid_impl_)
#define _Deref_pre_opt_bytecount_x_(size)       _SAL1_1_Source_(_Deref_pre_opt_bytecount_x_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__bytecount_x_impl(size)) _Pre_valid_impl_)

// e.g. void PrintStringArray( _In_count_(cElems) _Deref_pre_valid_ LPCSTR rgStr[], size_t cElems );
#define _Deref_pre_valid_                       _SAL1_1_Source_(_Deref_pre_valid_, (), _Deref_pre1_impl_(__notnull_impl_notref)   _Pre_valid_impl_)
#define _Deref_pre_opt_valid_                   _SAL1_1_Source_(_Deref_pre_opt_valid_, (), _Deref_pre1_impl_(__maybenull_impl_notref) _Pre_valid_impl_)
#define _Deref_pre_invalid_                     _SAL1_1_Source_(_Deref_pre_invalid_, (), _Deref_pre1_impl_(__notvalid_impl))

#define _Deref_pre_notnull_                     _SAL1_1_Source_(_Deref_pre_notnull_, (), _Deref_pre1_impl_(__notnull_impl_notref))
#define _Deref_pre_maybenull_                   _SAL1_1_Source_(_Deref_pre_maybenull_, (), _Deref_pre1_impl_(__maybenull_impl_notref))
#define _Deref_pre_null_                        _SAL1_1_Source_(_Deref_pre_null_, (), _Deref_pre1_impl_(__null_impl_notref))

// restrict access rights
#define _Deref_pre_readonly_                    _SAL1_1_Source_(_Deref_pre_readonly_, (), _Deref_pre1_impl_(__readaccess_impl_notref))
#define _Deref_pre_writeonly_                   _SAL1_1_Source_(_Deref_pre_writeonly_, (), _Deref_pre1_impl_(__writeaccess_impl_notref))

//
// _Deref_post_ ---
//
// describing conditions for array elements or dereferenced pointer parameters that hold after the call

// e.g. void CloneString( _In_z_ const Wchar_t* wzIn _Out_ _Deref_post_z_ wchar_t** pWzOut );
#define _Deref_post_z_                           _SAL1_1_Source_(_Deref_post_z_, (), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__zterm_impl) _Post_valid_impl_)
#define _Deref_post_opt_z_                       _SAL1_1_Source_(_Deref_post_opt_z_, (), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__zterm_impl) _Post_valid_impl_)

// e.g. HRESULT HrAllocateMemory( size_t cb, _Out_ _Deref_post_bytecap_(cb) void** ppv );
// buffer capacity is described by another parameter
#define _Deref_post_cap_(size)                   _SAL1_1_Source_(_Deref_post_cap_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__cap_impl(size)))
#define _Deref_post_opt_cap_(size)               _SAL1_1_Source_(_Deref_post_opt_cap_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__cap_impl(size)))
#define _Deref_post_bytecap_(size)               _SAL1_1_Source_(_Deref_post_bytecap_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__bytecap_impl(size)))
#define _Deref_post_opt_bytecap_(size)           _SAL1_1_Source_(_Deref_post_opt_bytecap_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__bytecap_impl(size)))

// buffer capacity is described by a constant expression
#define _Deref_post_cap_c_(size)                 _SAL1_1_Source_(_Deref_post_cap_c_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__cap_c_impl(size)))
#define _Deref_post_opt_cap_c_(size)             _SAL1_1_Source_(_Deref_post_opt_cap_c_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__cap_c_impl(size)))
#define _Deref_post_bytecap_c_(size)             _SAL1_1_Source_(_Deref_post_bytecap_c_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__bytecap_c_impl(size)))
#define _Deref_post_opt_bytecap_c_(size)         _SAL1_1_Source_(_Deref_post_opt_bytecap_c_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__bytecap_c_impl(size)))

// buffer capacity is described by a complex expression
#define _Deref_post_cap_x_(size)                 _SAL1_1_Source_(_Deref_post_cap_x_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__cap_x_impl(size)))
#define _Deref_post_opt_cap_x_(size)             _SAL1_1_Source_(_Deref_post_opt_cap_x_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__cap_x_impl(size)))
#define _Deref_post_bytecap_x_(size)             _SAL1_1_Source_(_Deref_post_bytecap_x_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__bytecap_x_impl(size)))
#define _Deref_post_opt_bytecap_x_(size)         _SAL1_1_Source_(_Deref_post_opt_bytecap_x_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__bytecap_x_impl(size)))

// convenience macros for nullterminated buffers with given capacity
#define _Deref_post_z_cap_(size)                 _SAL1_1_Source_(_Deref_post_z_cap_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post2_impl_(__zterm_impl,__cap_impl(size))       _Post_valid_impl_)
#define _Deref_post_opt_z_cap_(size)             _SAL1_1_Source_(_Deref_post_opt_z_cap_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post2_impl_(__zterm_impl,__cap_impl(size))       _Post_valid_impl_)
#define _Deref_post_z_bytecap_(size)             _SAL1_1_Source_(_Deref_post_z_bytecap_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post2_impl_(__zterm_impl,__bytecap_impl(size))   _Post_valid_impl_)
#define _Deref_post_opt_z_bytecap_(size)         _SAL1_1_Source_(_Deref_post_opt_z_bytecap_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post2_impl_(__zterm_impl,__bytecap_impl(size))   _Post_valid_impl_)

#define _Deref_post_z_cap_c_(size)               _SAL1_1_Source_(_Deref_post_z_cap_c_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post2_impl_(__zterm_impl,__cap_c_impl(size))     _Post_valid_impl_)
#define _Deref_post_opt_z_cap_c_(size)           _SAL1_1_Source_(_Deref_post_opt_z_cap_c_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post2_impl_(__zterm_impl,__cap_c_impl(size))     _Post_valid_impl_)
#define _Deref_post_z_bytecap_c_(size)           _SAL1_1_Source_(_Deref_post_z_bytecap_c_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post2_impl_(__zterm_impl,__bytecap_c_impl(size)) _Post_valid_impl_)
#define _Deref_post_opt_z_bytecap_c_(size)       _SAL1_1_Source_(_Deref_post_opt_z_bytecap_c_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post2_impl_(__zterm_impl,__bytecap_c_impl(size)) _Post_valid_impl_)

#define _Deref_post_z_cap_x_(size)               _SAL1_1_Source_(_Deref_post_z_cap_x_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post2_impl_(__zterm_impl,__cap_x_impl(size))     _Post_valid_impl_)
#define _Deref_post_opt_z_cap_x_(size)           _SAL1_1_Source_(_Deref_post_opt_z_cap_x_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post2_impl_(__zterm_impl,__cap_x_impl(size))     _Post_valid_impl_)
#define _Deref_post_z_bytecap_x_(size)           _SAL1_1_Source_(_Deref_post_z_bytecap_x_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post2_impl_(__zterm_impl,__bytecap_x_impl(size)) _Post_valid_impl_)
#define _Deref_post_opt_z_bytecap_x_(size)       _SAL1_1_Source_(_Deref_post_opt_z_bytecap_x_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post2_impl_(__zterm_impl,__bytecap_x_impl(size)) _Post_valid_impl_)

// known capacity and valid but unknown readable extent
#define _Deref_post_valid_cap_(size)             _SAL1_1_Source_(_Deref_post_valid_cap_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__cap_impl(size))       _Post_valid_impl_)
#define _Deref_post_opt_valid_cap_(size)         _SAL1_1_Source_(_Deref_post_opt_valid_cap_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__cap_impl(size))       _Post_valid_impl_)
#define _Deref_post_valid_bytecap_(size)         _SAL1_1_Source_(_Deref_post_valid_bytecap_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__bytecap_impl(size))   _Post_valid_impl_)
#define _Deref_post_opt_valid_bytecap_(size)     _SAL1_1_Source_(_Deref_post_opt_valid_bytecap_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__bytecap_impl(size))   _Post_valid_impl_)

#define _Deref_post_valid_cap_c_(size)           _SAL1_1_Source_(_Deref_post_valid_cap_c_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__cap_c_impl(size))     _Post_valid_impl_)
#define _Deref_post_opt_valid_cap_c_(size)       _SAL1_1_Source_(_Deref_post_opt_valid_cap_c_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__cap_c_impl(size))     _Post_valid_impl_)
#define _Deref_post_valid_bytecap_c_(size)       _SAL1_1_Source_(_Deref_post_valid_bytecap_c_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__bytecap_c_impl(size)) _Post_valid_impl_)
#define _Deref_post_opt_valid_bytecap_c_(size)   _SAL1_1_Source_(_Deref_post_opt_valid_bytecap_c_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__bytecap_c_impl(size)) _Post_valid_impl_)

#define _Deref_post_valid_cap_x_(size)           _SAL1_1_Source_(_Deref_post_valid_cap_x_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__cap_x_impl(size))     _Post_valid_impl_)
#define _Deref_post_opt_valid_cap_x_(size)       _SAL1_1_Source_(_Deref_post_opt_valid_cap_x_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__cap_x_impl(size))     _Post_valid_impl_)
#define _Deref_post_valid_bytecap_x_(size)       _SAL1_1_Source_(_Deref_post_valid_bytecap_x_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__bytecap_x_impl(size)) _Post_valid_impl_)
#define _Deref_post_opt_valid_bytecap_x_(size)   _SAL1_1_Source_(_Deref_post_opt_valid_bytecap_x_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__bytecap_x_impl(size)) _Post_valid_impl_)

// e.g. HRESULT HrAllocateZeroInitializedMemory( size_t cb, _Out_ _Deref_post_bytecount_(cb) void** ppv );
// valid buffer extent is described by another parameter
#define _Deref_post_count_(size)                 _SAL1_1_Source_(_Deref_post_count_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__count_impl(size))       _Post_valid_impl_)
#define _Deref_post_opt_count_(size)             _SAL1_1_Source_(_Deref_post_opt_count_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__count_impl(size))       _Post_valid_impl_)
#define _Deref_post_bytecount_(size)             _SAL1_1_Source_(_Deref_post_bytecount_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__bytecount_impl(size))   _Post_valid_impl_)
#define _Deref_post_opt_bytecount_(size)         _SAL1_1_Source_(_Deref_post_opt_bytecount_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__bytecount_impl(size))   _Post_valid_impl_)

// buffer capacity is described by a constant expression
#define _Deref_post_count_c_(size)               _SAL1_1_Source_(_Deref_post_count_c_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__count_c_impl(size))     _Post_valid_impl_)
#define _Deref_post_opt_count_c_(size)           _SAL1_1_Source_(_Deref_post_opt_count_c_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__count_c_impl(size))     _Post_valid_impl_)
#define _Deref_post_bytecount_c_(size)           _SAL1_1_Source_(_Deref_post_bytecount_c_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__bytecount_c_impl(size)) _Post_valid_impl_)
#define _Deref_post_opt_bytecount_c_(size)       _SAL1_1_Source_(_Deref_post_opt_bytecount_c_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__bytecount_c_impl(size)) _Post_valid_impl_)

// buffer capacity is described by a complex expression
#define _Deref_post_count_x_(size)               _SAL1_1_Source_(_Deref_post_count_x_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__count_x_impl(size))     _Post_valid_impl_)
#define _Deref_post_opt_count_x_(size)           _SAL1_1_Source_(_Deref_post_opt_count_x_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__count_x_impl(size))     _Post_valid_impl_)
#define _Deref_post_bytecount_x_(size)           _SAL1_1_Source_(_Deref_post_bytecount_x_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__bytecount_x_impl(size)) _Post_valid_impl_)
#define _Deref_post_opt_bytecount_x_(size)       _SAL1_1_Source_(_Deref_post_opt_bytecount_x_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__bytecount_x_impl(size)) _Post_valid_impl_)

// e.g. void GetStrings( _Out_count_(cElems) _Deref_post_valid_ LPSTR const rgStr[], size_t cElems );
#define _Deref_post_valid_                       _SAL1_1_Source_(_Deref_post_valid_, (), _Deref_post1_impl_(__notnull_impl_notref)   _Post_valid_impl_)
#define _Deref_post_opt_valid_                   _SAL1_1_Source_(_Deref_post_opt_valid_, (), _Deref_post1_impl_(__maybenull_impl_notref) _Post_valid_impl_)

#define _Deref_post_notnull_                     _SAL1_1_Source_(_Deref_post_notnull_, (), _Deref_post1_impl_(__notnull_impl_notref))
#define _Deref_post_maybenull_                   _SAL1_1_Source_(_Deref_post_maybenull_, (), _Deref_post1_impl_(__maybenull_impl_notref))
#define _Deref_post_null_                        _SAL1_1_Source_(_Deref_post_null_, (), _Deref_post1_impl_(__null_impl_notref))

//
// _Deref_ret_ ---
//

#define _Deref_ret_z_                            _SAL1_1_Source_(_Deref_ret_z_, (), _Deref_ret1_impl_(__notnull_impl_notref) _Deref_ret1_impl_(__zterm_impl))
#define _Deref_ret_opt_z_                        _SAL1_1_Source_(_Deref_ret_opt_z_, (), _Deref_ret1_impl_(__maybenull_impl_notref) _Ret1_impl_(__zterm_impl))

//
// special _Deref_ ---
//
#define _Deref2_pre_readonly_                    _SAL1_1_Source_(_Deref2_pre_readonly_, (), _Deref2_pre1_impl_(__readaccess_impl_notref))

//
// _Ret_ ---
//

// e.g. _Ret_opt_valid_ LPSTR void* CloneSTR( _Pre_valid_ LPSTR src );
#define _Ret_opt_valid_                   _SAL1_1_Source_(_Ret_opt_valid_, (), _Ret1_impl_(__maybenull_impl_notref) _Ret_valid_impl_)
#define _Ret_opt_z_                       _SAL1_1_Source_(_Ret_opt_z_, (), _Ret2_impl_(__maybenull_impl,__zterm_impl) _Ret_valid_impl_)

// e.g. _Ret_opt_bytecap_(cb) void* AllocateMemory( size_t cb );
// Buffer capacity is described by another parameter
#define _Ret_cap_(size)                   _SAL1_1_Source_(_Ret_cap_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret1_impl_(__cap_impl(size)))
#define _Ret_opt_cap_(size)               _SAL1_1_Source_(_Ret_opt_cap_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret1_impl_(__cap_impl(size)))
#define _Ret_bytecap_(size)               _SAL1_1_Source_(_Ret_bytecap_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret1_impl_(__bytecap_impl(size)))
#define _Ret_opt_bytecap_(size)           _SAL1_1_Source_(_Ret_opt_bytecap_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret1_impl_(__bytecap_impl(size)))

// Buffer capacity is described by a constant expression
#define _Ret_cap_c_(size)                 _SAL1_1_Source_(_Ret_cap_c_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret1_impl_(__cap_c_impl(size)))
#define _Ret_opt_cap_c_(size)             _SAL1_1_Source_(_Ret_opt_cap_c_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret1_impl_(__cap_c_impl(size)))
#define _Ret_bytecap_c_(size)             _SAL1_1_Source_(_Ret_bytecap_c_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret1_impl_(__bytecap_c_impl(size)))
#define _Ret_opt_bytecap_c_(size)         _SAL1_1_Source_(_Ret_opt_bytecap_c_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret1_impl_(__bytecap_c_impl(size)))

// Buffer capacity is described by a complex condition
#define _Ret_cap_x_(size)                 _SAL1_1_Source_(_Ret_cap_x_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret1_impl_(__cap_x_impl(size)))
#define _Ret_opt_cap_x_(size)             _SAL1_1_Source_(_Ret_opt_cap_x_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret1_impl_(__cap_x_impl(size)))
#define _Ret_bytecap_x_(size)             _SAL1_1_Source_(_Ret_bytecap_x_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret1_impl_(__bytecap_x_impl(size)))
#define _Ret_opt_bytecap_x_(size)         _SAL1_1_Source_(_Ret_opt_bytecap_x_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret1_impl_(__bytecap_x_impl(size)))

// return value is nullterminated and capacity is given by another parameter
#define _Ret_z_cap_(size)                 _SAL1_1_Source_(_Ret_z_cap_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret2_impl_(__zterm_impl,__cap_impl(size))     _Ret_valid_impl_)
#define _Ret_opt_z_cap_(size)             _SAL1_1_Source_(_Ret_opt_z_cap_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret2_impl_(__zterm_impl,__cap_impl(size))     _Ret_valid_impl_)
#define _Ret_z_bytecap_(size)             _SAL1_1_Source_(_Ret_z_bytecap_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret2_impl_(__zterm_impl,__bytecap_impl(size)) _Ret_valid_impl_)
#define _Ret_opt_z_bytecap_(size)         _SAL1_1_Source_(_Ret_opt_z_bytecap_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret2_impl_(__zterm_impl,__bytecap_impl(size)) _Ret_valid_impl_)

// e.g. _Ret_opt_bytecount_(cb) void* AllocateZeroInitializedMemory( size_t cb );
// Valid Buffer extent is described by another parameter
#define _Ret_count_(size)                 _SAL1_1_Source_(_Ret_count_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret1_impl_(__count_impl(size))     _Ret_valid_impl_)
#define _Ret_opt_count_(size)             _SAL1_1_Source_(_Ret_opt_count_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret1_impl_(__count_impl(size))     _Ret_valid_impl_)
#define _Ret_bytecount_(size)             _SAL1_1_Source_(_Ret_bytecount_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret1_impl_(__bytecount_impl(size)) _Ret_valid_impl_)
#define _Ret_opt_bytecount_(size)         _SAL1_1_Source_(_Ret_opt_bytecount_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret1_impl_(__bytecount_impl(size)) _Ret_valid_impl_)

// Valid Buffer extent is described by a constant expression
#define _Ret_count_c_(size)               _SAL1_1_Source_(_Ret_count_c_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret1_impl_(__count_c_impl(size))     _Ret_valid_impl_)
#define _Ret_opt_count_c_(size)           _SAL1_1_Source_(_Ret_opt_count_c_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret1_impl_(__count_c_impl(size))     _Ret_valid_impl_)
#define _Ret_bytecount_c_(size)           _SAL1_1_Source_(_Ret_bytecount_c_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret1_impl_(__bytecount_c_impl(size)) _Ret_valid_impl_)
#define _Ret_opt_bytecount_c_(size)       _SAL1_1_Source_(_Ret_opt_bytecount_c_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret1_impl_(__bytecount_c_impl(size)) _Ret_valid_impl_)

// Valid Buffer extent is described by a complex expression
#define _Ret_count_x_(size)               _SAL1_1_Source_(_Ret_count_x_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret1_impl_(__count_x_impl(size))     _Ret_valid_impl_)
#define _Ret_opt_count_x_(size)           _SAL1_1_Source_(_Ret_opt_count_x_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret1_impl_(__count_x_impl(size))     _Ret_valid_impl_)
#define _Ret_bytecount_x_(size)           _SAL1_1_Source_(_Ret_bytecount_x_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret1_impl_(__bytecount_x_impl(size)) _Ret_valid_impl_)
#define _Ret_opt_bytecount_x_(size)       _SAL1_1_Source_(_Ret_opt_bytecount_x_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret1_impl_(__bytecount_x_impl(size)) _Ret_valid_impl_)

// return value is nullterminated and length is given by another parameter
#define _Ret_z_count_(size)               _SAL1_1_Source_(_Ret_z_count_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret2_impl_(__zterm_impl,__count_impl(size))     _Ret_valid_impl_)
#define _Ret_opt_z_count_(size)           _SAL1_1_Source_(_Ret_opt_z_count_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret2_impl_(__zterm_impl,__count_impl(size))     _Ret_valid_impl_)
#define _Ret_z_bytecount_(size)           _SAL1_1_Source_(_Ret_z_bytecount_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret2_impl_(__zterm_impl,__bytecount_impl(size)) _Ret_valid_impl_)
#define _Ret_opt_z_bytecount_(size)       _SAL1_1_Source_(_Ret_opt_z_bytecount_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret2_impl_(__zterm_impl,__bytecount_impl(size)) _Ret_valid_impl_)


// _Pre_ annotations ---
#define _Pre_opt_z_                       _SAL1_1_Source_(_Pre_opt_z_, (), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__zterm_impl) _Pre_valid_impl_)

// restrict access rights
#define _Pre_readonly_                    _SAL1_1_Source_(_Pre_readonly_, (), _Pre1_impl_(__readaccess_impl_notref))
#define _Pre_writeonly_                   _SAL1_1_Source_(_Pre_writeonly_, (), _Pre1_impl_(__writeaccess_impl_notref))

// e.g. void FreeMemory( _Pre_bytecap_(cb) _Post_ptr_invalid_ void* pv, size_t cb );
// buffer capacity described by another parameter
#define _Pre_cap_(size)                   _SAL1_1_Source_(_Pre_cap_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__cap_impl(size)))
#define _Pre_opt_cap_(size)               _SAL1_1_Source_(_Pre_opt_cap_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__cap_impl(size)))
#define _Pre_bytecap_(size)               _SAL1_1_Source_(_Pre_bytecap_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__bytecap_impl(size)))
#define _Pre_opt_bytecap_(size)           _SAL1_1_Source_(_Pre_opt_bytecap_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__bytecap_impl(size)))

// buffer capacity described by a constant expression
#define _Pre_cap_c_(size)                 _SAL1_1_Source_(_Pre_cap_c_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__cap_c_impl(size)))
#define _Pre_opt_cap_c_(size)             _SAL1_1_Source_(_Pre_opt_cap_c_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__cap_c_impl(size)))
#define _Pre_bytecap_c_(size)             _SAL1_1_Source_(_Pre_bytecap_c_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__bytecap_c_impl(size)))
#define _Pre_opt_bytecap_c_(size)         _SAL1_1_Source_(_Pre_opt_bytecap_c_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__bytecap_c_impl(size)))
#define _Pre_cap_c_one_                   _SAL1_1_Source_(_Pre_cap_c_one_, (), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__cap_c_one_notref_impl))
#define _Pre_opt_cap_c_one_               _SAL1_1_Source_(_Pre_opt_cap_c_one_, (), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__cap_c_one_notref_impl))

// buffer capacity is described by another parameter multiplied by a constant expression
#define _Pre_cap_m_(mult,size)            _SAL1_1_Source_(_Pre_cap_m_, (mult,size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__mult_impl(mult,size)))
#define _Pre_opt_cap_m_(mult,size)        _SAL1_1_Source_(_Pre_opt_cap_m_, (mult,size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__mult_impl(mult,size)))

// buffer capacity described by size of other buffer, only used by dangerous legacy APIs
// e.g. int strcpy(_Pre_cap_for_(src) char* dst, const char* src);
#define _Pre_cap_for_(param)              _SAL1_1_Source_(_Pre_cap_for_, (param), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__cap_for_impl(param)))
#define _Pre_opt_cap_for_(param)          _SAL1_1_Source_(_Pre_opt_cap_for_, (param), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__cap_for_impl(param)))

// buffer capacity described by a complex condition
#define _Pre_cap_x_(size)                 _SAL1_1_Source_(_Pre_cap_x_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__cap_x_impl(size)))
#define _Pre_opt_cap_x_(size)             _SAL1_1_Source_(_Pre_opt_cap_x_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__cap_x_impl(size)))
#define _Pre_bytecap_x_(size)             _SAL1_1_Source_(_Pre_bytecap_x_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__bytecap_x_impl(size)))
#define _Pre_opt_bytecap_x_(size)         _SAL1_1_Source_(_Pre_opt_bytecap_x_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__bytecap_x_impl(size)))

// buffer capacity described by the difference to another pointer parameter
#define _Pre_ptrdiff_cap_(ptr)            _SAL1_1_Source_(_Pre_ptrdiff_cap_, (ptr), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__cap_x_impl(__ptrdiff(ptr))))
#define _Pre_opt_ptrdiff_cap_(ptr)        _SAL1_1_Source_(_Pre_opt_ptrdiff_cap_, (ptr), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__cap_x_impl(__ptrdiff(ptr))))

// e.g. void AppendStr( _Pre_z_ const char* szFrom, _Pre_z_cap_(cchTo) _Post_z_ char* szTo, size_t cchTo );
#define _Pre_z_cap_(size)                 _SAL1_1_Source_(_Pre_z_cap_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre2_impl_(__zterm_impl,__cap_impl(size))       _Pre_valid_impl_)
#define _Pre_opt_z_cap_(size)             _SAL1_1_Source_(_Pre_opt_z_cap_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre2_impl_(__zterm_impl,__cap_impl(size))       _Pre_valid_impl_)
#define _Pre_z_bytecap_(size)             _SAL1_1_Source_(_Pre_z_bytecap_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre2_impl_(__zterm_impl,__bytecap_impl(size))   _Pre_valid_impl_)
#define _Pre_opt_z_bytecap_(size)         _SAL1_1_Source_(_Pre_opt_z_bytecap_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre2_impl_(__zterm_impl,__bytecap_impl(size))   _Pre_valid_impl_)

#define _Pre_z_cap_c_(size)               _SAL1_1_Source_(_Pre_z_cap_c_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre2_impl_(__zterm_impl,__cap_c_impl(size))     _Pre_valid_impl_)
#define _Pre_opt_z_cap_c_(size)           _SAL1_1_Source_(_Pre_opt_z_cap_c_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre2_impl_(__zterm_impl,__cap_c_impl(size))     _Pre_valid_impl_)
#define _Pre_z_bytecap_c_(size)           _SAL1_1_Source_(_Pre_z_bytecap_c_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre2_impl_(__zterm_impl,__bytecap_c_impl(size)) _Pre_valid_impl_)
#define _Pre_opt_z_bytecap_c_(size)       _SAL1_1_Source_(_Pre_opt_z_bytecap_c_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre2_impl_(__zterm_impl,__bytecap_c_impl(size)) _Pre_valid_impl_)

#define _Pre_z_cap_x_(size)               _SAL1_1_Source_(_Pre_z_cap_x_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre2_impl_(__zterm_impl,__cap_x_impl(size))     _Pre_valid_impl_)
#define _Pre_opt_z_cap_x_(size)           _SAL1_1_Source_(_Pre_opt_z_cap_x_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre2_impl_(__zterm_impl,__cap_x_impl(size))     _Pre_valid_impl_)
#define _Pre_z_bytecap_x_(size)           _SAL1_1_Source_(_Pre_z_bytecap_x_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre2_impl_(__zterm_impl,__bytecap_x_impl(size)) _Pre_valid_impl_)
#define _Pre_opt_z_bytecap_x_(size)       _SAL1_1_Source_(_Pre_opt_z_bytecap_x_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre2_impl_(__zterm_impl,__bytecap_x_impl(size)) _Pre_valid_impl_)

// known capacity and valid but unknown readable extent
#define _Pre_valid_cap_(size)             _SAL1_1_Source_(_Pre_valid_cap_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__cap_impl(size))       _Pre_valid_impl_)
#define _Pre_opt_valid_cap_(size)         _SAL1_1_Source_(_Pre_opt_valid_cap_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__cap_impl(size))       _Pre_valid_impl_)
#define _Pre_valid_bytecap_(size)         _SAL1_1_Source_(_Pre_valid_bytecap_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__bytecap_impl(size))   _Pre_valid_impl_)
#define _Pre_opt_valid_bytecap_(size)     _SAL1_1_Source_(_Pre_opt_valid_bytecap_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__bytecap_impl(size))   _Pre_valid_impl_)

#define _Pre_valid_cap_c_(size)           _SAL1_1_Source_(_Pre_valid_cap_c_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__cap_c_impl(size))     _Pre_valid_impl_)
#define _Pre_opt_valid_cap_c_(size)       _SAL1_1_Source_(_Pre_opt_valid_cap_c_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__cap_c_impl(size))     _Pre_valid_impl_)
#define _Pre_valid_bytecap_c_(size)       _SAL1_1_Source_(_Pre_valid_bytecap_c_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__bytecap_c_impl(size)) _Pre_valid_impl_)
#define _Pre_opt_valid_bytecap_c_(size)   _SAL1_1_Source_(_Pre_opt_valid_bytecap_c_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__bytecap_c_impl(size)) _Pre_valid_impl_)

#define _Pre_valid_cap_x_(size)           _SAL1_1_Source_(_Pre_valid_cap_x_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__cap_x_impl(size))     _Pre_valid_impl_)
#define _Pre_opt_valid_cap_x_(size)       _SAL1_1_Source_(_Pre_opt_valid_cap_x_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__cap_x_impl(size))     _Pre_valid_impl_)
#define _Pre_valid_bytecap_x_(size)       _SAL1_1_Source_(_Pre_valid_bytecap_x_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__bytecap_x_impl(size)) _Pre_valid_impl_)
#define _Pre_opt_valid_bytecap_x_(size)   _SAL1_1_Source_(_Pre_opt_valid_bytecap_x_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__bytecap_x_impl(size)) _Pre_valid_impl_)

// e.g. void AppendCharRange( _Pre_count_(cchFrom) const char* rgFrom, size_t cchFrom, _Out_z_cap_(cchTo) char* szTo, size_t cchTo );
// Valid buffer extent described by another parameter
#define _Pre_count_(size)                 _SAL1_1_Source_(_Pre_count_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__count_impl(size))       _Pre_valid_impl_)
#define _Pre_opt_count_(size)             _SAL1_1_Source_(_Pre_opt_count_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__count_impl(size))       _Pre_valid_impl_)
#define _Pre_bytecount_(size)             _SAL1_1_Source_(_Pre_bytecount_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__bytecount_impl(size))   _Pre_valid_impl_)
#define _Pre_opt_bytecount_(size)         _SAL1_1_Source_(_Pre_opt_bytecount_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__bytecount_impl(size))   _Pre_valid_impl_)

// Valid buffer extent described by a constant expression
#define _Pre_count_c_(size)               _SAL1_1_Source_(_Pre_count_c_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__count_c_impl(size))     _Pre_valid_impl_)
#define _Pre_opt_count_c_(size)           _SAL1_1_Source_(_Pre_opt_count_c_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__count_c_impl(size))     _Pre_valid_impl_)
#define _Pre_bytecount_c_(size)           _SAL1_1_Source_(_Pre_bytecount_c_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__bytecount_c_impl(size)) _Pre_valid_impl_)
#define _Pre_opt_bytecount_c_(size)       _SAL1_1_Source_(_Pre_opt_bytecount_c_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__bytecount_c_impl(size)) _Pre_valid_impl_)

// Valid buffer extent described by a complex expression
#define _Pre_count_x_(size)               _SAL1_1_Source_(_Pre_count_x_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__count_x_impl(size))     _Pre_valid_impl_)
#define _Pre_opt_count_x_(size)           _SAL1_1_Source_(_Pre_opt_count_x_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__count_x_impl(size))     _Pre_valid_impl_)
#define _Pre_bytecount_x_(size)           _SAL1_1_Source_(_Pre_bytecount_x_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__bytecount_x_impl(size)) _Pre_valid_impl_)
#define _Pre_opt_bytecount_x_(size)       _SAL1_1_Source_(_Pre_opt_bytecount_x_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__bytecount_x_impl(size)) _Pre_valid_impl_)

// Valid buffer extent described by the difference to another pointer parameter
#define _Pre_ptrdiff_count_(ptr)          _SAL1_1_Source_(_Pre_ptrdiff_count_, (ptr), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__count_x_impl(__ptrdiff(ptr))) _Pre_valid_impl_)
#define _Pre_opt_ptrdiff_count_(ptr)      _SAL1_1_Source_(_Pre_opt_ptrdiff_count_, (ptr), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__count_x_impl(__ptrdiff(ptr))) _Pre_valid_impl_)


// char * strncpy(_Out_cap_(_Count) _Post_maybez_ char * _Dest, _In_z_ const char * _Source, _In_ size_t _Count)
// buffer maybe zero-terminated after the call
#define _Post_maybez_                    _SAL_L_Source_(_Post_maybez_, (), _Post1_impl_(__maybezterm_impl))

// e.g. SIZE_T HeapSize( _In_ HANDLE hHeap, DWORD dwFlags, _Pre_notnull_ _Post_bytecap_(return) LPCVOID lpMem );
#define _Post_cap_(size)                 _SAL1_1_Source_(_Post_cap_, (size), _Post1_impl_(__cap_impl(size)))
#define _Post_bytecap_(size)             _SAL1_1_Source_(_Post_bytecap_, (size), _Post1_impl_(__bytecap_impl(size)))

// e.g. int strlen( _In_z_ _Post_count_(return+1) const char* sz );
#define _Post_count_(size)               _SAL1_1_Source_(_Post_count_, (size), _Post1_impl_(__count_impl(size))       _Post_valid_impl_)
#define _Post_bytecount_(size)           _SAL1_1_Source_(_Post_bytecount_, (size), _Post1_impl_(__bytecount_impl(size))   _Post_valid_impl_)
#define _Post_count_c_(size)             _SAL1_1_Source_(_Post_count_c_, (size), _Post1_impl_(__count_c_impl(size))     _Post_valid_impl_)
#define _Post_bytecount_c_(size)         _SAL1_1_Source_(_Post_bytecount_c_, (size), _Post1_impl_(__bytecount_c_impl(size)) _Post_valid_impl_)
#define _Post_count_x_(size)             _SAL1_1_Source_(_Post_count_x_, (size), _Post1_impl_(__count_x_impl(size))     _Post_valid_impl_)
#define _Post_bytecount_x_(size)         _SAL1_1_Source_(_Post_bytecount_x_, (size), _Post1_impl_(__bytecount_x_impl(size)) _Post_valid_impl_)

// e.g. size_t CopyStr( _In_z_ const char* szFrom, _Pre_cap_(cch) _Post_z_count_(return+1) char* szFrom, size_t cchFrom );
#define _Post_z_count_(size)             _SAL1_1_Source_(_Post_z_count_, (size), _Post2_impl_(__zterm_impl,__count_impl(size))       _Post_valid_impl_)
#define _Post_z_bytecount_(size)         _SAL1_1_Source_(_Post_z_bytecount_, (size), _Post2_impl_(__zterm_impl,__bytecount_impl(size))   _Post_valid_impl_)
#define _Post_z_count_c_(size)           _SAL1_1_Source_(_Post_z_count_c_, (size), _Post2_impl_(__zterm_impl,__count_c_impl(size))     _Post_valid_impl_)
#define _Post_z_bytecount_c_(size)       _SAL1_1_Source_(_Post_z_bytecount_c_, (size), _Post2_impl_(__zterm_impl,__bytecount_c_impl(size)) _Post_valid_impl_)
#define _Post_z_count_x_(size)           _SAL1_1_Source_(_Post_z_count_x_, (size), _Post2_impl_(__zterm_impl,__count_x_impl(size))     _Post_valid_impl_)
#define _Post_z_bytecount_x_(size)       _SAL1_1_Source_(_Post_z_bytecount_x_, (size), _Post2_impl_(__zterm_impl,__bytecount_x_impl(size)) _Post_valid_impl_)

//
// _Prepost_ ---
//
// describing conditions that hold before and after the function call

#define _Prepost_opt_z_                  _SAL1_1_Source_(_Prepost_opt_z_, (), _Pre_opt_z_  _Post_z_)

#define _Prepost_count_(size)            _SAL1_1_Source_(_Prepost_count_, (size), _Pre_count_(size)           _Post_count_(size))
#define _Prepost_opt_count_(size)        _SAL1_1_Source_(_Prepost_opt_count_, (size), _Pre_opt_count_(size)       _Post_count_(size))
#define _Prepost_bytecount_(size)        _SAL1_1_Source_(_Prepost_bytecount_, (size), _Pre_bytecount_(size)       _Post_bytecount_(size))
#define _Prepost_opt_bytecount_(size)    _SAL1_1_Source_(_Prepost_opt_bytecount_, (size), _Pre_opt_bytecount_(size)   _Post_bytecount_(size))
#define _Prepost_count_c_(size)          _SAL1_1_Source_(_Prepost_count_c_, (size), _Pre_count_c_(size)         _Post_count_c_(size))
#define _Prepost_opt_count_c_(size)      _SAL1_1_Source_(_Prepost_opt_count_c_, (size), _Pre_opt_count_c_(size)     _Post_count_c_(size))
#define _Prepost_bytecount_c_(size)      _SAL1_1_Source_(_Prepost_bytecount_c_, (size), _Pre_bytecount_c_(size)     _Post_bytecount_c_(size))
#define _Prepost_opt_bytecount_c_(size)  _SAL1_1_Source_(_Prepost_opt_bytecount_c_, (size), _Pre_opt_bytecount_c_(size) _Post_bytecount_c_(size))
#define _Prepost_count_x_(size)          _SAL1_1_Source_(_Prepost_count_x_, (size), _Pre_count_x_(size)         _Post_count_x_(size))
#define _Prepost_opt_count_x_(size)      _SAL1_1_Source_(_Prepost_opt_count_x_, (size), _Pre_opt_count_x_(size)     _Post_count_x_(size))
#define _Prepost_bytecount_x_(size)      _SAL1_1_Source_(_Prepost_bytecount_x_, (size), _Pre_bytecount_x_(size)     _Post_bytecount_x_(size))
#define _Prepost_opt_bytecount_x_(size)  _SAL1_1_Source_(_Prepost_opt_bytecount_x_, (size), _Pre_opt_bytecount_x_(size) _Post_bytecount_x_(size))

#define _Prepost_valid_                   _SAL1_1_Source_(_Prepost_valid_, (), _Pre_valid_     _Post_valid_)
#define _Prepost_opt_valid_               _SAL1_1_Source_(_Prepost_opt_valid_, (), _Pre_opt_valid_ _Post_valid_)

//
// _Deref_<both> ---
//
// short version for _Deref_pre_<ann> _Deref_post_<ann>
// describing conditions for array elements or dereferenced pointer parameters that hold before and after the call

#define _Deref_prepost_z_                         _SAL1_1_Source_(_Deref_prepost_z_, (), _Deref_pre_z_      _Deref_post_z_)
#define _Deref_prepost_opt_z_                     _SAL1_1_Source_(_Deref_prepost_opt_z_, (), _Deref_pre_opt_z_  _Deref_post_opt_z_)

#define _Deref_prepost_cap_(size)                 _SAL1_1_Source_(_Deref_prepost_cap_, (size), _Deref_pre_cap_(size)                _Deref_post_cap_(size))
#define _Deref_prepost_opt_cap_(size)             _SAL1_1_Source_(_Deref_prepost_opt_cap_, (size), _Deref_pre_opt_cap_(size)            _Deref_post_opt_cap_(size))
#define _Deref_prepost_bytecap_(size)             _SAL1_1_Source_(_Deref_prepost_bytecap_, (size), _Deref_pre_bytecap_(size)            _Deref_post_bytecap_(size))
#define _Deref_prepost_opt_bytecap_(size)         _SAL1_1_Source_(_Deref_prepost_opt_bytecap_, (size), _Deref_pre_opt_bytecap_(size)        _Deref_post_opt_bytecap_(size))

#define _Deref_prepost_cap_x_(size)               _SAL1_1_Source_(_Deref_prepost_cap_x_, (size), _Deref_pre_cap_x_(size)              _Deref_post_cap_x_(size))
#define _Deref_prepost_opt_cap_x_(size)           _SAL1_1_Source_(_Deref_prepost_opt_cap_x_, (size), _Deref_pre_opt_cap_x_(size)          _Deref_post_opt_cap_x_(size))
#define _Deref_prepost_bytecap_x_(size)           _SAL1_1_Source_(_Deref_prepost_bytecap_x_, (size), _Deref_pre_bytecap_x_(size)          _Deref_post_bytecap_x_(size))
#define _Deref_prepost_opt_bytecap_x_(size)       _SAL1_1_Source_(_Deref_prepost_opt_bytecap_x_, (size), _Deref_pre_opt_bytecap_x_(size)      _Deref_post_opt_bytecap_x_(size))

#define _Deref_prepost_z_cap_(size)               _SAL1_1_Source_(_Deref_prepost_z_cap_, (size), _Deref_pre_z_cap_(size)              _Deref_post_z_cap_(size))
#define _Deref_prepost_opt_z_cap_(size)           _SAL1_1_Source_(_Deref_prepost_opt_z_cap_, (size), _Deref_pre_opt_z_cap_(size)          _Deref_post_opt_z_cap_(size))
#define _Deref_prepost_z_bytecap_(size)           _SAL1_1_Source_(_Deref_prepost_z_bytecap_, (size), _Deref_pre_z_bytecap_(size)          _Deref_post_z_bytecap_(size))
#define _Deref_prepost_opt_z_bytecap_(size)       _SAL1_1_Source_(_Deref_prepost_opt_z_bytecap_, (size), _Deref_pre_opt_z_bytecap_(size)      _Deref_post_opt_z_bytecap_(size))

#define _Deref_prepost_valid_cap_(size)           _SAL1_1_Source_(_Deref_prepost_valid_cap_, (size), _Deref_pre_valid_cap_(size)          _Deref_post_valid_cap_(size))
#define _Deref_prepost_opt_valid_cap_(size)       _SAL1_1_Source_(_Deref_prepost_opt_valid_cap_, (size), _Deref_pre_opt_valid_cap_(size)      _Deref_post_opt_valid_cap_(size))
#define _Deref_prepost_valid_bytecap_(size)       _SAL1_1_Source_(_Deref_prepost_valid_bytecap_, (size), _Deref_pre_valid_bytecap_(size)      _Deref_post_valid_bytecap_(size))
#define _Deref_prepost_opt_valid_bytecap_(size)   _SAL1_1_Source_(_Deref_prepost_opt_valid_bytecap_, (size), _Deref_pre_opt_valid_bytecap_(size)  _Deref_post_opt_valid_bytecap_(size))

#define _Deref_prepost_valid_cap_x_(size)           _SAL1_1_Source_(_Deref_prepost_valid_cap_x_, (size), _Deref_pre_valid_cap_x_(size)          _Deref_post_valid_cap_x_(size))
#define _Deref_prepost_opt_valid_cap_x_(size)       _SAL1_1_Source_(_Deref_prepost_opt_valid_cap_x_, (size), _Deref_pre_opt_valid_cap_x_(size)      _Deref_post_opt_valid_cap_x_(size))
#define _Deref_prepost_valid_bytecap_x_(size)       _SAL1_1_Source_(_Deref_prepost_valid_bytecap_x_, (size), _Deref_pre_valid_bytecap_x_(size)      _Deref_post_valid_bytecap_x_(size))
#define _Deref_prepost_opt_valid_bytecap_x_(size)   _SAL1_1_Source_(_Deref_prepost_opt_valid_bytecap_x_, (size), _Deref_pre_opt_valid_bytecap_x_(size)  _Deref_post_opt_valid_bytecap_x_(size))

#define _Deref_prepost_count_(size)             _SAL1_1_Source_(_Deref_prepost_count_, (size), _Deref_pre_count_(size)            _Deref_post_count_(size))
#define _Deref_prepost_opt_count_(size)         _SAL1_1_Source_(_Deref_prepost_opt_count_, (size), _Deref_pre_opt_count_(size)        _Deref_post_opt_count_(size))
#define _Deref_prepost_bytecount_(size)         _SAL1_1_Source_(_Deref_prepost_bytecount_, (size), _Deref_pre_bytecount_(size)        _Deref_post_bytecount_(size))
#define _Deref_prepost_opt_bytecount_(size)     _SAL1_1_Source_(_Deref_prepost_opt_bytecount_, (size), _Deref_pre_opt_bytecount_(size)    _Deref_post_opt_bytecount_(size))

#define _Deref_prepost_count_x_(size)           _SAL1_1_Source_(_Deref_prepost_count_x_, (size), _Deref_pre_count_x_(size)          _Deref_post_count_x_(size))
#define _Deref_prepost_opt_count_x_(size)       _SAL1_1_Source_(_Deref_prepost_opt_count_x_, (size), _Deref_pre_opt_count_x_(size)      _Deref_post_opt_count_x_(size))
#define _Deref_prepost_bytecount_x_(size)       _SAL1_1_Source_(_Deref_prepost_bytecount_x_, (size), _Deref_pre_bytecount_x_(size)      _Deref_post_bytecount_x_(size))
#define _Deref_prepost_opt_bytecount_x_(size)   _SAL1_1_Source_(_Deref_prepost_opt_bytecount_x_, (size), _Deref_pre_opt_bytecount_x_(size)  _Deref_post_opt_bytecount_x_(size))

#define _Deref_prepost_valid_                    _SAL1_1_Source_(_Deref_prepost_valid_, (), _Deref_pre_valid_     _Deref_post_valid_)
#define _Deref_prepost_opt_valid_                _SAL1_1_Source_(_Deref_prepost_opt_valid_, (), _Deref_pre_opt_valid_ _Deref_post_opt_valid_)

//
// _Deref_<miscellaneous>
//
// used with references to arrays

#define _Deref_out_z_cap_c_(size)  _SAL1_1_Source_(_Deref_out_z_cap_c_, (size), _Deref_pre_cap_c_(size) _Deref_post_z_)
#define _Deref_inout_z_cap_c_(size)  _SAL1_1_Source_(_Deref_inout_z_cap_c_, (size), _Deref_pre_z_cap_c_(size) _Deref_post_z_)
#define _Deref_out_z_bytecap_c_(size)  _SAL1_1_Source_(_Deref_out_z_bytecap_c_, (size), _Deref_pre_bytecap_c_(size) _Deref_post_z_)
#define _Deref_inout_z_bytecap_c_(size)  _SAL1_1_Source_(_Deref_inout_z_bytecap_c_, (size), _Deref_pre_z_bytecap_c_(size) _Deref_post_z_)
#define _Deref_inout_z_  _SAL1_1_Source_(_Deref_inout_z_, (), _Deref_prepost_z_)

#pragma endregion Input Buffer SAL 1 compatibility macros


//============================================================================
//   Implementation Layer:
//============================================================================


// Naming conventions:
// A symbol the begins with _SA_ is for the machinery of creating any
// annotations; many of those come from sourceannotations.h in the case
// of attributes.

// A symbol that ends with _impl is the very lowest level macro.  It is
// not required to be a legal standalone annotation, and in the case
// of attribute annotations, usually is not.  (In the case of some declspec
// annotations, it might be, but it should not be assumed so.)  Those
// symbols will be used in the _PreN..., _PostN... and _RetN... annotations
// to build up more complete annotations.

// A symbol ending in _impl_ is reserved to the implementation as well,
// but it does form a complete annotation; usually they are used to build
// up even higher level annotations.


#if _USE_ATTRIBUTES_FOR_SAL || _USE_DECLSPECS_FOR_SAL // [
// Sharable "_impl" macros: these can be shared between the various annotation
// forms but are part of the implementation of the macros.  These are collected
// here to assure that only necessary differences in the annotations
// exist.

#define _Always_impl_(annos)            _Group_(annos _SAL_nop_impl_) _On_failure_impl_(annos _SAL_nop_impl_)
#define _Bound_impl_                    _SA_annotes0(SAL_bound)
#define _Field_range_impl_(min,max)     _Range_impl_(min,max)
#define _Literal_impl_                  _SA_annotes1(SAL_constant, __yes)
#define _Maybenull_impl_                _SA_annotes1(SAL_null, __maybe)
#define _Maybevalid_impl_               _SA_annotes1(SAL_valid, __maybe)
#define _Must_inspect_impl_ _Post_impl_ _SA_annotes0(SAL_mustInspect)
#define _Notliteral_impl_               _SA_annotes1(SAL_constant, __no)
#define _Notnull_impl_                  _SA_annotes1(SAL_null, __no)
#define _Notvalid_impl_                 _SA_annotes1(SAL_valid, __no)
#define _NullNull_terminated_impl_      _Group_(_SA_annotes1(SAL_nullTerminated, __yes) _SA_annotes1(SAL_readableTo,inexpressibleCount("NullNull terminated string")))
#define _Null_impl_                     _SA_annotes1(SAL_null, __yes)
#define _Null_terminated_impl_          _SA_annotes1(SAL_nullTerminated, __yes)
#define _Out_impl_                      _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__cap_c_one_notref_impl) _Post_valid_impl_
#define _Out_opt_impl_                  _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__cap_c_one_notref_impl) _Post_valid_impl_
#define _Points_to_data_impl_           _At_(*_Curr_, _SA_annotes1(SAL_mayBePointer, __no))
#define _Post_satisfies_impl_(cond)     _Post_impl_ _Satisfies_impl_(cond)
#define _Post_valid_impl_               _Post1_impl_(__valid_impl)
#define _Pre_satisfies_impl_(cond)      _Pre_impl_ _Satisfies_impl_(cond)
#define _Pre_valid_impl_                _Pre1_impl_(__valid_impl)
#define _Range_impl_(min,max)           _SA_annotes2(SAL_range, min, max)
#define _Readable_bytes_impl_(size)     _SA_annotes1(SAL_readableTo, byteCount(size))
#define _Readable_elements_impl_(size)  _SA_annotes1(SAL_readableTo, elementCount(size))
#define _Ret_valid_impl_                _Ret1_impl_(__valid_impl)
#define _Satisfies_impl_(cond)          _SA_annotes1(SAL_satisfies, cond)
#define _Valid_impl_                    _SA_annotes1(SAL_valid, __yes)
#define _Writable_bytes_impl_(size)     _SA_annotes1(SAL_writableTo, byteCount(size))
#define _Writable_elements_impl_(size)  _SA_annotes1(SAL_writableTo, elementCount(size))

#define _In_range_impl_(min,max)        _Pre_impl_ _Range_impl_(min,max)
#define _Out_range_impl_(min,max)       _Post_impl_ _Range_impl_(min,max)
#define _Ret_range_impl_(min,max)       _Post_impl_ _Range_impl_(min,max)
#define _Deref_in_range_impl_(min,max)  _Deref_pre_impl_ _Range_impl_(min,max)
#define _Deref_out_range_impl_(min,max) _Deref_post_impl_ _Range_impl_(min,max)
#define _Deref_ret_range_impl_(min,max) _Deref_post_impl_ _Range_impl_(min,max)

#define _Deref_pre_impl_                _Pre_impl_  _Notref_impl_ _Deref_impl_
#define _Deref_post_impl_               _Post_impl_ _Notref_impl_ _Deref_impl_

// The following are for the implementation machinery, and are not
// suitable for annotating general code.
// We're tying to phase this out, someday.  The parser quotes the param.
#define __AuToQuOtE                     _SA_annotes0(SAL_AuToQuOtE)

// Normally the parser does some simple type checking of annotation params,
// defer that check to the plugin.
#define __deferTypecheck                _SA_annotes0(SAL_deferTypecheck)

#define _SA_SPECSTRIZE( x ) #x
#define _SAL_nop_impl_       /* nothing */
#define __nop_impl(x)            x
#endif


#if _USE_ATTRIBUTES_FOR_SAL // [

// Using attributes for sal

#include "CodeAnalysis/sourceannotations.h"


#define _SA_annotes0(n)                [SAL_annotes(Name=#n)]
#define _SA_annotes1(n,pp1)            [SAL_annotes(Name=#n, p1=_SA_SPECSTRIZE(pp1))]
#define _SA_annotes2(n,pp1,pp2)        [SAL_annotes(Name=#n, p1=_SA_SPECSTRIZE(pp1), p2=_SA_SPECSTRIZE(pp2))]
#define _SA_annotes3(n,pp1,pp2,pp3)    [SAL_annotes(Name=#n, p1=_SA_SPECSTRIZE(pp1), p2=_SA_SPECSTRIZE(pp2), p3=_SA_SPECSTRIZE(pp3))]

#define _Pre_impl_                     [SAL_pre]
#define _Post_impl_                    [SAL_post]
#define _Deref_impl_                   [SAL_deref]
#define _Notref_impl_                  [SAL_notref]


// Declare a function to be an annotation or primop (respectively).
// Done this way so that they don't appear in the regular compiler's
// namespace.
#define __ANNOTATION(fun)              _SA_annotes0(SAL_annotation)  void __SA_##fun;
#define __PRIMOP(type, fun)            _SA_annotes0(SAL_primop)  type __SA_##fun;
#define __QUALIFIER(fun)               _SA_annotes0(SAL_qualifier)  void __SA_##fun;

// Benign declspec needed here for WindowsPREfast
#define __In_impl_ [SA_Pre(Valid=SA_Yes)] [SA_Pre(Deref=1, Notref=1, Access=SA_Read)] __declspec("SAL_pre SAL_valid")

#elif _USE_DECLSPECS_FOR_SAL // ][

// Using declspecs for sal

#define _SA_annotes0(n)                __declspec(#n)
#define _SA_annotes1(n,pp1)            __declspec(#n "(" _SA_SPECSTRIZE(pp1) ")" )
#define _SA_annotes2(n,pp1,pp2)        __declspec(#n "(" _SA_SPECSTRIZE(pp1) "," _SA_SPECSTRIZE(pp2) ")")
#define _SA_annotes3(n,pp1,pp2,pp3)    __declspec(#n "(" _SA_SPECSTRIZE(pp1) "," _SA_SPECSTRIZE(pp2) "," _SA_SPECSTRIZE(pp3) ")")

#define _Pre_impl_                     _SA_annotes0(SAL_pre)
#define _Post_impl_                    _SA_annotes0(SAL_post)
#define _Deref_impl_                   _SA_annotes0(SAL_deref)
#define _Notref_impl_                  _SA_annotes0(SAL_notref)

// Declare a function to be an annotation or primop (respectively).
// Done this way so that they don't appear in the regular compiler's
// namespace.
#define __ANNOTATION(fun)              _SA_annotes0(SAL_annotation) void __SA_##fun

#define __PRIMOP(type, fun)            _SA_annotes0(SAL_primop) type __SA_##fun

#define __QUALIFIER(fun)               _SA_annotes0(SAL_qualifier)  void __SA_##fun;

#define __In_impl_ _Pre_impl_ _SA_annotes0(SAL_valid) _Pre_impl_ _Deref_impl_ _Notref_impl_ _SA_annotes0(SAL_readonly)

#else // ][

// Using "nothing" for sal

#define _SA_annotes0(n)
#define _SA_annotes1(n,pp1)
#define _SA_annotes2(n,pp1,pp2)
#define _SA_annotes3(n,pp1,pp2,pp3)

#define __ANNOTATION(fun)
#define __PRIMOP(type, fun)
#define __QUALIFIER(type, fun)

#endif // ]

#if _USE_ATTRIBUTES_FOR_SAL || _USE_DECLSPECS_FOR_SAL // [

// Declare annotations that need to be declared.
__ANNOTATION(SAL_useHeader(void));
__ANNOTATION(SAL_bound(void));
__ANNOTATION(SAL_allocator(void));   //??? resolve with PFD
__ANNOTATION(SAL_file_parser(__AuToQuOtE __In_impl_ char*, __In_impl_ char*));
__ANNOTATION(SAL_source_code_content(__In_impl_ char*));
__ANNOTATION(SAL_analysisHint(__AuToQuOtE __In_impl_ char*));
__ANNOTATION(SAL_untrusted_data_source(__AuToQuOtE __In_impl_ char*));
__ANNOTATION(SAL_untrusted_data_source_this(__AuToQuOtE __In_impl_ char*));
__ANNOTATION(SAL_validated(__AuToQuOtE __In_impl_ char*));
__ANNOTATION(SAL_validated_this(__AuToQuOtE __In_impl_ char*));
__ANNOTATION(SAL_encoded(void));
__ANNOTATION(SAL_adt(__AuToQuOtE __In_impl_ char*, __AuToQuOtE __In_impl_ char*));
__ANNOTATION(SAL_add_adt_property(__AuToQuOtE __In_impl_ char*, __AuToQuOtE __In_impl_ char*));
__ANNOTATION(SAL_remove_adt_property(__AuToQuOtE __In_impl_ char*, __AuToQuOtE __In_impl_ char*));
__ANNOTATION(SAL_transfer_adt_property_from(__AuToQuOtE __In_impl_ char*));
__ANNOTATION(SAL_post_type(__AuToQuOtE __In_impl_ char*));
__ANNOTATION(SAL_volatile(void));
__ANNOTATION(SAL_nonvolatile(void));
__ANNOTATION(SAL_entrypoint(__AuToQuOtE __In_impl_ char*, __AuToQuOtE __In_impl_ char*));
__ANNOTATION(SAL_blocksOn(__In_impl_ void*));
__ANNOTATION(SAL_mustInspect(void));

// Only appears in model files, but needs to be declared.
__ANNOTATION(SAL_TypeName(__AuToQuOtE __In_impl_ char*));

// To be declared well-known soon.
__ANNOTATION(SAL_interlocked(void);)

__QUALIFIER(SAL_name(__In_impl_ char*, __In_impl_ char*, __In_impl_ char*);)

__PRIMOP(char*, _Macro_value_(__In_impl_ char*));
__PRIMOP(int, _Macro_defined_(__In_impl_ char*));
__PRIMOP(char*, _Strstr_(__In_impl_ char*, __In_impl_ char*));

#endif // ]

#if _USE_ATTRIBUTES_FOR_SAL // [

#define _Check_return_impl_           [SA_Post(MustCheck=SA_Yes)]

#define _Success_impl_(expr)          [SA_Success(Condition=#expr)]
#define _On_failure_impl_(annos)      [SAL_context(p1="SAL_failed")] _Group_(_Post_impl_ _Group_(annos _SAL_nop_impl_))

#define _Printf_format_string_impl_   [SA_FormatString(Style="printf")]
#define _Scanf_format_string_impl_    [SA_FormatString(Style="scanf")]
#define _Scanf_s_format_string_impl_  [SA_FormatString(Style="scanf_s")]

#define _In_bound_impl_               [SA_PreBound(Deref=0)]
#define _Out_bound_impl_              [SA_PostBound(Deref=0)]
#define _Ret_bound_impl_              [SA_PostBound(Deref=0)]
#define _Deref_in_bound_impl_         [SA_PreBound(Deref=1)]
#define _Deref_out_bound_impl_        [SA_PostBound(Deref=1)]
#define _Deref_ret_bound_impl_        [SA_PostBound(Deref=1)]

#define __valid_impl                  Valid=SA_Yes
#define __maybevalid_impl             Valid=SA_Maybe
#define __notvalid_impl               Valid=SA_No

#define __null_impl                   Null=SA_Yes
#define __maybenull_impl              Null=SA_Maybe
#define __notnull_impl                Null=SA_No

#define __null_impl_notref        Null=SA_Yes,Notref=1
#define __maybenull_impl_notref   Null=SA_Maybe,Notref=1
#define __notnull_impl_notref     Null=SA_No,Notref=1

#define __zterm_impl              NullTerminated=SA_Yes
#define __maybezterm_impl         NullTerminated=SA_Maybe
#define __maybzterm_impl          NullTerminated=SA_Maybe
#define __notzterm_impl           NullTerminated=SA_No

#define __readaccess_impl         Access=SA_Read
#define __writeaccess_impl        Access=SA_Write
#define __allaccess_impl          Access=SA_ReadWrite

#define __readaccess_impl_notref  Access=SA_Read,Notref=1
#define __writeaccess_impl_notref Access=SA_Write,Notref=1
#define __allaccess_impl_notref   Access=SA_ReadWrite,Notref=1

// For SAL2, we need to expect general expressions.

#define __cap_impl(size)          WritableElements="\n"#size
#define __bytecap_impl(size)      WritableBytes="\n"#size
#define __bytecount_impl(size)    ValidBytes="\n"#size
#define __count_impl(size)        ValidElements="\n"#size

#define __cap_c_impl(size)        WritableElementsConst=size
#define __cap_c_one_notref_impl   WritableElementsConst=1,Notref=1
#define __cap_for_impl(param)     WritableElementsLength=#param
#define __cap_x_impl(size)        WritableElements="\n@"#size

#define __bytecap_c_impl(size)    WritableBytesConst=size
#define __bytecap_x_impl(size)    WritableBytes="\n@"#size

#define __mult_impl(mult,size)    __cap_impl((mult)*(size))

#define __count_c_impl(size)      ValidElementsConst=size
#define __count_x_impl(size)      ValidElements="\n@"#size

#define __bytecount_c_impl(size)  ValidBytesConst=size
#define __bytecount_x_impl(size)  ValidBytes="\n@"#size


#define _At_impl_(target, annos)       [SAL_at(p1=#target)] _Group_(annos)
#define _At_buffer_impl_(target, iter, bound, annos)  [SAL_at_buffer(p1=#target, p2=#iter, p3=#bound)] _Group_(annos)
#define _When_impl_(expr, annos)       [SAL_when(p1=#expr)] _Group_(annos)

#define _Group_impl_(annos)            [SAL_begin] annos [SAL_end]
#define _GrouP_impl_(annos)            [SAL_BEGIN] annos [SAL_END]

#define _Use_decl_anno_impl_               _SA_annotes0(SAL_useHeader) // this is a special case!

#define _Pre1_impl_(p1)                    [SA_Pre(p1)]
#define _Pre2_impl_(p1,p2)                 [SA_Pre(p1,p2)]
#define _Pre3_impl_(p1,p2,p3)              [SA_Pre(p1,p2,p3)]

#define _Post1_impl_(p1)                   [SA_Post(p1)]
#define _Post2_impl_(p1,p2)                [SA_Post(p1,p2)]
#define _Post3_impl_(p1,p2,p3)             [SA_Post(p1,p2,p3)]

#define _Ret1_impl_(p1)                    [SA_Post(p1)]
#define _Ret2_impl_(p1,p2)                 [SA_Post(p1,p2)]
#define _Ret3_impl_(p1,p2,p3)              [SA_Post(p1,p2,p3)]

#define _Deref_pre1_impl_(p1)              [SA_Pre(Deref=1,p1)]
#define _Deref_pre2_impl_(p1,p2)           [SA_Pre(Deref=1,p1,p2)]
#define _Deref_pre3_impl_(p1,p2,p3)        [SA_Pre(Deref=1,p1,p2,p3)]


#define _Deref_post1_impl_(p1)             [SA_Post(Deref=1,p1)]
#define _Deref_post2_impl_(p1,p2)          [SA_Post(Deref=1,p1,p2)]
#define _Deref_post3_impl_(p1,p2,p3)       [SA_Post(Deref=1,p1,p2,p3)]

#define _Deref_ret1_impl_(p1)              [SA_Post(Deref=1,p1)]
#define _Deref_ret2_impl_(p1,p2)           [SA_Post(Deref=1,p1,p2)]
#define _Deref_ret3_impl_(p1,p2,p3)        [SA_Post(Deref=1,p1,p2,p3)]

#define _Deref2_pre1_impl_(p1)             [SA_Pre(Deref=2,Notref=1,p1)]
#define _Deref2_post1_impl_(p1)            [SA_Post(Deref=2,Notref=1,p1)]
#define _Deref2_ret1_impl_(p1)             [SA_Post(Deref=2,Notref=1,p1)]

// Obsolete -- may be needed for transition to attributes.
#define __inner_typefix(ctype)             [SAL_typefix(p1=_SA_SPECSTRIZE(ctype))]
#define __inner_exceptthat                 [SAL_except]


#elif _USE_DECLSPECS_FOR_SAL // ][

#define _Check_return_impl_ __post      _SA_annotes0(SAL_checkReturn)

#define _Success_impl_(expr)            _SA_annotes1(SAL_success, expr)
#define _On_failure_impl_(annos)        _SA_annotes1(SAL_context, SAL_failed) _Group_(_Post_impl_ _Group_(_SAL_nop_impl_ annos))

#define _Printf_format_string_impl_     _SA_annotes1(SAL_IsFormatString, "printf")
#define _Scanf_format_string_impl_      _SA_annotes1(SAL_IsFormatString, "scanf")
#define _Scanf_s_format_string_impl_    _SA_annotes1(SAL_IsFormatString, "scanf_s")

#define _In_bound_impl_                 _Pre_impl_ _Bound_impl_
#define _Out_bound_impl_                _Post_impl_ _Bound_impl_
#define _Ret_bound_impl_                _Post_impl_ _Bound_impl_
#define _Deref_in_bound_impl_           _Deref_pre_impl_ _Bound_impl_
#define _Deref_out_bound_impl_          _Deref_post_impl_ _Bound_impl_
#define _Deref_ret_bound_impl_          _Deref_post_impl_ _Bound_impl_


#define __null_impl              _SA_annotes0(SAL_null) // _SA_annotes1(SAL_null, __yes)
#define __notnull_impl           _SA_annotes0(SAL_notnull) // _SA_annotes1(SAL_null, __no)
#define __maybenull_impl         _SA_annotes0(SAL_maybenull) // _SA_annotes1(SAL_null, __maybe)

#define __valid_impl             _SA_annotes0(SAL_valid) // _SA_annotes1(SAL_valid, __yes)
#define __notvalid_impl          _SA_annotes0(SAL_notvalid) // _SA_annotes1(SAL_valid, __no)
#define __maybevalid_impl        _SA_annotes0(SAL_maybevalid) // _SA_annotes1(SAL_valid, __maybe)

#define __null_impl_notref       _Notref_ _Null_impl_
#define __maybenull_impl_notref  _Notref_ _Maybenull_impl_
#define __notnull_impl_notref    _Notref_ _Notnull_impl_

#define __zterm_impl             _SA_annotes1(SAL_nullTerminated, __yes)
#define __maybezterm_impl        _SA_annotes1(SAL_nullTerminated, __maybe)
#define __maybzterm_impl         _SA_annotes1(SAL_nullTerminated, __maybe)
#define __notzterm_impl          _SA_annotes1(SAL_nullTerminated, __no)

#define __readaccess_impl        _SA_annotes1(SAL_access, 0x1)
#define __writeaccess_impl       _SA_annotes1(SAL_access, 0x2)
#define __allaccess_impl         _SA_annotes1(SAL_access, 0x3)

#define __readaccess_impl_notref  _Notref_ _SA_annotes1(SAL_access, 0x1)
#define __writeaccess_impl_notref _Notref_ _SA_annotes1(SAL_access, 0x2)
#define __allaccess_impl_notref   _Notref_ _SA_annotes1(SAL_access, 0x3)

#define __cap_impl(size)         _SA_annotes1(SAL_writableTo,elementCount(size))
#define __cap_c_impl(size)       _SA_annotes1(SAL_writableTo,elementCount(size))
#define __cap_c_one_notref_impl  _Notref_ _SA_annotes1(SAL_writableTo,elementCount(1))
#define __cap_for_impl(param)    _SA_annotes1(SAL_writableTo,inexpressibleCount(sizeof(param)))
#define __cap_x_impl(size)       _SA_annotes1(SAL_writableTo,inexpressibleCount(#size))

#define __bytecap_impl(size)     _SA_annotes1(SAL_writableTo,byteCount(size))
#define __bytecap_c_impl(size)   _SA_annotes1(SAL_writableTo,byteCount(size))
#define __bytecap_x_impl(size)   _SA_annotes1(SAL_writableTo,inexpressibleCount(#size))

#define __mult_impl(mult,size)   _SA_annotes1(SAL_writableTo,(mult)*(size))

#define __count_impl(size)       _SA_annotes1(SAL_readableTo,elementCount(size))
#define __count_c_impl(size)     _SA_annotes1(SAL_readableTo,elementCount(size))
#define __count_x_impl(size)     _SA_annotes1(SAL_readableTo,inexpressibleCount(#size))

#define __bytecount_impl(size)   _SA_annotes1(SAL_readableTo,byteCount(size))
#define __bytecount_c_impl(size) _SA_annotes1(SAL_readableTo,byteCount(size))
#define __bytecount_x_impl(size) _SA_annotes1(SAL_readableTo,inexpressibleCount(#size))

#define _At_impl_(target, annos)     _SA_annotes0(SAL_at(target)) _Group_(annos)
#define _At_buffer_impl_(target, iter, bound, annos)  _SA_annotes3(SAL_at_buffer, target, iter, bound) _Group_(annos)
#define _Group_impl_(annos)          _SA_annotes0(SAL_begin) annos _SA_annotes0(SAL_end)
#define _GrouP_impl_(annos)          _SA_annotes0(SAL_BEGIN) annos _SA_annotes0(SAL_END)
#define _When_impl_(expr, annos)     _SA_annotes0(SAL_when(expr)) _Group_(annos)

#define _Use_decl_anno_impl_         __declspec("SAL_useHeader()") // this is a special case!

#define _Pre1_impl_(p1)              _Pre_impl_ p1
#define _Pre2_impl_(p1,p2)           _Pre_impl_ p1 _Pre_impl_ p2
#define _Pre3_impl_(p1,p2,p3)        _Pre_impl_ p1 _Pre_impl_ p2 _Pre_impl_ p3

#define _Post1_impl_(p1)             _Post_impl_ p1
#define _Post2_impl_(p1,p2)          _Post_impl_ p1 _Post_impl_ p2
#define _Post3_impl_(p1,p2,p3)       _Post_impl_ p1 _Post_impl_ p2 _Post_impl_ p3

#define _Ret1_impl_(p1)              _Post_impl_ p1
#define _Ret2_impl_(p1,p2)           _Post_impl_ p1 _Post_impl_ p2
#define _Ret3_impl_(p1,p2,p3)        _Post_impl_ p1 _Post_impl_ p2 _Post_impl_ p3

#define _Deref_pre1_impl_(p1)        _Deref_pre_impl_ p1
#define _Deref_pre2_impl_(p1,p2)     _Deref_pre_impl_ p1 _Deref_pre_impl_ p2
#define _Deref_pre3_impl_(p1,p2,p3)  _Deref_pre_impl_ p1 _Deref_pre_impl_ p2 _Deref_pre_impl_ p3

#define _Deref_post1_impl_(p1)       _Deref_post_impl_ p1
#define _Deref_post2_impl_(p1,p2)    _Deref_post_impl_ p1 _Deref_post_impl_ p2
#define _Deref_post3_impl_(p1,p2,p3) _Deref_post_impl_ p1 _Deref_post_impl_ p2 _Deref_post_impl_ p3

#define _Deref_ret1_impl_(p1)        _Deref_post_impl_ p1
#define _Deref_ret2_impl_(p1,p2)     _Deref_post_impl_ p1 _Deref_post_impl_ p2
#define _Deref_ret3_impl_(p1,p2,p3)  _Deref_post_impl_ p1 _Deref_post_impl_ p2 _Deref_post_impl_ p3

#define _Deref2_pre1_impl_(p1)       _Deref_pre_impl_ _Notref_impl_ _Deref_impl_ p1
#define _Deref2_post1_impl_(p1)      _Deref_post_impl_ _Notref_impl_ _Deref_impl_ p1
#define _Deref2_ret1_impl_(p1)       _Deref_post_impl_ _Notref_impl_ _Deref_impl_ p1

#define __inner_typefix(ctype)             _SA_annotes1(SAL_typefix, ctype)
#define __inner_exceptthat                 _SA_annotes0(SAL_except)

#elif defined(_MSC_EXTENSIONS) && !defined( MIDL_PASS ) && !defined(__midl) && !defined(RC_INVOKED) && defined(_PFT_VER) // ][

// minimum attribute expansion for foreground build

#pragma push_macro( "SA" )
#pragma push_macro( "REPEATABLE" )

#ifdef __cplusplus // [
#define SA( id ) id
#define REPEATABLE [repeatable]
#else  // !__cplusplus // ][
#define SA( id ) SA_##id
#define REPEATABLE
#endif  // !__cplusplus // ]

REPEATABLE
[source_annotation_attribute(SA(Parameter))]
struct __P_impl
{
#ifdef __cplusplus // [
    __P_impl();
#endif // ]
    int __d_;
};
typedef struct __P_impl __P_impl;

REPEATABLE
[source_annotation_attribute(SA(ReturnValue))]
struct __R_impl
{
#ifdef __cplusplus // [
    __R_impl();
#endif // ]
    int __d_;
};
typedef struct __R_impl __R_impl;

[source_annotation_attribute(SA(Method))]
struct __M_
{
#ifdef __cplusplus // [
    __M_();
#endif // ]
    int __d_;
};
typedef struct __M_ __M_;

[source_annotation_attribute(SA(All))]
struct __A_
{
#ifdef __cplusplus // [
    __A_();
#endif // ]
    int __d_;
};
typedef struct __A_ __A_;

[source_annotation_attribute(SA(Field))]
struct __F_
{
#ifdef __cplusplus // [
    __F_();
#endif // ]
    int __d_;
};
typedef struct __F_ __F_;

#pragma pop_macro( "REPEATABLE" )
#pragma pop_macro( "SA" )


#define _SAL_nop_impl_

#define _At_impl_(target, annos)        [__A_(__d_=0)]
#define _At_buffer_impl_(target, iter, bound, annos)  [__A_(__d_=0)]
#define _When_impl_(expr, annos)        annos
#define _Group_impl_(annos)             annos
#define _GrouP_impl_(annos)             annos
#define _Use_decl_anno_impl_            [__M_(__d_=0)]

#define _Points_to_data_impl_           [__P_impl(__d_=0)]
#define _Literal_impl_                  [__P_impl(__d_=0)]
#define _Notliteral_impl_               [__P_impl(__d_=0)]

#define _Pre_valid_impl_                [__P_impl(__d_=0)]
#define _Post_valid_impl_               [__P_impl(__d_=0)]
#define _Ret_valid_impl_                [__R_impl(__d_=0)]

#define _Check_return_impl_             [__R_impl(__d_=0)]
#define _Must_inspect_impl_             [__R_impl(__d_=0)]

#define _Success_impl_(expr)            [__M_(__d_=0)]
#define _On_failure_impl_(expr)         [__M_(__d_=0)]
#define _Always_impl_(expr)             [__M_(__d_=0)]

#define _Printf_format_string_impl_     [__P_impl(__d_=0)]
#define _Scanf_format_string_impl_      [__P_impl(__d_=0)]
#define _Scanf_s_format_string_impl_    [__P_impl(__d_=0)]

#define _Raises_SEH_exception_impl_         [__M_(__d_=0)]
#define _Maybe_raises_SEH_exception_impl_   [__M_(__d_=0)]

#define _In_bound_impl_                 [__P_impl(__d_=0)]
#define _Out_bound_impl_                [__P_impl(__d_=0)]
#define _Ret_bound_impl_                [__R_impl(__d_=0)]
#define _Deref_in_bound_impl_           [__P_impl(__d_=0)]
#define _Deref_out_bound_impl_          [__P_impl(__d_=0)]
#define _Deref_ret_bound_impl_          [__R_impl(__d_=0)]

#define _Range_impl_(min,max)           [__P_impl(__d_=0)]
#define _In_range_impl_(min,max)        [__P_impl(__d_=0)]
#define _Out_range_impl_(min,max)       [__P_impl(__d_=0)]
#define _Ret_range_impl_(min,max)       [__R_impl(__d_=0)]
#define _Deref_in_range_impl_(min,max)  [__P_impl(__d_=0)]
#define _Deref_out_range_impl_(min,max) [__P_impl(__d_=0)]
#define _Deref_ret_range_impl_(min,max) [__R_impl(__d_=0)]

#define _Field_range_impl_(min,max)     [__F_(__d_=0)]

#define _Pre_satisfies_impl_(cond)      [__A_(__d_=0)]
#define _Post_satisfies_impl_(cond)     [__A_(__d_=0)]
#define _Satisfies_impl_(cond)          [__A_(__d_=0)]

#define _Null_impl_                     [__A_(__d_=0)]
#define _Notnull_impl_                  [__A_(__d_=0)]
#define _Maybenull_impl_                [__A_(__d_=0)]

#define _Valid_impl_                    [__A_(__d_=0)]
#define _Notvalid_impl_                 [__A_(__d_=0)]
#define _Maybevalid_impl_               [__A_(__d_=0)]

#define _Readable_bytes_impl_(size)     [__A_(__d_=0)]
#define _Readable_elements_impl_(size)  [__A_(__d_=0)]
#define _Writable_bytes_impl_(size)     [__A_(__d_=0)]
#define _Writable_elements_impl_(size)  [__A_(__d_=0)]

#define _Null_terminated_impl_          [__A_(__d_=0)]
#define _NullNull_terminated_impl_      [__A_(__d_=0)]

#define _Pre_impl_                      [__P_impl(__d_=0)]
#define _Pre1_impl_(p1)                 [__P_impl(__d_=0)]
#define _Pre2_impl_(p1,p2)              [__P_impl(__d_=0)]
#define _Pre3_impl_(p1,p2,p3)           [__P_impl(__d_=0)]

#define _Post_impl_                     [__P_impl(__d_=0)]
#define _Post1_impl_(p1)                [__P_impl(__d_=0)]
#define _Post2_impl_(p1,p2)             [__P_impl(__d_=0)]
#define _Post3_impl_(p1,p2,p3)          [__P_impl(__d_=0)]

#define _Ret1_impl_(p1)                 [__R_impl(__d_=0)]
#define _Ret2_impl_(p1,p2)              [__R_impl(__d_=0)]
#define _Ret3_impl_(p1,p2,p3)           [__R_impl(__d_=0)]

#define _Deref_pre1_impl_(p1)           [__P_impl(__d_=0)]
#define _Deref_pre2_impl_(p1,p2)        [__P_impl(__d_=0)]
#define _Deref_pre3_impl_(p1,p2,p3)     [__P_impl(__d_=0)]

#define _Deref_post1_impl_(p1)          [__P_impl(__d_=0)]
#define _Deref_post2_impl_(p1,p2)       [__P_impl(__d_=0)]
#define _Deref_post3_impl_(p1,p2,p3)    [__P_impl(__d_=0)]

#define _Deref_ret1_impl_(p1)           [__R_impl(__d_=0)]
#define _Deref_ret2_impl_(p1,p2)        [__R_impl(__d_=0)]
#define _Deref_ret3_impl_(p1,p2,p3)     [__R_impl(__d_=0)]

#define _Deref2_pre1_impl_(p1)          //[__P_impl(__d_=0)]
#define _Deref2_post1_impl_(p1)         //[__P_impl(__d_=0)]
#define _Deref2_ret1_impl_(p1)          //[__P_impl(__d_=0)]

#else // ][


#define _SAL_nop_impl_ X

#define _At_impl_(target, annos)
#define _When_impl_(expr, annos)
#define _Group_impl_(annos)
#define _GrouP_impl_(annos)
#define _At_buffer_impl_(target, iter, bound, annos)
#define _Use_decl_anno_impl_
#define _Points_to_data_impl_
#define _Literal_impl_
#define _Notliteral_impl_
#define _Notref_impl_

#define _Pre_valid_impl_
#define _Post_valid_impl_
#define _Ret_valid_impl_

#define _Check_return_impl_
#define _Must_inspect_impl_

#define _Success_impl_(expr)
#define _On_failure_impl_(annos)
#define _Always_impl_(annos)

#define _Printf_format_string_impl_
#define _Scanf_format_string_impl_
#define _Scanf_s_format_string_impl_

#define _In_bound_impl_
#define _Out_bound_impl_
#define _Ret_bound_impl_
#define _Deref_in_bound_impl_
#define _Deref_out_bound_impl_
#define _Deref_ret_bound_impl_

#define _Range_impl_(min,max)
#define _In_range_impl_(min,max)
#define _Out_range_impl_(min,max)
#define _Ret_range_impl_(min,max)
#define _Deref_in_range_impl_(min,max)
#define _Deref_out_range_impl_(min,max)
#define _Deref_ret_range_impl_(min,max)

#define _Satisfies_impl_(expr)
#define _Pre_satisfies_impl_(expr)
#define _Post_satisfies_impl_(expr)

#define _Null_impl_
#define _Notnull_impl_
#define _Maybenull_impl_

#define _Valid_impl_
#define _Notvalid_impl_
#define _Maybevalid_impl_

#define _Field_range_impl_(min,max)

#define _Pre_impl_
#define _Pre1_impl_(p1)
#define _Pre2_impl_(p1,p2)
#define _Pre3_impl_(p1,p2,p3)

#define _Post_impl_
#define _Post1_impl_(p1)
#define _Post2_impl_(p1,p2)
#define _Post3_impl_(p1,p2,p3)

#define _Ret1_impl_(p1)
#define _Ret2_impl_(p1,p2)
#define _Ret3_impl_(p1,p2,p3)

#define _Deref_pre1_impl_(p1)
#define _Deref_pre2_impl_(p1,p2)
#define _Deref_pre3_impl_(p1,p2,p3)

#define _Deref_post1_impl_(p1)
#define _Deref_post2_impl_(p1,p2)
#define _Deref_post3_impl_(p1,p2,p3)

#define _Deref_ret1_impl_(p1)
#define _Deref_ret2_impl_(p1,p2)
#define _Deref_ret3_impl_(p1,p2,p3)

#define _Deref2_pre1_impl_(p1)
#define _Deref2_post1_impl_(p1)
#define _Deref2_ret1_impl_(p1)

#define _Readable_bytes_impl_(size)
#define _Readable_elements_impl_(size)
#define _Writable_bytes_impl_(size)
#define _Writable_elements_impl_(size)

#define _Null_terminated_impl_
#define _NullNull_terminated_impl_

// Obsolete -- may be needed for transition to attributes.
#define __inner_typefix(ctype)
#define __inner_exceptthat

#endif // ]

// This section contains the deprecated annotations

/*
 -------------------------------------------------------------------------------
 Introduction

 sal.h provides a set of annotations to describe how a function uses its
 parameters - the assumptions it makes about them, and the guarantees it makes
 upon finishing.

 Annotations may be placed before either a function parameter's type or its return
 type, and describe the function's behavior regarding the parameter or return value.
 There are two classes of annotations: buffer annotations and advanced annotations.
 Buffer annotations describe how functions use their pointer parameters, and
 advanced annotations either describe complex/unusual buffer behavior, or provide
 additional information about a parameter that is not otherwise expressible.

 -------------------------------------------------------------------------------
 Buffer Annotations

 The most important annotations in sal.h provide a consistent way to annotate
 buffer parameters or return values for a function. Each of these annotations describes
 a single buffer (which could be a string, a fixed-length or variable-length array,
 or just a pointer) that the function interacts with: where it is, how large it is,
 how much is initialized, and what the function does with it.

 The appropriate macro for a given buffer can be constructed using the table below.
 Just pick the appropriate values from each category, and combine them together
 with a leading underscore. Some combinations of values do not make sense as buffer
 annotations. Only meaningful annotations can be added to your code; for a list of
 these, see the buffer annotation definitions section.

 Only a single buffer annotation should be used for each parameter.

 |------------|------------|---------|--------|----------|----------|---------------|
 |   Level    |   Usage    |  Size   | Output | NullTerm | Optional |  Parameters   |
 |------------|------------|---------|--------|----------|----------|---------------|
 | <>         | <>         | <>      | <>     | _z       | <>       | <>            |
 | _deref     | _in        | _ecount | _full  | _nz      | _opt     | (size)        |
 | _deref_opt | _out       | _bcount | _part  |          |          | (size,length) |
 |            | _inout     |         |        |          |          |               |
 |            |            |         |        |          |          |               |
 |------------|------------|---------|--------|----------|----------|---------------|

 Level: Describes the buffer pointer's level of indirection from the parameter or
          return value 'p'.

 <>         : p is the buffer pointer.
 _deref     : *p is the buffer pointer. p must not be NULL.
 _deref_opt : *p may be the buffer pointer. p may be NULL, in which case the rest of
                the annotation is ignored.

 Usage: Describes how the function uses the buffer.

 <>     : The buffer is not accessed. If used on the return value or with _deref, the
            function will provide the buffer, and it will be uninitialized at exit.
            Otherwise, the caller must provide the buffer. This should only be used
            for alloc and free functions.
 _in    : The function will only read from the buffer. The caller must provide the
            buffer and initialize it. Cannot be used with _deref.
 _out   : The function will only write to the buffer. If used on the return value or
            with _deref, the function will provide the buffer and initialize it.
            Otherwise, the caller must provide the buffer, and the function will
            initialize it.
 _inout : The function may freely read from and write to the buffer. The caller must
            provide the buffer and initialize it. If used with _deref, the buffer may
            be reallocated by the function.

 Size: Describes the total size of the buffer. This may be less than the space actually
         allocated for the buffer, in which case it describes the accessible amount.

 <>      : No buffer size is given. If the type specifies the buffer size (such as
             with LPSTR and LPWSTR), that amount is used. Otherwise, the buffer is one
             element long. Must be used with _in, _out, or _inout.
 _ecount : The buffer size is an explicit element count.
 _bcount : The buffer size is an explicit byte count.

 Output: Describes how much of the buffer will be initialized by the function. For
           _inout buffers, this also describes how much is initialized at entry. Omit this
           category for _in buffers; they must be fully initialized by the caller.

 <>    : The type specifies how much is initialized. For instance, a function initializing
           an LPWSTR must NULL-terminate the string.
 _full : The function initializes the entire buffer.
 _part : The function initializes part of the buffer, and explicitly indicates how much.

 NullTerm: States if the present of a '\0' marks the end of valid elements in the buffer.
 _z    : A '\0' indicated the end of the buffer
 _nz     : The buffer may not be null terminated and a '\0' does not indicate the end of the
          buffer.
 Optional: Describes if the buffer itself is optional.

 <>   : The pointer to the buffer must not be NULL.
 _opt : The pointer to the buffer might be NULL. It will be checked before being dereferenced.

 Parameters: Gives explicit counts for the size and length of the buffer.

 <>            : There is no explicit count. Use when neither _ecount nor _bcount is used.
 (size)        : Only the buffer's total size is given. Use with _ecount or _bcount but not _part.
 (size,length) : The buffer's total size and initialized length are given. Use with _ecount_part
                   and _bcount_part.

 -------------------------------------------------------------------------------
 Buffer Annotation Examples

 LWSTDAPI_(BOOL) StrToIntExA(
     __in LPCSTR pszString,
     DWORD dwFlags,
     __out int *piRet                     -- A pointer whose dereference will be filled in.
 );

 void MyPaintingFunction(
     __in HWND hwndControl,               -- An initialized read-only parameter.
     __in_opt HDC hdcOptional,            -- An initialized read-only parameter that might be NULL.
     __inout IPropertyStore *ppsStore     -- An initialized parameter that may be freely used
                                          --   and modified.
 );

 LWSTDAPI_(BOOL) PathCompactPathExA(
     __out_ecount(cchMax) LPSTR pszOut,   -- A string buffer with cch elements that will
                                          --   be NULL terminated on exit.
     __in LPCSTR pszSrc,
     UINT cchMax,
     DWORD dwFlags
 );

 HRESULT SHLocalAllocBytes(
     size_t cb,
     __deref_bcount(cb) T **ppv           -- A pointer whose dereference will be set to an
                                          --   uninitialized buffer with cb bytes.
 );

 __inout_bcount_full(cb) : A buffer with cb elements that is fully initialized at
     entry and exit, and may be written to by this function.

 __out_ecount_part(count, *countOut) : A buffer with count elements that will be
     partially initialized by this function. The function indicates how much it
     initialized by setting *countOut.

 -------------------------------------------------------------------------------
 Advanced Annotations

 Advanced annotations describe behavior that is not expressible with the regular
 buffer macros. These may be used either to annotate buffer parameters that involve
 complex or conditional behavior, or to enrich existing annotations with additional
 information.

 __success(expr) f :
     <expr> indicates whether function f succeeded or not. If <expr> is true at exit,
     all the function's guarantees (as given by other annotations) must hold. If <expr>
     is false at exit, the caller should not expect any of the function's guarantees
     to hold. If not used, the function must always satisfy its guarantees. Added
     automatically to functions that indicate success in standard ways, such as by
     returning an HRESULT.

 __nullterminated p :
     Pointer p is a buffer that may be read or written up to and including the first
     NULL character or pointer. May be used on typedefs, which marks valid (properly
     initialized) instances of that type as being NULL-terminated.

 __nullnullterminated p :
     Pointer p is a buffer that may be read or written up to and including the first
     sequence of two NULL characters or pointers. May be used on typedefs, which marks
     valid instances of that type as being double-NULL terminated.

 __reserved v :
     Value v must be 0/NULL, reserved for future use.

 __checkReturn v :
     Return value v must not be ignored by callers of this function.

 __typefix(ctype) v :
     Value v should be treated as an instance of ctype, rather than its declared type.

 __override f :
     Specify C#-style 'override' behaviour for overriding virtual methods.

 __callback f :
     Function f can be used as a function pointer.

 __format_string p :
     Pointer p is a string that contains % markers in the style of printf.

 __blocksOn(resource) f :
     Function f blocks on the resource 'resource'.

 __fallthrough :
     Annotates switch statement labels where fall-through is desired, to distinguish
     from forgotten break statements.

 -------------------------------------------------------------------------------
 Advanced Annotation Examples

 __success(return != FALSE) LWSTDAPI_(BOOL)
 PathCanonicalizeA(__out_ecount(MAX_PATH) LPSTR pszBuf, LPCSTR pszPath) :
    pszBuf is only guaranteed to be NULL-terminated when TRUE is returned.

 typedef __nullterminated WCHAR* LPWSTR : Initialized LPWSTRs are NULL-terminated strings.

 __out_ecount(cch) __typefix(LPWSTR) void *psz : psz is a buffer parameter which will be
     a NULL-terminated WCHAR string at exit, and which initially contains cch WCHARs.

 -------------------------------------------------------------------------------
*/

#define __specstrings

#ifdef  __cplusplus // [
#ifndef __nothrow // [
# define __nothrow __declspec(nothrow)
#endif // ]
extern "C" {
#else // ][
#ifndef __nothrow // [
# define __nothrow
#endif // ]
#endif  /* __cplusplus */ // ]


/*
 -------------------------------------------------------------------------------
 Helper Macro Definitions

 These express behavior common to many of the high-level annotations.
 DO NOT USE THESE IN YOUR CODE.
 -------------------------------------------------------------------------------
*/

/*
    The helper annotations are only understood by the compiler version used by
    various defect detection tools. When the regular compiler is running, they
    are defined into nothing, and do not affect the compiled code.
*/

#if !defined(__midl) && defined(_PREFAST_) // [

/*
 In the primitive "SAL_*" annotations "SAL" stands for Standard
 Annotation Language.  These "SAL_*" annotations are the
 primitives the compiler understands and high-level MACROs
 will decompose into these primitives.
*/

#define _SA_SPECSTRIZE( x ) #x

/*
 __null p
 __notnull p
 __maybenull p

 Annotates a pointer p. States that pointer p is null. Commonly used
 in the negated form __notnull or the possibly null form __maybenull.
*/

#define __null                  _Null_impl_
#define __notnull               _Notnull_impl_
#define __maybenull             _Maybenull_impl_

/*
 __readonly l
 __notreadonly l
 __maybereadonly l

 Annotates a location l. States that location l is not modified after
 this point.  If the annotation is placed on the precondition state of
 a function, the restriction only applies until the postcondition state
 of the function.  __maybereadonly states that the annotated location
 may be modified, whereas __notreadonly states that a location must be
 modified.
*/

#define __readonly              _Pre1_impl_(__readaccess_impl)
#define __notreadonly           _Pre1_impl_(__allaccess_impl)
#define __maybereadonly         _Pre1_impl_(__readaccess_impl)

/*
 __valid v
 __notvalid v
 __maybevalid v

 Annotates any value v. States that the value satisfies all properties of
 valid values of its type. For example, for a string buffer, valid means
 that the buffer pointer is either NULL or points to a NULL-terminated string.
*/

#define __valid                 _Valid_impl_
#define __notvalid              _Notvalid_impl_
#define __maybevalid            _Maybevalid_impl_

/*
 __readableTo(extent) p

 Annotates a buffer pointer p.  If the buffer can be read, extent describes
 how much of the buffer is readable. For a reader of the buffer, this is
 an explicit permission to read up to that amount, rather than a restriction to
 read only up to it.
*/

#define __readableTo(extent)    _SA_annotes1(SAL_readableTo, extent)

/*

 __elem_readableTo(size)

 Annotates a buffer pointer p as being readable to size elements.
*/

#define __elem_readableTo(size)   _SA_annotes1(SAL_readableTo, elementCount( size ))

/*
 __byte_readableTo(size)

 Annotates a buffer pointer p as being readable to size bytes.
*/
#define __byte_readableTo(size)   _SA_annotes1(SAL_readableTo, byteCount(size))

/*
 __writableTo(extent) p

 Annotates a buffer pointer p. If the buffer can be modified, extent
 describes how much of the buffer is writable (usually the allocation
 size). For a writer of the buffer, this is an explicit permission to
 write up to that amount, rather than a restriction to write only up to it.
*/
#define __writableTo(size)   _SA_annotes1(SAL_writableTo, size)

/*
 __elem_writableTo(size)

 Annotates a buffer pointer p as being writable to size elements.
*/
#define __elem_writableTo(size)   _SA_annotes1(SAL_writableTo, elementCount( size ))

/*
 __byte_writableTo(size)

 Annotates a buffer pointer p as being writable to size bytes.
*/
#define __byte_writableTo(size)   _SA_annotes1(SAL_writableTo, byteCount( size))

/*
 __deref p

 Annotates a pointer p. The next annotation applies one dereference down
 in the type. If readableTo(p, size) then the next annotation applies to
 all elements *(p+i) for which i satisfies the size. If p is a pointer
 to a struct, the next annotation applies to all fields of the struct.
*/
#define __deref                 _Deref_impl_

/*
 __pre __next_annotation

 The next annotation applies in the precondition state
*/
#define __pre                   _Pre_impl_

/*
 __post __next_annotation

 The next annotation applies in the postcondition state
*/
#define __post                  _Post_impl_

/*
 __precond(<expr>)

 When <expr> is true, the next annotation applies in the precondition state
 (currently not enabled)
*/
#define __precond(expr)         __pre

/*
 __postcond(<expr>)

 When <expr> is true, the next annotation applies in the postcondition state
 (currently not enabled)
*/
#define __postcond(expr)        __post

/*
 __exceptthat

 Given a set of annotations Q containing __exceptthat maybeP, the effect of
 the except clause is to erase any P or notP annotations (explicit or
 implied) within Q at the same level of dereferencing that the except
 clause appears, and to replace it with maybeP.

  Example 1: __valid __pre_except_maybenull on a pointer p means that the
             pointer may be null, and is otherwise valid, thus overriding
             the implicit notnull annotation implied by __valid on
             pointers.

  Example 2: __valid __deref __pre_except_maybenull on an int **p means
             that p is not null (implied by valid), but the elements
             pointed to by p could be null, and are otherwise valid.
*/
#define __exceptthat                __inner_exceptthat

/*
 _refparam

 Added to all out parameter macros to indicate that they are all reference
 parameters.
*/
#define __refparam                  _Notref_ __deref __notreadonly

/*
 __inner_*

 Helper macros that directly correspond to certain high-level annotations.

*/

/*
 Macros to classify the entrypoints and indicate their category.

 Pre-defined control point categories include: RPC, LPC, DeviceDriver, UserToKernel, ISAPI, COM.

*/
#define __inner_control_entrypoint(category) _SA_annotes2(SAL_entrypoint, controlEntry, category)


/*
 Pre-defined data entry point categories include: Registry, File, Network.
*/
#define __inner_data_entrypoint(category)    _SA_annotes2(SAL_entrypoint, dataEntry, category)

#define __inner_override                    _SA_annotes0(__override)
#define __inner_callback                    _SA_annotes0(__callback)
#define __inner_blocksOn(resource)          _SA_annotes1(SAL_blocksOn, resource)
#define __inner_fallthrough_dec             __inline __nothrow void __FallThrough() {}
#define __inner_fallthrough                 __FallThrough();

#define __post_except_maybenull     __post __inner_exceptthat _Maybenull_impl_
#define __pre_except_maybenull      __pre  __inner_exceptthat _Maybenull_impl_

#define __post_deref_except_maybenull       __post __deref __inner_exceptthat _Maybenull_impl_
#define __pre_deref_except_maybenull    __pre  __deref __inner_exceptthat _Maybenull_impl_

#define __inexpressible_readableTo(size)  _Readable_elements_impl_(_Inexpressible_(size))
#define __inexpressible_writableTo(size)  _Writable_elements_impl_(_Inexpressible_(size))


#else // ][
#define __null
#define __notnull
#define __maybenull
#define __readonly
#define __notreadonly
#define __maybereadonly
#define __valid
#define __notvalid
#define __maybevalid
#define __readableTo(extent)
#define __elem_readableTo(size)
#define __byte_readableTo(size)
#define __writableTo(size)
#define __elem_writableTo(size)
#define __byte_writableTo(size)
#define __deref
#define __pre
#define __post
#define __precond(expr)
#define __postcond(expr)
#define __exceptthat
#define __inner_override
#define __inner_callback
#define __inner_blocksOn(resource)
#define __inner_fallthrough_dec
#define __inner_fallthrough
#define __refparam
#define __inner_control_entrypoint(category)
#define __inner_data_entrypoint(category)

#define __post_except_maybenull
#define __pre_except_maybenull
#define __post_deref_except_maybenull
#define __pre_deref_except_maybenull

#define __inexpressible_readableTo(size)
#define __inexpressible_writableTo(size)

#endif /* !defined(__midl) && defined(_PREFAST_) */ // ]

/*
-------------------------------------------------------------------------------
Buffer Annotation Definitions

Any of these may be used to directly annotate functions, but only one should
be used for each parameter. To determine which annotation to use for a given
buffer, use the table in the buffer annotations section.
-------------------------------------------------------------------------------
*/

#define __ecount(size)                                           _SAL1_Source_(__ecount, (size), __notnull __elem_writableTo(size))
#define __bcount(size)                                           _SAL1_Source_(__bcount, (size), __notnull __byte_writableTo(size))
#define __in                                                     _SAL1_Source_(__in, (), _In_)
#define __in_ecount(size)                                        _SAL1_Source_(__in_ecount, (size), _In_reads_(size))
#define __in_bcount(size)                                        _SAL1_Source_(__in_bcount, (size), _In_reads_bytes_(size))
#define __in_z                                                   _SAL1_Source_(__in_z, (), _In_z_)
#define __in_ecount_z(size)                                      _SAL1_Source_(__in_ecount_z, (size), _In_reads_z_(size))
#define __in_bcount_z(size)                                      _SAL1_Source_(__in_bcount_z, (size), __in_bcount(size) __pre __nullterminated)
#define __in_nz                                                  _SAL1_Source_(__in_nz, (), __in)
#define __in_ecount_nz(size)                                     _SAL1_Source_(__in_ecount_nz, (size), __in_ecount(size))
#define __in_bcount_nz(size)                                     _SAL1_Source_(__in_bcount_nz, (size), __in_bcount(size))
#define __out                                                    _SAL1_Source_(__out, (), _Out_)
#define __out_ecount(size)                                       _SAL1_Source_(__out_ecount, (size), _Out_writes_(size))
#define __out_bcount(size)                                       _SAL1_Source_(__out_bcount, (size), _Out_writes_bytes_(size))
#define __out_ecount_part(size,length)                           _SAL1_Source_(__out_ecount_part, (size,length), _Out_writes_to_(size,length))
#define __out_bcount_part(size,length)                           _SAL1_Source_(__out_bcount_part, (size,length), _Out_writes_bytes_to_(size,length))
#define __out_ecount_full(size)                                  _SAL1_Source_(__out_ecount_full, (size), _Out_writes_all_(size))
#define __out_bcount_full(size)                                  _SAL1_Source_(__out_bcount_full, (size), _Out_writes_bytes_all_(size))
#define __out_z                                                  _SAL1_Source_(__out_z, (), __post __valid __refparam __post __nullterminated)
#define __out_z_opt                                              _SAL1_Source_(__out_z_opt, (), __post __valid __refparam __post __nullterminated __pre_except_maybenull)
#define __out_ecount_z(size)                                     _SAL1_Source_(__out_ecount_z, (size), __ecount(size) __post __valid __refparam __post __nullterminated)
#define __out_bcount_z(size)                                     _SAL1_Source_(__out_bcount_z, (size), __bcount(size) __post __valid __refparam __post __nullterminated)
#define __out_ecount_part_z(size,length)                         _SAL1_Source_(__out_ecount_part_z, (size,length), __out_ecount_part(size,length) __post __nullterminated)
#define __out_bcount_part_z(size,length)                         _SAL1_Source_(__out_bcount_part_z, (size,length), __out_bcount_part(size,length) __post __nullterminated)
#define __out_ecount_full_z(size)                                _SAL1_Source_(__out_ecount_full_z, (size), __out_ecount_full(size) __post __nullterminated)
#define __out_bcount_full_z(size)                                _SAL1_Source_(__out_bcount_full_z, (size), __out_bcount_full(size) __post __nullterminated)
#define __out_nz                                                 _SAL1_Source_(__out_nz, (), __post __valid __refparam)
#define __out_nz_opt                                             _SAL1_Source_(__out_nz_opt, (), __post __valid __refparam __post_except_maybenull_)
#define __out_ecount_nz(size)                                    _SAL1_Source_(__out_ecount_nz, (size), __ecount(size) __post __valid __refparam)
#define __out_bcount_nz(size)                                    _SAL1_Source_(__out_bcount_nz, (size), __bcount(size) __post __valid __refparam)
#define __inout                                                  _SAL1_Source_(__inout, (), _Inout_)
#define __inout_ecount(size)                                     _SAL1_Source_(__inout_ecount, (size), _Inout_updates_(size))
#define __inout_bcount(size)                                     _SAL1_Source_(__inout_bcount, (size), _Inout_updates_bytes_(size))
#define __inout_ecount_part(size,length)                         _SAL1_Source_(__inout_ecount_part, (size,length), _Inout_updates_to_(size,length))
#define __inout_bcount_part(size,length)                         _SAL1_Source_(__inout_bcount_part, (size,length), _Inout_updates_bytes_to_(size,length))
#define __inout_ecount_full(size)                                _SAL1_Source_(__inout_ecount_full, (size), _Inout_updates_all_(size))
#define __inout_bcount_full(size)                                _SAL1_Source_(__inout_bcount_full, (size), _Inout_updates_bytes_all_(size))
#define __inout_z                                                _SAL1_Source_(__inout_z, (), _Inout_z_)
#define __inout_ecount_z(size)                                   _SAL1_Source_(__inout_ecount_z, (size), _Inout_updates_z_(size))
#define __inout_bcount_z(size)                                   _SAL1_Source_(__inout_bcount_z, (size), __inout_bcount(size) __pre __nullterminated __post __nullterminated)
#define __inout_nz                                               _SAL1_Source_(__inout_nz, (), __inout)
#define __inout_ecount_nz(size)                                  _SAL1_Source_(__inout_ecount_nz, (size), __inout_ecount(size))
#define __inout_bcount_nz(size)                                  _SAL1_Source_(__inout_bcount_nz, (size), __inout_bcount(size))
#define __ecount_opt(size)                                       _SAL1_Source_(__ecount_opt, (size), __ecount(size)                              __pre_except_maybenull)
#define __bcount_opt(size)                                       _SAL1_Source_(__bcount_opt, (size), __bcount(size)                              __pre_except_maybenull)
#define __in_opt                                                 _SAL1_Source_(__in_opt, (), _In_opt_)
#define __in_ecount_opt(size)                                    _SAL1_Source_(__in_ecount_opt, (size), _In_reads_opt_(size))
#define __in_bcount_opt(size)                                    _SAL1_Source_(__in_bcount_opt, (size), _In_reads_bytes_opt_(size))
#define __in_z_opt                                               _SAL1_Source_(__in_z_opt, (), _In_opt_z_)
#define __in_ecount_z_opt(size)                                  _SAL1_Source_(__in_ecount_z_opt, (size), __in_ecount_opt(size) __pre __nullterminated)
#define __in_bcount_z_opt(size)                                  _SAL1_Source_(__in_bcount_z_opt, (size), __in_bcount_opt(size) __pre __nullterminated)
#define __in_nz_opt                                              _SAL1_Source_(__in_nz_opt, (), __in_opt)
#define __in_ecount_nz_opt(size)                                 _SAL1_Source_(__in_ecount_nz_opt, (size), __in_ecount_opt(size))
#define __in_bcount_nz_opt(size)                                 _SAL1_Source_(__in_bcount_nz_opt, (size), __in_bcount_opt(size))
#define __out_opt                                                _SAL1_Source_(__out_opt, (), _Out_opt_)
#define __out_ecount_opt(size)                                   _SAL1_Source_(__out_ecount_opt, (size), _Out_writes_opt_(size))
#define __out_bcount_opt(size)                                   _SAL1_Source_(__out_bcount_opt, (size), _Out_writes_bytes_opt_(size))
#define __out_ecount_part_opt(size,length)                       _SAL1_Source_(__out_ecount_part_opt, (size,length), __out_ecount_part(size,length)              __pre_except_maybenull)
#define __out_bcount_part_opt(size,length)                       _SAL1_Source_(__out_bcount_part_opt, (size,length), __out_bcount_part(size,length)              __pre_except_maybenull)
#define __out_ecount_full_opt(size)                              _SAL1_Source_(__out_ecount_full_opt, (size), __out_ecount_full(size)                     __pre_except_maybenull)
#define __out_bcount_full_opt(size)                              _SAL1_Source_(__out_bcount_full_opt, (size), __out_bcount_full(size)                     __pre_except_maybenull)
#define __out_ecount_z_opt(size)                                 _SAL1_Source_(__out_ecount_z_opt, (size), __out_ecount_opt(size) __post __nullterminated)
#define __out_bcount_z_opt(size)                                 _SAL1_Source_(__out_bcount_z_opt, (size), __out_bcount_opt(size) __post __nullterminated)
#define __out_ecount_part_z_opt(size,length)                     _SAL1_Source_(__out_ecount_part_z_opt, (size,length), __out_ecount_part_opt(size,length) __post __nullterminated)
#define __out_bcount_part_z_opt(size,length)                     _SAL1_Source_(__out_bcount_part_z_opt, (size,length), __out_bcount_part_opt(size,length) __post __nullterminated)
#define __out_ecount_full_z_opt(size)                            _SAL1_Source_(__out_ecount_full_z_opt, (size), __out_ecount_full_opt(size) __post __nullterminated)
#define __out_bcount_full_z_opt(size)                            _SAL1_Source_(__out_bcount_full_z_opt, (size), __out_bcount_full_opt(size) __post __nullterminated)
#define __out_ecount_nz_opt(size)                                _SAL1_Source_(__out_ecount_nz_opt, (size), __out_ecount_opt(size) __post __nullterminated)
#define __out_bcount_nz_opt(size)                                _SAL1_Source_(__out_bcount_nz_opt, (size), __out_bcount_opt(size) __post __nullterminated)
#define __inout_opt                                              _SAL1_Source_(__inout_opt, (), _Inout_opt_)
#define __inout_ecount_opt(size)                                 _SAL1_Source_(__inout_ecount_opt, (size), __inout_ecount(size)                        __pre_except_maybenull)
#define __inout_bcount_opt(size)                                 _SAL1_Source_(__inout_bcount_opt, (size), __inout_bcount(size)                        __pre_except_maybenull)
#define __inout_ecount_part_opt(size,length)                     _SAL1_Source_(__inout_ecount_part_opt, (size,length), __inout_ecount_part(size,length)            __pre_except_maybenull)
#define __inout_bcount_part_opt(size,length)                     _SAL1_Source_(__inout_bcount_part_opt, (size,length), __inout_bcount_part(size,length)            __pre_except_maybenull)
#define __inout_ecount_full_opt(size)                            _SAL1_Source_(__inout_ecount_full_opt, (size), __inout_ecount_full(size)                   __pre_except_maybenull)
#define __inout_bcount_full_opt(size)                            _SAL1_Source_(__inout_bcount_full_opt, (size), __inout_bcount_full(size)                   __pre_except_maybenull)
#define __inout_z_opt                                            _SAL1_Source_(__inout_z_opt, (), __inout_opt __pre __nullterminated __post __nullterminated)
#define __inout_ecount_z_opt(size)                               _SAL1_Source_(__inout_ecount_z_opt, (size), __inout_ecount_opt(size) __pre __nullterminated __post __nullterminated)
#define __inout_ecount_z_opt(size)                               _SAL1_Source_(__inout_ecount_z_opt, (size), __inout_ecount_opt(size) __pre __nullterminated __post __nullterminated)
#define __inout_bcount_z_opt(size)                               _SAL1_Source_(__inout_bcount_z_opt, (size), __inout_bcount_opt(size))
#define __inout_nz_opt                                           _SAL1_Source_(__inout_nz_opt, (), __inout_opt)
#define __inout_ecount_nz_opt(size)                              _SAL1_Source_(__inout_ecount_nz_opt, (size), __inout_ecount_opt(size))
#define __inout_bcount_nz_opt(size)                              _SAL1_Source_(__inout_bcount_nz_opt, (size), __inout_bcount_opt(size))
#define __deref_ecount(size)                                     _SAL1_Source_(__deref_ecount, (size), _Notref_ __ecount(1) __post _Notref_ __elem_readableTo(1) __post _Notref_ __deref _Notref_ __notnull __post __deref __elem_writableTo(size))
#define __deref_bcount(size)                                     _SAL1_Source_(__deref_bcount, (size), _Notref_ __ecount(1) __post _Notref_ __elem_readableTo(1) __post _Notref_ __deref _Notref_ __notnull __post __deref __byte_writableTo(size))
#define __deref_out                                              _SAL1_Source_(__deref_out, (), _Outptr_)
#define __deref_out_ecount(size)                                 _SAL1_Source_(__deref_out_ecount, (size), _Outptr_result_buffer_(size))
#define __deref_out_bcount(size)                                 _SAL1_Source_(__deref_out_bcount, (size), _Outptr_result_bytebuffer_(size))
#define __deref_out_ecount_part(size,length)                     _SAL1_Source_(__deref_out_ecount_part, (size,length), _Outptr_result_buffer_to_(size,length))
#define __deref_out_bcount_part(size,length)                     _SAL1_Source_(__deref_out_bcount_part, (size,length), _Outptr_result_bytebuffer_to_(size,length))
#define __deref_out_ecount_full(size)                            _SAL1_Source_(__deref_out_ecount_full, (size), __deref_out_ecount_part(size,size))
#define __deref_out_bcount_full(size)                            _SAL1_Source_(__deref_out_bcount_full, (size), __deref_out_bcount_part(size,size))
#define __deref_out_z                                            _SAL1_Source_(__deref_out_z, (), _Outptr_result_z_)
#define __deref_out_ecount_z(size)                               _SAL1_Source_(__deref_out_ecount_z, (size), __deref_out_ecount(size) __post __deref __nullterminated)
#define __deref_out_bcount_z(size)                               _SAL1_Source_(__deref_out_bcount_z, (size), __deref_out_bcount(size) __post __deref __nullterminated)
#define __deref_out_nz                                           _SAL1_Source_(__deref_out_nz, (), __deref_out)
#define __deref_out_ecount_nz(size)                              _SAL1_Source_(__deref_out_ecount_nz, (size), __deref_out_ecount(size))
#define __deref_out_bcount_nz(size)                              _SAL1_Source_(__deref_out_bcount_nz, (size), __deref_out_ecount(size))
#define __deref_inout                                            _SAL1_Source_(__deref_inout, (), _Notref_ __notnull _Notref_ __elem_readableTo(1) __pre __deref __valid __post _Notref_ __deref __valid __refparam)
#define __deref_inout_z                                          _SAL1_Source_(__deref_inout_z, (), __deref_inout __pre __deref __nullterminated __post _Notref_ __deref __nullterminated)
#define __deref_inout_ecount(size)                               _SAL1_Source_(__deref_inout_ecount, (size), __deref_inout __pre __deref __elem_writableTo(size) __post _Notref_ __deref __elem_writableTo(size))
#define __deref_inout_bcount(size)                               _SAL1_Source_(__deref_inout_bcount, (size), __deref_inout __pre __deref __byte_writableTo(size) __post _Notref_ __deref __byte_writableTo(size))
#define __deref_inout_ecount_part(size,length)                   _SAL1_Source_(__deref_inout_ecount_part, (size,length), __deref_inout_ecount(size) __pre __deref __elem_readableTo(length) __post __deref __elem_readableTo(length))
#define __deref_inout_bcount_part(size,length)                   _SAL1_Source_(__deref_inout_bcount_part, (size,length), __deref_inout_bcount(size) __pre __deref __byte_readableTo(length) __post __deref __byte_readableTo(length))
#define __deref_inout_ecount_full(size)                          _SAL1_Source_(__deref_inout_ecount_full, (size), __deref_inout_ecount_part(size,size))
#define __deref_inout_bcount_full(size)                          _SAL1_Source_(__deref_inout_bcount_full, (size), __deref_inout_bcount_part(size,size))
#define __deref_inout_ecount_z(size)                             _SAL1_Source_(__deref_inout_ecount_z, (size), __deref_inout_ecount(size) __pre __deref __nullterminated __post __deref __nullterminated)
#define __deref_inout_bcount_z(size)                             _SAL1_Source_(__deref_inout_bcount_z, (size), __deref_inout_bcount(size) __pre __deref __nullterminated __post __deref __nullterminated)
#define __deref_inout_nz                                         _SAL1_Source_(__deref_inout_nz, (), __deref_inout)
#define __deref_inout_ecount_nz(size)                            _SAL1_Source_(__deref_inout_ecount_nz, (size), __deref_inout_ecount(size))
#define __deref_inout_bcount_nz(size)                            _SAL1_Source_(__deref_inout_bcount_nz, (size), __deref_inout_ecount(size))
#define __deref_ecount_opt(size)                                 _SAL1_Source_(__deref_ecount_opt, (size), __deref_ecount(size)                        __post_deref_except_maybenull)
#define __deref_bcount_opt(size)                                 _SAL1_Source_(__deref_bcount_opt, (size), __deref_bcount(size)                        __post_deref_except_maybenull)
#define __deref_out_opt                                          _SAL1_Source_(__deref_out_opt, (), __deref_out                                 __post_deref_except_maybenull)
#define __deref_out_ecount_opt(size)                             _SAL1_Source_(__deref_out_ecount_opt, (size), __deref_out_ecount(size)                    __post_deref_except_maybenull)
#define __deref_out_bcount_opt(size)                             _SAL1_Source_(__deref_out_bcount_opt, (size), __deref_out_bcount(size)                    __post_deref_except_maybenull)
#define __deref_out_ecount_part_opt(size,length)                 _SAL1_Source_(__deref_out_ecount_part_opt, (size,length), __deref_out_ecount_part(size,length)        __post_deref_except_maybenull)
#define __deref_out_bcount_part_opt(size,length)                 _SAL1_Source_(__deref_out_bcount_part_opt, (size,length), __deref_out_bcount_part(size,length)        __post_deref_except_maybenull)
#define __deref_out_ecount_full_opt(size)                        _SAL1_Source_(__deref_out_ecount_full_opt, (size), __deref_out_ecount_full(size)               __post_deref_except_maybenull)
#define __deref_out_bcount_full_opt(size)                        _SAL1_Source_(__deref_out_bcount_full_opt, (size), __deref_out_bcount_full(size)               __post_deref_except_maybenull)
#define __deref_out_z_opt                                        _SAL1_Source_(__deref_out_z_opt, (), _Outptr_result_maybenull_z_)
#define __deref_out_ecount_z_opt(size)                           _SAL1_Source_(__deref_out_ecount_z_opt, (size), __deref_out_ecount_opt(size) __post __deref __nullterminated)
#define __deref_out_bcount_z_opt(size)                           _SAL1_Source_(__deref_out_bcount_z_opt, (size), __deref_out_bcount_opt(size) __post __deref __nullterminated)
#define __deref_out_nz_opt                                       _SAL1_Source_(__deref_out_nz_opt, (), __deref_out_opt)
#define __deref_out_ecount_nz_opt(size)                          _SAL1_Source_(__deref_out_ecount_nz_opt, (size), __deref_out_ecount_opt(size))
#define __deref_out_bcount_nz_opt(size)                          _SAL1_Source_(__deref_out_bcount_nz_opt, (size), __deref_out_bcount_opt(size))
#define __deref_inout_opt                                        _SAL1_Source_(__deref_inout_opt, (), __deref_inout                               __pre_deref_except_maybenull __post_deref_except_maybenull)
#define __deref_inout_ecount_opt(size)                           _SAL1_Source_(__deref_inout_ecount_opt, (size), __deref_inout_ecount(size)                  __pre_deref_except_maybenull __post_deref_except_maybenull)
#define __deref_inout_bcount_opt(size)                           _SAL1_Source_(__deref_inout_bcount_opt, (size), __deref_inout_bcount(size)                  __pre_deref_except_maybenull __post_deref_except_maybenull)
#define __deref_inout_ecount_part_opt(size,length)               _SAL1_Source_(__deref_inout_ecount_part_opt, (size,length), __deref_inout_ecount_part(size,length)      __pre_deref_except_maybenull __post_deref_except_maybenull)
#define __deref_inout_bcount_part_opt(size,length)               _SAL1_Source_(__deref_inout_bcount_part_opt, (size,length), __deref_inout_bcount_part(size,length)      __pre_deref_except_maybenull __post_deref_except_maybenull)
#define __deref_inout_ecount_full_opt(size)                      _SAL1_Source_(__deref_inout_ecount_full_opt, (size), __deref_inout_ecount_full(size)             __pre_deref_except_maybenull __post_deref_except_maybenull)
#define __deref_inout_bcount_full_opt(size)                      _SAL1_Source_(__deref_inout_bcount_full_opt, (size), __deref_inout_bcount_full(size)             __pre_deref_except_maybenull __post_deref_except_maybenull)
#define __deref_inout_z_opt                                      _SAL1_Source_(__deref_inout_z_opt, (), __deref_inout_opt __pre __deref __nullterminated __post __deref __nullterminated)
#define __deref_inout_ecount_z_opt(size)                         _SAL1_Source_(__deref_inout_ecount_z_opt, (size), __deref_inout_ecount_opt(size) __pre __deref __nullterminated __post __deref __nullterminated)
#define __deref_inout_bcount_z_opt(size)                         _SAL1_Source_(__deref_inout_bcount_z_opt, (size), __deref_inout_bcount_opt(size) __pre __deref __nullterminated __post __deref __nullterminated)
#define __deref_inout_nz_opt                                     _SAL1_Source_(__deref_inout_nz_opt, (), __deref_inout_opt)
#define __deref_inout_ecount_nz_opt(size)                        _SAL1_Source_(__deref_inout_ecount_nz_opt, (size), __deref_inout_ecount_opt(size))
#define __deref_inout_bcount_nz_opt(size)                        _SAL1_Source_(__deref_inout_bcount_nz_opt, (size), __deref_inout_bcount_opt(size))
#define __deref_opt_ecount(size)                                 _SAL1_Source_(__deref_opt_ecount, (size), __deref_ecount(size)                        __pre_except_maybenull)
#define __deref_opt_bcount(size)                                 _SAL1_Source_(__deref_opt_bcount, (size), __deref_bcount(size)                        __pre_except_maybenull)
#define __deref_opt_out                                          _SAL1_Source_(__deref_opt_out, (), _Outptr_opt_)
#define __deref_opt_out_z                                        _SAL1_Source_(__deref_opt_out_z, (), _Outptr_opt_result_z_)
#define __deref_opt_out_ecount(size)                             _SAL1_Source_(__deref_opt_out_ecount, (size), __deref_out_ecount(size)                    __pre_except_maybenull)
#define __deref_opt_out_bcount(size)                             _SAL1_Source_(__deref_opt_out_bcount, (size), __deref_out_bcount(size)                    __pre_except_maybenull)
#define __deref_opt_out_ecount_part(size,length)                 _SAL1_Source_(__deref_opt_out_ecount_part, (size,length), __deref_out_ecount_part(size,length)        __pre_except_maybenull)
#define __deref_opt_out_bcount_part(size,length)                 _SAL1_Source_(__deref_opt_out_bcount_part, (size,length), __deref_out_bcount_part(size,length)        __pre_except_maybenull)
#define __deref_opt_out_ecount_full(size)                        _SAL1_Source_(__deref_opt_out_ecount_full, (size), __deref_out_ecount_full(size)               __pre_except_maybenull)
#define __deref_opt_out_bcount_full(size)                        _SAL1_Source_(__deref_opt_out_bcount_full, (size), __deref_out_bcount_full(size)               __pre_except_maybenull)
#define __deref_opt_inout                                        _SAL1_Source_(__deref_opt_inout, (), _Inout_opt_)
#define __deref_opt_inout_ecount(size)                           _SAL1_Source_(__deref_opt_inout_ecount, (size), __deref_inout_ecount(size)                  __pre_except_maybenull)
#define __deref_opt_inout_bcount(size)                           _SAL1_Source_(__deref_opt_inout_bcount, (size), __deref_inout_bcount(size)                  __pre_except_maybenull)
#define __deref_opt_inout_ecount_part(size,length)               _SAL1_Source_(__deref_opt_inout_ecount_part, (size,length), __deref_inout_ecount_part(size,length)      __pre_except_maybenull)
#define __deref_opt_inout_bcount_part(size,length)               _SAL1_Source_(__deref_opt_inout_bcount_part, (size,length), __deref_inout_bcount_part(size,length)      __pre_except_maybenull)
#define __deref_opt_inout_ecount_full(size)                      _SAL1_Source_(__deref_opt_inout_ecount_full, (size), __deref_inout_ecount_full(size)             __pre_except_maybenull)
#define __deref_opt_inout_bcount_full(size)                      _SAL1_Source_(__deref_opt_inout_bcount_full, (size), __deref_inout_bcount_full(size)             __pre_except_maybenull)
#define __deref_opt_inout_z                                      _SAL1_Source_(__deref_opt_inout_z, (), __deref_opt_inout __pre __deref __nullterminated __post __deref __nullterminated)
#define __deref_opt_inout_ecount_z(size)                         _SAL1_Source_(__deref_opt_inout_ecount_z, (size), __deref_opt_inout_ecount(size) __pre __deref __nullterminated __post __deref __nullterminated)
#define __deref_opt_inout_bcount_z(size)                         _SAL1_Source_(__deref_opt_inout_bcount_z, (size), __deref_opt_inout_bcount(size) __pre __deref __nullterminated __post __deref __nullterminated)
#define __deref_opt_inout_nz                                     _SAL1_Source_(__deref_opt_inout_nz, (), __deref_opt_inout)
#define __deref_opt_inout_ecount_nz(size)                        _SAL1_Source_(__deref_opt_inout_ecount_nz, (size), __deref_opt_inout_ecount(size))
#define __deref_opt_inout_bcount_nz(size)                        _SAL1_Source_(__deref_opt_inout_bcount_nz, (size), __deref_opt_inout_bcount(size))
#define __deref_opt_ecount_opt(size)                             _SAL1_Source_(__deref_opt_ecount_opt, (size), __deref_ecount_opt(size)                    __pre_except_maybenull)
#define __deref_opt_bcount_opt(size)                             _SAL1_Source_(__deref_opt_bcount_opt, (size), __deref_bcount_opt(size)                    __pre_except_maybenull)
#define __deref_opt_out_opt                                      _SAL1_Source_(__deref_opt_out_opt, (), _Outptr_opt_result_maybenull_)
#define __deref_opt_out_ecount_opt(size)                         _SAL1_Source_(__deref_opt_out_ecount_opt, (size), __deref_out_ecount_opt(size)                __pre_except_maybenull)
#define __deref_opt_out_bcount_opt(size)                         _SAL1_Source_(__deref_opt_out_bcount_opt, (size), __deref_out_bcount_opt(size)                __pre_except_maybenull)
#define __deref_opt_out_ecount_part_opt(size,length)             _SAL1_Source_(__deref_opt_out_ecount_part_opt, (size,length), __deref_out_ecount_part_opt(size,length)    __pre_except_maybenull)
#define __deref_opt_out_bcount_part_opt(size,length)             _SAL1_Source_(__deref_opt_out_bcount_part_opt, (size,length), __deref_out_bcount_part_opt(size,length)    __pre_except_maybenull)
#define __deref_opt_out_ecount_full_opt(size)                    _SAL1_Source_(__deref_opt_out_ecount_full_opt, (size), __deref_out_ecount_full_opt(size)           __pre_except_maybenull)
#define __deref_opt_out_bcount_full_opt(size)                    _SAL1_Source_(__deref_opt_out_bcount_full_opt, (size), __deref_out_bcount_full_opt(size)           __pre_except_maybenull)
#define __deref_opt_out_z_opt                                    _SAL1_Source_(__deref_opt_out_z_opt, (), __post __deref __valid __refparam __pre_except_maybenull __pre_deref_except_maybenull __post_deref_except_maybenull __post __deref __nullterminated)
#define __deref_opt_out_ecount_z_opt(size)                       _SAL1_Source_(__deref_opt_out_ecount_z_opt, (size), __deref_opt_out_ecount_opt(size) __post __deref __nullterminated)
#define __deref_opt_out_bcount_z_opt(size)                       _SAL1_Source_(__deref_opt_out_bcount_z_opt, (size), __deref_opt_out_bcount_opt(size) __post __deref __nullterminated)
#define __deref_opt_out_nz_opt                                   _SAL1_Source_(__deref_opt_out_nz_opt, (), __deref_opt_out_opt)
#define __deref_opt_out_ecount_nz_opt(size)                      _SAL1_Source_(__deref_opt_out_ecount_nz_opt, (size), __deref_opt_out_ecount_opt(size))
#define __deref_opt_out_bcount_nz_opt(size)                      _SAL1_Source_(__deref_opt_out_bcount_nz_opt, (size), __deref_opt_out_bcount_opt(size))
#define __deref_opt_inout_opt                                    _SAL1_Source_(__deref_opt_inout_opt, (), __deref_inout_opt                           __pre_except_maybenull)
#define __deref_opt_inout_ecount_opt(size)                       _SAL1_Source_(__deref_opt_inout_ecount_opt, (size), __deref_inout_ecount_opt(size)              __pre_except_maybenull)
#define __deref_opt_inout_bcount_opt(size)                       _SAL1_Source_(__deref_opt_inout_bcount_opt, (size), __deref_inout_bcount_opt(size)              __pre_except_maybenull)
#define __deref_opt_inout_ecount_part_opt(size,length)           _SAL1_Source_(__deref_opt_inout_ecount_part_opt, (size,length), __deref_inout_ecount_part_opt(size,length)  __pre_except_maybenull)
#define __deref_opt_inout_bcount_part_opt(size,length)           _SAL1_Source_(__deref_opt_inout_bcount_part_opt, (size,length), __deref_inout_bcount_part_opt(size,length)  __pre_except_maybenull)
#define __deref_opt_inout_ecount_full_opt(size)                  _SAL1_Source_(__deref_opt_inout_ecount_full_opt, (size), __deref_inout_ecount_full_opt(size)         __pre_except_maybenull)
#define __deref_opt_inout_bcount_full_opt(size)                  _SAL1_Source_(__deref_opt_inout_bcount_full_opt, (size), __deref_inout_bcount_full_opt(size)         __pre_except_maybenull)
#define __deref_opt_inout_z_opt                                  _SAL1_Source_(__deref_opt_inout_z_opt, (), __deref_opt_inout_opt  __pre __deref __nullterminated __post __deref __nullterminated)
#define __deref_opt_inout_ecount_z_opt(size)                     _SAL1_Source_(__deref_opt_inout_ecount_z_opt, (size), __deref_opt_inout_ecount_opt(size)  __pre __deref __nullterminated __post __deref __nullterminated)
#define __deref_opt_inout_bcount_z_opt(size)                     _SAL1_Source_(__deref_opt_inout_bcount_z_opt, (size), __deref_opt_inout_bcount_opt(size)  __pre __deref __nullterminated __post __deref __nullterminated)
#define __deref_opt_inout_nz_opt                                 _SAL1_Source_(__deref_opt_inout_nz_opt, (), __deref_opt_inout_opt)
#define __deref_opt_inout_ecount_nz_opt(size)                    _SAL1_Source_(__deref_opt_inout_ecount_nz_opt, (size), __deref_opt_inout_ecount_opt(size))
#define __deref_opt_inout_bcount_nz_opt(size)                    _SAL1_Source_(__deref_opt_inout_bcount_nz_opt, (size), __deref_opt_inout_bcount_opt(size))

/*
-------------------------------------------------------------------------------
Advanced Annotation Definitions

Any of these may be used to directly annotate functions, and may be used in
combination with each other or with regular buffer macros. For an explanation
of each annotation, see the advanced annotations section.
-------------------------------------------------------------------------------
*/

#define __success(expr)                      _SAL1_1_Source_(__success, (expr), _Success_(expr))
#define __nullterminated                     _SAL1_Source_(__nullterminated, (), _Null_terminated_)
#define __nullnullterminated                 _SAL1_Source_(__nullnulltermiated, (), _SAL_nop_impl_)
#define __reserved                           _SAL1_Source_(__reserved, (), _Reserved_)
#define __checkReturn                        _SAL1_Source_(__checkReturn, (), _Check_return_)
#define __typefix(ctype)                     _SAL1_Source_(__typefix, (ctype), __inner_typefix(ctype))
#define __override                           __inner_override
#define __callback                           __inner_callback
#define __format_string                      _SAL1_1_Source_(__format_string, (), _Printf_format_string_)
#define __blocksOn(resource)                 _SAL_L_Source_(__blocksOn, (resource), __inner_blocksOn(resource))
#define __control_entrypoint(category)       _SAL_L_Source_(__control_entrypoint, (category), __inner_control_entrypoint(category))
#define __data_entrypoint(category)          _SAL_L_Source_(__data_entrypoint, (category), __inner_data_entrypoint(category))

#ifdef _USING_V110_SDK71_ // [
#ifndef _PREFAST_ // [
#define __useHeader
#else // ][
#error Code analysis is not supported when using Visual C++ 11.0/12.0 with the Windows 7.1 SDK.
#endif // ]
#else // ][
#define __useHeader                          _Use_decl_anno_impl_
#endif // ]

#ifdef _USING_V110_SDK71_ // [
#ifndef _PREFAST_ // [
#define __on_failure(annotes)
#else // ][
#error Code analysis is not supported when using Visual C++ 11.0/12.0 with the Windows 7.1 SDK.
#endif // ]
#else // ][
#define __on_failure(annotes)                _SAL1_1_Source_(__on_failure, (annotes), _On_failure_impl_(annotes _SAL_nop_impl_))
#endif // ]

#ifndef __fallthrough // [
#if (!defined(_MSVC_LANG) || _MSVC_LANG < 201703l) // [
__inner_fallthrough_dec
#define __fallthrough __inner_fallthrough
#else // ][
#define __fallthrough [[fallthrough]]
#endif // ]
#endif // ]

#ifndef __analysis_assume // [
#ifdef _PREFAST_ // [
#define __analysis_assume(expr) __assume(expr)
#else // ][
#define __analysis_assume(expr)
#endif // ]
#endif // ]

#ifndef _Analysis_assume_ // [
#ifdef _PREFAST_ // [
#define _Analysis_assume_(expr) __assume(expr)
#else // ][
#define _Analysis_assume_(expr)
#endif // ]
#endif // ]

#define _Analysis_noreturn_    _SAL2_Source_(_Analysis_noreturn_, (), _SA_annotes0(SAL_terminates))

#ifdef _PREFAST_ // [
__inline __nothrow
void __AnalysisAssumeNullterminated(_Post_ _Null_terminated_ const void* p);

#define _Analysis_assume_nullterminated_(x) __AnalysisAssumeNullterminated(x)

#else // ][
#define _Analysis_assume_nullterminated_(x)
#endif // ]

//
// Set the analysis mode (global flags to analysis).
// They take effect at the point of declaration; use at global scope
// as a declaration.
//

// Synthesize a unique symbol.
#define ___MKID(x, y) x ## y
#define __MKID(x, y) ___MKID(x, y)
#define __GENSYM(x) __MKID(x, __COUNTER__)

__ANNOTATION(SAL_analysisMode(__AuToQuOtE __In_impl_ char* mode);)

#define _Analysis_mode_impl_(mode) _SAL2_Source_(_Analysis_mode_impl_, (mode), _SA_annotes1(SAL_analysisMode, #mode))

//
// Floating point warnings are only meaningful in kernel-mode on x86
// so avoid reporting them on other platforms.
//
#ifndef _M_IX86 // [

#define _Analysis_mode_(mode)                                                 \
    __pragma(warning(disable: 28110 28111 28161 28162))                       \
    typedef _Analysis_mode_impl_(mode) int                                    \
        __GENSYM(__prefast_analysis_mode_flag);

#else // ][

#define _Analysis_mode_(mode)                                                 \
    typedef _Analysis_mode_impl_(mode) int                                    \
        __GENSYM(__prefast_analysis_mode_flag);

#endif // ]

// The following are predefined:
//  _Analysis_operator_new_throw_   (operator new throws)
//  _Analysis_operator_new_null_        (operator new returns null)
//  _Analysis_operator_new_never_fails_ (operator new never fails)
//

// Function class annotations.
__ANNOTATION(SAL_functionClassNew(__In_impl_ char*);)
__PRIMOP(int, _In_function_class_(__In_impl_ char*);)
#define _In_function_class_(x)  _In_function_class_(#x)
#define _Called_from_function_class_(x) _In_function_class_(x)

#define _Function_class_(x)  _SAL2_Source_(_Function_class_, (x), _SA_annotes1(SAL_functionClassNew, _SA_SPECSTRIZE(x)))

#define _Enum_is_bitflag_    _SAL2_Source_(_Enum_is_bitflag_, (), _SA_annotes0(SAL_enumIsBitflag))
#define _Strict_type_match_  _SAL2_Source_(_Strict_type_match, (), _SA_annotes0(SAL_strictType2))

#define _Maybe_raises_SEH_exception_   _SAL2_Source_(_Maybe_raises_SEH_exception_, (x), _Pre_ _SA_annotes1(SAL_inTry,__yes))
#define _Raises_SEH_exception_         _SAL2_Source_(_Raises_SEH_exception_, (x), _Maybe_raises_SEH_exception_ _Analysis_noreturn_)

#ifdef  __cplusplus // [
}
#endif // ]

/***
*concurrencysal.h - markers for documenting the concurrent semantics of APIs
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains macros for Concurrency SAL annotations. Definitions
*       starting with _Internal are low level macros that are subject to change.
*       Users should not use those low level macros directly.
*       [ANSI]
*
*       [Public]
*
****/

#ifndef CONCURRENCYSAL_H
#define CONCURRENCYSAL_H

#pragma once

#ifdef  __cplusplus // [
extern "C" {
#endif  // ]

#if !defined(__midl) && defined(_PREFAST_) && !defined(_SDV_)

    __ANNOTATION(SAL_guarded_by(__deferTypecheck void*));
    __ANNOTATION(SAL_write_guarded_by(__deferTypecheck void*));
    __ANNOTATION(SAL_requires_lock_held(__deferTypecheck void*));
    __ANNOTATION(SAL_requires_exclusive_lock_held(__deferTypecheck void*));
    __ANNOTATION(SAL_requires_shared_lock_held(__deferTypecheck void*));
    __ANNOTATION(SAL_requires_lock_not_held(__deferTypecheck void*));
    __ANNOTATION(SAL_requires_no_locks_held(void));
    __ANNOTATION(SAL_set_lock_count_to_zero(__deferTypecheck void*));
    __ANNOTATION(SAL_set_lock_count_to_one(__deferTypecheck void*));
    __ANNOTATION(SAL_acquires_lock(__deferTypecheck void*));
    __ANNOTATION(SAL_acquires_exclusive_lock(__deferTypecheck void*));
    __ANNOTATION(SAL_acquires_shared_lock(__deferTypecheck void*));
    __ANNOTATION(SAL_releases_lock(__deferTypecheck void*));
    __ANNOTATION(SAL_releases_exclusive_lock(__deferTypecheck void*));
    __ANNOTATION(SAL_releases_shared_lock(__deferTypecheck void*));
    __ANNOTATION(SAL_ignore_lock_match(__deferTypecheck void*));
    __ANNOTATION(SAL_has_lock_property(__AuToQuOtE __In_impl_ char*));
    __ANNOTATION(SAL_has_lock_level(__AuToQuOtE __In_impl_ char*));
    __ANNOTATION(SAL_lock_level_order(__deferTypecheck void*, __deferTypecheck void*));
    __ANNOTATION(SAL_no_competing_thread(void));
    __ANNOTATION(SAL_set_same_lock(__deferTypecheck void*, __deferTypecheck void*));

    /*
     * pre-defined global system locks
     */
    extern int _Global_interlock_;
    extern int _Global_cancel_spin_lock_;
    extern int _Global_critical_region_;

    /*
     * Annotation identifiers
     */
#define _Internal_create_CSAL_identifier_(id) const char id[] = "";

    _Internal_create_CSAL_identifier_(_Lock_kind_mutex_)
        _Internal_create_CSAL_identifier_(_Lock_kind_event_)
        _Internal_create_CSAL_identifier_(_Lock_kind_semaphore_)
        _Internal_create_CSAL_identifier_(_Lock_kind_spin_lock_)
        _Internal_create_CSAL_identifier_(_Lock_kind_critical_section_)

        /*
         * data protection
         */
#define _Guarded_by_(lock) _SAL2_Source_(_Guarded_by_, (lock), _SA_annotes1(SAL_guarded_by,lock))
#define _Write_guarded_by_(lock) _SAL2_Source_(_Write_guarded_by_, (lock), _SA_annotes1(SAL_write_guarded_by,lock))
#define _Interlocked_ _Guarded_by_(_Global_interlock_)

         /*
          * interlocked operand used in interlocked instructions
          */
#ifndef _Interlocked_operand_
#define _Interlocked_operand_ _SAL2_Source_(_Interlocked_operand_, (), _Pre_ _SA_annotes0(SAL_interlocked))
#endif

          /*
           * caller/callee locking contracts
           */
#define _Requires_lock_held_(lock)  _SAL2_Source_(_Requires_lock_held_, (lock), _Pre_ _SA_annotes1(SAL_requires_lock_held,lock))
#define _Requires_exclusive_lock_held_(lock)  _SAL2_Source_(_Requires_exclusive_lock_held_, (lock), _Pre_ _SA_annotes1(SAL_requires_exclusive_lock_held,lock))
#define _Requires_shared_lock_held_(lock)  _SAL2_Source_(_Requires_shared_lock_held_, (lock), _Pre_ _SA_annotes1(SAL_requires_shared_lock_held,lock))

#define _Requires_lock_not_held_(lock)  _SAL2_Source_(_Requires_lock_not_held_, (lock), _Pre_ _SA_annotes1(SAL_requires_lock_not_held,lock))
#define _Requires_no_locks_held_  _SAL2_Source_(_Requires_no_locks_held_, (), _Pre_ _SA_annotes0(SAL_requires_no_locks_held))

           /*
            * acquire/release locking side effects
            */
#define _Acquires_lock_(lock)  _SAL2_Source_(_Acquires_lock_, (lock), _Post_ _SA_annotes1(SAL_acquires_lock,lock))
#define _Acquires_exclusive_lock_(lock)  _SAL2_Source_(_Acquires_exclusive_lock_, (lock), _Post_ _SA_annotes1(SAL_acquires_exclusive_lock,lock))
#define _Acquires_shared_lock_(lock)  _SAL2_Source_(_Acquires_shared_lock_, (lock), _Post_ _SA_annotes1(SAL_acquires_shared_lock,lock))

#define _Releases_lock_(lock)  _SAL2_Source_(_Releases_lock_, (lock), _Post_ _SA_annotes1(SAL_releases_lock,lock))
#define _Releases_exclusive_lock_(lock)  _SAL2_Source_(_Releases_exclusive_lock_, (lock), _Post_ _SA_annotes1(SAL_releases_exclusive_lock,lock))
#define _Releases_shared_lock_(lock)  _SAL2_Source_(_Releases_shared_lock_, (lock), _Post_ _SA_annotes1(SAL_releases_shared_lock,lock))

            /*
             * acquire/release locking side effects for non-reentrant locks
             */
#define _Acquires_nonreentrant_lock_(lock) \
     _SAL2_Source_(_Acquires_nonreentrant_lock_, (lock), \
    _Requires_lock_not_held_(lock) \
    _Acquires_lock_(lock))

#define _Releases_nonreentrant_lock_(lock) \
     _SAL2_Source_(_Releases_nonreentrant_lock_, (lock), \
    _Requires_lock_held_(lock) \
    _Releases_lock_(lock))

#define _Post_same_lock_(a,b)  _SAL2_Source_(_Post_same_lock_, (a,b), _Post_ _SA_annotes2(SAL_set_same_lock,a,b))

             /*
              * lock level
              */
#define _Create_lock_level_(level) _Internal_create_CSAL_identifier_(level)

#define _Has_lock_level_(level)  _SAL2_Source_(_Has_lock_level_, (level), _SA_annotes1(SAL_has_lock_level,#level))

#define _Internal_lock_level_order_(a,b)  _SAL2_Source_(_Internal_lock_level_order_, (a,b), _SA_annotes2(SAL_lock_level_order,a,b))
#define _Csalcat1_(x,y) x##y
#define _Csalcat2_(x,y) _Csalcat1_(x,y)

#define _Lock_level_order_(a,b) \
    extern _Internal_lock_level_order_(a,b) void _Sal_order_##a##_##b(_In_z_ const char*a, _In_z_ const char*b); \
    static __inline void CSALCAT2(CSAL_LockOrder,__COUNTER__)(void){_Sal_order_##a##_##b(#a,#b);}

              /*
               * threading context
               */
#define _No_competing_thread_  _SAL2_Source_(_No_competing_thread_, (), _Pre_ _SA_annotes0(SAL_no_competing_thread))

               /*
                * refinement and suppression
                */
        extern _Acquires_lock_(*plock) void _Internal_acquires_lock_(void* plock);
    extern _Releases_lock_(*plock) void _Internal_releases_lock_(void* plock);

#define _Internal_set_lock_count_to_zero_(lock)  _SAL2_Source_(Internal_set_lock_count_to_zero_, (lock), _Post_ _SA_annotes1(SAL_set_lock_count_to_zero,lock))
#define _Internal_set_lock_count_to_one_(lock)  _SAL2_Source_(_Internal_set_lock_count_to_one_, (lock), _Post_ _SA_annotes1(SAL_set_lock_count_to_one,lock))

    extern _Internal_set_lock_count_to_one_(*plock) void _Internal_lock_held_(void* plock);
    extern _Internal_set_lock_count_to_zero_(*plock) void _Internal_lock_not_held_(void* plock);
    extern _Post_same_lock_(*plock1, *plock2) void _Internal_same_lock_(void* plock1, void* plock2);

#define _Analysis_assume_lock_acquired_(lock)  _Internal_acquires_lock_((void*)(&(lock)))
#define _Analysis_assume_lock_released_(lock)  _Internal_releases_lock_((void*)(&(lock)))

#define _Analysis_assume_lock_held_(lock) _Internal_lock_held_((void*)(&(lock)))
#define _Analysis_assume_lock_not_held_(lock) _Internal_lock_not_held_((void*)(&(lock)))
#define _Analysis_assume_same_lock_(lock1, lock2) _Internal_same_lock_((void*)(&(lock1)), (void*)(&(lock2)))

    /*
     * _Function_ignore_lock_checking_ may be deprecated in future versions of SAL
     */
#define _Function_ignore_lock_checking_(lock)  _SAL2_Source_(_Function_ignore_lock_checking_, (lock), _Pre_ _SA_annotes1(SAL_ignore_lock_match,lock))
    extern _Function_ignore_lock_checking_(*plock) void _Internal_suppress_lock_checking_(void* plock);

    /*
     * _Analysis_suppress_lock_checking_ may be deprecated in future versions of SAL
     */
#define _Analysis_suppress_lock_checking_(lock) _Internal_suppress_lock_checking_((void*)(&(lock)));

#define _Benign_race_begin_ __pragma(warning(push)) __pragma(warning(disable:26100 26101 26150 26130 26180 26131 26181 28112))
#define _Benign_race_end_ __pragma(warning(pop))

#define _No_competing_thread_begin_ __pragma(warning(push)) __pragma(warning(disable:26100 26101 26150 26101 26151 26110 26160 26130 26180 26131 26181 28112))
#define _No_competing_thread_end_ __pragma(warning(pop))

     /*
      * lock kinds
      */
#define _Has_lock_kind_(kind)  _SAL2_Source_(_Has_lock_kind_, (kind), _SA_annotes1(SAL_has_lock_property,#kind))

      /*
       * smart locks (RAII lock wrappers)
       */
#ifdef __cplusplus
} // extern "C"

extern "C++"
{
    template<class _SmartLockType> _Acquires_lock_(_smartLock) void _Internal_acquires_smart_lock_(const _SmartLockType& _smartLock);
    template<class _SmartLockType> _Releases_lock_(_smartLock) void _Internal_releases_smart_lock_(const _SmartLockType& _smartLock);
} // extern "C++"

#define _Analysis_assume_smart_lock_acquired_(lock) _Internal_acquires_smart_lock_((lock))
#define _Analysis_assume_smart_lock_released_(lock) _Internal_releases_smart_lock_((lock))

extern "C" {
#endif

    /*
     * move semantics
     */
#define _Internal_swap_lock_ 0

#define _Detaches_lock_(detached, lock) _Post_same_lock_(_Internal_swap_lock_, (lock)) _Post_same_lock_((detached), _Internal_swap_lock_)
#define _Moves_lock_(target, source) _Post_same_lock_(_Internal_swap_lock_, (source)) _Post_same_lock_((target), _Internal_swap_lock_)
#define _Replaces_lock_(target, source) _Post_same_lock_(_Internal_swap_lock_, (target)) _Post_same_lock_((target), (source)) _Releases_lock_(_Internal_swap_lock_)
#define _Swaps_locks_(left, right) _Post_same_lock_(_Internal_swap_lock_, (left)) _Post_same_lock_((left), (right)) _Post_same_lock_((right), _Internal_swap_lock_)

     /*
      * Old spelling
      * Note: the old version may be deprecated in the future!!!
      */
    extern int __system_interlock;
    extern int __system_cancel_spinlock;
    extern int __system_critical_region;

#define __guarded_by(lock) _SAL1_1_Source_(__guarded_by, (lock), _SA_annotes1(SAL_guarded_by,lock))
#define __write_guarded_by(lock) _SAL1_1_Source_(__write_guarded_by, (lock), _SA_annotes1(SAL_write_guarded_by,lock))
#define __interlocked __guarded_by(_Global_interlock_)

    /*
     * caller/callee locking contracts
     */
#define __requires_lock_held(lock) _SAL1_1_Source_(__requires_lock_held, (lock), __pre _SA_annotes1(SAL_requires_lock_held,lock))
#define __requires_exclusive_lock_held(lock) _SAL1_1_Source_(__requires_exclusive_lock_held, (lock), __pre _SA_annotes1(SAL_requires_exclusive_lock_held,lock))
#define __requires_shared_lock_held(lock) _SAL1_1_Source_(__requires_shared_lock_held, (lock), __pre _SA_annotes1(SAL_requires_shared_lock_held,lock))

#define __requires_lock_not_held(lock) _SAL1_1_Source_(__requires_lock_not_held, (lock), __pre _SA_annotes1(SAL_requires_lock_not_held,lock))
#define __requires_no_locks_held _SAL1_1_Source_(__requires_no_locks_held, (), __pre _SA_annotes0(SAL_requires_no_locks_held))

     /*
      * acquire/release locking side effects
      */
#define __acquires_lock(lock) _SAL1_1_Source_(__acquires_lock, (lock), __post _SA_annotes1(SAL_acquires_lock,lock))
#define __acquires_exclusive_lock(lock) _SAL1_1_Source_(__acquires_exclusive_lock, (lock), __post _SA_annotes1(SAL_acquires_exclusive_lock,lock))
#define __acquires_shared_lock(lock) _SAL1_1_Source_(__acquires_shared_lock, (lock), __post _SA_annotes1(SAL_acquires_shared_lock,lock))

#define __releases_lock(lock) _SAL1_1_Source_(__releases_lock, (lock), __post _SA_annotes1(SAL_releases_lock,lock))
#define __releases_exclusive_lock(lock) _SAL1_1_Source_(__releases_exclusive_lock, (lock),__post _SA_annotes1(SAL_releases_exclusive_lock,lock))
#define __releases_shared_lock(lock) _SAL1_1_Source_(__releases_shared_lock, (lock), __post _SA_annotes1(SAL_releases_shared_lock,lock))

      /*
       * lock properties
       * The following kind options are supported:
       * __has_lock_property(MUTEX)
       * __has_lock_property(EVENT)
       * __has_lock_property(SEMAPHORE)
       * __has_lock_property(OTHER_HANDLE)
       * __has_lock_property(REENTRANT)
       * __has_lock_property(NON_REENTRANT)
       */
#define __has_lock_property(kind) _SAL1_1_Source_(__has_lock_property, (kind), _SA_annotes1(SAL_has_lock_property,#kind))

       /*
        * lock level
        */
#define __declare_lock_level(level) _Internal_create_CSAL_identifier_(level)
#define __has_lock_level(level) _SAL1_1_Source_(__has_lock_level, (level), _SA_annotes1(SAL_has_lock_level,#level))

#define __internal_lock_level_order(a,b) _SAL1_1_Source_(__internal_lock_level_order, (a,b), _SA_annotes2(SAL_lock_level_order,#a,#b))
#define CSALCAT1(x,y) x##y
#define CSALCAT2(x,y) CSALCAT1(x,y)

#define __lock_level_order(a,b) \
    extern __internal_lock_level_order(a,b) void __sal_order_##a##_##b(__in_z char*a, __in_z char*b); \
    static __inline void CSALCAT2(CSAL_LockOrder,__COUNTER__)(void){__sal_order_##a##_##b(#a,#b);}

        /*
         * threading context
         */
#define __no_competing_thread _SAL1_1_Source_(__no_competing_thread, (), __pre _SA_annotes0(SAL_no_competing_thread))

         /*
          * refinement and suppression
          */
    extern __acquires_lock(*plock) void __internal_acquires_lock(void* plock);
    extern __releases_lock(*plock) void __internal_releases_lock(void* plock);

#define __analysis_assume_lock_acquired(lock) __internal_acquires_lock((void*)(&(lock)))
#define __analysis_assume_lock_released(lock) __internal_releases_lock((void*)(&(lock)))

#define __function_ignore_lock_checking(lock) _SAL1_1_Source_(__function_ignore_lock_cleanup, (lock), __pre _SA_annotes1(SAL_ignore_lock_match,lock))
    extern __function_ignore_lock_checking(*plock) void __internal_suppress_lock_checking(void* plock);

#define __analysis_suppress_lock_checking(lock) __internal_suppress_lock_checking((void*)(&(lock)));

#define BENIGN_RACE_BEGIN __pragma(warning(push)) __pragma(warning(disable:26100 26150 26130 26180 26131 26181))
#define BENIGN_RACE_END __pragma(warning(pop))

#define NO_COMPETING_THREAD_BEGIN __pragma(warning(push)) __pragma(warning(disable:26100 26150 26101 26151 26110 26160 26130 26180 26131 26181))
#define NO_COMPETING_THREAD_END __pragma(warning(pop))

#else

#ifndef _Interlocked_operand_
#define _Interlocked_operand_
#endif

#define _Guarded_by_(lock)
#define _Write_guarded_by_(lock)
#define _Interlocked_
#define _Requires_lock_held_(lock)
#define _Requires_exclusive_lock_held_(lock)
#define _Requires_shared_lock_held_(lock)
#define _Requires_lock_not_held_(lock)
#define _Requires_no_locks_held_
#define _Acquires_lock_(lock)
#define _Acquires_exclusive_lock_(lock)
#define _Acquires_shared_lock_(lock)
#define _Releases_lock_(lock)
#define _Releases_exclusive_lock_(lock)
#define _Releases_shared_lock_(lock)
#define _Acquires_nonreentrant_lock_(lock)
#define _Releases_nonreentrant_lock_(lock)

#define _Post_same_lock_(lock1,lock2)

#define _Internal_set_lock_count_(lock, count)

#define _Create_lock_level_(level)
#define _Has_lock_level_(level)
#define _Internal_lock_level_order_(a,b)
#define _Csalcat1_(x,y)
#define _Csalcat2_(x,y)
#define _Lock_level_order_(a,b)
#define _No_competing_thread_
#define _Analysis_assume_lock_acquired_(lock)
#define _Analysis_assume_lock_released_(lock)
#define _Analysis_assume_lock_held_(lock)
#define _Analysis_assume_lock_not_held_(lock)
#define _Analysis_assume_same_lock_(lock1, lock2)
#define _Function_ignore_lock_checking_(lock)
#define _Analysis_suppress_lock_checking_(lock)

#define _Benign_race_begin_ __pragma(warning(push))
#define _Benign_race_end_ __pragma(warning(pop))

#define _No_competing_thread_begin_ __pragma(warning(push))
#define _No_competing_thread_end_ __pragma(warning(pop))

#define _Has_lock_kind_(kind)

#ifdef __cplusplus
#define _Analysis_assume_smart_lock_acquired_(lock)
#define _Analysis_assume_smart_lock_released_(lock)
#endif

#define _Detaches_lock_(detached, lock)
#define _Moves_lock_(target, source)
#define _Replaces_lock_(target, source)
#define _Swaps_locks_(left, right)

    /*
     * Old spelling: will be deprecated
     */
#define __guarded_by(lock)
#define __write_guarded_by(lock)
#define __interlocked
#define __requires_lock_held(lock)
#define __requires_exclusive_lock_held(lock)
#define __requires_shared_lock_held(lock)
#define __requires_lock_not_held(lock)
#define __requires_no_locks_held
#define __acquires_lock(lock)
#define __acquires_exclusive_lock(lock)
#define __acquires_shared_lock(lock)
#define __releases_lock(lock)
#define __releases_exclusive_lock(lock)
#define __releases_shared_lock(lock)

#define __has_lock_property(kind)
#define __declare_lock_level(level)
#define __has_lock_level(level)
#define __internal_lock_level_order(a,b)
#define CSALCAT1(x,y)
#define CSALCAT2(x,y)
#define __lock_level_order(a,b)
#define __no_competing_thread
#define __analysis_assume_lock_acquired(lock)
#define __analysis_assume_lock_released(lock)
#define __function_ignore_lock_checking(lock)
#define __analysis_suppress_lock_checking(lock)

#define BENIGN_RACE_BEGIN __pragma(warning(push))
#define BENIGN_RACE_END __pragma(warning(pop))

#define NO_COMPETING_THREAD_BEGIN __pragma(warning(push))
#define NO_COMPETING_THREAD_END __pragma(warning(pop))

#endif

#ifdef __cplusplus
}
#endif

#endif // CONCURRENCYSAL_H


//
// vadefs.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Definitions of macro helpers used by <stdarg.h>.  This is the topmost header
// in the CRT header lattice, and is always the first CRT header to be included,
// explicitly or implicitly.  Therefore, this header also has several definitions
// that are used throughout the CRT.
//
#pragma once
#define _INC_VADEFS

#define _CRT_PACKING 8
#pragma pack(push, _CRT_PACKING)

// C4339: '__type_info_node': use of undefined type detected in CLR meta-data (/Wall)
#ifndef _VCRUNTIME_DISABLED_WARNING_4339
#ifdef _M_CEE_PURE
#define _VCRUNTIME_DISABLED_WARNING_4339 4339
#else
#define _VCRUNTIME_DISABLED_WARNING_4339
#endif
#endif

// C4412: function signature contains type '<typename>';
//        C++ objects are unsafe to pass between pure code and mixed or native. (/Wall)
#ifndef _VCRUNTIME_DISABLED_WARNING_4412
#ifdef _M_CEE_PURE
#define _VCRUNTIME_DISABLED_WARNING_4412 4412
#else
#define _VCRUNTIME_DISABLED_WARNING_4412
#endif
#endif

// Use _VCRUNTIME_EXTRA_DISABLED_WARNINGS to add additional warning suppressions to VCRuntime headers.
#ifndef _VCRUNTIME_EXTRA_DISABLED_WARNINGS
#define _VCRUNTIME_EXTRA_DISABLED_WARNINGS
#endif

// C4514: unreferenced inline function has been removed (/Wall)
// C4820: '<typename>' : 'N' bytes padding added after data member (/Wall)
#ifndef _VCRUNTIME_DISABLED_WARNINGS
#define _VCRUNTIME_DISABLED_WARNINGS _VCRUNTIME_DISABLED_WARNING_4339 _VCRUNTIME_DISABLED_WARNING_4412 4514 4820 _VCRUNTIME_EXTRA_DISABLED_WARNINGS
#endif

#pragma warning(push)
#pragma warning(disable: _VCRUNTIME_DISABLED_WARNINGS)

#ifdef __cplusplus
extern "C" {
#endif

#if !defined _W64
#define _W64
#endif

#ifndef _UINTPTR_T_DEFINED
#define _UINTPTR_T_DEFINED
#ifdef _WIN64
    typedef unsigned __int64  uintptr_t;
#else
    typedef unsigned int uintptr_t;
#endif
#endif

#ifndef _VA_LIST_DEFINED
#define _VA_LIST_DEFINED
#ifdef _M_CEE_PURE
    typedef System::ArgIterator va_list;
#else
    typedef char* va_list;
#endif
#endif

#ifdef __cplusplus
#define _ADDRESSOF(v) (&const_cast<char&>(reinterpret_cast<const volatile char&>(v)))
#else
#define _ADDRESSOF(v) (&(v))
#endif

#if (defined _M_ARM || defined _M_HYBRID_X86_ARM64) && !defined _M_CEE_PURE
#define _VA_ALIGN       4
#define _SLOTSIZEOF(t)  ((sizeof(t) + _VA_ALIGN - 1) & ~(_VA_ALIGN - 1))
#define _APALIGN(t,ap)  (((va_list)0 - (ap)) & (__alignof(t) - 1))
#elif (defined _M_ARM64 || defined _M_ARM64EC) && !defined _M_CEE_PURE
#define _VA_ALIGN       8
#define _SLOTSIZEOF(t)  ((sizeof(t) + _VA_ALIGN - 1) & ~(_VA_ALIGN - 1))
#define _APALIGN(t,ap)  (((va_list)0 - (ap)) & (__alignof(t) - 1))
#else
#define _SLOTSIZEOF(t)  (sizeof(t))
#define _APALIGN(t,ap)  (__alignof(t))
#endif

#if defined _M_CEE_PURE || (defined _M_CEE && !defined _M_ARM && !defined _M_ARM64)

    void  __cdecl __va_start(va_list*, ...);
    void* __cdecl __va_arg(va_list*, ...);
    void  __cdecl __va_end(va_list*);

#define __crt_va_start_a(ap, v) ((void)(__va_start(&ap, _ADDRESSOF(v), _SLOTSIZEOF(v), __alignof(v), _ADDRESSOF(v))))
#define __crt_va_arg(ap, t)     (*(t *)__va_arg(&ap, _SLOTSIZEOF(t), _APALIGN(t,ap), (t*)0))
#define __crt_va_end(ap)        ((void)(__va_end(&ap)))

#elif defined _M_IX86 && !defined _M_HYBRID_X86_ARM64

#define _INTSIZEOF(n)          ((sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1))

#define __crt_va_start_a(ap, v) ((void)(ap = (va_list)_ADDRESSOF(v) + _INTSIZEOF(v)))
#define __crt_va_arg(ap, t)     (*(t*)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)))
#define __crt_va_end(ap)        ((void)(ap = (va_list)0))

#elif defined _M_ARM

#ifdef __cplusplus
    void __cdecl __va_start(va_list*, ...);
#define __crt_va_start_a(ap, v) ((void)(__va_start(&ap, _ADDRESSOF(v), _SLOTSIZEOF(v), _ADDRESSOF(v))))
#else
#define __crt_va_start_a(ap, v) ((void)(ap = (va_list)_ADDRESSOF(v) + _SLOTSIZEOF(v)))
#endif

#define __crt_va_arg(ap, t) (*(t*)((ap += _SLOTSIZEOF(t) + _APALIGN(t,ap)) - _SLOTSIZEOF(t)))
#define __crt_va_end(ap)    ((void)(ap = (va_list)0))

#elif defined _M_HYBRID_X86_ARM64
    void __cdecl __va_start(va_list*, ...);
#define __crt_va_start_a(ap,v) ((void)(__va_start(&ap, _ADDRESSOF(v), _SLOTSIZEOF(v), __alignof(v), _ADDRESSOF(v))))
#define __crt_va_arg(ap, t)    (*(t*)((ap += _SLOTSIZEOF(t)) - _SLOTSIZEOF(t)))
#define __crt_va_end(ap)       ((void)(ap = (va_list)0))

#elif defined _M_ARM64

    void __cdecl __va_start(va_list*, ...);

#define __crt_va_start_a(ap,v) ((void)(__va_start(&ap, _ADDRESSOF(v), _SLOTSIZEOF(v), __alignof(v), _ADDRESSOF(v))))
#define __crt_va_arg(ap, t)                                                 \
       ((sizeof(t) > (2 * sizeof(__int64)))                                   \
           ? **(t**)((ap += sizeof(__int64)) - sizeof(__int64))               \
           : *(t*)((ap += _SLOTSIZEOF(t) + _APALIGN(t,ap)) - _SLOTSIZEOF(t)))
#define __crt_va_end(ap)       ((void)(ap = (va_list)0))

#elif defined _M_ARM64EC
    void __cdecl __va_start(va_list*, ...);
    //take the ARM64 va_start (for now)
#define __crt_va_start_a(ap,v) ((void)(__va_start(&ap, _ADDRESSOF(v), _SLOTSIZEOF(v), __alignof(v), _ADDRESSOF(v))))
//a hybrid va arg, to account for the shift in calling convention, with the alignment of ARM64
#define __crt_va_arg(ap, t)                                               \
        ((sizeof(t) > sizeof(__int64) || (sizeof(t) & (sizeof(t) - 1)) != 0) \
            ? **(t**)((ap += sizeof(__int64)) - sizeof(__int64))             \
            : *(t*)((ap += _SLOTSIZEOF(t) + _APALIGN(t,ap)) - _SLOTSIZEOF(t)))
#define __crt_va_end(ap)        ((void)(ap = (va_list)0))

#elif defined _M_X64

    void __cdecl __va_start(va_list*, ...);

#define __crt_va_start_a(ap, x) ((void)(__va_start(&ap, x)))
#define __crt_va_arg(ap, t)                                               \
        ((sizeof(t) > sizeof(__int64) || (sizeof(t) & (sizeof(t) - 1)) != 0) \
            ? **(t**)((ap += sizeof(__int64)) - sizeof(__int64))             \
            :  *(t* )((ap += sizeof(__int64)) - sizeof(__int64)))
#define __crt_va_end(ap)        ((void)(ap = (va_list)0))

#endif

#ifdef __cplusplus
} // extern "C"
#endif

#if defined __cplusplus && !defined _CRT_NO_VA_START_VALIDATION
extern "C++"
{
    template <typename _Ty>
    struct __vcrt_va_list_is_reference
    {
        enum : bool { __the_value = false };
    };

    template <typename _Ty>
    struct __vcrt_va_list_is_reference<_Ty&>
    {
        enum : bool { __the_value = true };
    };

    template <typename _Ty>
    struct __vcrt_va_list_is_reference<_Ty&&>
    {
        enum : bool { __the_value = true };
    };

    template <typename _Ty>
    struct __vcrt_assert_va_start_is_not_reference
    {
        static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value,
            "va_start argument must not have reference type and must not be parenthesized");
    };
} // extern "C++"

#define __crt_va_start(ap, x) ((void)(__vcrt_assert_va_start_is_not_reference<decltype(x)>(), __crt_va_start_a(ap, x)))

#else // ^^^ __cplusplus ^^^ // vvv !__cplusplus vvv //

#define __crt_va_start(ap, x) __crt_va_start_a(ap, x)

#endif

#pragma warning(pop) // _VCRUNTIME_DISABLED_WARNINGS
#pragma pack(pop)


#pragma warning(push)
#pragma warning(disable: _VCRUNTIME_DISABLED_WARNINGS)

// All C headers have a common prologue and epilogue, to enclose the header in
// an extern "C" declaration when the header is #included in a C++ translation
// unit and to push/pop the packing.
#if defined __cplusplus

#define _CRT_BEGIN_C_HEADER            \
        __pragma(pack(push, _CRT_PACKING)) \
        extern "C" {

#define _CRT_END_C_HEADER \
        }                     \
        __pragma(pack(pop))

#elif defined __midl

#define _CRT_BEGIN_C_HEADER                         \
        cpp_quote("__pragma(pack(push, _CRT_PACKING))") \
        cpp_quote("extern \"C\" {")

#define _CRT_END_C_HEADER            \
        cpp_quote("}")                   \
        cpp_quote("__pragma(pack(pop))")

#else

#define _CRT_BEGIN_C_HEADER            \
        __pragma(pack(push, _CRT_PACKING))

#define _CRT_END_C_HEADER \
        __pragma(pack(pop))

#endif

_CRT_BEGIN_C_HEADER



#ifndef _HAS_EXCEPTIONS // Predefine as 0 to disable exceptions
#ifdef _KERNEL_MODE
#define _HAS_EXCEPTIONS 0
#else
#define _HAS_EXCEPTIONS 1
#endif /* _KERNEL_MODE */
#endif /* _HAS_EXCEPTIONS */



#define _CRT_STRINGIZE_(x) #x
#define _CRT_STRINGIZE(x) _CRT_STRINGIZE_(x)

#define _CRT_WIDE_(s) L ## s
#define _CRT_WIDE(s) _CRT_WIDE_(s)

#define _CRT_CONCATENATE_(a, b) a ## b
#define _CRT_CONCATENATE(a, b)  _CRT_CONCATENATE_(a, b)

#define _CRT_UNPARENTHESIZE_(...) __VA_ARGS__
#define _CRT_UNPARENTHESIZE(...)  _CRT_UNPARENTHESIZE_ __VA_ARGS__

#ifndef _VCRTIMP
#if defined _CRTIMP && !defined _VCRT_DEFINED_CRTIMP
#define _VCRTIMP _CRTIMP
#elif defined _VCRT_BUILD && defined CRTDLL && !defined _VCRT_SAT_1
#define _VCRTIMP __declspec(dllexport)
#else
#define _VCRTIMP
#endif
#endif

#ifndef _MRTIMP
#if defined MRTDLL && defined _CRTBLD && !defined _M_CEE_PURE
#define _MRTIMP __declspec(dllexport)
#else
#define _MRTIMP
#endif
#endif

// Definitions of calling conventions used code sometimes compiled as managed
#if defined _M_CEE_PURE || defined MRTDLL
#define __CLRCALL_OR_CDECL __clrcall
#define __CLR_OR_THIS_CALL __clrcall
#else
#define __CLRCALL_OR_CDECL __cdecl
#define __CLR_OR_THIS_CALL
#endif

#ifdef _M_CEE_PURE
#define __CLRCALL_PURE_OR_CDECL __clrcall
#else
#define __CLRCALL_PURE_OR_CDECL __cdecl
#endif

#define __CRTDECL __CLRCALL_PURE_OR_CDECL

// Definitions of common __declspecs
#define _VCRT_NOALIAS __declspec(noalias)
#define _VCRT_RESTRICT __declspec(restrict)
#define _VCRT_ALLOCATOR __declspec(allocator)

#if defined _M_CEE && defined _M_X64
#define _VCRT_JIT_INTRINSIC __declspec(jitintrinsic)
#else
#define _VCRT_JIT_INTRINSIC
#endif

#ifdef __midl
#define _VCRT_ALIGN(x)
#else
#define _VCRT_ALIGN(x) __declspec(align(x))
#endif

#ifndef _CONST_RETURN
#ifdef __cplusplus
#define _CRT_CONST_CORRECT_OVERLOADS
#define _CONST_RETURN  const
#else
#define _CONST_RETURN
#endif
#endif

// For backwards compatibility
#define _WConst_return _CONST_RETURN

// Definitions of common types
#ifdef _WIN64
typedef unsigned __int64 size_t;
typedef __int64          ptrdiff_t;
typedef __int64          intptr_t;
#else
typedef unsigned int     size_t;
typedef int              ptrdiff_t;
typedef int              intptr_t;
#endif

#if defined __cplusplus
typedef bool  __vcrt_bool;
#elif defined __midl
// MIDL understands neither bool nor _Bool.  Use char as a best-fit
// replacement (the differences won't matter in practice).
typedef char __vcrt_bool;
#else
typedef _Bool __vcrt_bool;
#endif

// Indicate that these common types are defined
#ifndef _SIZE_T_DEFINED
#define _SIZE_T_DEFINED
#endif

#ifndef _PTRDIFF_T_DEFINED
#define _PTRDIFF_T_DEFINED
#endif

#ifndef _INTPTR_T_DEFINED
#define _INTPTR_T_DEFINED
#endif

// Provide a typedef for wchar_t for use under /Zc:wchar_t-
#ifndef _WCHAR_T_DEFINED
#define _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#endif

#ifndef NULL
#ifdef __cplusplus
#define NULL 0
#else
#define NULL ((void *)0)
#endif
#endif

#if defined _M_X64 || defined _M_ARM || defined _M_ARM64
#define _UNALIGNED __unaligned
#else
#define _UNALIGNED
#endif

#if defined _M_ARM64EC
#define __security_check_cookie __security_check_cookie_arm64ec
#endif

#ifdef __cplusplus
extern "C++"
{
    template <typename _CountofType, size_t _SizeOfArray>
    char(*__countof_helper(_UNALIGNED _CountofType(&_Array)[_SizeOfArray]))[_SizeOfArray];

#define __crt_countof(_Array) (sizeof(*__countof_helper(_Array)) + 0)
}
#else
#define __crt_countof(_Array) (sizeof(_Array) / sizeof(_Array[0]))
#endif

#if defined(_M_IX86) && defined(_CRT_LEGACY_X86_FLT_EXCEPTIONS) && !defined(_M_CEE_PURE)
#pragma comment(lib, "legacy_x86_flt_exceptions")
#endif

#ifdef __cplusplus
#if defined(_MSVC_LANG) && _MSVC_LANG > __cplusplus
#define _STL_LANG _MSVC_LANG
#else  // ^^^ language mode is _MSVC_LANG / language mode is __cplusplus vvv
#define _STL_LANG __cplusplus
#endif // ^^^ language mode is larger of _MSVC_LANG and __cplusplus ^^^
#else  // ^^^ determine compiler's C++ mode / no C++ support vvv
#define _STL_LANG 0L
#endif // ^^^ no C++ support ^^^

#ifndef _HAS_CXX17
#if _STL_LANG > 201402L
#define _HAS_CXX17 1
#else
#define _HAS_CXX17 0
#endif
#endif // _HAS_CXX17

#ifndef _HAS_CXX20
#if _HAS_CXX17 && _STL_LANG > 201703L
#define _HAS_CXX20 1
#else
#define _HAS_CXX20 0
#endif
#endif // _HAS_CXX20

#ifndef _HAS_CXX23
#if _HAS_CXX20 && _STL_LANG > 202002L
#define _HAS_CXX23 1
#else
#define _HAS_CXX23 0
#endif
#endif // _HAS_CXX23

#undef _STL_LANG

#if _HAS_CXX20 && !_HAS_CXX17
#error _HAS_CXX20 must imply _HAS_CXX17.
#endif

#if _HAS_CXX23 && !_HAS_CXX20
#error _HAS_CXX23 must imply _HAS_CXX20.
#endif

// [[nodiscard]] attributes on STL functions
#ifndef _HAS_NODISCARD
#ifndef __has_cpp_attribute
#define _HAS_NODISCARD 0
#elif __has_cpp_attribute(nodiscard) >= 201603L // TRANSITION, VSO#939899 (need toolset update)
#define _HAS_NODISCARD 1
#else
#define _HAS_NODISCARD 0
#endif
#endif // _HAS_NODISCARD

#if _HAS_NODISCARD
#define _NODISCARD [[nodiscard]]
#else // ^^^ CAN HAZ [[nodiscard]] / NO CAN HAZ [[nodiscard]] vvv
#define _NODISCARD
#endif // _HAS_NODISCARD

#pragma push_macro("msvc")
#pragma push_macro("constexpr")
#undef msvc
#undef constexpr

// Determine if we should use [[msvc::constexpr]] to allow for "extended constexpr"
// in Visual C++.
#ifndef _MSVC_CONSTEXPR
#ifdef _MSVC_CONSTEXPR_ATTRIBUTE
#define _MSVC_CONSTEXPR [[msvc::constexpr]]
#else
#define _MSVC_CONSTEXPR
#endif
#endif

#pragma pop_macro("constexpr")
#pragma pop_macro("msvc")

#ifdef _BUILD_STD_MODULE
#define _VCRT_EXPORT_STD export
#else // ^^^ defined(_BUILD_STD_MODULE) / !defined(_BUILD_STD_MODULE) vvv
#define _VCRT_EXPORT_STD
#endif // ^^^ !defined(_BUILD_STD_MODULE) ^^^

// See note on use of "deprecate" at the top of this file
#define _CRT_DEPRECATE_TEXT(_Text) __declspec(deprecated(_Text))

#if defined _CRT_SECURE_NO_DEPRECATE && !defined _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS
#endif

#ifndef _CRT_INSECURE_DEPRECATE
#ifdef _CRT_SECURE_NO_WARNINGS
#define _CRT_INSECURE_DEPRECATE(_Replacement)
#else
#define _CRT_INSECURE_DEPRECATE(_Replacement) _CRT_DEPRECATE_TEXT(    \
            "This function or variable may be unsafe. Consider using "        \
            #_Replacement                                                     \
            " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " \
            "See online help for details.")
#endif
#endif

#if defined _CRT_SECURE_DEPRECATE_MEMORY && !defined _CRT_SECURE_WARNINGS_MEMORY
#define _CRT_SECURE_WARNINGS_MEMORY
#endif

#ifndef _CRT_INSECURE_DEPRECATE_MEMORY
#ifndef _CRT_SECURE_WARNINGS_MEMORY
#define _CRT_INSECURE_DEPRECATE_MEMORY(_Replacement)
#else
#define _CRT_INSECURE_DEPRECATE_MEMORY(_Replacement) \
            _CRT_INSECURE_DEPRECATE(_Replacement)
#endif
#endif

#if !defined _M_CEE && !defined __midl
void __cdecl __security_init_cookie(void);

#if defined(_M_IX86)
void __fastcall __security_check_cookie(_In_ uintptr_t _StackCookie);
__declspec(noreturn) void __cdecl __report_gsfailure(void);
#elif defined(_M_ARM64EC)
void __cdecl __security_check_cookie_arm64ec(_In_ uintptr_t _StackCookie);
__declspec(noreturn) void __cdecl __report_gsfailure(_In_ uintptr_t _StackCookie);
#else
void __cdecl __security_check_cookie(_In_ uintptr_t _StackCookie);
__declspec(noreturn) void __cdecl __report_gsfailure(_In_ uintptr_t _StackCookie);
#endif
#endif

extern uintptr_t __security_cookie;

#ifndef _VCRT_BUILD
#define __vcrt_malloc_normal(_Size) malloc(_Size)
#define __vcrt_calloc_normal(_Count, _Size) calloc(_Count, _Size)
#define __vcrt_free_normal(_Memory) free(_Memory)
#endif

_CRT_END_C_HEADER

#pragma warning(pop) // _VCRUNTIME_DISABLED_WARNINGS

#endif // _VCRUNTIME_H
// xkeycheck.h internal header

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#ifndef _XKEYCHECK_H
#define _XKEYCHECK_H

// xkeycheck.h assumes that it's being included by yvals_core.h in a specific order.
// Nothing else should include xkeycheck.h.

#if _STL_COMPILER_PREPROCESSOR

#if !defined(_ALLOW_KEYWORD_MACROS) && !defined(__INTELLISENSE__)

// clang-format off
// #if defined($KEYWORD)
// #define $KEYWORD EMIT WARNING C4005
// #error The C++ Standard Library forbids macroizing the keyword "$KEYWORD". \
// Enable warning C4005 to find the forbidden define.
// #endif // $KEYWORD
// clang-format on

// *don't* check the "alternative token representations"

// keywords:
#if defined(alignas)
#define alignas EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "alignas". \
Enable warning C4005 to find the forbidden define.
#endif // alignas

#if defined(alignof)
#define alignof EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "alignof". \
Enable warning C4005 to find the forbidden define.
#endif // alignof

#if defined(asm)
#define asm EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "asm". \
Enable warning C4005 to find the forbidden define.
#endif // asm

#if defined(auto)
#define auto EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "auto". \
Enable warning C4005 to find the forbidden define.
#endif // auto

#if defined(bool)
#define bool EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "bool". \
Enable warning C4005 to find the forbidden define.
#endif // bool

#if defined(break)
#define break EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "break". \
Enable warning C4005 to find the forbidden define.
#endif // break

#if defined(case)
#define case EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "case". \
Enable warning C4005 to find the forbidden define.
#endif // case

#if defined(catch)
#define catch EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "catch". \
Enable warning C4005 to find the forbidden define.
#endif // catch

#if defined(char)
#define char EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "char". \
Enable warning C4005 to find the forbidden define.
#endif // char

#if defined(char8_t) && _HAS_CXX20
#define char8_t EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "char8_t". \
Enable warning C4005 to find the forbidden define.
#endif // char8_t

#if defined(char16_t)
#define char16_t EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "char16_t". \
Enable warning C4005 to find the forbidden define.
#endif // char16_t

#if defined(char32_t)
#define char32_t EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "char32_t". \
Enable warning C4005 to find the forbidden define.
#endif // char32_t

#if defined(class)
#define class EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "class". \
Enable warning C4005 to find the forbidden define.
#endif // class

#if defined(concept) && _HAS_CXX20
#define concept EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "concept". \
Enable warning C4005 to find the forbidden define.
#endif // concept

#if defined(const)
#define const EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "const". \
Enable warning C4005 to find the forbidden define.
#endif // const

#if defined(consteval) && _HAS_CXX20
#define consteval EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "consteval". \
Enable warning C4005 to find the forbidden define.
#endif // consteval

#if defined(constexpr)
#define constexpr EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "constexpr". \
Enable warning C4005 to find the forbidden define.
#endif // constexpr

#if defined(constinit) && _HAS_CXX20
#define constinit EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "constinit". \
Enable warning C4005 to find the forbidden define.
#endif // constinit

#if defined(const_cast)
#define const_cast EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "const_cast". \
Enable warning C4005 to find the forbidden define.
#endif // const_cast

#if defined(continue)
#define continue EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "continue". \
Enable warning C4005 to find the forbidden define.
#endif // continue

#if defined(co_await) && _HAS_CXX20
#define co_await EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "co_await". \
Enable warning C4005 to find the forbidden define.
#endif // co_await

#if defined(co_return) && _HAS_CXX20
#define co_return EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "co_return". \
Enable warning C4005 to find the forbidden define.
#endif // co_return

#if defined(co_yield) && _HAS_CXX20
#define co_yield EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "co_yield". \
Enable warning C4005 to find the forbidden define.
#endif // co_yield

#if defined(decltype)
#define decltype EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "decltype". \
Enable warning C4005 to find the forbidden define.
#endif // decltype

#if defined(default)
#define default EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "default". \
Enable warning C4005 to find the forbidden define.
#endif // default

#if defined(delete)
#define delete EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "delete". \
Enable warning C4005 to find the forbidden define.
#endif // delete

#if defined(do)
#define do EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "do". \
Enable warning C4005 to find the forbidden define.
#endif // do

#if defined(double)
#define double EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "double". \
Enable warning C4005 to find the forbidden define.
#endif // double

#if defined(dynamic_cast)
#define dynamic_cast EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "dynamic_cast". \
Enable warning C4005 to find the forbidden define.
#endif // dynamic_cast

#if defined(else)
#define else EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "else". \
Enable warning C4005 to find the forbidden define.
#endif // else

#if defined(enum)
#define enum EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "enum". \
Enable warning C4005 to find the forbidden define.
#endif // enum

#if defined(explicit)
#define explicit EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "explicit". \
Enable warning C4005 to find the forbidden define.
#endif // explicit

#if defined(export)
#define export EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "export". \
Enable warning C4005 to find the forbidden define.
#endif // export

#if defined(extern)
#define extern EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "extern". \
Enable warning C4005 to find the forbidden define.
#endif // extern

#if defined(false)
#define false EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "false". \
Enable warning C4005 to find the forbidden define.
#endif // false

#if defined(float)
#define float EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "float". \
Enable warning C4005 to find the forbidden define.
#endif // float

#if defined(for)
#define for EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "for". \
Enable warning C4005 to find the forbidden define.
#endif // for

#if defined(friend)
#define friend EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "friend". \
Enable warning C4005 to find the forbidden define.
#endif // friend

#if defined(goto)
#define goto EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "goto". \
Enable warning C4005 to find the forbidden define.
#endif // goto

#if defined(if)
#define if EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "if". \
Enable warning C4005 to find the forbidden define.
#endif // if

#if defined(inline)
#define inline EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "inline". \
Enable warning C4005 to find the forbidden define.
#endif // inline

#if defined(int)
#define int EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "int". \
Enable warning C4005 to find the forbidden define.
#endif // int

#if defined(long)
#define long EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "long". \
Enable warning C4005 to find the forbidden define.
#endif // long

#if defined(mutable)
#define mutable EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "mutable". \
Enable warning C4005 to find the forbidden define.
#endif // mutable

#if defined(namespace)
#define namespace EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "namespace". \
Enable warning C4005 to find the forbidden define.
#endif // namespace

#if defined(new) && defined(_ENFORCE_BAN_OF_MACRO_NEW)
#define new EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "new", though macroized new is supported on this \
implementation as a nonstandard extension. Enable warning C4005 to find the forbidden define, or re-enable the \
extension by removing _ENFORCE_BAN_OF_MACRO_NEW.
#endif // new

#if defined(noexcept)
#define noexcept EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "noexcept". \
Enable warning C4005 to find the forbidden define.
#endif // noexcept

#if defined(nullptr)
#define nullptr EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "nullptr". \
Enable warning C4005 to find the forbidden define.
#endif // nullptr

#if defined(operator)
#define operator EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "operator". \
Enable warning C4005 to find the forbidden define.
#endif // operator

#if defined(private)
#define private EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "private". \
Enable warning C4005 to find the forbidden define.
#endif // private

#if defined(protected)
#define protected EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "protected". \
Enable warning C4005 to find the forbidden define.
#endif // protected

#if defined(public)
#define public EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "public". \
Enable warning C4005 to find the forbidden define.
#endif // public

#if defined(register)
#define register EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "register". \
Enable warning C4005 to find the forbidden define.
#endif // register

#if defined(reinterpret_cast)
#define reinterpret_cast EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "reinterpret_cast". \
Enable warning C4005 to find the forbidden define.
#endif // reinterpret_cast

#if defined(requires) && _HAS_CXX20
#define requires EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "requires". \
Enable warning C4005 to find the forbidden define.
#endif // requires

#if defined(return)
#define return EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "return". \
Enable warning C4005 to find the forbidden define.
#endif // return

#if defined(short)
#define short EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "short". \
Enable warning C4005 to find the forbidden define.
#endif // short

#if defined(signed)
#define signed EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "signed". \
Enable warning C4005 to find the forbidden define.
#endif // signed

#if defined(sizeof)
#define sizeof EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "sizeof". \
Enable warning C4005 to find the forbidden define.
#endif // sizeof

#if defined(static)
#define static EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "static". \
Enable warning C4005 to find the forbidden define.
#endif // static

#if defined(static_assert)
#define static_assert EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "static_assert". \
Enable warning C4005 to find the forbidden define.
#endif // static_assert

#if defined(static_cast)
#define static_cast EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "static_cast". \
Enable warning C4005 to find the forbidden define.
#endif // static_cast

#if defined(struct)
#define struct EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "struct". \
Enable warning C4005 to find the forbidden define.
#endif // struct

#if defined(switch)
#define switch EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "switch". \
Enable warning C4005 to find the forbidden define.
#endif // switch

#if defined(template)
#define template EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "template". \
Enable warning C4005 to find the forbidden define.
#endif // template

#if defined(this)
#define this EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "this". \
Enable warning C4005 to find the forbidden define.
#endif // this

#if defined(thread_local)
#define thread_local EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "thread_local". \
Enable warning C4005 to find the forbidden define.
#endif // thread_local

#if defined(throw)
#define throw EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "throw". \
Enable warning C4005 to find the forbidden define.
#endif // throw

#if defined(true)
#define true EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "true". \
Enable warning C4005 to find the forbidden define.
#endif // true

#if defined(try)
#define try EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "try". \
Enable warning C4005 to find the forbidden define.
#endif // try

#if defined(typedef)
#define typedef EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "typedef". \
Enable warning C4005 to find the forbidden define.
#endif // typedef

#if defined(typeid)
#define typeid EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "typeid". \
Enable warning C4005 to find the forbidden define.
#endif // typeid

#if defined(typename)
#define typename EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "typename". \
Enable warning C4005 to find the forbidden define.
#endif // typename

#if defined(union)
#define union EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "union". \
Enable warning C4005 to find the forbidden define.
#endif // union

#if defined(unsigned)
#define unsigned EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "unsigned". \
Enable warning C4005 to find the forbidden define.
#endif // unsigned

#if defined(using)
#define using EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "using". \
Enable warning C4005 to find the forbidden define.
#endif // using

#if defined(virtual)
#define virtual EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "virtual". \
Enable warning C4005 to find the forbidden define.
#endif // virtual

#if defined(void)
#define void EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "void". \
Enable warning C4005 to find the forbidden define.
#endif // void

#if defined(volatile)
#define volatile EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "volatile". \
Enable warning C4005 to find the forbidden define.
#endif // volatile

#if defined(wchar_t)
#define wchar_t EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "wchar_t". \
Enable warning C4005 to find the forbidden define.
#endif // wchar_t

#if defined(while)
#define while EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the keyword "while". \
Enable warning C4005 to find the forbidden define.
#endif // while

// contextual keywords (a.k.a. "identifiers with special meaning"):
#if defined(final)
#define final EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the contextual keyword "final". \
Enable warning C4005 to find the forbidden define.
#endif // final

#if defined(import) && _HAS_CXX20
#define import EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the contextual keyword "import". \
Enable warning C4005 to find the forbidden define.
#endif // import

#if defined(module) && _HAS_CXX20
#define module EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the contextual keyword "module". \
Enable warning C4005 to find the forbidden define.
#endif // module

#if defined(override)
#define override EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the contextual keyword "override". \
Enable warning C4005 to find the forbidden define.
#endif // override

// attribute-tokens:
#if defined(carries_dependency)
#define carries_dependency EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the attribute-token "carries_dependency". \
Enable warning C4005 to find the forbidden define.
#endif // carries_dependency

#if defined(deprecated)
#define deprecated EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the attribute-token "deprecated". \
Enable warning C4005 to find the forbidden define.
#endif // deprecated

#if defined(fallthrough) && _HAS_CXX17
#define fallthrough EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the attribute-token "fallthrough". \
Enable warning C4005 to find the forbidden define.
#endif // fallthrough

// not checking "likely" because it is commonly defined as a function-like macro

#if defined(maybe_unused) && _HAS_CXX17
#define maybe_unused EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the attribute-token "maybe_unused". \
Enable warning C4005 to find the forbidden define.
#endif // maybe_unused

#if defined(nodiscard) // C++17 attribute-token, also enforced in C++14 mode
#define nodiscard EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the attribute-token "nodiscard". \
Enable warning C4005 to find the forbidden define.
#endif // nodiscard

#if defined(noreturn)
#define noreturn EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the attribute-token "noreturn". \
Enable warning C4005 to find the forbidden define.
#endif // noreturn

#if defined(no_unique_address) && _HAS_CXX20
#define no_unique_address EMIT WARNING C4005
#error The C++ Standard Library forbids macroizing the attribute-token "no_unique_address". \
Enable warning C4005 to find the forbidden define.
#endif // no_unique_address

// not checking "unlikely" because it is commonly defined as a function-like macro

#endif // !defined(_ALLOW_KEYWORD_MACROS) && !defined(__INTELLISENSE__)

#endif // _STL_COMPILER_PREPROCESSOR
#endif // _XKEYCHECK_H

#define _STL_STRINGIZE_(S) #S
#define _STL_STRINGIZE(S)  _STL_STRINGIZE_(S)

// Note that _STL_PRAGMA is load-bearing;
// it still needs to exist even once CUDA and ICC support _Pragma.
#if defined(__CUDACC__) || defined(__INTEL_COMPILER)
#define _STL_PRAGMA(PRAGMA) __pragma(PRAGMA)
#else
#define _STL_PRAGMA(PRAGMA) _Pragma(#PRAGMA)
#endif

#define _STL_PRAGMA_MESSAGE(MESSAGE) _STL_PRAGMA(message(MESSAGE))
#define _EMIT_STL_MESSAGE(MESSAGE)   _STL_PRAGMA_MESSAGE(__FILE__ "(" _STL_STRINGIZE(__LINE__) "): " MESSAGE)

#define _EMIT_STL_WARNING(NUMBER, MESSAGE) _EMIT_STL_MESSAGE("warning " #NUMBER ": " MESSAGE)
#define _EMIT_STL_ERROR(NUMBER, MESSAGE)   static_assert(false, "error " #NUMBER ": " MESSAGE)

#ifndef _STL_WARNING_LEVEL
#if defined(_MSVC_WARNING_LEVEL) && _MSVC_WARNING_LEVEL >= 4
#define _STL_WARNING_LEVEL 4
#else // defined(_MSVC_WARNING_LEVEL) && _MSVC_WARNING_LEVEL >= 4
#define _STL_WARNING_LEVEL 3
#endif // defined(_MSVC_WARNING_LEVEL) && _MSVC_WARNING_LEVEL >= 4
#endif // !defined(_STL_WARNING_LEVEL)

#if _STL_WARNING_LEVEL < 3
#error _STL_WARNING_LEVEL cannot be less than 3.
#endif // _STL_WARNING_LEVEL < 3

#if _STL_WARNING_LEVEL > 4
#error _STL_WARNING_LEVEL cannot be greater than 4.
#endif // _STL_WARNING_LEVEL > 4

#ifndef __has_cpp_attribute
#define _FALLTHROUGH
#elif __has_cpp_attribute(fallthrough) >= 201603L
#define _FALLTHROUGH [[fallthrough]]
#else
#define _FALLTHROUGH
#endif

#ifndef __has_cpp_attribute // vvv no attributes vvv
#define _LIKELY
#define _UNLIKELY
#elif __has_cpp_attribute(likely) >= 201803L && __has_cpp_attribute(unlikely) >= 201803L // ^^^ no attr / C++20 attr vvv
#define _LIKELY   [[likely]]
#define _UNLIKELY [[unlikely]]
#elif defined(__clang__) // ^^^ C++20 attributes / clang attributes and C++17 or C++14 vvv
#define _LIKELY   [[__likely__]]
#define _UNLIKELY [[__unlikely__]]
#else // ^^^ clang attributes and C++17 or C++14 / C1XX attributes and C++17 or C++14 vvv
#define _LIKELY
#define _UNLIKELY
#endif // ^^^ C1XX attributes and C++17 or C++14 ^^^

// _HAS_NODISCARD (in vcruntime.h) controls:
// [[nodiscard]] attributes on STL functions

// TRANSITION, This should go to vcruntime.h
#ifndef __has_cpp_attribute
#define _NODISCARD_MSG(_Msg)
#elif __has_cpp_attribute(nodiscard) >= 201907L
#define _NODISCARD_MSG(_Msg) [[nodiscard(_Msg)]]
#elif __has_cpp_attribute(nodiscard) >= 201603L
#define _NODISCARD_MSG(_Msg) [[nodiscard]]
#else
#define _NODISCARD_MSG(_Msg)
#endif

#ifndef __has_cpp_attribute
#define _NODISCARD_CTOR
#define _NODISCARD_CTOR_MSG(_Msg)
#elif __has_cpp_attribute(nodiscard) >= 201907L
#define _NODISCARD_CTOR           _NODISCARD
#define _NODISCARD_CTOR_MSG(_Msg) _NODISCARD_MSG(_Msg)
#else // ^^^ __has_cpp_attribute(nodiscard) >= 201907L / __has_cpp_attribute(nodiscard) < 201907L vvv
#define _NODISCARD_CTOR
#define _NODISCARD_CTOR_MSG(_Msg)
#endif // ^^^ defined(__has_cpp_attribute) && __has_cpp_attribute(nodiscard) < 201907L ^^^

#if defined(__CUDACC__) && !defined(__clang__) // TRANSITION, VSO-568006
#define _NODISCARD_FRIEND friend
#else // ^^^ workaround / no workaround vvv
#define _NODISCARD_FRIEND _NODISCARD friend
#endif // ^^^ no workaround ^^^

#define _NODISCARD_REMOVE_ALG                                                                                    \
    _NODISCARD_MSG("The 'remove' and 'remove_if' algorithms return the iterator past the last element "          \
                   "that should be kept. You need to call container.erase(result, container.end()) afterwards. " \
                   "In C++20, 'std::erase' and 'std::erase_if' are simpler replacements for these two steps.")

#define _NODISCARD_UNIQUE_ALG                                                                                \
    _NODISCARD_MSG("The 'unique' algorithm returns the iterator past the last element that should be kept. " \
                   "You need to call container.erase(result, container.end()) afterwards.")

#define _NODISCARD_EMPTY_MEMBER                                                                                    \
    _NODISCARD_MSG(                                                                                                \
        "This member function returns a bool indicating whether the container is empty and has no other effects. " \
        "It is not useful to call this member function and discard the return value. "                             \
        "Use the 'clear()' member function if you want to erase all elements.")

#define _NODISCARD_EMPTY_ARRAY_MEMBER                                                                              \
    _NODISCARD_MSG(                                                                                                \
        "This member function returns a bool indicating whether the container is empty and has no other effects. " \
        "It is not useful to call this member function and discard the return value. "                             \
        "There's no way to clear an array as its size is fixed.")

#define _NODISCARD_EMPTY_STACKTRACE_MEMBER                                                                         \
    _NODISCARD_MSG(                                                                                                \
        "This member function returns a bool indicating whether the container is empty and has no other effects. " \
        "It is not useful to call this member function and discard the return value. "                             \
        "'std::stacktrace' can be cleared by assigning an empty value to it.")

#define _NODISCARD_EMPTY_NON_MEMBER                                                                            \
    _NODISCARD_MSG(                                                                                            \
        "This function returns a bool indicating whether the container or container-like object is empty and " \
        "has no other effects. It is not useful to call this function and discard the return value.")

#define _NODISCARD_EMPTY_ADAPTOR_MEMBER                                                                            \
    _NODISCARD_MSG(                                                                                                \
        "This member function returns a bool indicating whether the container is empty and has no other effects. " \
        "It is not useful to call this member function and discard the return value. "                             \
        "Container adaptors don't provide 'clear()' member functions, but you can assign an empty object to them.")

#define _NODISCARD_BARRIER_TOKEN \
    _NODISCARD_MSG("The token from 'arrive()' should not be discarded; it should be passed to 'wait()'.")

#define _NODISCARD_TRY_WAIT                                                                                    \
    _NODISCARD_MSG(                                                                                            \
        "This member function returns the state of the synchronization object and does not do anything else; " \
        "it is not useful to call this member function and discard the return value.")

#define _NODISCARD_TRY_CHANGE_STATE                                                                    \
    _NODISCARD_MSG("This function returns whether the operation succeeded in modifying object state. " \
                   "It is dangerous to ignore the return value.")

#define _NODISCARD_SMART_PTR_ALLOC                                                                            \
    _NODISCARD_MSG("This function constructs an object wrapped by a smart pointer and has no other effects; " \
                   "it is not useful to call this function and discard the return value.")

#define _NODISCARD_RAW_PTR_ALLOC                                                \
    _NODISCARD_MSG("This function allocates memory and returns a raw pointer. " \
                   "Discarding the return value will cause a memory leak.")

#define _NODISCARD_ASSUME_ALIGNED                                                                                    \
    _NODISCARD_MSG("'std::assume_aligned' has a potential effect on the return value (not on the passed argument). " \
                   "It is not useful to call 'std::assume_aligned' and discard the return value.")

#define _NODISCARD_LAUNDER                                                                                    \
    _NODISCARD_MSG("'std::launder' has a potential effect on the return value (not on the passed argument). " \
                   "It is not useful to call 'std::launder' and discard the return value.")

#ifdef _SILENCE_NODISCARD_LOCK_WARNINGS

#define _NODISCARD_LOCK
#define _NODISCARD_CTOR_LOCK

#else // ^^^ defined(_SILENCE_NODISCARD_LOCK_WARNINGS) / !defined(_SILENCE_NODISCARD_LOCK_WARNINGS) vvv

#define _NODISCARD_LOCK                                                                                                \
    _NODISCARD_MSG("A lock should be stored in a variable to protect the scope. If you're intentionally constructing " \
                   "a temporary to protect the rest of the current expression using the comma operator, you can cast " \
                   "the temporary to void or define _SILENCE_NODISCARD_LOCK_WARNINGS to suppress this warning.")

#define _NODISCARD_CTOR_LOCK                                                                                \
    _NODISCARD_CTOR_MSG(                                                                                    \
        "A lock should be stored in a variable to protect the scope. If you're intentionally constructing " \
        "a temporary to protect the rest of the current expression using the comma operator, you can cast " \
        "the temporary to void or define _SILENCE_NODISCARD_LOCK_WARNINGS to suppress this warning.")

#endif // ^^^ !defined(_SILENCE_NODISCARD_LOCK_WARNINGS) ^^^

#define _NODISCARD_CTOR_THREAD                                                     \
    _NODISCARD_CTOR_MSG("This temporary 'std::thread' is not joined or detached, " \
                        "so 'std::terminate' will be called at the end of the statement.")

#define _NODISCARD_CTOR_JTHREAD                                                                            \
    _NODISCARD_CTOR_MSG("This temporary 'std::jthread' is implicitly joined at the end of the statement. " \
                        "If this is intentional, you can add '.join()' to suppress this warning. "         \
                        "Otherwise, this 'std::jthread' should be stored in a variable.")

#define _NODISCARD_ASYNC                                                                                           \
    _NODISCARD_MSG("The result of 'std::async' should be stored in a variable. If the return value is discarded, " \
                   "the temporary 'std::future' is destroyed, waiting for an async result or evaluating "          \
                   "a deferred result, thus defeating the purpose of 'std::async'.")

#define _NODISCARD_GET_FUTURE \
    _NODISCARD_MSG("Since 'get_future' may be called only once, discarding the result is likely a mistake.")

#pragma push_macro("msvc")
#pragma push_macro("known_semantics")
#pragma push_macro("noop_dtor")
#pragma push_macro("intrinsic")
#pragma push_macro("lifetimebound")
#undef msvc
#undef known_semantics
#undef noop_dtor
#undef intrinsic
#undef lifetimebound

#ifndef __has_cpp_attribute
#define _HAS_MSVC_ATTRIBUTE(x) 0
#elif defined(__CUDACC__) // TRANSITION, CUDA - warning: attribute namespace "msvc" is unrecognized
#define _HAS_MSVC_ATTRIBUTE(x) 0
#else
#define _HAS_MSVC_ATTRIBUTE(x) __has_cpp_attribute(msvc::x)
#endif

// Should we use [[msvc::known_semantics]] to tell the compiler that certain
// type trait specializations have the standard-mandated semantics?
#if _HAS_MSVC_ATTRIBUTE(known_semantics)
#define _MSVC_KNOWN_SEMANTICS [[msvc::known_semantics]]
#else
#define _MSVC_KNOWN_SEMANTICS
#endif

// Should we use [[msvc::noop_dtor]] to tell the compiler that some non-trivial
// destructors have no effects?
#if _HAS_MSVC_ATTRIBUTE(noop_dtor)
#define _MSVC_NOOP_DTOR [[msvc::noop_dtor]]
#else
#define _MSVC_NOOP_DTOR
#endif

// Should we use [[msvc::intrinsic]] allowing the compiler to implement the
// behavior of certain trivial functions?
#if _HAS_MSVC_ATTRIBUTE(intrinsic)
#define _MSVC_INTRINSIC [[msvc::intrinsic]]
#else
#define _MSVC_INTRINSIC
#endif

// Should we enable [[msvc::lifetimebound]] or [[clang::lifetimebound]] warnings?
#if !defined(__has_cpp_attribute) || defined(_SILENCE_LIFETIMEBOUND_WARNING)
#define _MSVC_LIFETIMEBOUND
#elif _HAS_MSVC_ATTRIBUTE(lifetimebound)
#define _MSVC_LIFETIMEBOUND [[msvc::lifetimebound]]
#elif __has_cpp_attribute(_Clang::__lifetimebound__)
#define _MSVC_LIFETIMEBOUND [[_Clang::__lifetimebound__]]
#else
#define _MSVC_LIFETIMEBOUND
#endif

#undef _HAS_MSVC_ATTRIBUTE
#pragma pop_macro("lifetimebound")
#pragma pop_macro("intrinsic")
#pragma pop_macro("noop_dtor")
#pragma pop_macro("known_semantics")
#pragma pop_macro("msvc")

// warning C4577: 'noexcept' used with no exception handling mode specified;
// termination on exception is not guaranteed. Specify /EHsc (/Wall)
#if _HAS_EXCEPTIONS
#define _STL_DISABLED_WARNING_C4577
#else
#define _STL_DISABLED_WARNING_C4577 4577
#endif

// warning C4984: 'if constexpr' is a C++17 language extension
#if !_HAS_CXX17
#define _STL_DISABLED_WARNING_C4984 4984
#else
#define _STL_DISABLED_WARNING_C4984
#endif

// warning C5053: support for 'explicit(<expr>)' in C++17 and earlier is a vendor extension
#if !_HAS_CXX20
#define _STL_DISABLED_WARNING_C5053 5053
#else
#define _STL_DISABLED_WARNING_C5053
#endif

#ifndef _STL_EXTRA_DISABLED_WARNINGS
#define _STL_EXTRA_DISABLED_WARNINGS
#endif // !defined(_STL_EXTRA_DISABLED_WARNINGS)

// warning C4180: qualifier applied to function type has no meaning; ignored
// warning C4324: structure was padded due to alignment specifier
// warning C4412: function signature contains type 'meow'; C++ objects are unsafe to pass between pure code
//                and mixed or native. (/Wall)
// warning C4455: literal suffix identifiers that do not start with an underscore are reserved
// warning C4494: Ignoring __declspec(allocator) because the function return type is not a pointer or reference
// warning C4514: unreferenced inline function has been removed (/Wall)
// warning C4574: 'MACRO' is defined to be '0': did you mean to use '#if MACRO'? (/Wall)
// warning C4582: 'union': constructor is not implicitly called (/Wall)
// warning C4583: 'union': destructor is not implicitly called (/Wall)
// warning C4587: behavior change: constructor is no longer implicitly called (/Wall)
// warning C4588: behavior change: destructor is no longer implicitly called (/Wall)
// warning C4619: #pragma warning: there is no warning number 'number' (/Wall)
// warning C4623: default constructor was implicitly defined as deleted (/Wall)
// warning C4625: copy constructor was implicitly defined as deleted (/Wall)
// warning C4626: assignment operator was implicitly defined as deleted (/Wall)
// warning C4643: Forward declaring 'meow' in namespace std is not permitted by the C++ Standard. (/Wall)
// warning C4648: standard attribute 'meow' is ignored
// warning C4702: unreachable code
// warning C4793: function compiled as native
// warning C4820: 'N' bytes padding added after data member 'meow' (/Wall)
// warning C4868: compiler may not enforce left-to-right evaluation order in braced initializer list (/Wall)
// warning C4988: variable declared outside class/function scope (/Wall /d1WarnOnGlobals)
// warning C5026: move constructor was implicitly defined as deleted (/Wall)
// warning C5027: move assignment operator was implicitly defined as deleted (/Wall)
// warning C5045: Compiler will insert Spectre mitigation for memory load if /Qspectre switch specified (/Wall)
// warning C5220: a non-static data member with a volatile qualified type no longer implies that compiler generated
//                copy/move constructors and copy/move assignment operators are not trivial (/Wall)
// warning C6294: Ill-defined for-loop: initial condition does not satisfy test. Loop body not executed

#ifndef _STL_DISABLED_WARNINGS
// clang-format off
#define _STL_DISABLED_WARNINGS                        \
    4180 4324 4412 4455 4494 4514 4574 4582 4583 4587 \
    4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 \
    4868 4988 5026 5027 5045 5220 6294                \
    _STL_DISABLED_WARNING_C4577                       \
    _STL_DISABLED_WARNING_C4984                       \
    _STL_DISABLED_WARNING_C5053                       \
    _STL_EXTRA_DISABLED_WARNINGS
// clang-format on
#endif // !defined(_STL_DISABLED_WARNINGS)

// warning: constexpr if is a C++17 extension [-Wc++17-extensions]
// warning: explicit(bool) is a C++20 extension [-Wc++20-extensions]
// warning: declaring overloaded 'operator()' as 'static' is a C++23 extension [-Wc++23-extensions]
// warning: ignoring __declspec(allocator) because the function return type '%s' is not a pointer or reference type
//     [-Wignored-attributes]
// warning: '#pragma float_control' is not supported on this target - ignored [-Wignored-pragmas]
// warning: user-defined literal suffixes not starting with '_' are reserved [-Wuser-defined-literals]
// warning: unknown pragma ignored [-Wunknown-pragmas]
#ifndef _STL_DISABLE_CLANG_WARNINGS
#ifdef __clang__
// clang-format off
#define _STL_DISABLE_CLANG_WARNINGS                                 \
    _Pragma("clang diagnostic push")                                \
    _Pragma("clang diagnostic ignored \"-Wc++17-extensions\"")      \
    _Pragma("clang diagnostic ignored \"-Wc++20-extensions\"")      \
    _Pragma("clang diagnostic ignored \"-Wc++23-extensions\"")      \
    _Pragma("clang diagnostic ignored \"-Wignored-attributes\"")    \
    _Pragma("clang diagnostic ignored \"-Wignored-pragmas\"")       \
    _Pragma("clang diagnostic ignored \"-Wuser-defined-literals\"") \
    _Pragma("clang diagnostic ignored \"-Wunknown-pragmas\"")
// clang-format on
#else // ^^^ defined(__clang__) / !defined(__clang__) vvv
#define _STL_DISABLE_CLANG_WARNINGS
#endif // ^^^ !defined(__clang__) ^^^
#endif // !defined(_STL_DISABLE_CLANG_WARNINGS)

#ifndef _STL_RESTORE_CLANG_WARNINGS
#ifdef __clang__
#define _STL_RESTORE_CLANG_WARNINGS _Pragma("clang diagnostic pop")
#else // ^^^ defined(__clang__) / !defined(__clang__) vvv
#define _STL_RESTORE_CLANG_WARNINGS
#endif // ^^^ !defined(__clang__) ^^^
#endif // !defined(_STL_RESTORE_CLANG_WARNINGS)

// clang-format off
#ifndef _STL_DISABLE_DEPRECATED_WARNING
#ifdef __clang__
#define _STL_DISABLE_DEPRECATED_WARNING \
    _Pragma("clang diagnostic push")    \
    _Pragma("clang diagnostic ignored \"-Wdeprecated-declarations\"")
#elif defined(__CUDACC__) || defined(__INTEL_COMPILER)
#define _STL_DISABLE_DEPRECATED_WARNING \
    __pragma(warning(push))             \
    __pragma(warning(disable : 4996)) // was declared deprecated
#else // vvv MSVC vvv
#define _STL_DISABLE_DEPRECATED_WARNING \
    _Pragma("warning(push)")            \
    _Pragma("warning(disable : 4996)") // was declared deprecated
#endif // ^^^ MSVC ^^^
#endif // _STL_DISABLE_DEPRECATED_WARNING
// clang-format on

#ifndef _STL_RESTORE_DEPRECATED_WARNING
#ifdef __clang__
#define _STL_RESTORE_DEPRECATED_WARNING _Pragma("clang diagnostic pop")
#elif defined(__CUDACC__) || defined(__INTEL_COMPILER)
#define _STL_RESTORE_DEPRECATED_WARNING __pragma(warning(pop))
#else // vvv MSVC vvv
#define _STL_RESTORE_DEPRECATED_WARNING _Pragma("warning(pop)")
#endif // ^^^ MSVC ^^^
#endif // !defined(_STL_RESTORE_DEPRECATED_WARNING)

#define _CPPLIB_VER       650
#define _MSVC_STL_VERSION 143
#define _MSVC_STL_UPDATE  202402L

#ifndef _ALLOW_COMPILER_AND_STL_VERSION_MISMATCH
#if defined(__CUDACC__) && defined(__CUDACC_VER_MAJOR__)
#if __CUDACC_VER_MAJOR__ < 11 || (__CUDACC_VER_MAJOR__ == 11 && __CUDACC_VER_MINOR__ < 6)
_EMIT_STL_ERROR(STL1002, "Unexpected compiler version, expected CUDA 11.6 or newer.");
#endif // ^^^ old CUDA ^^^
#elif defined(__EDG__)
// not attempting to detect __EDG_VERSION__ being less than expected
#elif defined(__clang__)
#if __clang_major__ < 17
_EMIT_STL_ERROR(STL1000, "Unexpected compiler version, expected Clang 17.0.0 or newer.");
#endif // ^^^ old Clang ^^^
#elif defined(_MSC_VER)
#if _MSC_VER < 1940 // Coarse-grained, not inspecting _MSC_FULL_VER
_EMIT_STL_ERROR(STL1001, "Unexpected compiler version, expected MSVC 19.40 or newer.");
#endif // ^^^ old MSVC ^^^
#else // vvv other compilers vvv
// not attempting to detect other compilers
#endif // ^^^ other compilers ^^^
#endif // !defined(_ALLOW_COMPILER_AND_STL_VERSION_MISMATCH)

#ifndef _HAS_STATIC_RTTI
#define _HAS_STATIC_RTTI 1
#endif // !defined(_HAS_STATIC_RTTI)

#if defined(_CPPRTTI) && !_HAS_STATIC_RTTI
#error /GR implies _HAS_STATIC_RTTI.
#endif // defined(_CPPRTTI) && !_HAS_STATIC_RTTI

// N4950 [dcl.constexpr]/1: "A function or static data member declared with the
// constexpr or consteval specifier is implicitly an inline function or variable"

// Functions that became constexpr in C++17
#if _HAS_CXX17
#define _CONSTEXPR17 constexpr
#else // ^^^ constexpr in C++17 and later / inline (not constexpr) in C++14 vvv
#define _CONSTEXPR17 inline
#endif // ^^^ inline (not constexpr) in C++14 ^^^

// Functions that became constexpr in C++20
#if _HAS_CXX20
#define _CONSTEXPR20 constexpr
#else // ^^^ constexpr in C++20 and later / inline (not constexpr) in C++17 and earlier vvv
#define _CONSTEXPR20 inline
#endif // ^^^ inline (not constexpr) in C++17 and earlier ^^^

// Functions that became constexpr in C++23
#if _HAS_CXX23
#define _CONSTEXPR23 constexpr
#else // ^^^ constexpr in C++23 and later / inline (not constexpr) in C++20 and earlier vvv
#define _CONSTEXPR23 inline
#endif // ^^^ inline (not constexpr) in C++20 and earlier ^^^

// P2465R3 Standard Library Modules std And std.compat
#ifdef _BUILD_STD_MODULE
#if !_HAS_CXX20
#error The Standard Library Modules are available only with C++20 or later.
#endif // ^^^ !_HAS_CXX20 ^^^
#define _EXPORT_STD export
#else // ^^^ defined(_BUILD_STD_MODULE) / !defined(_BUILD_STD_MODULE) vvv
#define _EXPORT_STD
#endif // ^^^ !defined(_BUILD_STD_MODULE) ^^^

// P0607R0 Inline Variables For The STL
#if _HAS_CXX17
#define _INLINE_VAR inline
#else
#define _INLINE_VAR
#endif

// N4190 Removing auto_ptr, random_shuffle(), And Old <functional> Stuff
#ifndef _HAS_AUTO_PTR_ETC
#define _HAS_AUTO_PTR_ETC (!_HAS_CXX17)
#endif // !defined(_HAS_AUTO_PTR_ETC)

// P0003R5 Removing Dynamic Exception Specifications
#ifndef _HAS_UNEXPECTED
#define _HAS_UNEXPECTED (!_HAS_CXX17)
#endif // !defined(_HAS_UNEXPECTED)

#if _HAS_UNEXPECTED && _HAS_CXX23
_EMIT_STL_ERROR(STL1004, "C++98 unexpected() is incompatible with C++23 unexpected<E>.");
#endif // _HAS_UNEXPECTED && _HAS_CXX23

// P0004R1 Removing Deprecated Iostreams Aliases
#ifndef _HAS_OLD_IOSTREAMS_MEMBERS
#define _HAS_OLD_IOSTREAMS_MEMBERS (!_HAS_CXX17)
#endif // !defined(_HAS_OLD_IOSTREAMS_MEMBERS)

// P0298R3 std::byte
#ifndef _HAS_STD_BYTE
#define _HAS_STD_BYTE _HAS_CXX17
#endif // !defined(_HAS_STD_BYTE)

// P0302R1 Removing Allocator Support In std::function
// LWG-2385 function::assign allocator argument doesn't make sense
// LWG-2921 packaged_task and type-erased allocators
// LWG-2976 Dangling uses_allocator specialization for packaged_task
#ifndef _HAS_FUNCTION_ALLOCATOR_SUPPORT
#define _HAS_FUNCTION_ALLOCATOR_SUPPORT (!_HAS_CXX17)
#endif // !defined(_HAS_FUNCTION_ALLOCATOR_SUPPORT)

// The non-Standard std::tr1 namespace and TR1-only machinery
#ifndef _HAS_TR1_NAMESPACE
#define _HAS_TR1_NAMESPACE (!_HAS_CXX17)
#endif // !defined(_HAS_TR1_NAMESPACE)

// STL4000 is "_STATIC_CPPLIB is deprecated", currently in yvals.h
// STL4001 is "/clr:pure is deprecated", currently in yvals.h

#if _HAS_TR1_NAMESPACE
#ifdef _SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING
#define _DEPRECATE_TR1_NAMESPACE
#else // ^^^ warning disabled / warning enabled vvv
#define _DEPRECATE_TR1_NAMESPACE                                                                                  \
    [[deprecated(                                                                                                 \
        "warning STL4002: "                                                                                       \
        "The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can " \
        "define _SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to suppress this warning.")]]
#endif // ^^^ warning enabled ^^^
#endif // _HAS_TR1_NAMESPACE

// STL4003 was "The non-Standard std::identity struct is deprecated and will be REMOVED."

// Enforcement of matching allocator value_types
#ifndef _ENFORCE_MATCHING_ALLOCATORS
#define _ENFORCE_MATCHING_ALLOCATORS _HAS_CXX17
#endif // !defined(_ENFORCE_MATCHING_ALLOCATORS)

#define _MISMATCHED_ALLOCATOR_MESSAGE(_CONTAINER, _VALUE_TYPE)                                                      \
    _CONTAINER " requires that Allocator's value_type match " _VALUE_TYPE " (See N4950 [container.alloc.reqmts]/5)" \
               " Either fix the allocator value_type or define _ENFORCE_MATCHING_ALLOCATORS=0"                      \
               " to suppress this error."

// Enforcement of Standard facet specializations
#ifndef _ENFORCE_FACET_SPECIALIZATIONS
#define _ENFORCE_FACET_SPECIALIZATIONS 0
#endif // !defined(_ENFORCE_FACET_SPECIALIZATIONS)

#define _FACET_SPECIALIZATION_MESSAGE                                                  \
    "Unsupported facet specialization; see N4950 [locale.category]. "                  \
    "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 " \
    "to suppress this error."

// To improve compiler throughput, use 'hidden friend' operators in <system_error> instead of non-members that are
// depicted in the Standard.
#ifndef _STL_OPTIMIZE_SYSTEM_ERROR_OPERATORS
#define _STL_OPTIMIZE_SYSTEM_ERROR_OPERATORS 1
#endif // !defined(_STL_OPTIMIZE_SYSTEM_ERROR_OPERATORS)

// Controls whether the STL will force /fp:fast to enable vectorization of algorithms defined
// in the standard as special cases; such as reduce, transform_reduce, inclusive_scan, exclusive_scan
#ifndef _STD_VECTORIZE_WITH_FLOAT_CONTROL
#ifdef _M_FP_EXCEPT
#define _STD_VECTORIZE_WITH_FLOAT_CONTROL 0
#else // ^^^ floating-point exceptions enabled / floating-point exceptions disabled (default) vvv
#define _STD_VECTORIZE_WITH_FLOAT_CONTROL 1
#endif // ^^^ floating-point exceptions disabled (default) ^^^
#endif // !defined(_STD_VECTORIZE_WITH_FLOAT_CONTROL)

// P0174R2 Deprecating Vestigial Library Parts
// P0521R0 Deprecating shared_ptr::unique()
// Other C++17 deprecation warnings

// N4659 D.4 [depr.cpp.headers]
#if _HAS_CXX17 && !defined(_SILENCE_CXX17_C_HEADER_DEPRECATION_WARNING) \
    && !defined(_SILENCE_ALL_CXX17_DEPRECATION_WARNINGS)
#define _CXX17_DEPRECATE_C_HEADER                                                               \
    [[deprecated("warning STL4004: "                                                            \
                 "<ccomplex>, <cstdalign>, <cstdbool>, and <ctgmath> are deprecated in C++17. " \
                 "You can define _SILENCE_CXX17_C_HEADER_DEPRECATION_WARNING "                  \
                 "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]
#else // ^^^ warning enabled / warning disabled vvv
#define _CXX17_DEPRECATE_C_HEADER
#endif // ^^^ warning disabled ^^^

// N4659 D.6 [depr.str.strstreams]
#if _HAS_CXX17 && !defined(_SILENCE_CXX17_STRSTREAM_DEPRECATION_WARNING) \
    && !defined(_SILENCE_ALL_CXX17_DEPRECATION_WARNINGS)
#define _CXX17_DEPRECATE_STRSTREAM                                              \
    [[deprecated("warning STL4005: <strstream> is deprecated in C++17. "        \
                 "You can define _SILENCE_CXX17_STRSTREAM_DEPRECATION_WARNING " \
                 "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]
#else // ^^^ warning enabled / warning disabled vvv
#define _CXX17_DEPRECATE_STRSTREAM
#endif // ^^^ warning disabled ^^^

// N4659 D.7 [depr.uncaught]
#if _HAS_CXX17 && !defined(_SILENCE_CXX17_UNCAUGHT_EXCEPTION_DEPRECATION_WARNING) \
    && !defined(_SILENCE_ALL_CXX17_DEPRECATION_WARNINGS)
#define _CXX17_DEPRECATE_UNCAUGHT_EXCEPTION                                              \
    [[deprecated("warning STL4006: "                                                     \
                 "std::uncaught_exception() is deprecated in C++17. "                    \
                 "It is superseded by std::uncaught_exceptions(), plural. "              \
                 "You can define _SILENCE_CXX17_UNCAUGHT_EXCEPTION_DEPRECATION_WARNING " \
                 "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]
#else // ^^^ warning enabled / warning disabled vvv
#define _CXX17_DEPRECATE_UNCAUGHT_EXCEPTION
#endif // ^^^ warning disabled ^^^

// N4659 D.8.1 [depr.weak.result_type]
// N4659 D.8.2 [depr.func.adaptor.typedefs]
#if _HAS_CXX17 && !defined(_SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING) \
    && !defined(_SILENCE_ALL_CXX17_DEPRECATION_WARNINGS)
#define _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS                                                                         \
    [[deprecated(                                                                                                 \
        "warning STL4007: Many result_type typedefs "                                                             \
        "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " \
        "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING "                                     \
        "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]
#else // ^^^ warning enabled / warning disabled vvv
#define _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS
#endif // ^^^ warning disabled ^^^

// N4659 D.8.3 [depr.negators]
#if _HAS_CXX17 && !defined(_SILENCE_CXX17_NEGATORS_DEPRECATION_WARNING) \
    && !defined(_SILENCE_ALL_CXX17_DEPRECATION_WARNINGS)
#define _CXX17_DEPRECATE_NEGATORS                                                                                \
    [[deprecated("warning STL4008: "                                                                             \
                 "std::not1(), std::not2(), std::unary_negate, and std::binary_negate are deprecated in C++17. " \
                 "They are superseded by std::not_fn(). "                                                        \
                 "You can define _SILENCE_CXX17_NEGATORS_DEPRECATION_WARNING "                                   \
                 "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]
#else // ^^^ warning enabled / warning disabled vvv
#define _CXX17_DEPRECATE_NEGATORS
#endif // ^^^ warning disabled ^^^

// STL4009 was "std::allocator<void> is deprecated in C++17"

// N4659 D.9 [depr.default.allocator]
#if _HAS_CXX17 && !defined(_SILENCE_CXX17_OLD_ALLOCATOR_MEMBERS_DEPRECATION_WARNING) \
    && !defined(_SILENCE_ALL_CXX17_DEPRECATION_WARNINGS)
#define _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS                                              \
    [[deprecated("warning STL4010: "                                                        \
                 "Various members of std::allocator are deprecated in C++17. "              \
                 "Use std::allocator_traits instead of accessing these members directly. "  \
                 "You can define _SILENCE_CXX17_OLD_ALLOCATOR_MEMBERS_DEPRECATION_WARNING " \
                 "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]
#else // ^^^ warning enabled / warning disabled vvv
#define _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS
#endif // ^^^ warning disabled ^^^

// N4659 D.10 [depr.storage.iterator]
#if _HAS_CXX17 && !defined(_SILENCE_CXX17_RAW_STORAGE_ITERATOR_DEPRECATION_WARNING) \
    && !defined(_SILENCE_ALL_CXX17_DEPRECATION_WARNINGS)
#define _CXX17_DEPRECATE_RAW_STORAGE_ITERATOR                                                  \
    [[deprecated("warning STL4011: "                                                           \
                 "std::raw_storage_iterator is deprecated in C++17. "                          \
                 "Consider using the std::uninitialized_copy() family of algorithms instead. " \
                 "You can define _SILENCE_CXX17_RAW_STORAGE_ITERATOR_DEPRECATION_WARNING "     \
                 "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]
#else // ^^^ warning enabled / warning disabled vvv
#define _CXX17_DEPRECATE_RAW_STORAGE_ITERATOR
#endif // ^^^ warning disabled ^^^

// N4659 D.11 [depr.temporary.buffer]
#if _HAS_CXX17 && !defined(_SILENCE_CXX17_TEMPORARY_BUFFER_DEPRECATION_WARNING) \
    && !defined(_SILENCE_ALL_CXX17_DEPRECATION_WARNINGS)
#define _CXX17_DEPRECATE_TEMPORARY_BUFFER                                                                   \
    [[deprecated("warning STL4012: "                                                                        \
                 "std::get_temporary_buffer() and std::return_temporary_buffer() are deprecated in C++17. " \
                 "You can define _SILENCE_CXX17_TEMPORARY_BUFFER_DEPRECATION_WARNING "                      \
                 "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]
#else // ^^^ warning enabled / warning disabled vvv
#define _CXX17_DEPRECATE_TEMPORARY_BUFFER
#endif // ^^^ warning disabled ^^^

// N4659 D.12 [depr.meta.types]
#if _HAS_CXX17 && !defined(_SILENCE_CXX17_IS_LITERAL_TYPE_DEPRECATION_WARNING) \
    && !defined(_SILENCE_ALL_CXX17_DEPRECATION_WARNINGS)
#define _CXX17_DEPRECATE_IS_LITERAL_TYPE                                                     \
    [[deprecated("warning STL4013: "                                                         \
                 "std::is_literal_type and std::is_literal_type_v are deprecated in C++17. " \
                 "You can define _SILENCE_CXX17_IS_LITERAL_TYPE_DEPRECATION_WARNING "        \
                 "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]
#else // ^^^ warning enabled / warning disabled vvv
#define _CXX17_DEPRECATE_IS_LITERAL_TYPE
#endif // ^^^ warning disabled ^^^

// N4659 D.12 [depr.meta.types]
#if _HAS_CXX17 && !defined(_SILENCE_CXX17_RESULT_OF_DEPRECATION_WARNING) \
    && !defined(_SILENCE_ALL_CXX17_DEPRECATION_WARNINGS)
#define _CXX17_DEPRECATE_RESULT_OF                                                      \
    [[deprecated("warning STL4014: "                                                    \
                 "std::result_of and std::result_of_t are deprecated in C++17. "        \
                 "They are superseded by std::invoke_result and std::invoke_result_t. " \
                 "You can define _SILENCE_CXX17_RESULT_OF_DEPRECATION_WARNING "         \
                 "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]
#else // ^^^ warning enabled / warning disabled vvv
#define _CXX17_DEPRECATE_RESULT_OF
#endif // ^^^ warning disabled ^^^

// N4659 D.13 [depr.iterator.primitives]
#if _HAS_CXX17 && !defined(_SILENCE_CXX17_ITERATOR_BASE_CLASS_DEPRECATION_WARNING) \
    && !defined(_SILENCE_ALL_CXX17_DEPRECATION_WARNINGS)
#define _CXX17_DEPRECATE_ITERATOR_BASE_CLASS                                                                          \
    [[deprecated(                                                                                                     \
        "warning STL4015: "                                                                                           \
        "The std::iterator class template (used as a base class to provide typedefs) is deprecated in C++17. "        \
        "(The <iterator> header is NOT deprecated.) The C++ Standard has never required user-defined iterators to "   \
        "derive from std::iterator. To fix this warning, stop deriving from std::iterator and start providing "       \
        "publicly accessible typedefs named iterator_category, value_type, difference_type, pointer, and reference. " \
        "Note that value_type is required to be non-const, even for constant iterators. "                             \
        "You can define _SILENCE_CXX17_ITERATOR_BASE_CLASS_DEPRECATION_WARNING "                                      \
        "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]
#else // ^^^ warning enabled / warning disabled vvv
#define _CXX17_DEPRECATE_ITERATOR_BASE_CLASS
#endif // ^^^ warning disabled ^^^

// N4659 D.14 [depr.util.smartptr.shared.obs]
#if _HAS_CXX17 && !defined(_SILENCE_CXX17_SHARED_PTR_UNIQUE_DEPRECATION_WARNING) \
    && !defined(_SILENCE_ALL_CXX17_DEPRECATION_WARNINGS)
#define _CXX17_DEPRECATE_SHARED_PTR_UNIQUE                                              \
    [[deprecated("warning STL4016: "                                                    \
                 "std::shared_ptr::unique() is deprecated in C++17. "                   \
                 "You can define _SILENCE_CXX17_SHARED_PTR_UNIQUE_DEPRECATION_WARNING " \
                 "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]
#else // ^^^ warning enabled / warning disabled vvv
#define _CXX17_DEPRECATE_SHARED_PTR_UNIQUE
#endif // ^^^ warning disabled ^^^

// N4659 D.15 [depr.locale.stdcvt]
// N4659 D.16 [depr.conversions]
#if _HAS_CXX17 && !defined(_SILENCE_CXX17_CODECVT_HEADER_DEPRECATION_WARNING) \
    && !defined(_SILENCE_ALL_CXX17_DEPRECATION_WARNINGS)
#define _CXX17_DEPRECATE_CODECVT_HEADER                                                                        \
    [[deprecated(                                                                                              \
        "warning STL4017: "                                                                                    \
        "std::wbuffer_convert, std::wstring_convert, and the <codecvt> header (containing std::codecvt_mode, " \
        "std::codecvt_utf8, std::codecvt_utf16, and std::codecvt_utf8_utf16) are deprecated in C++17. "        \
        "(The std::codecvt class template is NOT deprecated.) "                                                \
        "The C++ Standard doesn't provide equivalent non-deprecated functionality; "                           \
        "consider using MultiByteToWideChar() and WideCharToMultiByte() from <Windows.h> instead. "            \
        "You can define _SILENCE_CXX17_CODECVT_HEADER_DEPRECATION_WARNING "                                    \
        "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]
#else // ^^^ warning enabled / warning disabled vvv
#define _CXX17_DEPRECATE_CODECVT_HEADER
#endif // ^^^ warning disabled ^^^

// STL4018 was "The non-Standard std::tr2::sys namespace is deprecated and will be REMOVED."

#ifdef _SILENCE_FPOS_SEEKPOS_DEPRECATION_WARNING
#define _DEPRECATE_FPOS_SEEKPOS
#else // ^^^ warning disabled / warning enabled vvv
#define _DEPRECATE_FPOS_SEEKPOS                                                                                        \
    [[deprecated("warning STL4019: "                                                                                   \
                 "The member std::fpos::seekpos() is non-Standard, and is preserved only for compatibility with "      \
                 "workarounds for old versions of Visual C++. It will be removed in a future release, and in this "    \
                 "release always returns 0. Please use standards-conforming mechanisms to manipulate fpos, such as "   \
                 "conversions to and from streamoff, or an integral type, instead. If you are receiving this message " \
                 "while compiling Boost.IOStreams, a fix has been submitted upstream to make Boost use "               \
                 "standards-conforming mechanisms, as it does for other compilers. You can define "                    \
                 "_SILENCE_FPOS_SEEKPOS_DEPRECATION_WARNING to suppress this warning, "                                \
                 "or define _REMOVE_FPOS_SEEKPOS to remove std::fpos::seekpos entirely.")]]
#endif // ^^^ warning enabled ^^^

// P0482R6 Library Support For char8_t
// Other C++20 deprecation warnings

// N4868 D.23 [depr.locale.category]
#if _HAS_CXX20 && !defined(_SILENCE_CXX20_CODECVT_FACETS_DEPRECATION_WARNING) \
    && !defined(_SILENCE_ALL_CXX20_DEPRECATION_WARNINGS)
#define _CXX20_DEPRECATE_CODECVT_FACETS                                                                                \
    [[deprecated("warning STL4020: "                                                                                   \
                 "std::codecvt<char16_t, char, mbstate_t>, std::codecvt<char32_t, char, mbstate_t>, "                  \
                 "std::codecvt_byname<char16_t, char, mbstate_t>, and std::codecvt_byname<char32_t, char, mbstate_t> " \
                 "are deprecated in C++20 and replaced by specializations with a second argument of type char8_t. "    \
                 "You can define _SILENCE_CXX20_CODECVT_FACETS_DEPRECATION_WARNING "                                   \
                 "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]]
#else // ^^^ warning enabled / warning disabled vvv
#define _CXX20_DEPRECATE_CODECVT_FACETS
#endif // ^^^ warning disabled ^^^

// N4868 D.24 [depr.fs.path.factory]
#if _HAS_CXX20 && defined(__cpp_char8_t) && !defined(_SILENCE_CXX20_U8PATH_DEPRECATION_WARNING) \
    && !defined(_SILENCE_ALL_CXX20_DEPRECATION_WARNINGS)
#define _CXX20_DEPRECATE_U8PATH                                                                                      \
    [[deprecated("warning STL4021: "                                                                                 \
                 "The std::filesystem::u8path() overloads are deprecated in C++20. "                                 \
                 "The constructors of std::filesystem::path provide equivalent functionality via construction from " \
                 "u8string, u8string_view, or iterators with value_type char8_t. "                                   \
                 "You can define _SILENCE_CXX20_U8PATH_DEPRECATION_WARNING "                                         \
                 "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]]
#else // ^^^ warning enabled / warning disabled vvv
#define _CXX20_DEPRECATE_U8PATH
#endif // ^^^ warning disabled ^^^

#if !defined(_SILENCE_STDEXT_HASH_LOWER_BOUND_DEPRECATION_WARNING)
#define _DEPRECATE_STDEXT_HASH_LOWER_BOUND                                                                           \
    [[deprecated(                                                                                                    \
        "warning STL4022: "                                                                                          \
        "The hash_meow and unordered_meow containers' non-Standard lower_bound() member was provided for interface " \
        "compatibility with the ordered associative containers, and doesn't match the semantics of the "             \
        "hash_meow or unordered_meow containers. Please use the find() member instead. You can define "              \
        "_SILENCE_STDEXT_HASH_LOWER_BOUND_DEPRECATION_WARNING to suppress this warning.")]]
#else // ^^^ warning enabled / warning disabled vvv
#define _DEPRECATE_STDEXT_HASH_LOWER_BOUND
#endif // ^^^ warning disabled ^^^

#if !defined(_SILENCE_STDEXT_HASH_UPPER_BOUND_DEPRECATION_WARNING)
#define _DEPRECATE_STDEXT_HASH_UPPER_BOUND                                                                           \
    [[deprecated(                                                                                                    \
        "warning STL4023: "                                                                                          \
        "The hash_meow and unordered_meow containers' non-Standard upper_bound() member was provided for interface " \
        "compatibility with the ordered associative containers, and doesn't match the semantics of the "             \
        "hash_meow or unordered_meow containers. Please use the second iterator returned by the "                    \
        "equal_range() member instead. You can define "                                                              \
        "_SILENCE_STDEXT_HASH_UPPER_BOUND_DEPRECATION_WARNING to suppress this warning.")]]
#else // ^^^ warning enabled / warning disabled vvv
#define _DEPRECATE_STDEXT_HASH_UPPER_BOUND
#endif // ^^^ warning disabled ^^^

// P0966R1 [depr.string.capacity]
#if _HAS_CXX20 && !defined(_SILENCE_CXX20_STRING_RESERVE_WITHOUT_ARGUMENT_DEPRECATION_WARNING) \
    && !defined(_SILENCE_ALL_CXX20_DEPRECATION_WARNINGS)
#define _CXX20_DEPRECATE_STRING_RESERVE_WITHOUT_ARGUMENT                                                             \
    [[deprecated("warning STL4024: "                                                                                 \
                 "std::string::reserve() without an argument is deprecated in C++20. "                               \
                 "To shrink the string's capacity, use std::string::shrink_to_fit() instead. Otherwise, provide an " \
                 "argument to std::string::reserve(). "                                                              \
                 "You can define _SILENCE_CXX20_STRING_RESERVE_WITHOUT_ARGUMENT_DEPRECATION_WARNING "                \
                 "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]]
#else // ^^^ warning enabled / warning disabled vvv
#define _CXX20_DEPRECATE_STRING_RESERVE_WITHOUT_ARGUMENT
#endif // ^^^ warning disabled ^^^

// P0767R1 [depr.meta.types]
#if _HAS_CXX20 && !defined(_SILENCE_CXX20_IS_POD_DEPRECATION_WARNING) \
    && !defined(_SILENCE_ALL_CXX20_DEPRECATION_WARNINGS)
#define _CXX20_DEPRECATE_IS_POD                                                                                     \
    [[deprecated("warning STL4025: "                                                                                \
                 "std::is_pod and std::is_pod_v are deprecated in C++20. "                                          \
                 "The std::is_trivially_copyable and/or std::is_standard_layout traits likely suit your use case. " \
                 "You can define _SILENCE_CXX20_IS_POD_DEPRECATION_WARNING "                                        \
                 "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]]
#else // ^^^ warning enabled / warning disabled vvv
#define _CXX20_DEPRECATE_IS_POD
#endif // ^^^ warning disabled ^^^

#if _HAS_CXX20 && !defined(_SILENCE_EXPERIMENTAL_ERASE_DEPRECATION_WARNING)
#define _DEPRECATE_EXPERIMENTAL_ERASE                                                                                 \
    [[deprecated("warning STL4026: "                                                                                  \
                 "std::experimental::erase() and std::experimental::erase_if() are deprecated by Microsoft and will " \
                 "be REMOVED. They are superseded by std::erase() and std::erase_if(). "                              \
                 "You can define _SILENCE_EXPERIMENTAL_ERASE_DEPRECATION_WARNING to suppress this warning.")]]
#else // ^^^ warning enabled / warning disabled vvv
#define _DEPRECATE_EXPERIMENTAL_ERASE
#endif // ^^^ warning disabled ^^^

// P0768R1 [depr.relops]
#if _HAS_CXX20 && !defined(_SILENCE_CXX20_REL_OPS_DEPRECATION_WARNING) \
    && !defined(_SILENCE_ALL_CXX20_DEPRECATION_WARNINGS)
#define _CXX20_DEPRECATE_REL_OPS                                                                                      \
    [[deprecated("warning STL4027: "                                                                                  \
                 "The namespace std::rel_ops and its contents are deprecated in C++20. "                              \
                 "Their use is superseded by C++20's <=> operator and automatic rewrites of relational expressions. " \
                 "You can define _SILENCE_CXX20_REL_OPS_DEPRECATION_WARNING or "                                      \
                 "_SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]]
#else // ^^^ warning enabled / warning disabled vvv
#define _CXX20_DEPRECATE_REL_OPS
#endif // ^^^ warning disabled ^^^

#if _HAS_CXX20 && !defined(_SILENCE_CXX20_ATOMIC_INIT_DEPRECATION_WARNING) \
    && !defined(_SILENCE_ALL_CXX20_DEPRECATION_WARNINGS)
#define _CXX20_DEPRECATE_ATOMIC_INIT                                                  \
    [[deprecated("warning STL4028: "                                                  \
                 "std::atomic_init() overloads are deprecated in C++20. "             \
                 "The constructors of std::atomic provide equivalent functionality. " \
                 "You can define _SILENCE_CXX20_ATOMIC_INIT_DEPRECATION_WARNING "     \
                 "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]]
#else // ^^^ warning enabled / warning disabled vvv
#define _CXX20_DEPRECATE_ATOMIC_INIT
#endif // ^^^ warning disabled ^^^

#if _HAS_CXX20 && !defined(_SILENCE_CXX20_OLD_SHARED_PTR_ATOMIC_SUPPORT_DEPRECATION_WARNING) \
    && !defined(_SILENCE_ALL_CXX20_DEPRECATION_WARNINGS)
#define _CXX20_DEPRECATE_OLD_SHARED_PTR_ATOMIC_SUPPORT                                              \
    [[deprecated("warning STL4029: "                                                                \
                 "std::atomic_*() overloads for shared_ptr are deprecated in C++20. "               \
                 "The shared_ptr specialization of std::atomic provides superior functionality. "   \
                 "You can define _SILENCE_CXX20_OLD_SHARED_PTR_ATOMIC_SUPPORT_DEPRECATION_WARNING " \
                 "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]]
#else // ^^^ warning enabled / warning disabled vvv
#define _CXX20_DEPRECATE_OLD_SHARED_PTR_ATOMIC_SUPPORT
#endif // ^^^ warning disabled ^^^

#if _HAS_CXX20 && !defined(_SILENCE_CXX20_VOLATILE_DEPRECATION_WARNING) \
    && !defined(_SILENCE_ALL_CXX20_DEPRECATION_WARNINGS)
#define _CXX20_DEPRECATE_VOLATILE                                                                   \
    [[deprecated("warning STL4030: "                                                                \
                 "Some operations on volatile-qualified types in the STL are deprecated in C++20. " \
                 "You can define _SILENCE_CXX20_VOLATILE_DEPRECATION_WARNING "                      \
                 "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]]
#else // ^^^ warning enabled / warning disabled vvv
#define _CXX20_DEPRECATE_VOLATILE
#endif // ^^^ warning disabled ^^^

#if _HAS_CXX20 && !defined(_SILENCE_CXX20_MOVE_ITERATOR_ARROW_DEPRECATION_WARNING) \
    && !defined(_SILENCE_ALL_CXX20_DEPRECATION_WARNINGS)
#define _CXX20_DEPRECATE_MOVE_ITERATOR_ARROW                                              \
    [[deprecated("warning STL4031: "                                                      \
                 "std::move_iterator::operator->() is deprecated in C++20. "              \
                 "You can define _SILENCE_CXX20_MOVE_ITERATOR_ARROW_DEPRECATION_WARNING " \
                 "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]]
#else // ^^^ warning enabled / warning disabled vvv
#define _CXX20_DEPRECATE_MOVE_ITERATOR_ARROW
#endif // ^^^ warning disabled ^^^

#if _HAS_CXX17 && !defined(_SILENCE_CXX17_POLYMORPHIC_ALLOCATOR_DESTROY_DEPRECATION_WARNING) \
    && !defined(_SILENCE_ALL_CXX17_DEPRECATION_WARNINGS)
#define _CXX17_DEPRECATE_POLYMORPHIC_ALLOCATOR_DESTROY                                                   \
    [[deprecated("warning STL4032: "                                                                     \
                 "std::pmr::polymorphic_allocator::destroy() is deprecated in C++17 by LWG-3036. "       \
                 "Prefer std::destroy_at() or std::allocator_traits<polymorphic_allocator>::destroy(). " \
                 "You can define _SILENCE_CXX17_POLYMORPHIC_ALLOCATOR_DESTROY_DEPRECATION_WARNING "      \
                 "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]
#else // ^^^ warning enabled / warning disabled vvv
#define _CXX17_DEPRECATE_POLYMORPHIC_ALLOCATOR_DESTROY
#endif // ^^^ warning disabled ^^^

#if _HAS_CXX20 && !defined(_SILENCE_CXX20_IS_ALWAYS_EQUAL_DEPRECATION_WARNING) \
    && !defined(_SILENCE_ALL_CXX20_DEPRECATION_WARNINGS)
#define _CXX20_DEPRECATE_IS_ALWAYS_EQUAL                                                \
    [[deprecated("warning STL4033: "                                                    \
                 "std::allocator::is_always_equal is deprecated in C++20 by LWG-3170. " \
                 "Prefer std::allocator_traits<allocator<T>>::is_always_equal. "        \
                 "You can define _SILENCE_CXX20_IS_ALWAYS_EQUAL_DEPRECATION_WARNING "   \
                 "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]]
#else // ^^^ warning enabled / warning disabled vvv
#define _CXX20_DEPRECATE_IS_ALWAYS_EQUAL
#endif // ^^^ warning disabled ^^^

#if _HAS_CXX23 && !defined(_SILENCE_CXX23_ALIGNED_STORAGE_DEPRECATION_WARNING) \
    && !defined(_SILENCE_ALL_CXX23_DEPRECATION_WARNINGS)
#define _CXX23_DEPRECATE_ALIGNED_STORAGE                                                     \
    [[deprecated("warning STL4034: "                                                         \
                 "std::aligned_storage and std::aligned_storage_t are deprecated in C++23. " \
                 "Prefer alignas(T) std::byte t_buff[sizeof(T)]. "                           \
                 "You can define _SILENCE_CXX23_ALIGNED_STORAGE_DEPRECATION_WARNING "        \
                 "or _SILENCE_ALL_CXX23_DEPRECATION_WARNINGS to suppress this warning.")]]
#else // ^^^ warning enabled / warning disabled vvv
#define _CXX23_DEPRECATE_ALIGNED_STORAGE
#endif // ^^^ warning disabled ^^^

#if _HAS_CXX23 && !defined(_SILENCE_CXX23_ALIGNED_UNION_DEPRECATION_WARNING) \
    && !defined(_SILENCE_ALL_CXX23_DEPRECATION_WARNINGS)
#define _CXX23_DEPRECATE_ALIGNED_UNION                                                   \
    [[deprecated("warning STL4035: "                                                     \
                 "std::aligned_union and std::aligned_union_t are deprecated in C++23. " \
                 "Prefer alignas(Ts...) std::byte t_buff[std::max({sizeof(Ts)...})]. "   \
                 "You can define _SILENCE_CXX23_ALIGNED_UNION_DEPRECATION_WARNING "      \
                 "or _SILENCE_ALL_CXX23_DEPRECATION_WARNINGS to suppress this warning.")]]
#else // ^^^ warning enabled / warning disabled vvv
#define _CXX23_DEPRECATE_ALIGNED_UNION
#endif // ^^^ warning disabled ^^^

#if _HAS_CXX20 && !defined(_SILENCE_CXX20_CISO646_REMOVED_WARNING) && !defined(_SILENCE_ALL_CXX20_DEPRECATION_WARNINGS)
#define _CXX20_REMOVE_CISO646                                             \
    [[deprecated("warning STL4036: "                                      \
                 "<ciso646> is removed in C++20. "                        \
                 "You can define _SILENCE_CXX20_CISO646_REMOVED_WARNING " \
                 "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]]
#else // ^^^ warning enabled / warning disabled vvv
#define _CXX20_REMOVE_CISO646
#endif // ^^^ warning disabled ^^^

#if !defined(_SILENCE_NONFLOATING_COMPLEX_DEPRECATION_WARNING)
#define _DEPRECATE_NONFLOATING_COMPLEX                                                 \
    [[deprecated("warning STL4037: "                                                   \
                 "The effect of instantiating the template std::complex for any "      \
                 "type other than float, double, or long double is unspecified. "      \
                 "You can define _SILENCE_NONFLOATING_COMPLEX_DEPRECATION_WARNING to " \
                 "suppress this warning.")]]
#else // ^^^ warning enabled / warning disabled vvv
#define _DEPRECATE_NONFLOATING_COMPLEX
#endif // ^^^ warning disabled ^^^

// STL4038 is used to warn that "The contents of <meow> are available only with C++NN or later."

// STL4039 is used to warn that "The contents of <coroutine> are not available with /await."

// STL4040 is used to warn that "The contents of <any> require static RTTI."

#if _HAS_CXX23 && !defined(_SILENCE_CXX23_UNIX_STREAMS_DEPRECATION_WARNING) \
    && !defined(_SILENCE_ALL_CXX23_DEPRECATION_WARNINGS)
#define _CXX23_DEPRECATE_UNIX_STREAMS                                                                                  \
    [[deprecated(                                                                                                      \
        "warning STL4041: "                                                                                            \
        "std::errc enumerators std::errc::no_message_available, std::errc::no_stream_resources, "                      \
        "std::errc::not_a_stream, and std::errc::stream_timeout and their corresponding errno macros ENODATA, ENOSR, " \
        "ENOSTR, and ETIME are deprecated in C++23 by LWG-3869. These errno macros are deprecated in POSIX 2008 and "  \
        "removed in POSIX 202x. You can define _SILENCE_CXX23_UNIX_STREAMS_DEPRECATION_WARNING or "                    \
        "_SILENCE_ALL_CXX23_DEPRECATION_WARNINGS to suppress this warning.")]]
#else // ^^^ warning enabled / warning disabled vvv
#define _CXX23_DEPRECATE_UNIX_STREAMS
#endif // ^^^ warning disabled ^^^

#if _HAS_CXX23 && !defined(_SILENCE_CXX23_DENORM_DEPRECATION_WARNING) \
    && !defined(_SILENCE_ALL_CXX23_DEPRECATION_WARNINGS)
#define _CXX23_DEPRECATE_DENORM                                                                                        \
    [[deprecated("warning STL4042: "                                                                                   \
                 "std::float_denorm_style, std::numeric_limits::has_denorm, and std::numeric_limits::has_denorm_loss " \
                 "are deprecated in C++23. You can define _SILENCE_CXX23_DENORM_DEPRECATION_WARNING or "               \
                 "_SILENCE_ALL_CXX23_DEPRECATION_WARNINGS to suppress this warning.")]]
#else // ^^^ warning enabled / warning disabled vvv
#define _CXX23_DEPRECATE_DENORM
#endif // ^^^ warning disabled ^^^

#if _HAS_CXX17 && !defined(_SILENCE_STDEXT_ARR_ITERS_DEPRECATION_WARNING) \
    && !defined(_SILENCE_ALL_MS_EXT_DEPRECATION_WARNINGS)
#define _DEPRECATE_STDEXT_ARR_ITERS                                                                               \
    [[deprecated(                                                                                                 \
        "warning STL4043: stdext::checked_array_iterator, stdext::unchecked_array_iterator, and related factory " \
        "functions are non-Standard extensions and will be removed in the future. std::span (since C++20) and "   \
        "gsl::span can be used instead. You can define _SILENCE_STDEXT_ARR_ITERS_DEPRECATION_WARNING or "         \
        "_SILENCE_ALL_MS_EXT_DEPRECATION_WARNINGS to suppress this warning.")]]
#else // ^^^ warning enabled / warning disabled vvv
#define _DEPRECATE_STDEXT_ARR_ITERS
#endif // ^^^ warning disabled ^^^

#if _HAS_CXX17 && !defined(_SILENCE_STDEXT_CVT_DEPRECATION_WARNING) \
    && !defined(_SILENCE_ALL_MS_EXT_DEPRECATION_WARNINGS)
#define _DEPRECATE_STDEXT_CVT                                                                                          \
    [[deprecated("warning STL4044: The contents of the stdext::cvt namespace are non-Standard extensions and will be " \
                 "removed in the future. The MultiByteToWideChar() and WideCharToMultiByte() functions can be used "   \
                 "instead. You can define _SILENCE_STDEXT_CVT_DEPRECATION_WARNING or "                                 \
                 "_SILENCE_ALL_MS_EXT_DEPRECATION_WARNINGS to suppress this warning.")]]
#else // ^^^ warning enabled / warning disabled vvv
#define _DEPRECATE_STDEXT_CVT
#endif // ^^^ warning disabled ^^^

#if _HAS_CXX17 && !defined(_SILENCE_IO_PFX_SFX_DEPRECATION_WARNING) \
    && !defined(_SILENCE_ALL_MS_EXT_DEPRECATION_WARNINGS)
#define _DEPRECATE_IO_PFX_SFX                                                                                          \
    [[deprecated(                                                                                                      \
        "warning STL4045: The ipfx(), isfx(), opfx(), and osfx() functions are removed before C++98 (see WG21-N0794) " \
        "but kept as non-Standard extensions. They will be removed in the future, and the member classes sentry "      \
        "should be used instead. You can define _SILENCE_IO_PFX_SFX_DEPRECATION_WARNING or "                           \
        "_SILENCE_ALL_MS_EXT_DEPRECATION_WARNINGS to suppress this warning.")]]
#else // ^^^ warning enabled / warning disabled vvv
#define _DEPRECATE_IO_PFX_SFX
#endif // ^^^ warning disabled ^^^

#if _HAS_CXX17 && !defined(_SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING) \
    && !defined(_SILENCE_TR1_RANDOM_DEPRECATION_WARNING) && !defined(_SILENCE_ALL_MS_EXT_DEPRECATION_WARNINGS)
#define _DEPRECATE_TR1_RANDOM                                                                                          \
    [[deprecated("warning STL4046: Non-Standard TR1 components in <random> are deprecated and will be REMOVED. You "   \
                 "can define _SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING, _SILENCE_TR1_RANDOM_DEPRECATION_WARNING, or " \
                 "_SILENCE_ALL_MS_EXT_DEPRECATION_WARNINGS to suppress this warning.")]]
#else // ^^^ warning enabled / warning disabled vvv
#define _DEPRECATE_TR1_RANDOM
#endif // ^^^ warning disabled ^^^

// next warning number: STL4047

// next error number: STL1006

// P0619R4 Removing C++17-Deprecated Features
#ifndef _HAS_FEATURES_REMOVED_IN_CXX20
#define _HAS_FEATURES_REMOVED_IN_CXX20 (!_HAS_CXX20)
#endif // !defined(_HAS_FEATURES_REMOVED_IN_CXX20)

#ifndef _HAS_DEPRECATED_ADAPTOR_TYPEDEFS
#define _HAS_DEPRECATED_ADAPTOR_TYPEDEFS (_HAS_FEATURES_REMOVED_IN_CXX20)
#endif // !defined(_HAS_DEPRECATED_ADAPTOR_TYPEDEFS)

#ifndef _HAS_DEPRECATED_ALLOCATOR_MEMBERS
#define _HAS_DEPRECATED_ALLOCATOR_MEMBERS (_HAS_FEATURES_REMOVED_IN_CXX20)
#endif // !defined(_HAS_DEPRECATED_ALLOCATOR_MEMBERS)

#ifndef _HAS_DEPRECATED_ALLOCATOR_VOID
#define _HAS_DEPRECATED_ALLOCATOR_VOID (_HAS_FEATURES_REMOVED_IN_CXX20)
#endif // !defined(_HAS_DEPRECATED_ALLOCATOR_VOID)

#ifndef _HAS_DEPRECATED_IS_LITERAL_TYPE
#define _HAS_DEPRECATED_IS_LITERAL_TYPE (_HAS_FEATURES_REMOVED_IN_CXX20)
#endif // !defined(_HAS_DEPRECATED_IS_LITERAL_TYPE)

#ifndef _HAS_DEPRECATED_NEGATORS
#define _HAS_DEPRECATED_NEGATORS (_HAS_FEATURES_REMOVED_IN_CXX20)
#endif // !defined(_HAS_DEPRECATED_NEGATORS)

#ifndef _HAS_DEPRECATED_RAW_STORAGE_ITERATOR
#define _HAS_DEPRECATED_RAW_STORAGE_ITERATOR (_HAS_FEATURES_REMOVED_IN_CXX20)
#endif // !defined(_HAS_DEPRECATED_RAW_STORAGE_ITERATOR)

#ifndef _HAS_DEPRECATED_RESULT_OF
#define _HAS_DEPRECATED_RESULT_OF (_HAS_FEATURES_REMOVED_IN_CXX20)
#endif // !defined(_HAS_DEPRECATED_RESULT_OF)

#ifndef _HAS_DEPRECATED_SHARED_PTR_UNIQUE
#define _HAS_DEPRECATED_SHARED_PTR_UNIQUE (_HAS_FEATURES_REMOVED_IN_CXX20)
#endif // !defined(_HAS_DEPRECATED_SHARED_PTR_UNIQUE)

#ifndef _HAS_DEPRECATED_TEMPORARY_BUFFER
#define _HAS_DEPRECATED_TEMPORARY_BUFFER (_HAS_FEATURES_REMOVED_IN_CXX20)
#endif // !defined(_HAS_DEPRECATED_TEMPORARY_BUFFER)

#ifndef _HAS_DEPRECATED_UNCAUGHT_EXCEPTION
#define _HAS_DEPRECATED_UNCAUGHT_EXCEPTION (_HAS_FEATURES_REMOVED_IN_CXX20)
#endif // !defined(_HAS_DEPRECATED_UNCAUGHT_EXCEPTION)

#if _HAS_DEPRECATED_ADAPTOR_TYPEDEFS
#define _ARGUMENT_TYPE_NAME        argument_type
#define _FIRST_ARGUMENT_TYPE_NAME  first_argument_type
#define _SECOND_ARGUMENT_TYPE_NAME second_argument_type
#define _RESULT_TYPE_NAME          result_type
#else // ^^^ _HAS_DEPRECATED_ADAPTOR_TYPEDEFS / !_HAS_DEPRECATED_ADAPTOR_TYPEDEFS vvv
#define _ARGUMENT_TYPE_NAME        _Unnameable_argument
#define _FIRST_ARGUMENT_TYPE_NAME  _Unnameable_first_argument
#define _SECOND_ARGUMENT_TYPE_NAME _Unnameable_second_argument
#define _RESULT_TYPE_NAME          _Unnameable_result
#endif // ^^^ !_HAS_DEPRECATED_ADAPTOR_TYPEDEFS ^^^

// P1423R3 char8_t Backward Compatibility Remediation
// Controls whether we allow the stream insertions this proposal forbids
#ifndef _HAS_STREAM_INSERTION_OPERATORS_DELETED_IN_CXX20
#define _HAS_STREAM_INSERTION_OPERATORS_DELETED_IN_CXX20 (_HAS_FEATURES_REMOVED_IN_CXX20)
#endif // !defined(_HAS_STREAM_INSERTION_OPERATORS_DELETED_IN_CXX20)

#ifndef _HAS_FEATURES_REMOVED_IN_CXX23
#define _HAS_FEATURES_REMOVED_IN_CXX23 (!_HAS_CXX23)
#endif // !defined(_HAS_FEATURES_REMOVED_IN_CXX23)

// P2186R2 Removing Garbage Collection Support
#ifndef _HAS_GARBAGE_COLLECTION_SUPPORT_DELETED_IN_CXX23
#define _HAS_GARBAGE_COLLECTION_SUPPORT_DELETED_IN_CXX23 (_HAS_FEATURES_REMOVED_IN_CXX23)
#endif // !defined(_HAS_GARBAGE_COLLECTION_SUPPORT_DELETED_IN_CXX23)

// C++14
#define __cpp_lib_chrono_udls                      201304L
#define __cpp_lib_complex_udls                     201309L
#define __cpp_lib_exchange_function                201304L
#define __cpp_lib_freestanding_char_traits         202306L
#define __cpp_lib_freestanding_cstdlib             202306L
#define __cpp_lib_freestanding_cstring             202311L
#define __cpp_lib_freestanding_cwchar              202306L
#define __cpp_lib_freestanding_errc                202306L
#define __cpp_lib_freestanding_feature_test_macros 202306L
#define __cpp_lib_freestanding_functional          202306L
#define __cpp_lib_freestanding_iterator            202306L
#define __cpp_lib_freestanding_memory              202306L
#define __cpp_lib_freestanding_operator_new        202306L
#define __cpp_lib_freestanding_ratio               202306L
#define __cpp_lib_freestanding_tuple               202306L
#define __cpp_lib_freestanding_utility             202306L
#define __cpp_lib_generic_associative_lookup       201304L
#define __cpp_lib_integer_sequence                 201304L
#define __cpp_lib_integral_constant_callable       201304L
#define __cpp_lib_is_final                         201402L
#define __cpp_lib_is_null_pointer                  201309L
#define __cpp_lib_make_reverse_iterator            201402L
#define __cpp_lib_make_unique                      201304L
#define __cpp_lib_null_iterators                   201304L
#define __cpp_lib_quoted_string_io                 201304L
#define __cpp_lib_result_of_sfinae                 201210L
#define __cpp_lib_robust_nonmodifying_seq_ops      201304L
#ifndef _M_CEE_PURE
#define __cpp_lib_shared_timed_mutex 201402L
#endif // !defined(_M_CEE_PURE)
#define __cpp_lib_string_udls                  201304L
#define __cpp_lib_transformation_trait_aliases 201304L
#define __cpp_lib_tuple_element_t              201402L
#define __cpp_lib_tuples_by_type               201304L

// C++17
#define __cpp_lib_addressof_constexpr              201603L
#define __cpp_lib_allocator_traits_is_always_equal 201411L
#define __cpp_lib_as_const                         201510L
#define __cpp_lib_bool_constant                    201505L
#define __cpp_lib_enable_shared_from_this          201603L
#define __cpp_lib_incomplete_container_elements    201505L
#define __cpp_lib_invoke                           201411L
#define __cpp_lib_logical_traits                   201510L
#define __cpp_lib_map_try_emplace                  201411L
#define __cpp_lib_nonmember_container_access       201411L
#define __cpp_lib_shared_mutex                     201505L
#define __cpp_lib_transparent_operators            201510L
#define __cpp_lib_type_trait_variable_templates    201510L
#define __cpp_lib_uncaught_exceptions              201411L
#define __cpp_lib_unordered_map_try_emplace        201411L
#define __cpp_lib_void_t                           201411L

#if _HAS_CXX17
#if _HAS_STATIC_RTTI
#define __cpp_lib_any 201606L
#endif // _HAS_STATIC_RTTI
#define __cpp_lib_apply                      201603L
#define __cpp_lib_atomic_is_always_lock_free 201603L
#define __cpp_lib_boyer_moore_searcher       201603L
#if _HAS_STD_BYTE
#define __cpp_lib_byte 201603L
#endif // _HAS_STD_BYTE
#define __cpp_lib_clamp                             201603L
#define __cpp_lib_filesystem                        201703L
#define __cpp_lib_freestanding_charconv             202306L
#define __cpp_lib_gcd_lcm                           201606L
#define __cpp_lib_hardware_interference_size        201703L
#define __cpp_lib_has_unique_object_representations 201606L
#define __cpp_lib_hypot                             201603L
#define __cpp_lib_is_aggregate                      201703L
#define __cpp_lib_is_invocable                      201703L
#define __cpp_lib_is_swappable                      201603L
#define __cpp_lib_launder                           201606L
#define __cpp_lib_make_from_tuple                   201606L
#define __cpp_lib_math_special_functions            201603L
#define __cpp_lib_memory_resource                   201603L
#define __cpp_lib_node_extract                      201606L
#define __cpp_lib_not_fn                            201603L
#ifndef _M_CEE_PURE
#define __cpp_lib_parallel_algorithm 201603L
#endif // !defined(_M_CEE_PURE)
#define __cpp_lib_raw_memory_algorithms 201606L
#define __cpp_lib_sample                201603L
#define __cpp_lib_scoped_lock           201703L
#define __cpp_lib_shared_ptr_weak_type  201606L
#define __cpp_lib_string_view           201803L
#define __cpp_lib_to_chars              201611L
#endif // _HAS_CXX17

// C++20
#define __cpp_lib_atomic_value_initialization 201911L

#ifdef __cpp_char8_t
#define __cpp_lib_char8_t 201907L
#endif // defined(__cpp_char8_t)

#ifdef __cpp_impl_coroutine
#define __cpp_lib_coroutine 201902L
#endif // defined(__cpp_impl_coroutine)

#if _HAS_CXX20
#define __cpp_lib_algorithm_iterator_requirements 202207L
#define __cpp_lib_assume_aligned                  201811L
#define __cpp_lib_atomic_flag_test                201907L
#define __cpp_lib_atomic_float                    201711L
#define __cpp_lib_atomic_lock_free_type_aliases   201907L
#define __cpp_lib_atomic_ref                      201806L
#define __cpp_lib_atomic_shared_ptr               201711L
#define __cpp_lib_atomic_wait                     201907L
#define __cpp_lib_barrier                         202302L
#define __cpp_lib_bind_front                      201907L
#define __cpp_lib_bit_cast                        201806L
#define __cpp_lib_bitops                          201907L
#define __cpp_lib_bounded_array_traits            201902L
#define __cpp_lib_common_reference                202302L
#define __cpp_lib_common_reference_wrapper        202302L
#define __cpp_lib_constexpr_algorithms            201806L
#define __cpp_lib_constexpr_complex               201711L
#define __cpp_lib_constexpr_dynamic_alloc         201907L
#define __cpp_lib_constexpr_functional            201907L
#define __cpp_lib_constexpr_iterator              201811L
#define __cpp_lib_constexpr_numeric               201911L
#define __cpp_lib_constexpr_string                201907L
#define __cpp_lib_constexpr_string_view           201811L
#define __cpp_lib_constexpr_tuple                 201811L
#define __cpp_lib_constexpr_utility               201811L
#define __cpp_lib_constexpr_vector                201907L
#define __cpp_lib_destroying_delete               201806L
#define __cpp_lib_endian                          201907L
#define __cpp_lib_erase_if                        202002L
#define __cpp_lib_format                          202304L
#define __cpp_lib_format_uchar                    202311L
#define __cpp_lib_freestanding_ranges             202306L
#define __cpp_lib_generic_unordered_lookup        201811L
#define __cpp_lib_int_pow2                        202002L
#define __cpp_lib_integer_comparison_functions    202002L
#define __cpp_lib_interpolate                     201902L
#define __cpp_lib_is_constant_evaluated           201811L

#ifndef __clang__ // TRANSITION, LLVM-48860
#define __cpp_lib_is_layout_compatible 201907L
#endif // ^^^ no workaround ^^^

#define __cpp_lib_is_nothrow_convertible 201806L

#ifndef __clang__ // TRANSITION, LLVM-48860
#define __cpp_lib_is_pointer_interconvertible 201907L
#endif // ^^^ no workaround ^^^

#define __cpp_lib_jthread                 201911L
#define __cpp_lib_latch                   201907L
#define __cpp_lib_list_remove_return_type 201806L
#define __cpp_lib_math_constants          201907L

#if !defined(__clang__) && !defined(__EDG__) // TRANSITION, Clang and EDG support for modules
#define __cpp_lib_modules 202207L
#endif // ^^^ no workaround ^^^

#define __cpp_lib_move_iterator_concept   202207L
#define __cpp_lib_polymorphic_allocator   201902L
#define __cpp_lib_remove_cvref            201711L
#define __cpp_lib_semaphore               201907L
#define __cpp_lib_smart_ptr_for_overwrite 202002L
#define __cpp_lib_source_location         201907L
#define __cpp_lib_span                    202002L
#define __cpp_lib_ssize                   201902L
#define __cpp_lib_starts_ends_with        201711L
#define __cpp_lib_syncbuf                 201803L
#define __cpp_lib_three_way_comparison    201907L
#define __cpp_lib_to_address              201711L
#define __cpp_lib_to_array                201907L
#define __cpp_lib_type_identity           201806L
#define __cpp_lib_unwrap_ref              201811L
#endif // _HAS_CXX20

// C++23
#if _HAS_CXX23
#define __cpp_lib_adaptor_iterator_pair_constructor 202106L
#define __cpp_lib_allocate_at_least                 202302L
#define __cpp_lib_associative_heterogeneous_erasure 202110L
#define __cpp_lib_bind_back                         202202L
#define __cpp_lib_byteswap                          202110L
#define __cpp_lib_constexpr_bitset                  202207L
#define __cpp_lib_constexpr_charconv                202207L
#define __cpp_lib_constexpr_typeinfo                202106L
#define __cpp_lib_containers_ranges                 202202L
#define __cpp_lib_expected                          202211L
#define __cpp_lib_formatters                        202302L
#define __cpp_lib_forward_like                      202207L
#define __cpp_lib_invoke_r                          202106L
#define __cpp_lib_ios_noreplace                     202207L
#define __cpp_lib_is_scoped_enum                    202011L
#define __cpp_lib_mdspan                            202207L
#define __cpp_lib_move_only_function                202110L
#define __cpp_lib_out_ptr                           202106L
#define __cpp_lib_print                             202207L
#define __cpp_lib_ranges_as_const                   202311L
#define __cpp_lib_ranges_as_rvalue                  202207L
#define __cpp_lib_ranges_cartesian_product          202207L
#define __cpp_lib_ranges_chunk                      202202L
#define __cpp_lib_ranges_chunk_by                   202202L
#define __cpp_lib_ranges_contains                   202207L
#define __cpp_lib_ranges_enumerate                  202302L
#define __cpp_lib_ranges_find_last                  202207L
#define __cpp_lib_ranges_fold                       202207L
#define __cpp_lib_ranges_iota                       202202L
#define __cpp_lib_ranges_join_with                  202202L
#define __cpp_lib_ranges_repeat                     202207L
#define __cpp_lib_ranges_slide                      202202L
#define __cpp_lib_ranges_starts_ends_with           202106L
#define __cpp_lib_ranges_stride                     202207L
#define __cpp_lib_ranges_to_container               202202L
#define __cpp_lib_ranges_zip                        202110L
#define __cpp_lib_spanstream                        202106L
#define __cpp_lib_stacktrace                        202011L
#define __cpp_lib_stdatomic_h                       202011L
#define __cpp_lib_string_contains                   202011L
#define __cpp_lib_string_resize_and_overwrite       202110L
#define __cpp_lib_to_underlying                     202102L
#define __cpp_lib_tuple_like                        202207L
#define __cpp_lib_unreachable                       202202L
#endif // _HAS_CXX23

// macros with language mode sensitivity
#if _HAS_CXX20
#define __cpp_lib_array_constexpr 201811L // P1032R1 Miscellaneous constexpr
#elif _HAS_CXX17
#define __cpp_lib_array_constexpr 201803L // P0858R0 Constexpr Iterator Requirements
#endif

#if _HAS_CXX20
#define __cpp_lib_chrono 201907L // P1466R3 Miscellaneous Minor Fixes For <chrono>
#elif _HAS_CXX17
#define __cpp_lib_chrono 201611L // P0505R0 constexpr For <chrono> (Again)
#else
#define __cpp_lib_chrono 201510L // P0092R1 <chrono> floor(), ceil(), round(), abs()
#endif

#if _HAS_CXX23
#define __cpp_lib_concepts 202207L // P2404R3 Move-Only Types For Comparison Concepts
#elif _HAS_CXX20
#define __cpp_lib_concepts 202002L // P1964R2 Replacing boolean With boolean-testable
#endif

#if _HAS_CXX23
#define __cpp_lib_constexpr_memory 202202L // P2273R3 constexpr unique_ptr
#elif _HAS_CXX20
#define __cpp_lib_constexpr_memory 201811L // P1006R1 constexpr For pointer_traits<T*>::pointer_to()
#endif

#ifndef _M_CEE_PURE
#if _HAS_CXX20
#define __cpp_lib_execution 201902L // P1001R2 execution::unseq
#elif _HAS_CXX17
#define __cpp_lib_execution 201603L // P0024R2 Parallel Algorithms
#endif // language mode
#endif // !defined(_M_CEE_PURE)

#if _HAS_CXX23
#define __cpp_lib_optional 202110L // P0798R8 Monadic Operations For optional
#elif _HAS_CXX20
#define __cpp_lib_optional 202106L // P2231R1 Completing constexpr In optional And variant
#elif _HAS_CXX17
#define __cpp_lib_optional 201606L // P0307R2 Making Optional Greater Equal Again
#endif

#if _HAS_CXX23
#define __cpp_lib_ranges 202302L // P2609R3 Relaxing Ranges Just A Smidge
#elif _HAS_CXX20
#define __cpp_lib_ranges 202110L // P2415R2 What Is A view?
#endif

#if _HAS_CXX20
#define __cpp_lib_shared_ptr_arrays 201707L // P0674R1 make_shared() For Arrays
#else
#define __cpp_lib_shared_ptr_arrays 201611L // P0497R0 Fixing shared_ptr For Arrays
#endif

#if _HAS_CXX23
#define __cpp_lib_shift 202202L // P2440R1 ranges::shift_left, ranges::shift_right
#elif _HAS_CXX20
#define __cpp_lib_shift 201806L // P0769R2 shift_left(), shift_right()
#endif

#if _HAS_CXX20
#define __cpp_lib_variant 202106L // P2231R1 Completing constexpr In optional And variant
#elif _HAS_CXX17
#define __cpp_lib_variant 202102L // P2162R2 Inheriting From variant
#endif

#define __cpp_lib_experimental_erase_if   201411L
#define __cpp_lib_experimental_filesystem 201406L

#ifdef _RTC_CONVERSION_CHECKS_ENABLED
#ifndef _ALLOW_RTCc_IN_STL
#error /RTCc rejects conformant code, so it is not supported by the C++ Standard Library. Either remove this \
compiler option, or define _ALLOW_RTCc_IN_STL to suppress this error.
#endif // !defined(_ALLOW_RTCc_IN_STL)
#endif // defined(_RTC_CONVERSION_CHECKS_ENABLED)

#define _EMPTY_ARGUMENT // for empty macro argument

// extern "C++" attaches declarations to the global module, see N4964 [module.unit]/7.2.
// It has no effect in C++14/17.

// In the STL's headers (which might be used to build the named module std), we unconditionally
// and directly mark declarations of our separately compiled machinery as extern "C++", allowing
// the named module to work with the separately compiled code (which is always built classically).

// TRANSITION: _USE_EXTERN_CXX_EVERYWHERE_FOR_STL controls whether we also wrap the STL's
// header-only code in this linkage-specification, as a temporary workaround to allow
// importing the named module in a translation unit with classic includes.

#ifndef _USE_EXTERN_CXX_EVERYWHERE_FOR_STL
#define _USE_EXTERN_CXX_EVERYWHERE_FOR_STL _HAS_CXX20
#endif // ^^^ !defined(_USE_EXTERN_CXX_EVERYWHERE_FOR_STL) ^^^

#if _USE_EXTERN_CXX_EVERYWHERE_FOR_STL
#define _EXTERN_CXX_WORKAROUND     extern "C++" {
#define _END_EXTERN_CXX_WORKAROUND }
#else // ^^^ _USE_EXTERN_CXX_EVERYWHERE_FOR_STL / !_USE_EXTERN_CXX_EVERYWHERE_FOR_STL vvv
#define _EXTERN_CXX_WORKAROUND
#define _END_EXTERN_CXX_WORKAROUND
#endif // ^^^ !_USE_EXTERN_CXX_EVERYWHERE_FOR_STL ^^^

#define _STD_BEGIN         \
    _EXTERN_CXX_WORKAROUND \
    namespace std {
#define _STD_END \
    }            \
    _END_EXTERN_CXX_WORKAROUND

#define _STD    ::std::
#define _CHRONO ::std::chrono::
#define _RANGES ::std::ranges::

// We use the stdext (standard extension) namespace to contain non-standard extensions
#pragma push_macro("stdext")
#undef stdext
#define _STDEXT_BEGIN      \
    _EXTERN_CXX_WORKAROUND \
    namespace stdext {
#define _STDEXT_END \
    }               \
    _END_EXTERN_CXX_WORKAROUND

#define _STDEXT ::stdext::
#pragma pop_macro("stdext")

#define _CSTD ::

#ifdef _M_CEE_PURE
#define _EXTERN_C_UNLESS_PURE
#define _END_EXTERN_C_UNLESS_PURE
#else // ^^^ defined(_M_CEE_PURE) / !defined(_M_CEE_PURE) vvv
#define _EXTERN_C_UNLESS_PURE     extern "C" {
#define _END_EXTERN_C_UNLESS_PURE } // extern "C"
#endif // ^^^ !defined(_M_CEE_PURE) ^^^

#if defined(MRTDLL) && !defined(_CRTBLD)
#error In yvals_core.h, defined(MRTDLL) implies defined(_CRTBLD); !defined(_CRTBLD) implies !defined(MRTDLL)
#endif // defined(MRTDLL) && !defined(_CRTBLD)

#if defined(MRTDLL) && !defined(_M_CEE_PURE)
#error In yvals_core.h, defined(MRTDLL) implies defined(_M_CEE_PURE); !defined(_M_CEE_PURE) implies !defined(MRTDLL)
#endif // defined(MRTDLL) && !defined(_M_CEE_PURE)

#define _STL_WIN32_WINNT_VISTA   0x0600 // _WIN32_WINNT_VISTA from sdkddkver.h
#define _STL_WIN32_WINNT_WIN7    0x0601 // _WIN32_WINNT_WIN7 from sdkddkver.h
#define _STL_WIN32_WINNT_WIN8    0x0602 // _WIN32_WINNT_WIN8 from sdkddkver.h
#define _STL_WIN32_WINNT_WINBLUE 0x0603 // _WIN32_WINNT_WINBLUE from sdkddkver.h
#define _STL_WIN32_WINNT_WIN10   0x0A00 // _WIN32_WINNT_WIN10 from sdkddkver.h

// Note that the STL DLL builds will set this to XP for ABI compatibility with VS2015 which supported XP.
#ifndef _STL_WIN32_WINNT
#if defined(_M_ARM64)
// The first ARM64 Windows was Windows 10
#define _STL_WIN32_WINNT _STL_WIN32_WINNT_WIN10
#elif defined(_M_ARM) || defined(_ONECORE) || defined(_CRT_APP)
// The first ARM or OneCore or App Windows was Windows 8
#define _STL_WIN32_WINNT _STL_WIN32_WINNT_WIN8
#else // ^^^ default to Win8 / default to Win7 vvv
// The earliest Windows supported by this implementation is Windows 7
#define _STL_WIN32_WINNT _STL_WIN32_WINNT_WIN7
#endif // ^^^ !defined(_M_ARM) && !defined(_M_ARM64) && !defined(_ONECORE) && !defined(_CRT_APP) ^^^
#endif // !defined(_STL_WIN32_WINNT)

#ifdef __cpp_noexcept_function_type
#define _NOEXCEPT_FNPTR noexcept
#else // ^^^ defined(__cpp_noexcept_function_type) / !defined(__cpp_noexcept_function_type) vvv
#define _NOEXCEPT_FNPTR
#endif // ^^^ !defined(__cpp_noexcept_function_type) ^^^

#ifdef __clang__
#define _STL_INTRIN_HEADER <intrin.h>
#define _STL_UNREACHABLE   __builtin_unreachable()
#else // ^^^ defined(__clang__) / !defined(__clang__) vvv
#define _STL_INTRIN_HEADER <intrin0.h>
#define _STL_UNREACHABLE   __assume(false)
#endif // ^^^ !defined(__clang__) ^^^

#ifdef _ENABLE_STL_INTERNAL_CHECK
#define _STL_INTERNAL_STATIC_ASSERT(...) static_assert(__VA_ARGS__, #__VA_ARGS__)
#else // ^^^ defined(_ENABLE_STL_INTERNAL_CHECK) / !defined(_ENABLE_STL_INTERNAL_CHECK) vvv
#define _STL_INTERNAL_STATIC_ASSERT(...)
#endif // ^^^ !defined(_ENABLE_STL_INTERNAL_CHECK) ^^^

#ifdef __cpp_static_call_operator
#define _STATIC_CALL_OPERATOR static
#define _CONST_CALL_OPERATOR
#else // ^^^ defined(__cpp_static_call_operator) / !defined(__cpp_static_call_operator) vvv
#define _STATIC_CALL_OPERATOR
#define _CONST_CALL_OPERATOR const
#endif // ^^^ !defined(__cpp_static_call_operator) ^^^

#endif // _STL_COMPILER_PREPROCESSOR
#endif // _YVALS_CORE_H_

#define _OSTREAM_
#define _IOS_
#ifndef _XLOCNUM_
#define _XLOCNUM_
#if _STL_COMPILER_PREPROCESSOR
// cmath standard header

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#ifndef _CMATH_
#define _CMATH_
// yvals.h internal header

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

// This header is used to compile the import library (via locale0_implib.cpp => locale0.cpp => xfacet => yvals.h).
// MAJOR LIMITATIONS apply to what can be included here!
// Before editing this file, read: /docs/import_library.md

#ifndef _YVALS
#define _YVALS
#if _STL_COMPILER_PREPROCESSOR

#ifdef _ENFORCE_ONLY_CORE_HEADERS
_EMIT_STL_ERROR(
    STL1005, "Tried to include a non-core C++ Standard Library header file with _ENFORCE_ONLY_CORE_HEADERS defined.");
#endif // defined(_ENFORCE_ONLY_CORE_HEADERS)

//
// crtdbg.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Public debugging facilities for the CRT
//
#pragma once
#ifndef _INC_CRTDBG // include guard for 3rd party interop
#define _INC_CRTDBG

//
// corecrt.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Declarations used throughout the CoreCRT library.
//
#pragma once


//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Windows API Partitioning and ARM Desktop Support
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#define _CRT_USE_WINAPI_FAMILY_DESKTOP_APP

#ifndef _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE
#define _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE 1
#endif

#ifndef _CRT_BUILD_DESKTOP_APP
#ifdef _CRT_USE_WINAPI_FAMILY_DESKTOP_APP
#define _CRT_BUILD_DESKTOP_APP 1
#else
#define _CRT_BUILD_DESKTOP_APP 0
#endif
#endif

// Verify that the ARM Desktop SDK is available when building an ARM Desktop app
#ifdef _M_ARM
#if _CRT_BUILD_DESKTOP_APP && !_ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE
#error Compiling Desktop applications for the ARM platform is not supported.
#endif
#endif

//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Warning Suppression
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

// C4412: function signature contains type '_locale_t';
//        C++ objects are unsafe to pass between pure code and mixed or native. (/Wall)
#ifndef _UCRT_DISABLED_WARNING_4412
#ifdef _M_CEE_PURE
#define _UCRT_DISABLED_WARNING_4412 4412
#else
#define _UCRT_DISABLED_WARNING_4412
#endif
#endif

// Use _UCRT_EXTRA_DISABLED_WARNINGS to add additional warning suppressions to UCRT headers.
#ifndef _UCRT_EXTRA_DISABLED_WARNINGS
#define _UCRT_EXTRA_DISABLED_WARNINGS
#endif

// C4324: structure was padded due to __declspec(align()) (/W4)
// C4514: unreferenced inline function has been removed (/Wall)
// C4574: 'MACRO' is defined to be '0': did you mean to use '#if MACRO'? (/Wall)
// C4668: '__cplusplus' is not defined as a preprocessor macro (/Wall)
// C4710: function not inlined (/Wall)
// C4793: 'function' is compiled as native code (/Wall and /W1 under /clr:pure)
// C4820: padding after data member (/Wall)
// C4995: name was marked #pragma deprecated
// C4996: __declspec(deprecated)
// C28719: Banned API, use a more robust and secure replacement.
// C28726: Banned or deprecated API, use a more robust and secure replacement.
// C28727: Banned API.
#ifndef _UCRT_DISABLED_WARNINGS
#define _UCRT_DISABLED_WARNINGS 4324 _UCRT_DISABLED_WARNING_4412 4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 _UCRT_EXTRA_DISABLED_WARNINGS
#endif

#ifndef _UCRT_DISABLE_CLANG_WARNINGS
#ifdef __clang__
// warning: declspec(deprecated) [-Wdeprecated-declarations]
// warning: __declspec attribute 'allocator' is not supported [-Wignored-attributes]
// warning: '#pragma optimize' is not supported [-Wignored-pragma-optimize]
// warning: unknown pragma ignored [-Wunknown-pragmas]
#define _UCRT_DISABLE_CLANG_WARNINGS                                  \
            _Pragma("clang diagnostic push")                                  \
            _Pragma("clang diagnostic ignored \"-Wdeprecated-declarations\"") \
            _Pragma("clang diagnostic ignored \"-Wignored-attributes\"")      \
            _Pragma("clang diagnostic ignored \"-Wignored-pragma-optimize\"") \
            _Pragma("clang diagnostic ignored \"-Wunknown-pragmas\"")
#else // __clang__
#define _UCRT_DISABLE_CLANG_WARNINGS
#endif // __clang__
#endif // _UCRT_DISABLE_CLANG_WARNINGS

#ifndef _UCRT_RESTORE_CLANG_WARNINGS
#ifdef __clang__
#define _UCRT_RESTORE_CLANG_WARNINGS _Pragma("clang diagnostic pop")
#else // __clang__
#define _UCRT_RESTORE_CLANG_WARNINGS
#endif // __clang__
#endif // _UCRT_RESTORE_CLANG_WARNINGS

#pragma warning(push)
#pragma warning(disable: _UCRT_DISABLED_WARNINGS)
_UCRT_DISABLE_CLANG_WARNINGS

_CRT_BEGIN_C_HEADER

//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Annotation Macros
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#ifndef _ACRTIMP
#if defined _CRTIMP && !defined _VCRT_DEFINED_CRTIMP
#define _ACRTIMP _CRTIMP
#elif !defined _CORECRT_BUILD && defined _DLL
#define _ACRTIMP __declspec(dllimport)
#else
#define _ACRTIMP
#endif
#endif

// If you need the ability to remove __declspec(import) from an API, to support static replacement,
// declare the API using _ACRTIMP_ALT instead of _ACRTIMP.
#ifndef _ACRTIMP_ALT
#define _ACRTIMP_ALT _ACRTIMP
#endif

#ifndef _DCRTIMP
#if defined _CRTIMP && !defined _VCRT_DEFINED_CRTIMP
#define _DCRTIMP _CRTIMP
#elif !defined _CORECRT_BUILD && defined _DLL
#define _DCRTIMP __declspec(dllimport)
#else
#define _DCRTIMP
#endif
#endif

#if defined _CRT_SUPPRESS_RESTRICT || defined _CORECRT_BUILD
#define _CRTRESTRICT
#else
#define _CRTRESTRICT __declspec(restrict)
#endif

#if defined _MSC_VER && _MSC_VER >= 1900 && !defined _CORECRT_BUILD
#define _CRTALLOCATOR __declspec(allocator)
#else
#define _CRTALLOCATOR
#endif

#if defined _M_CEE && defined _M_X64
    // This is only needed when managed code is calling the native APIs,
    // targeting the 64-bit runtime.
#define _CRT_JIT_INTRINSIC __declspec(jitintrinsic)
#else
#define _CRT_JIT_INTRINSIC
#endif

// __declspec(guard(overflow)) enabled by /sdl compiler switch for CRT allocators
#ifdef _GUARDOVERFLOW_CRT_ALLOCATORS
#define _CRT_GUARDOVERFLOW __declspec(guard(overflow))
#else
#define _CRT_GUARDOVERFLOW
#endif

#if defined _DLL && (defined _M_HYBRID || defined _M_ARM64EC) && (defined _CORECRT_BUILD || defined _VCRT_BUILD)
#define _CRT_HYBRIDPATCHABLE __declspec(hybrid_patchable)
#else
#define _CRT_HYBRIDPATCHABLE
#endif

// The CLR requires code calling other SecurityCritical code or using SecurityCritical types
// to be marked as SecurityCritical.
// _CRT_SECURITYCRITICAL_ATTRIBUTE covers this for internal function definitions.
// _CRT_INLINE_PURE_SECURITYCRITICAL_ATTRIBUTE is for inline pure functions defined in the header.
// This is clr:pure-only because for mixed mode we compile inline functions as native.
#ifdef _M_CEE_PURE
#define _CRT_INLINE_PURE_SECURITYCRITICAL_ATTRIBUTE [System::Security::SecurityCritical]
#else
#define _CRT_INLINE_PURE_SECURITYCRITICAL_ATTRIBUTE
#endif

#ifndef _CONST_RETURN
#ifdef __cplusplus
#define _CONST_RETURN const
#define _CRT_CONST_CORRECT_OVERLOADS
#else
#define _CONST_RETURN
#endif
#endif

#define _WConst_return _CONST_RETURN // For backwards compatibility

#ifndef _CRT_ALIGN
#ifdef __midl
#define _CRT_ALIGN(x)
#else
#define _CRT_ALIGN(x) __declspec(align(x))
#endif
#endif

#if defined _PREFAST_ && defined _CA_SHOULD_CHECK_RETURN
#define _Check_return_opt_ _Check_return_
#else
#define _Check_return_opt_
#endif

#if defined _PREFAST_ && defined _CA_SHOULD_CHECK_RETURN_WER
#define _Check_return_wat_ _Check_return_
#else
#define _Check_return_wat_
#endif

#if !defined __midl && !defined MIDL_PASS && defined _PREFAST_
#define __crt_typefix(ctype) __declspec("SAL_typefix(" _CRT_STRINGIZE(ctype) ")")
#else
#define __crt_typefix(ctype)
#endif

#ifndef _CRT_NOEXCEPT
#ifdef __cplusplus
#define _CRT_NOEXCEPT noexcept
#else
#define _CRT_NOEXCEPT
#endif
#endif


//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Miscellaneous Stuff
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#ifdef __cplusplus
extern "C++"
{
    template<bool _Enable, typename _Ty>
    struct _CrtEnableIf;

    template<typename _Ty>
    struct _CrtEnableIf<true, _Ty>
    {
        typedef _Ty _Type;
    };
}
#endif

#if defined __cplusplus
typedef bool  __crt_bool;
#elif defined __midl
// MIDL understands neither bool nor _Bool.  Use char as a best-fit
// replacement (the differences won't matter in practice).
typedef char __crt_bool;
#else
typedef _Bool __crt_bool;
#endif

#define _ARGMAX   100
#define _TRUNCATE ((size_t)-1)
#define _CRT_INT_MAX 2147483647
#define _CRT_SIZE_MAX ((size_t)-1)

#define __FILEW__     _CRT_WIDE(__FILE__)
#define __FUNCTIONW__ _CRT_WIDE(__FUNCTION__)

#ifdef __cplusplus
#ifndef _STATIC_ASSERT
#define _STATIC_ASSERT(expr) static_assert((expr), #expr)
#endif
#else
#ifndef _STATIC_ASSERT
#ifdef __clang__
#define _STATIC_ASSERT(expr) _Static_assert((expr), #expr)
#else
#define _STATIC_ASSERT(expr) typedef char __static_assert_t[(expr) != 0]
#endif
#endif
#endif

#ifndef NULL
#ifdef __cplusplus
#define NULL 0
#else
#define NULL ((void *)0)
#endif
#endif

// CRT headers are included into some kinds of source files where only data type
// definitions and macro definitions are required but function declarations and
// inline function definitions are not.  These files include assembly files, IDL
// files, and resource files.  The tools that process these files often have a
// limited ability to process C and C++ code.  The _CRT_FUNCTIONS_REQUIRED macro
// is defined to 1 when we are compiling a file that actually needs functions to
// be declared (and defined, where applicable), and to 0 when we are compiling a
// file that does not.  This allows us to suppress declarations and definitions
// that are not compilable with the aforementioned tools.
#if !defined _CRT_FUNCTIONS_REQUIRED
#if defined __assembler || defined __midl || defined RC_INVOKED
#define _CRT_FUNCTIONS_REQUIRED 0
#else
#define _CRT_FUNCTIONS_REQUIRED 1
#endif
#endif

#if !defined _NO_INLINING && !_CRT_FUNCTIONS_REQUIRED
#define _NO_INLINING // Suppress <tchar.h> inlines
#endif

#ifndef _CRT_UNUSED
#define _CRT_UNUSED(x) (void)x
#endif

#ifndef _CRT_HAS_CXX17
#ifdef _MSVC_LANG
#if _MSVC_LANG > 201402
#define _CRT_HAS_CXX17   1
#else /* _MSVC_LANG > 201402 */
#define _CRT_HAS_CXX17   0
#endif /* _MSVC_LANG > 201402 */
#else /* _MSVC_LANG */
#if defined __cplusplus && __cplusplus > 201402
#define _CRT_HAS_CXX17   1
#else /* __cplusplus > 201402 */
#define _CRT_HAS_CXX17   0
#endif /* __cplusplus > 201402 */
#endif /* _MSVC_LANG */
#endif /* _CRT_HAS_CXX17 */

#ifndef _CRT_HAS_C11
#if defined __STDC_VERSION__ && __STDC_VERSION__ >= 201112L
#define _CRT_HAS_C11 1
#else /* defined __STDC_VERSION__ && __STDC_VERSION__ >= 201112L */
#define _CRT_HAS_C11 0
#endif /* defined __STDC_VERSION__ && __STDC_VERSION__ >= 201112L */
#endif /* _CRT_HAS_C11 */

//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Invalid Parameter Handler
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#ifdef _DEBUG
_ACRTIMP void __cdecl _invalid_parameter(
    _In_opt_z_ wchar_t const*,
    _In_opt_z_ wchar_t const*,
    _In_opt_z_ wchar_t const*,
    _In_       unsigned int,
    _In_       uintptr_t
);
#endif

_ACRTIMP_ALT void __cdecl _invalid_parameter_noinfo(void);
_ACRTIMP __declspec(noreturn) void __cdecl _invalid_parameter_noinfo_noreturn(void);

__declspec(noreturn)
_ACRTIMP void __cdecl _invoke_watson(
    _In_opt_z_ wchar_t const* _Expression,
    _In_opt_z_ wchar_t const* _FunctionName,
    _In_opt_z_ wchar_t const* _FileName,
    _In_       unsigned int _LineNo,
    _In_       uintptr_t _Reserved);

#ifndef _CRT_SECURE_INVALID_PARAMETER
#ifdef _DEBUG
#define _CRT_SECURE_INVALID_PARAMETER(expr) \
            ::_invalid_parameter(_CRT_WIDE(#expr), __FUNCTIONW__, __FILEW__, __LINE__, 0)
#else
// By default, _CRT_SECURE_INVALID_PARAMETER in retail invokes
// _invalid_parameter_noinfo_noreturn(), which is marked
// __declspec(noreturn) and does not return control to the application.
// Even if _set_invalid_parameter_handler() is used to set a new invalid
// parameter handler which does return control to the application,
// _invalid_parameter_noinfo_noreturn() will terminate the application
// and invoke Watson. You can overwrite the definition of
// _CRT_SECURE_INVALID_PARAMETER if you need.
//
// _CRT_SECURE_INVALID_PARAMETER is used in the Standard C++ Libraries
// and the SafeInt library.
#define _CRT_SECURE_INVALID_PARAMETER(expr) \
            ::_invalid_parameter_noinfo_noreturn()
#endif
#endif



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Deprecation and Warnings
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#define _CRT_WARNING_MESSAGE(NUMBER, MESSAGE) \
    __FILE__ "(" _CRT_STRINGIZE(__LINE__) "): warning " NUMBER ": " MESSAGE

#if ( defined _CRT_DECLARE_NONSTDC_NAMES && _CRT_DECLARE_NONSTDC_NAMES) || \
    (!defined _CRT_DECLARE_NONSTDC_NAMES && !__STDC__                 )
#define _CRT_INTERNAL_NONSTDC_NAMES 1
#else
#define _CRT_INTERNAL_NONSTDC_NAMES 0
#endif

#if defined _CRT_NONSTDC_NO_DEPRECATE && !defined _CRT_NONSTDC_NO_WARNINGS
#define _CRT_NONSTDC_NO_WARNINGS
#endif

#ifndef _CRT_NONSTDC_DEPRECATE
#ifdef _CRT_NONSTDC_NO_WARNINGS
#define _CRT_NONSTDC_DEPRECATE(_NewName)
#else
#define _CRT_NONSTDC_DEPRECATE(_NewName) _CRT_DEPRECATE_TEXT(             \
            "The POSIX name for this item is deprecated. Instead, use the ISO C " \
            "and C++ conformant name: " #_NewName ". See online help for details.")
#endif
#endif



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Managed CRT Support
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#ifndef _PGLOBAL
#ifdef _M_CEE
#ifdef __cplusplus_cli
#define _PGLOBAL __declspec(process)
#else
#define _PGLOBAL
#endif
#else
#define _PGLOBAL
#endif
#endif

#ifndef _AGLOBAL
#ifdef _M_CEE
#define _AGLOBAL __declspec(appdomain)
#else
#define _AGLOBAL
#endif
#endif

#if defined _M_CEE && !defined _M_CEE_PURE
#define _M_CEE_MIXED
#endif



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// SecureCRT Configuration
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#if defined _CRTBLD || defined _CORECRT_BUILD || defined _VCRT_BUILD
    // Disable C++ overloads internally:
#define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES       0
#define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT 0
#define _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES         0
#endif

#if !_CRT_FUNCTIONS_REQUIRED
    // If we don't require function declarations at all, we need not define the
    // overloads (MIDL and RC do not need the C++ overloads).
#undef  _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES
#undef  _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT
#undef  _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES
#undef  _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY
#undef  _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY

#define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES 0
#define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT 0
#define _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES 0
#define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY 0
#define _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY 0
#endif

#define __STDC_SECURE_LIB__ 200411L
#define __GOT_SECURE_LIB__ __STDC_SECURE_LIB__ // For backwards compatibility

#ifndef __STDC_WANT_SECURE_LIB__
#define __STDC_WANT_SECURE_LIB__ 1
#endif

#if !__STDC_WANT_SECURE_LIB__ && !defined _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS
#endif

#ifndef RC_INVOKED
#if defined _CRT_SECURE_NO_DEPRECATE_GLOBALS && !defined _CRT_SECURE_NO_WARNINGS_GLOBALS
#define _CRT_SECURE_NO_WARNINGS_GLOBALS
#endif
#endif

#ifndef _CRT_INSECURE_DEPRECATE_GLOBALS
#ifdef RC_INVOKED
#define _CRT_INSECURE_DEPRECATE_GLOBALS(replacement)
#else
#ifdef _CRT_SECURE_NO_WARNINGS_GLOBALS
#define _CRT_INSECURE_DEPRECATE_GLOBALS(replacement)
#else
#define _CRT_INSECURE_DEPRECATE_GLOBALS(replacement) _CRT_INSECURE_DEPRECATE(replacement)
#endif
#endif
#endif

#if defined _CRT_MANAGED_HEAP_NO_DEPRECATE && !defined _CRT_MANAGED_HEAP_NO_WARNINGS
#define _CRT_MANAGED_HEAP_NO_WARNINGS
#endif

#define _SECURECRT_FILL_BUFFER_PATTERN 0xFE

#if defined _CRT_OBSOLETE_NO_DEPRECATE && !defined _CRT_OBSOLETE_NO_WARNINGS
#define _CRT_OBSOLETE_NO_WARNINGS
#endif

#ifndef _CRT_OBSOLETE
#ifdef _CRT_OBSOLETE_NO_WARNINGS
#define _CRT_OBSOLETE(_NewItem)
#else
#define _CRT_OBSOLETE(_NewItem) _CRT_DEPRECATE_TEXT(                   \
            "This function or variable has been superceded by newer library "  \
            "or operating system functionality. Consider using " #_NewItem " " \
            "instead. See online help for details.")
#endif
#endif

#ifndef RC_INVOKED
#ifndef _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES
#define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES 0
#else
#if !__STDC_WANT_SECURE_LIB__ && _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES
#error Cannot use Secure CRT C++ overloads when __STDC_WANT_SECURE_LIB__ is 0
#endif
#endif

#ifndef _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT
    // _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT is ignored if
    // _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES is set to 0
#define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT 0
#else
#if !__STDC_WANT_SECURE_LIB__ && _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT
#error Cannot use Secure CRT C++ overloads when __STDC_WANT_SECURE_LIB__ is 0
#endif
#endif

#ifndef _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES
#if __STDC_WANT_SECURE_LIB__
#define _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES 1
#else
#define _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES 0
#endif
#else
#if !__STDC_WANT_SECURE_LIB__ && _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES
#error Cannot use Secure CRT C++ overloads when __STDC_WANT_SECURE_LIB__ is 0
#endif
#endif

#ifndef _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY
#define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY 0
#else
#if !__STDC_WANT_SECURE_LIB__ && _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY
#error Cannot use Secure CRT C++ overloads when __STDC_WANT_SECURE_LIB__ is 0
#endif
#endif

#ifndef _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY
#define _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY 0
#else
#if !__STDC_WANT_SECURE_LIB__ && _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY
#error Cannot use Secure CRT C++ overloads when __STDC_WANT_SECURE_LIB__ is 0
#endif
#endif
#endif

#ifndef _CRT_SECURE_CPP_NOTHROW
#define _CRT_SECURE_CPP_NOTHROW throw()
#endif



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Basic Types
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
typedef int                           errno_t;
typedef unsigned short                wint_t;
typedef unsigned short                wctype_t;
typedef long                          __time32_t;
typedef __int64                       __time64_t;

typedef struct __crt_locale_data_public
{
    unsigned short const* _locale_pctype;
    _Field_range_(1, 2) int _locale_mb_cur_max;
    unsigned int _locale_lc_codepage;
} __crt_locale_data_public;

typedef struct __crt_locale_pointers
{
    struct __crt_locale_data* locinfo;
    struct __crt_multibyte_data* mbcinfo;
} __crt_locale_pointers;

typedef __crt_locale_pointers* _locale_t;

typedef struct _Mbstatet
{ // state of a multibyte translation
    unsigned long _Wchar;
    unsigned short _Byte, _State;
} _Mbstatet;

typedef _Mbstatet mbstate_t;

#if defined _USE_32BIT_TIME_T && defined _WIN64
#error You cannot use 32-bit time_t (_USE_32BIT_TIME_T) with _WIN64
#endif

#if defined _VCRT_BUILD || defined _CORECRT_BUILD
#define _CRT_NO_TIME_T
#endif

#ifndef _CRT_NO_TIME_T
#ifdef _USE_32BIT_TIME_T
typedef __time32_t time_t;
#else
typedef __time64_t time_t;
#endif
#endif

// Indicate that these common types are defined
#ifndef _TIME_T_DEFINED
#define _TIME_T_DEFINED
#endif

#if __STDC_WANT_SECURE_LIB__
typedef size_t rsize_t;
#endif




//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// C++ Secure Overload Generation Macros
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#ifndef RC_INVOKED
#if defined __cplusplus && _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES

#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(_ReturnType, _FuncName, _DstType, _Dst)     \
            extern "C++"                                                                          \
            {                                                                                     \
                template <size_t _Size>                                                           \
                inline                                                                            \
                _ReturnType __CRTDECL _FuncName(_DstType (&_Dst)[_Size]) _CRT_SECURE_CPP_NOTHROW  \
                {                                                                                 \
                    return _FuncName(_Dst, _Size);                                                \
                }                                                                                 \
            }

#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(_ReturnType, _FuncName, _DstType, _Dst, _TType1, _TArg1)   \
            extern "C++"                                                                                         \
            {                                                                                                    \
                template <size_t _Size>                                                                          \
                inline                                                                                           \
                _ReturnType __CRTDECL _FuncName(_DstType (&_Dst)[_Size], _TType1 _TArg1) _CRT_SECURE_CPP_NOTHROW \
                {                                                                                                \
                    return _FuncName(_Dst, _Size, _TArg1);                                                       \
                }                                                                                                \
            }

#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(_ReturnType, _FuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)  \
            extern "C++"                                                                                                         \
            {                                                                                                                    \
                template <size_t _Size>                                                                                          \
                inline                                                                                                           \
                _ReturnType __CRTDECL _FuncName(_DstType (&_Dst)[_Size], _TType1 _TArg1, _TType2 _TArg2) _CRT_SECURE_CPP_NOTHROW \
                {                                                                                                                \
                    return _FuncName(_Dst, _Size, _TArg1, _TArg2);                                                               \
                }                                                                                                                \
            }

#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(_ReturnType, _FuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
            extern "C++"                                                                                                                         \
            {                                                                                                                                    \
                template <size_t _Size>                                                                                                          \
                inline                                                                                                                           \
                _ReturnType __CRTDECL _FuncName(_DstType (&_Dst)[_Size], _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) _CRT_SECURE_CPP_NOTHROW \
                {                                                                                                                                \
                    return _FuncName(_Dst, _Size, _TArg1, _TArg2, _TArg3);                                                                       \
                }                                                                                                                                \
            }

#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_4(_ReturnType, _FuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3, _TType4, _TArg4) \
            extern "C++"                                                                                                                                          \
            {                                                                                                                                                     \
                template <size_t _Size>                                                                                                                           \
                inline                                                                                                                                            \
                _ReturnType __CRTDECL _FuncName(_DstType (&_Dst)[_Size], _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3, _TType4 _TArg4) _CRT_SECURE_CPP_NOTHROW  \
                {                                                                                                                                                 \
                    return _FuncName(_Dst, _Size, _TArg1, _TArg2, _TArg3, _TArg4);                                                                                \
                }                                                                                                                                                 \
            }

#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1(_ReturnType, _FuncName, _HType1, _HArg1, _DstType, _Dst, _TType1, _TArg1)  \
            extern "C++"                                                                                                         \
            {                                                                                                                    \
                template <size_t _Size>                                                                                          \
                inline                                                                                                           \
                _ReturnType __CRTDECL _FuncName(_HType1 _HArg1, _DstType (&_Dst)[_Size], _TType1 _TArg1) _CRT_SECURE_CPP_NOTHROW \
                {                                                                                                                \
                    return _FuncName(_HArg1, _Dst, _Size, _TArg1);                                                               \
                }                                                                                                                \
            }

#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_2(_ReturnType, _FuncName, _HType1, _HArg1, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
            extern "C++"                                                                                                                         \
            {                                                                                                                                    \
                template <size_t _Size>                                                                                                          \
                inline                                                                                                                           \
                _ReturnType __CRTDECL _FuncName(_HType1 _HArg1, _DstType (&_Dst)[_Size], _TType1 _TArg1, _TType2 _TArg2) _CRT_SECURE_CPP_NOTHROW \
                {                                                                                                                                \
                    return _FuncName(_HArg1, _Dst, _Size, _TArg1, _TArg2);                                                                       \
                }                                                                                                                                \
            }

#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_3(_ReturnType, _FuncName, _HType1, _HArg1, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
            extern "C++"                                                                                                                                          \
            {                                                                                                                                                     \
                template <size_t _Size>                                                                                                                           \
                inline                                                                                                                                            \
                _ReturnType __CRTDECL _FuncName(_HType1 _HArg1, _DstType (&_Dst)[_Size], _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) _CRT_SECURE_CPP_NOTHROW  \
                {                                                                                                                                                 \
                    return _FuncName(_HArg1, _Dst, _Size, _TArg1, _TArg2, _TArg3);                                                                                \
                }                                                                                                                                                 \
            }

#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_2_0(_ReturnType, _FuncName, _HType1, _HArg1, _HType2, _HArg2, _DstType, _Dst)  \
            extern "C++"                                                                                                         \
            {                                                                                                                    \
                template <size_t _Size>                                                                                          \
                inline                                                                                                           \
                _ReturnType __CRTDECL _FuncName(_HType1 _HArg1, _HType2 _HArg2, _DstType (&_Dst)[_Size]) _CRT_SECURE_CPP_NOTHROW \
                {                                                                                                                \
                    return _FuncName(_HArg1, _HArg2, _Dst, _Size);                                                               \
                }                                                                                                                \
            }

#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1_ARGLIST(_ReturnType, _FuncName, _VFuncName, _DstType, _Dst, _TType1, _TArg1) \
            extern "C++"                                                                                                           \
            {                                                                                                                      \
                template <size_t _Size>                                                                                            \
                inline                                                                                                             \
                _ReturnType __CRTDECL _FuncName(_DstType (&_Dst)[_Size], _TType1 _TArg1, ...) _CRT_SECURE_CPP_NOTHROW              \
                {                                                                                                                  \
                    va_list _ArgList;                                                                                              \
                    __crt_va_start(_ArgList, _TArg1);                                                                              \
                    return _VFuncName(_Dst, _Size, _TArg1, _ArgList);                                                              \
                }                                                                                                                  \
            }

#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2_ARGLIST(_ReturnType, _FuncName, _VFuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
            extern "C++"                                                                                                                            \
            {                                                                                                                                       \
                template <size_t _Size>                                                                                                             \
                inline                                                                                                                              \
                _ReturnType __CRTDECL _FuncName(_DstType (&_Dst)[_Size], _TType1 _TArg1, _TType2 _TArg2, ...) _CRT_SECURE_CPP_NOTHROW               \
                {                                                                                                                                   \
                    va_list _ArgList;                                                                                                               \
                    __crt_va_start(_ArgList, _TArg2);                                                                                               \
                    return _VFuncName(_Dst, _Size, _TArg1, _TArg2, _ArgList);                                                                       \
                }                                                                                                                                   \
            }

#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_SPLITPATH(_ReturnType, _FuncName, _DstType, _Src)               \
            extern "C++"                                                                                          \
            {                                                                                                     \
                template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize>                  \
                inline                                                                                            \
                _ReturnType __CRTDECL _FuncName(                                                                  \
                    _In_z_ _DstType const* _Src,                                                                  \
                    _Post_z_ _DstType (&_Drive)[_DriveSize],                                                      \
                    _Post_z_ _DstType (&_Dir)[_DirSize],                                                          \
                    _Post_z_ _DstType (&_Name)[_NameSize],                                                        \
                    _Post_z_ _DstType (&_Ext)[_ExtSize]                                                           \
                    ) _CRT_SECURE_CPP_NOTHROW                                                                     \
                {                                                                                                 \
                    return _FuncName(_Src, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize); \
                }                                                                                                 \
            }

#else  // ^^^ _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES ^^^ // vvv !_CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES vvv //

#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(_ReturnType, _FuncName, _DstType, _Dst)
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(_ReturnType, _FuncName, _DstType, _Dst, _TType1, _TArg1)
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(_ReturnType, _FuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(_ReturnType, _FuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_4(_ReturnType, _FuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3, _TType4, _TArg4)
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1(_ReturnType, _FuncName, _HType1, _HArg1, _DstType, _Dst, _TType1, _TArg1)
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_2(_ReturnType, _FuncName, _HType1, _HArg1, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_3(_ReturnType, _FuncName, _HType1, _HArg1, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_2_0(_ReturnType, _FuncName, _HType1, _HArg1, _HType2, _HArg2, _DstType, _Dst)
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1_ARGLIST(_ReturnType, _FuncName, _VFuncName, _DstType, _Dst, _TType1, _TArg1)
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2_ARGLIST(_ReturnType, _FuncName, _VFuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_SPLITPATH(_ReturnType, _FuncName, _DstType, _Src)

#endif // !_CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES
#endif



#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SalAttributeDst, _DstType, _Dst) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _SalAttributeDst, _DstType, _Dst)

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1)

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3, _TType4, _TArg4) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3, _TType4, _TArg4)

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _HType1, _HArg1, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _HType1, _HArg1, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1)

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_2_0(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _HType1, _HArg1, _HType2, _HArg2, _SalAttributeDst, _DstType, _Dst) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_2_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _HType1, _HArg1, _HType2, _HArg2, _SalAttributeDst, _DstType, _Dst)

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_ARGLIST(_ReturnType, _ReturnPolicy, _DeclSpec, _CC, _FuncName, _VFuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _CC, _FuncName, _FuncName##_s, _VFuncName, _VFuncName##_s, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1)

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_ARGLIST(_ReturnType, _ReturnPolicy, _DeclSpec, _CC, _FuncName, _VFuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _CC, _FuncName, _VFuncName, _VFuncName##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_SIZE(_DeclSpec, _FuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_SIZE_EX(_DeclSpec, _FuncName, _FuncName##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_SIZE(_DeclSpec, _FuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_SIZE_EX(_DeclSpec, _FuncName, _FuncName##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)



#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_0(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SalAttributeDst, _DstType, _Dst) \
    __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _SalAttributeDst, _DstType, _Dst)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
    __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _SalAttributeDst, _DstType, _DstType, _Dst, _TType1, _TArg1)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
    __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_4(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3, _TType4, _TArg4) \
    __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_4_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3, _TType4, _TArg4)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_1_1(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _HType1, _HArg1, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
    __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_1_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _HType1, _HArg1, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_2_0(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _HType1, _HArg1, _HType2, _HArg2, _SalAttributeDst, _DstType, _Dst) \
    __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_2_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _HType1, _HArg1, _HType2, _HArg2, _SalAttributeDst, _DstType, _Dst)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_ARGLIST(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _VFuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
    __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, __cdecl, _FuncName, _FuncName##_s, _VFuncName, _VFuncName##_s, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_SIZE(_DeclSpec, _FuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_SIZE_EX(_DeclSpec, _FuncName, _FuncName##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_SIZE(_DeclSpec, _FuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
    __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_SIZE_EX(_DeclSpec, _FuncName, _FuncName##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// C++ Standard Overload Generation Macros
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#ifndef RC_INVOKED
#if defined __cplusplus && _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES

#define __RETURN_POLICY_SAME(_FunctionCall, _Dst) return (_FunctionCall)
#define __RETURN_POLICY_DST(_FunctionCall, _Dst)  return ((_FunctionCall) == 0 ? _Dst : 0)
#define __RETURN_POLICY_VOID(_FunctionCall, _Dst) (_FunctionCall); return
#define __EMPTY_DECLSPEC

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SalAttributeDst, _DstType, _Dst) \
            __inline \
            _ReturnType __CRTDECL __insecure_##_FuncName(_SalAttributeDst _DstType *_Dst) \
            { \
                _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst); \
                return _FuncName(_Dst); \
            } \
            extern "C++" \
            { \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(_T &_Dst) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(static_cast<_DstType *>(_Dst)); \
            } \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(const _T &_Dst) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(static_cast<_DstType *>(_Dst)); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(_SalAttributeDst _DstType * &_Dst) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(_Dst); \
            } \
            template <size_t _Size> \
            inline \
            _ReturnType __CRTDECL _FuncName(_DstType (&_Dst)[_Size]) _CRT_SECURE_CPP_NOTHROW \
            { \
                _ReturnPolicy(_SecureFuncName(_Dst, _Size), _Dst); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName<1>(_DstType (&_Dst)[1]) _CRT_SECURE_CPP_NOTHROW \
            { \
                _ReturnPolicy(_SecureFuncName(_Dst, 1), _Dst); \
            } \
            }

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_CGETS(_ReturnType, _DeclSpec, _FuncName, _SalAttributeDst, _DstType, _Dst) \
            __inline \
            _ReturnType __CRTDECL __insecure_##_FuncName(_SalAttributeDst _DstType *_Dst) \
            { \
                _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst); \
                return _FuncName(_Dst); \
            } \
            extern "C++" \
            { \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_FuncName##_s) \
            _ReturnType __CRTDECL _FuncName(_T &_Dst) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(static_cast<_DstType *>(_Dst)); \
            } \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_FuncName##_s) \
            _ReturnType __CRTDECL _FuncName(const _T &_Dst) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(static_cast<_DstType *>(_Dst)); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_FuncName##_s) \
            _ReturnType __CRTDECL _FuncName(_SalAttributeDst _DstType * &_Dst) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(_Dst); \
            } \
            template <size_t _Size> \
            inline \
            _ReturnType __CRTDECL _FuncName(_DstType (&_Dst)[_Size]) _CRT_SECURE_CPP_NOTHROW \
            { \
                size_t _SizeRead = 0; \
                errno_t _Err = _FuncName##_s(_Dst + 2, (_Size - 2) < ((size_t)_Dst[0]) ? (_Size - 2) : ((size_t)_Dst[0]), &_SizeRead); \
                _Dst[1] = (_DstType)(_SizeRead); \
                return (_Err == 0 ? _Dst + 2 : 0); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_FuncName##_s) \
            _ReturnType __CRTDECL _FuncName<1>(_DstType (&_Dst)[1]) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName((_DstType *)_Dst); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_FuncName##_s) \
            _ReturnType __CRTDECL _FuncName<2>(_DstType (&_Dst)[2]) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName((_DstType *)_Dst); \
            } \
            }

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
            __inline \
            _ReturnType __CRTDECL __insecure_##_FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1) \
            { \
                _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1); \
                return _FuncName(_Dst, _TArg1); \
            } \
            extern "C++" \
            { \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(_T &_Dst, _TType1 _TArg1) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1); \
            } \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(const _T &_Dst, _TType1 _TArg1) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(_SalAttributeDst _DstType * &_Dst, _TType1 _TArg1) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(_Dst, _TArg1); \
            } \
            template <size_t _Size> \
            inline \
            _ReturnType __CRTDECL _FuncName(_SecureDstType (&_Dst)[_Size], _TType1 _TArg1) _CRT_SECURE_CPP_NOTHROW \
            { \
                _ReturnPolicy(_SecureFuncName(_Dst, _Size, _TArg1), _Dst); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName<1>(_DstType (&_Dst)[1], _TType1 _TArg1) _CRT_SECURE_CPP_NOTHROW \
            { \
                _ReturnPolicy(_SecureFuncName(_Dst, 1, _TArg1), _Dst); \
            } \
            }

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
            __inline \
            _ReturnType __CRTDECL __insecure_##_FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2) _CRT_SECURE_CPP_NOTHROW \
            { \
                _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2); \
                return _FuncName(_Dst, _TArg1, _TArg2); \
            } \
            extern "C++" \
            { \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(_T &_Dst, _TType1 _TArg1, _TType2 _TArg2) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2); \
            } \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(const _T &_Dst, _TType1 _TArg1, _TType2 _TArg2) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(_SalAttributeDst _DstType * &_Dst, _TType1 _TArg1, _TType2 _TArg2) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(_Dst, _TArg1, _TArg2); \
            } \
            template <size_t _Size> \
            inline \
            _ReturnType __CRTDECL _FuncName(_SecureDstType (&_Dst)[_Size], _TType1 _TArg1, _TType2 _TArg2) _CRT_SECURE_CPP_NOTHROW \
            { \
                _ReturnPolicy(_SecureFuncName(_Dst, _Size, _TArg1, _TArg2), _Dst); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName<1>(_DstType (&_Dst)[1], _TType1 _TArg1, _TType2 _TArg2) _CRT_SECURE_CPP_NOTHROW \
            { \
                _ReturnPolicy(_SecureFuncName(_Dst, 1, _TArg1, _TArg2), _Dst); \
            } \
            }

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
            __inline \
            _ReturnType __CRTDECL __insecure_##_FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) \
            { \
                _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3); \
                return _FuncName(_Dst, _TArg1, _TArg2, _TArg3); \
            } \
            extern "C++" \
            { \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(_T &_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2, _TArg3); \
            } \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(const _T &_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2, _TArg3); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(_SalAttributeDst _DstType * &_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(_Dst, _TArg1, _TArg2, _TArg3); \
            } \
            template <size_t _Size> \
            inline \
            _ReturnType __CRTDECL _FuncName(_SecureDstType (&_Dst)[_Size], _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) _CRT_SECURE_CPP_NOTHROW \
            { \
                _ReturnPolicy(_SecureFuncName(_Dst, _Size, _TArg1, _TArg2, _TArg3), _Dst); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName<1>(_DstType (&_Dst)[1], _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) _CRT_SECURE_CPP_NOTHROW \
            { \
                _ReturnPolicy(_SecureFuncName(_Dst, 1, _TArg1, _TArg2, _TArg3), _Dst); \
            } \
            }

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3, _TType4, _TArg4) \
            __inline \
            _ReturnType __CRTDECL __insecure_##_FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3, _TType4 _TArg4) \
            { \
                _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3, _TType4 _TArg4); \
                return _FuncName(_Dst, _TArg1, _TArg2, _TArg3, _TArg4); \
            } \
            extern "C++" \
            { \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(_T &_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3, _TType4 _TArg4) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2, _TArg3, _TArg4); \
            } \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(const _T &_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3, _TType4 _TArg4) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2, _TArg3, _TArg4); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(_SalAttributeDst _DstType * &_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3, _TType4 _TArg4) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(_Dst, _TArg1, _TArg2, _TArg3, _TArg4); \
            } \
            template <size_t _Size> \
            inline \
            _ReturnType __CRTDECL _FuncName(_DstType (&_Dst)[_Size], _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3, _TType4 _TArg4) _CRT_SECURE_CPP_NOTHROW \
            { \
                _ReturnPolicy(_SecureFuncName(_Dst, _Size, _TArg1, _TArg2, _TArg3, _TArg4), _Dst); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName<1>(_DstType (&_Dst)[1], _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3, _TType4 _TArg4) _CRT_SECURE_CPP_NOTHROW \
            { \
                _ReturnPolicy(_SecureFuncName(_Dst, 1, _TArg1, _TArg2, _TArg3, _TArg4), _Dst); \
            } \
            }

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _HType1, _HArg1, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
            __inline \
            _ReturnType __CRTDECL __insecure_##_FuncName(_HType1 _HArg1, _SalAttributeDst _DstType *_Dst, _TType1 _TArg1) \
            { \
                _ReturnType __cdecl _FuncName(_HType1 _HArg1, _SalAttributeDst _DstType *_Dst, _TType1 _TArg1); \
                return _FuncName(_HArg1, _Dst, _TArg1); \
            } \
            extern "C++" \
            { \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(_HType1 _HArg1, _T &_Dst, _TType1 _TArg1) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(_HArg1, static_cast<_DstType *>(_Dst), _TArg1); \
            } \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(_HType1 _HArg1, const _T &_Dst, _TType1 _TArg1) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(_HArg1, static_cast<_DstType *>(_Dst), _TArg1); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(_HType1 _HArg1, _SalAttributeDst _DstType * &_Dst, _TType1 _TArg1) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(_HArg1, _Dst, _TArg1); \
            } \
            template <size_t _Size> \
            inline \
            _ReturnType __CRTDECL _FuncName(_HType1 _HArg1, _DstType (&_Dst)[_Size], _TType1 _TArg1) _CRT_SECURE_CPP_NOTHROW \
            { \
                _ReturnPolicy(_SecureFuncName(_HArg1, _Dst, _Size, _TArg1), _Dst); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName<1>(_HType1 _HArg1, _DstType (&_Dst)[1], _TType1 _TArg1) _CRT_SECURE_CPP_NOTHROW \
            { \
                _ReturnPolicy(_SecureFuncName(_HArg1, _Dst, 1, _TArg1), _Dst); \
            } \
            }

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_2_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _HType1, _HArg1, _HType2, _HArg2, _SalAttributeDst, _DstType, _Dst) \
            __inline \
            _ReturnType __CRTDECL __insecure_##_FuncName(_HType1 _HArg1, _HType2 _HArg2, _SalAttributeDst _DstType *_Dst) \
            { \
                _ReturnType __cdecl _FuncName(_HType1 _HArg1, _HType2 _HArg2, _SalAttributeDst _DstType *_Dst); \
                return _FuncName(_HArg1, _HArg2, _Dst); \
            } \
            extern "C++" \
            { \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(_HType1 _HArg1, _HType2 _HArg2, _T &_Dst) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(_HArg1, _HArg2, static_cast<_DstType *>(_Dst)); \
            } \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(_HType1 _HArg1, _HType2 _HArg2, const _T &_Dst) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(_HArg1, _HArg2, static_cast<_DstType *>(_Dst)); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(_HType1 _HArg1, _HType2 _HArg2, _SalAttributeDst _DstType * &_Dst) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(_HArg1, _HArg2, _Dst); \
            } \
            template <size_t _Size> \
            inline \
            _ReturnType __CRTDECL _FuncName(_HType1 _HArg1, _HType2 _HArg2, _DstType (&_Dst)[_Size]) _CRT_SECURE_CPP_NOTHROW \
            { \
                _ReturnPolicy(_SecureFuncName(_HArg1, _HArg2, _Dst, _Size), _Dst); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName<1>(_HType1 _HArg1, _HType2 _HArg2, _DstType (&_Dst)[1]) _CRT_SECURE_CPP_NOTHROW \
            { \
                _ReturnPolicy(_SecureFuncName(_HArg1, _HArg2, _Dst, 1), _Dst); \
            } \
            }

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _CC, _FuncName, _SecureFuncName, _VFuncName, _SecureVFuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
            __inline \
            _ReturnType __CRTDECL __insecure_##_VFuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, va_list _ArgList) \
            { \
                _ReturnType _CC _VFuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, va_list _ArgList); \
                return _VFuncName(_Dst, _TArg1, _ArgList); \
            } \
            extern "C++" \
            { \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(_T &_Dst, _TType1 _TArg1, ...) _CRT_SECURE_CPP_NOTHROW \
            { \
                va_list _ArgList; \
                __crt_va_start(_ArgList, _TArg1); \
                return __insecure_##_VFuncName(static_cast<_DstType *>(_Dst), _TArg1, _ArgList); \
            } \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(const _T &_Dst, _TType1 _TArg1, ...) _CRT_SECURE_CPP_NOTHROW \
            { \
                va_list _ArgList; \
                __crt_va_start(_ArgList, _TArg1); \
                return __insecure_##_VFuncName(static_cast<_DstType *>(_Dst), _TArg1, _ArgList); \
            } \
                \
                template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(_SalAttributeDst _DstType * &_Dst, _TType1 _TArg1, ...) _CRT_SECURE_CPP_NOTHROW \
            { \
                va_list _ArgList; \
                __crt_va_start(_ArgList, _TArg1); \
                return __insecure_##_VFuncName(_Dst, _TArg1, _ArgList); \
            } \
                \
                template <size_t _Size> \
            inline \
            _ReturnType __CRTDECL _FuncName(_DstType (&_Dst)[_Size], _TType1 _TArg1, ...) _CRT_SECURE_CPP_NOTHROW \
            { \
                va_list _ArgList; \
                __crt_va_start(_ArgList, _TArg1); \
                _ReturnPolicy(_SecureVFuncName(_Dst, _Size, _TArg1, _ArgList), _Dst); \
            } \
                \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName<1>(_DstType (&_Dst)[1], _TType1 _TArg1, ...) _CRT_SECURE_CPP_NOTHROW \
            { \
                va_list _ArgList; \
                __crt_va_start(_ArgList, _TArg1); \
                _ReturnPolicy(_SecureVFuncName(_Dst, 1, _TArg1, _ArgList), _Dst); \
            } \
                \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureVFuncName) \
            _ReturnType __CRTDECL _VFuncName(_T &_Dst, _TType1 _TArg1, va_list _ArgList) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_VFuncName(static_cast<_DstType *>(_Dst), _TArg1, _ArgList); \
            } \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureVFuncName) \
            _ReturnType __CRTDECL _VFuncName(const _T &_Dst, _TType1 _TArg1, va_list _ArgList) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_VFuncName(static_cast<_DstType *>(_Dst), _TArg1, _ArgList); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureVFuncName) \
            _ReturnType __CRTDECL _VFuncName(_SalAttributeDst _DstType *&_Dst, _TType1 _TArg1, va_list _ArgList) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_VFuncName(_Dst, _TArg1, _ArgList); \
            } \
            template <size_t _Size> \
            inline \
            _ReturnType __CRTDECL _VFuncName(_DstType (&_Dst)[_Size], _TType1 _TArg1, va_list _ArgList) _CRT_SECURE_CPP_NOTHROW \
            { \
                _ReturnPolicy(_SecureVFuncName(_Dst, _Size, _TArg1, _ArgList), _Dst); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureVFuncName) \
            _ReturnType __CRTDECL _VFuncName<1>(_DstType (&_Dst)[1], _TType1 _TArg1, va_list _ArgList) _CRT_SECURE_CPP_NOTHROW \
            { \
                _ReturnPolicy(_SecureVFuncName(_Dst, 1, _TArg1, _ArgList), _Dst); \
            } \
            }

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _CC, _FuncName, _VFuncName, _SecureVFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
            __inline \
            _ReturnType __CRTDECL __insecure_##_VFuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, va_list _ArgList) \
            { \
                _ReturnType _CC _VFuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, va_list _ArgList); \
                return _VFuncName(_Dst, _TArg1, _TArg2, _ArgList); \
            } \
            extern "C++" \
            { \
            template <typename _T> \
            inline \
                _CRT_INSECURE_DEPRECATE(_FuncName##_s) \
            _ReturnType __CRTDECL _FuncName(_T &_Dst, _TType1 _TArg1, _TType2 _TArg2, ...) _CRT_SECURE_CPP_NOTHROW \
            { \
                va_list _ArgList; \
                __crt_va_start(_ArgList, _TArg2); \
                return __insecure_##_VFuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2, _ArgList); \
            } \
            template <typename _T> \
            inline \
                _CRT_INSECURE_DEPRECATE(_FuncName##_s) \
            _ReturnType __CRTDECL _FuncName(const _T &_Dst, _TType1 _TArg1, _TType2 _TArg2, ...) _CRT_SECURE_CPP_NOTHROW \
            { \
                va_list _ArgList; \
                __crt_va_start(_ArgList, _TArg2); \
                return __insecure_##_VFuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2, _ArgList); \
            } \
                \
            template <> \
            inline \
                _CRT_INSECURE_DEPRECATE(_FuncName##_s) \
            _ReturnType __CRTDECL _FuncName(_SalAttributeDst _DstType * &_Dst, _TType1 _TArg1, _TType2 _TArg2, ...) _CRT_SECURE_CPP_NOTHROW \
            { \
                va_list _ArgList; \
                __crt_va_start(_ArgList, _TArg2); \
                return __insecure_##_VFuncName(_Dst, _TArg1, _TArg2, _ArgList); \
            } \
                \
            template <size_t _Size> \
            inline \
            _ReturnType __CRTDECL _FuncName(_SecureDstType (&_Dst)[_Size], _TType1 _TArg1, _TType2 _TArg2, ...) _CRT_SECURE_CPP_NOTHROW \
            { \
                va_list _ArgList; \
                __crt_va_start(_ArgList, _TArg2); \
                _ReturnPolicy(_SecureVFuncName(_Dst, _Size, _TArg1, _TArg2, _ArgList), _Dst); \
            } \
                \
            template <> \
            inline \
                _CRT_INSECURE_DEPRECATE(_FuncName##_s) \
            _ReturnType __CRTDECL _FuncName<1>(_DstType (&_Dst)[1], _TType1 _TArg1, _TType2 _TArg2, ...) _CRT_SECURE_CPP_NOTHROW \
            { \
                va_list _ArgList; \
                __crt_va_start(_ArgList, _TArg2); \
                _ReturnPolicy(_SecureVFuncName(_Dst, 1, _TArg1, _TArg2, _ArgList), _Dst); \
            } \
                \
            template <typename _T> \
            inline \
                _CRT_INSECURE_DEPRECATE(_SecureVFuncName) \
            _ReturnType __CRTDECL _VFuncName(_T &_Dst, _TType1 _TArg1, _TType2 _TArg2, va_list _ArgList) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_VFuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2, _ArgList); \
            } \
            template <typename _T> \
            inline \
                _CRT_INSECURE_DEPRECATE(_SecureVFuncName) \
            _ReturnType __CRTDECL _VFuncName(const _T &_Dst, _TType1 _TArg1, _TType2 _TArg2, va_list _ArgList) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_VFuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2, _ArgList); \
            } \
            template <> \
            inline \
                _CRT_INSECURE_DEPRECATE(_SecureVFuncName) \
            _ReturnType __CRTDECL _VFuncName(_SalAttributeDst _DstType *&_Dst, _TType1 _TArg1, _TType2 _TArg2, va_list _ArgList) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_VFuncName(_Dst, _TArg1, _TArg2, _ArgList); \
            } \
            template <size_t _Size> \
            inline \
            _ReturnType __CRTDECL _VFuncName(_SecureDstType (&_Dst)[_Size], _TType1 _TArg1, _TType2 _TArg2, va_list _ArgList) _CRT_SECURE_CPP_NOTHROW \
            { \
                _ReturnPolicy(_SecureVFuncName(_Dst, _Size, _TArg1, _TArg2, _ArgList), _Dst); \
            } \
            template <> \
            inline \
                _CRT_INSECURE_DEPRECATE(_SecureVFuncName) \
            _ReturnType __CRTDECL _VFuncName<1>(_DstType (&_Dst)[1], _TType1 _TArg1, _TType2 _TArg2, va_list _ArgList) _CRT_SECURE_CPP_NOTHROW \
            { \
                _ReturnPolicy(_SecureVFuncName(_Dst, 1, _TArg1, _TArg2, _ArgList), _Dst); \
            } \
            }

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_SIZE_EX(_DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
            __inline \
            size_t __CRTDECL __insecure_##_FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2) \
            { \
                _DeclSpec size_t __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2); \
                return _FuncName(_Dst, _TArg1, _TArg2); \
            } \
            extern "C++" \
            { \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            size_t __CRTDECL _FuncName(_T &_Dst, _TType1 _TArg1, _TType2 _TArg2) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2); \
            } \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            size_t __CRTDECL _FuncName(const _T &_Dst, _TType1 _TArg1, _TType2 _TArg2) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            size_t __CRTDECL _FuncName(_SalAttributeDst _DstType * &_Dst, _TType1 _TArg1, _TType2 _TArg2) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(_Dst, _TArg1, _TArg2); \
            } \
            template <size_t _Size> \
            inline \
            size_t __CRTDECL _FuncName(_SecureDstType (&_Dst)[_Size], _TType1 _TArg1, _TType2 _TArg2) _CRT_SECURE_CPP_NOTHROW \
            { \
                size_t _Ret = 0; \
                _SecureFuncName(&_Ret, _Dst, _Size, _TArg1, _TArg2); \
                return (_Ret > 0 ? (_Ret - 1) : _Ret); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            size_t __CRTDECL _FuncName<1>(_DstType (&_Dst)[1], _TType1 _TArg1, _TType2 _TArg2) _CRT_SECURE_CPP_NOTHROW \
            { \
                size_t _Ret = 0; \
                _SecureFuncName(&_Ret, _Dst, 1, _TArg1, _TArg2); \
                return (_Ret > 0 ? (_Ret - 1) : _Ret); \
            } \
            }

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_SIZE_EX(_DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
            __inline \
            size_t __CRTDECL __insecure_##_FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) \
            { \
                _DeclSpec size_t __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3); \
                return _FuncName(_Dst, _TArg1, _TArg2, _TArg3); \
            } \
            extern "C++" \
            { \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            size_t __CRTDECL _FuncName(_T &_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2, _TArg3); \
            } \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            size_t __CRTDECL _FuncName(const _T &_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2, _TArg3); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            size_t __CRTDECL _FuncName(_SalAttributeDst _DstType * &_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(_Dst, _TArg1, _TArg2, _TArg3); \
            } \
            template <size_t _Size> \
            inline \
            size_t __CRTDECL _FuncName(_SecureDstType (&_Dst)[_Size], _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) _CRT_SECURE_CPP_NOTHROW \
            { \
                size_t _Ret = 0; \
                _SecureFuncName(&_Ret, _Dst, _Size, _TArg1, _TArg2, _TArg3); \
                return (_Ret > 0 ? (_Ret - 1) : _Ret); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            size_t __CRTDECL _FuncName<1>(_DstType (&_Dst)[1], _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) _CRT_SECURE_CPP_NOTHROW \
            { \
                size_t _Ret = 0; \
                _SecureFuncName(&_Ret, _Dst, 1, _TArg1, _TArg2, _TArg3); \
                return (_Ret > 0 ? (_Ret - 1) : _Ret); \
            } \
            }

#define __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_0_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst) \
            __inline \
            _ReturnType __CRTDECL __insecure_##_FuncName(_DstType *_Dst)

#define __DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_0_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst) \
            extern "C++" \
            { \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(_T &_Dst) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(static_cast<_DstType *>(_Dst)); \
            } \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(const _T &_Dst) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(static_cast<_DstType *>(_Dst)); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(_DstType * &_Dst) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(_Dst); \
            } \
            template <size_t _Size> \
            inline \
            _ReturnType __CRTDECL _FuncName(_SecureDstType (&_Dst)[_Size]) _CRT_SECURE_CPP_NOTHROW \
            { \
                _ReturnPolicy(_SecureFuncName(_Dst, _Size), _Dst); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName<1>(_DstType (&_Dst)[1]) _CRT_SECURE_CPP_NOTHROW \
            { \
                _ReturnPolicy(_SecureFuncName(_Dst, 1), _Dst); \
            } \
            }

#define __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_1_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1) \
            __inline \
            _ReturnType __CRTDECL __insecure_##_FuncName(_DstType *_Dst, _TType1 _TArg1)

#define __DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_1_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1) \
            extern "C++" \
            { \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(_T &_Dst, _TType1 _TArg1) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1); \
            } \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(const _T &_Dst, _TType1 _TArg1) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(_DstType * &_Dst, _TType1 _TArg1) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(_Dst, _TArg1); \
            } \
            template <size_t _Size> \
            inline \
            _ReturnType __CRTDECL _FuncName(_SecureDstType (&_Dst)[_Size], _TType1 _TArg1) _CRT_SECURE_CPP_NOTHROW \
            { \
                _ReturnPolicy(_SecureFuncName(_Dst, _Size, _TArg1), _Dst); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName<1>(_DstType (&_Dst)[1], _TType1 _TArg1) _CRT_SECURE_CPP_NOTHROW \
            { \
                _ReturnPolicy(_SecureFuncName(_Dst, 1, _TArg1), _Dst); \
            } \
            }

#define __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_2_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
            __inline \
            _ReturnType __CRTDECL __insecure_##_FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2)

#define __DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_2_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
            extern "C++" \
            { \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(_T &_Dst, _TType1 _TArg1, _TType2 _TArg2) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2); \
            } \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(const _T &_Dst, _TType1 _TArg1, _TType2 _TArg2) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(_SalAttributeDst _DstType * &_Dst, _TType1 _TArg1, _TType2 _TArg2) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(_Dst, _TArg1, _TArg2); \
            } \
            template <size_t _Size> \
            inline \
            _ReturnType __CRTDECL _FuncName(_SecureDstType (&_Dst)[_Size], _TType1 _TArg1, _TType2 _TArg2) _CRT_SECURE_CPP_NOTHROW \
            { \
                _ReturnPolicy(_SecureFuncName(_Dst, _Size, _TArg1, _TArg2), _Dst); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName<1>(_DstType (&_Dst)[1], _TType1 _TArg1, _TType2 _TArg2) _CRT_SECURE_CPP_NOTHROW \
            { \
                _ReturnPolicy(_SecureFuncName(_Dst, 1, _TArg1, _TArg2), _Dst); \
            } \
            }

#define __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_3_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
            __inline \
            _ReturnType __CRTDECL __insecure_##_FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3)

#define __DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_3_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
            extern "C++" \
            { \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(_T &_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2, _TArg3); \
            } \
            template <typename _T> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(const _T &_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2, _TArg3); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName(_SalAttributeDst _DstType * &_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) _CRT_SECURE_CPP_NOTHROW \
            { \
                return __insecure_##_FuncName(_Dst, _TArg1, _TArg2, _TArg3); \
            } \
            template <size_t _Size> \
            inline \
            _ReturnType __CRTDECL _FuncName(_SecureDstType (&_Dst)[_Size], _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) _CRT_SECURE_CPP_NOTHROW \
            { \
                _ReturnPolicy(_SecureFuncName(_Dst, _Size, _TArg1, _TArg2, _TArg3), _Dst); \
            } \
            template <> \
            inline \
            _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
            _ReturnType __CRTDECL _FuncName<1>(_DstType (&_Dst)[1], _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) _CRT_SECURE_CPP_NOTHROW \
            { \
                _ReturnPolicy(_SecureFuncName(_Dst, 1, _TArg1, _TArg2, _TArg3), _Dst); \
            } \
            }

#if _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SalAttributeDst, _DstType, _Dst) \
                __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SalAttributeDst, _DstType, _Dst)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_0_CGETS(_ReturnType, _DeclSpec, _FuncName, _SalAttributeDst, _DstType, _Dst) \
                __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_CGETS(_ReturnType, _DeclSpec, _FuncName, _SalAttributeDst, _DstType, _Dst)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
                __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
                __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
                __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_4_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3, _TType4) \
                __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3, _TType4)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_1_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _HType1, _HArg1, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
                __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _HType1, _HArg1, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_2_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _HType1, _HArg1, _HType2, _HArg2, _SalAttributeDst, _DstType, _Dst) \
                __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_2_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _HType1, _HArg1, _HType2, _HArg2, _SalAttributeDst, _DstType, _Dst)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _CC, _FuncName, _SecureFuncName, _VFuncName, _SecureVFuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
                __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _CC, _FuncName, _SecureFuncName, _VFuncName, _SecureVFuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_ARGLIST(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _VFuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
                __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_ARGLIST(_ReturnType, _ReturnPolicy, _DeclSpec, __cdecl, _FuncName, _VFuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _CC, _FuncName, _VFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
                __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _CC, _FuncName, _VFuncName, _VFuncName##_s, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_SIZE_EX(_DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
                __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_SIZE_EX(_DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_SIZE_EX(_DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
                __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_SIZE_EX(_DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)


#define __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_0_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst) \
                __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_0_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType _DstType, _Dst)

#define __DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_0_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst) \
                __DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_0_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst)

#define __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_1_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1) \
                __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_1_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType _DstType, _Dst, _TType1, _TArg1)

#define __DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_1_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1) \
                __DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_1_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1)

#define __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_2_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
                __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_2_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)

#define __DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_2_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
                __DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_2_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)

#define __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_3_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
                __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_3_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)

#define __DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_3_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
                __DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_3_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)

#else // ^^^ _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT ^^^ // vvv _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT vvv //

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SalAttributeDst, _DstType, _Dst) \
                    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_0_GETS(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _DstType, _Dst) \
                    _CRT_INSECURE_DEPRECATE(_FuncName##_s) _DeclSpec _ReturnType __cdecl _FuncName(_DstType *_Dst);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_4_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3, _TType4, _TArg4) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3, _TType4 _TArg4);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_1_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _HType1, _HArg1, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_HType1 _HArg1, _SalAttributeDst _DstType *_Dst, _TType1 _TArg1);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_2_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _HType1, _HArg1, _HType2, _HArg2, _SalAttributeDst, _DstType, _Dst) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_HType1 _HArg1, _HType2 _HArg2, _SalAttributeDst _DstType *_Dst);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _CC, _FuncName, _SecureFuncName,_VFuncName, _SecureVFuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType _CC _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, ...); \
                _CRT_INSECURE_DEPRECATE(_SecureVFuncName) _DeclSpec _ReturnType _CC _VFuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, va_list _Args);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_ARGLIST(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _VFuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
                _CRT_INSECURE_DEPRECATE(_FuncName##_s) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, ...); \
                _CRT_INSECURE_DEPRECATE(_VFuncName##_s) _DeclSpec _ReturnType __cdecl _VFuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, va_list _Args);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _CC, _FuncName, _VFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
                _CRT_INSECURE_DEPRECATE(_FuncName##_s) _DeclSpec _ReturnType _CC _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, ...); \
                _CRT_INSECURE_DEPRECATE(_VFuncName##_s) _DeclSpec _ReturnType _CC _VFuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, va_list _Args);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_SIZE_EX(_DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec size_t __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_SIZE_EX(_DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec size_t __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3);


#define __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_0_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
                __inline \
                _ReturnType __CRTDECL _FuncName(_DstType *_Dst)

#define __DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_0_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst)

#define __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_1_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
                __inline \
                _ReturnType __CRTDECL _FuncName(_DstType *_Dst, _TType1 _TArg1)

#define __DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_1_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1)

#define __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_2_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
                __inline \
                _ReturnType __CRTDECL _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2)

#define __DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_2_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)

#define __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_3_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
                __inline \
                _ReturnType __CRTDECL _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3)

#define __DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_3_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)

#endif // !_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT

#else  // ^^^ _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES ^^^ // vvv !_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES vvv //

#define __RETURN_POLICY_SAME(_FunctionCall)
#define __RETURN_POLICY_DST(_FunctionCall)
#define __RETURN_POLICY_VOID(_FunctionCall)
#define __EMPTY_DECLSPEC

#if _CRT_FUNCTIONS_REQUIRED

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SalAttributeDst, _DstType, _Dst) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst);

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_CGETS(_ReturnType, _DeclSpec, _FuncName, _SalAttributeDst, _DstType, _Dst) \
                _CRT_INSECURE_DEPRECATE(_FuncName##_s) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst);

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1);

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2);

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3);

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3, _TType4, _TArg4) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3, _TType4 _TArg4);

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _HType1, _HArg1, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_HType1 _HArg1, _SalAttributeDst _DstType *_Dst, _TType1 _TArg1);

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_2_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _HType1, _HArg1, _HType2, _HArg2, _SalAttributeDst, _DstType, _Dst) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_HType1 _HArg1, _HType2 _HArg2, _SalAttributeDst _DstType *_Dst);

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _CC, _FuncName, _SecureFuncName, _VFuncName, _SecureVFuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType _CC _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, ...); \
                _CRT_INSECURE_DEPRECATE(_SecureVFuncName) _DeclSpec _ReturnType _CC _VFuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, va_list _Args);

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _CC, _FuncName, _VFuncName, _SecureVFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
                _CRT_INSECURE_DEPRECATE(_FuncName##_s) _DeclSpec _ReturnType _CC _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, ...); \
                _CRT_INSECURE_DEPRECATE(_SecureVFuncName) _DeclSpec _ReturnType _CC _VFuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, va_list _Args);

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_SIZE_EX(_DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec size_t __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2);

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_SIZE_EX(_DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec size_t __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SalAttributeDst, _DstType, _Dst) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_0_GETS(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _DstType, _Dst) \
                _CRT_INSECURE_DEPRECATE(_FuncName##_s) _DeclSpec _ReturnType __cdecl _FuncName(_DstType *_Dst);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_4_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3, _TType4, _TArg4) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3, _TType4 _TArg4);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_1_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _HType1, _HArg1, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_HType1 _HArg1, _SalAttributeDst _DstType *_Dst, _TType1 _TArg1);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_2_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _HType1, _HArg1, _HType2, _HArg2, _SalAttributeDst, _DstType, _Dst) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_HType1 _HArg1, _HType2 _HArg2, _SalAttributeDst _DstType *_Dst);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _CC, _FuncName, _SecureFuncName, _VFuncName, _SecureVFuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType _CC _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, ...); \
                _CRT_INSECURE_DEPRECATE(_SecureVFuncName) _DeclSpec _ReturnType _CC _VFuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, va_list _Args);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_ARGLIST(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _VFuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
                _CRT_INSECURE_DEPRECATE(_FuncName##_s) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, ...); \
                _CRT_INSECURE_DEPRECATE(_VFuncName##_s) _DeclSpec _ReturnType __cdecl _VFuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, va_list _Args);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _CC, _FuncName, _VFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
                _CRT_INSECURE_DEPRECATE(_FuncName##_s) _DeclSpec _ReturnType _CC _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, ...); \
                _CRT_INSECURE_DEPRECATE(_VFuncName##_s) _DeclSpec _ReturnType _CC _VFuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, va_list _Args);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_SIZE_EX(_DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec size_t __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_SIZE_EX(_DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec size_t __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3);


#define __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_0_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
                __inline \
                _ReturnType __CRTDECL _FuncName(_DstType *_Dst)

#define __DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_0_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst)

#define __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_1_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
                __inline \
                _ReturnType __CRTDECL _FuncName(_DstType *_Dst, _TType1 _TArg1)

#define __DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_1_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1)

#define __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_2_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
                __inline \
                _ReturnType __CRTDECL _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2)

#define __DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_2_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)

#define __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_3_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
                __inline \
                _ReturnType __CRTDECL _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3)

#define __DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_3_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)

#define __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_0_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
                __inline \
                _ReturnType __CRTDECL _FuncName(_DstType *_Dst)

#define __DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_0_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst)

#define __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_1_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
                __inline \
                _ReturnType __CRTDECL _FuncName(_DstType *_Dst, _TType1 _TArg1)

#define __DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_1_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1)

#define __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_2_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
                __inline \
                _ReturnType __CRTDECL _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2)

#define __DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_2_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)

#define __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_3_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
                _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
                __inline \
                _ReturnType __CRTDECL _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3)

#define __DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_3_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)

#else // ^^^ _CRT_FUNCTIONS_REQUIRED ^^^ // vvv !_CRT_FUNCTIONS_REQUIRED vvv //

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_EX(...)
#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_CGETS(...)
#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_EX(...)
#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_EX(...)
#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_EX(...)
#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4_EX(...)
#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1_EX(...)
#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_2_0_EX(...)
#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_ARGLIST_EX(...)
#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_ARGLIST_EX(...)
#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_SIZE_EX(...)
#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_SIZE_EX(...)
#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_0_EX(...)
#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_0_GETS(...)
#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_EX(...)
#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_EX(...)
#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_EX(...)
#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_4_EX(...)
#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_1_1_EX(...)
#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_2_0_EX(...)
#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_ARGLIST_EX(...)
#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_ARGLIST(...)
#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_ARGLIST_EX(...)
#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_SIZE_EX(...)
#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_SIZE_EX(...)
#define __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_0_EX(...)
#define __DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_0_EX(...)
#define __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_1_EX(...)
#define __DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_1_EX(...)
#define __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_2_EX(...)
#define __DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_2_EX(...)
#define __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_3_EX(...)
#define __DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_3_EX(...)
#define __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_0_EX(...)
#define __DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_0_EX(...)
#define __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_1_EX(...)
#define __DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_1_EX(...)
#define __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_2_EX(...)
#define __DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_2_EX(...)
#define __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_3_EX(...)
#define __DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_3_EX(...)

#endif // !_CRT_FUNCTIONS_REQUIRED
#endif // !_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES
#endif

_CRT_END_C_HEADER

_UCRT_RESTORE_CLANG_WARNINGS
#pragma warning(pop) // _UCRT_DISABLED_WARNINGS

//
// vcruntime_new_debug.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Declarations and definitions of the debug operators new and delete.
//
#pragma once

//
// vcruntime_new.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Declarations and definitions of memory management functions in the VCRuntime.
//
#pragma once

#pragma warning(push)
#pragma warning(disable: _VCRUNTIME_DISABLED_WARNINGS)
#pragma warning(disable: 4985) // attributes not present on previous declaration

#ifdef __cplusplus
extern "C++" {

#pragma pack(push, _CRT_PACKING)

#pragma push_macro("new")
#undef new

#ifdef __cpp_aligned_new
    namespace std
    {
        _VCRT_EXPORT_STD enum class align_val_t : size_t {};
    }
#endif // __cpp_aligned_new

#ifndef __NOTHROW_T_DEFINED
#define __NOTHROW_T_DEFINED
    namespace std
    {
        _VCRT_EXPORT_STD struct nothrow_t {
            explicit nothrow_t() = default;
        };

        _VCRT_EXPORT_STD extern nothrow_t const nothrow;
    }
#endif

    _VCRT_EXPORT_STD _NODISCARD _Ret_notnull_ _Post_writable_byte_size_(_Size) _VCRT_ALLOCATOR
        void* __CRTDECL operator new(
            size_t _Size
            );

    _VCRT_EXPORT_STD _NODISCARD _Ret_maybenull_ _Success_(return != NULL) _Post_writable_byte_size_(_Size) _VCRT_ALLOCATOR
        void* __CRTDECL operator new(
            size_t _Size,
            ::std::nothrow_t const&
            ) noexcept;

    _VCRT_EXPORT_STD _NODISCARD _Ret_notnull_ _Post_writable_byte_size_(_Size) _VCRT_ALLOCATOR
        void* __CRTDECL operator new[](
            size_t _Size
            );

    _VCRT_EXPORT_STD _NODISCARD _Ret_maybenull_ _Success_(return != NULL) _Post_writable_byte_size_(_Size) _VCRT_ALLOCATOR
        void* __CRTDECL operator new[](
            size_t _Size,
            ::std::nothrow_t const&
            ) noexcept;

    _VCRT_EXPORT_STD void __CRTDECL operator delete(
        void* _Block
        ) noexcept;

    _VCRT_EXPORT_STD void __CRTDECL operator delete(
        void* _Block,
        ::std::nothrow_t const&
        ) noexcept;

    _VCRT_EXPORT_STD void __CRTDECL operator delete[](
        void* _Block
        ) noexcept;

    _VCRT_EXPORT_STD void __CRTDECL operator delete[](
        void* _Block,
        ::std::nothrow_t const&
        ) noexcept;

    _VCRT_EXPORT_STD void __CRTDECL operator delete(
        void* _Block,
        size_t _Size
        ) noexcept;

    _VCRT_EXPORT_STD void __CRTDECL operator delete[](
        void* _Block,
        size_t _Size
        ) noexcept;

#ifdef __cpp_aligned_new
    _VCRT_EXPORT_STD _NODISCARD _Ret_notnull_ _Post_writable_byte_size_(_Size) _VCRT_ALLOCATOR
        void* __CRTDECL operator new(
            size_t             _Size,
            ::std::align_val_t _Al
            );

    _VCRT_EXPORT_STD _NODISCARD _Ret_maybenull_ _Success_(return != NULL) _Post_writable_byte_size_(_Size) _VCRT_ALLOCATOR
        void* __CRTDECL operator new(
            size_t                  _Size,
            ::std::align_val_t      _Al,
            ::std::nothrow_t const&
            ) noexcept;


    _VCRT_EXPORT_STD _NODISCARD _Ret_notnull_ _Post_writable_byte_size_(_Size) _VCRT_ALLOCATOR
        void* __CRTDECL operator new[](
            size_t             _Size,
            ::std::align_val_t _Al
            );

    _VCRT_EXPORT_STD _NODISCARD _Ret_maybenull_ _Success_(return != NULL) _Post_writable_byte_size_(_Size) _VCRT_ALLOCATOR
        void* __CRTDECL operator new[](
            size_t                  _Size,
            ::std::align_val_t      _Al,
            ::std::nothrow_t const&
            ) noexcept;

    _VCRT_EXPORT_STD void __CRTDECL operator delete(
        void* _Block,
        ::std::align_val_t _Al
        ) noexcept;

    _VCRT_EXPORT_STD void __CRTDECL operator delete(
        void* _Block,
        ::std::align_val_t      _Al,
        ::std::nothrow_t const&
        ) noexcept;

    _VCRT_EXPORT_STD void __CRTDECL operator delete[](
        void* _Block,
        ::std::align_val_t _Al
        ) noexcept;

    _VCRT_EXPORT_STD void __CRTDECL operator delete[](
        void* _Block,
        ::std::align_val_t      _Al,
        ::std::nothrow_t const&
        ) noexcept;

    _VCRT_EXPORT_STD void __CRTDECL operator delete(
        void* _Block,
        size_t             _Size,
        ::std::align_val_t _Al
        ) noexcept;

    _VCRT_EXPORT_STD void __CRTDECL operator delete[](
        void* _Block,
        size_t             _Size,
        ::std::align_val_t _Al
        ) noexcept;
#endif // __cpp_aligned_new

#pragma warning(push)
#pragma warning(disable: 4577) // 'noexcept' used with no exception handling mode specified
#pragma warning(disable: 4514) // 'operator new': unreferenced inline function has been removed
#ifndef __PLACEMENT_NEW_INLINE
#define __PLACEMENT_NEW_INLINE
    _VCRT_EXPORT_STD _NODISCARD _MSVC_CONSTEXPR _Ret_notnull_ _Post_writable_byte_size_(_Size) _Post_satisfies_(return == _Where)
        inline void* __CRTDECL operator new(size_t _Size,
            _Writable_bytes_(_Size) void* _Where) noexcept
    {
        (void)_Size;
        return _Where;
    }

    _VCRT_EXPORT_STD inline void __CRTDECL operator delete(void*, void*) noexcept
    {
        return;
    }
#endif

#ifndef __PLACEMENT_VEC_NEW_INLINE
#define __PLACEMENT_VEC_NEW_INLINE
    _VCRT_EXPORT_STD _NODISCARD _Ret_notnull_ _Post_writable_byte_size_(_Size) _Post_satisfies_(return == _Where)
        inline void* __CRTDECL operator new[](size_t _Size,
            _Writable_bytes_(_Size) void* _Where) noexcept
    {
        (void)_Size;
        return _Where;
    }

    _VCRT_EXPORT_STD inline void __CRTDECL operator delete[](void*, void*) noexcept
    {
    }
#endif
#pragma warning(pop)

#pragma pop_macro("new")

#pragma pack(pop)

} // extern "C++"
#endif // __cplusplus

#pragma warning(pop) // _VCRUNTIME_DISABLED_WARNINGS


#pragma warning(push)
#pragma warning(disable: _VCRUNTIME_DISABLED_WARNINGS)

#ifdef __cplusplus
extern "C++" {

#pragma pack(push, _CRT_PACKING)

#pragma push_macro("new")
#undef new

#ifndef _MFC_OVERRIDES_NEW

    _NODISCARD _Check_return_ _Ret_notnull_ _Post_writable_byte_size_(_Size)
        _VCRT_ALLOCATOR void* __CRTDECL operator new(
            _In_   size_t      _Size,
            _In_   int         _BlockUse,
            _In_z_ char const* _FileName,
            _In_   int         _LineNumber
            );

    _NODISCARD _Check_return_ _Ret_notnull_ _Post_writable_byte_size_(_Size)
        _VCRT_ALLOCATOR void* __CRTDECL operator new[](
            _In_   size_t      _Size,
            _In_   int         _BlockUse,
            _In_z_ char const* _FileName,
            _In_   int         _LineNumber
            );

    void __CRTDECL operator delete(
        void* _Block,
        int         _BlockUse,
        char const* _FileName,
        int         _LineNumber
        ) noexcept;

    void __CRTDECL operator delete[](
        void* _Block,
        int         _BlockUse,
        char const* _FileName,
        int         _LineNumber
        ) noexcept;

#endif

#pragma pop_macro("new")

#pragma pack(pop)

} // extern "C++"
#endif // __cplusplus

#pragma warning(pop) // _VCRUNTIME_DISABLED_WARNINGS


#pragma warning(push)
#pragma warning(disable: _UCRT_DISABLED_WARNINGS)
_UCRT_DISABLE_CLANG_WARNINGS

_CRT_BEGIN_C_HEADER



typedef void* _HFILE; // file handle pointer

#define _CRT_WARN           0
#define _CRT_ERROR          1
#define _CRT_ASSERT         2
#define _CRT_ERRCNT         3

#define _CRTDBG_MODE_FILE      0x1
#define _CRTDBG_MODE_DEBUG     0x2
#define _CRTDBG_MODE_WNDW      0x4
#define _CRTDBG_REPORT_MODE    -1

#define _CRTDBG_INVALID_HFILE ((_HFILE)(intptr_t)-1)
#define _CRTDBG_HFILE_ERROR   ((_HFILE)(intptr_t)-2)
#define _CRTDBG_FILE_STDOUT   ((_HFILE)(intptr_t)-4)
#define _CRTDBG_FILE_STDERR   ((_HFILE)(intptr_t)-5)
#define _CRTDBG_REPORT_FILE   ((_HFILE)(intptr_t)-6)



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Client-defined reporting and allocation hooks
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

typedef int (__CRTDECL* _CRT_REPORT_HOOK)(int, char*, int*);
typedef int (__CRTDECL* _CRT_REPORT_HOOKW)(int, wchar_t*, int*);

#define _CRT_RPTHOOK_INSTALL  0
#define _CRT_RPTHOOK_REMOVE   1


typedef int (__CRTDECL* _CRT_ALLOC_HOOK)(int, void*, size_t, int, long, unsigned char const*, int);

#ifdef _M_CEE
typedef int(__clrcall* _CRT_ALLOC_HOOK_M)(int, void*, size_t, int, long, unsigned char const*, int);
#endif

#define _HOOK_ALLOC     1
#define _HOOK_REALLOC   2
#define _HOOK_FREE      3



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Memory Management and State Tracking
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

// Bit values for _crtDbgFlag flag. These bitflags control debug heap behavior.
#define _CRTDBG_ALLOC_MEM_DF        0x01  // Turn on debug allocation
#define _CRTDBG_DELAY_FREE_MEM_DF   0x02  // Don't actually free memory
#define _CRTDBG_CHECK_ALWAYS_DF     0x04  // Check heap every alloc/dealloc
#define _CRTDBG_RESERVED_DF         0x08  // Reserved - do not use
#define _CRTDBG_CHECK_CRT_DF        0x10  // Leak check/diff CRT blocks
#define _CRTDBG_LEAK_CHECK_DF       0x20  // Leak check at program exit

// Some bit values for _crtDbgFlag which correspond to frequencies for checking
// the heap.
#define _CRTDBG_CHECK_EVERY_16_DF   0x00100000 // Check heap every 16 heap ops
#define _CRTDBG_CHECK_EVERY_128_DF  0x00800000 // Check heap every 128 heap ops
#define _CRTDBG_CHECK_EVERY_1024_DF 0x04000000 // Check heap every 1024 heap ops

// We do not check the heap by default at this point because the cost was too
// high for some applications. You can still turn this feature on manually.
#define _CRTDBG_CHECK_DEFAULT_DF    0

#define _CRTDBG_REPORT_FLAG         -1 // Query bitflag status

#define _BLOCK_TYPE(block)          (block & 0xFFFF)
#define _BLOCK_SUBTYPE(block)       (block >> 16 & 0xFFFF)

// Memory block identification
#define _FREE_BLOCK      0
#define _NORMAL_BLOCK    1
#define _CRT_BLOCK       2
#define _IGNORE_BLOCK    3
#define _CLIENT_BLOCK    4
#define _MAX_BLOCKS      5

// _UNKNOWN_BLOCK is a sentinel value that may be passed to some functions that
// expect a block type as an argument.  If this value is passed, those functions
// will use the block type specified in the block header instead.  This is used
// in cases where the heap lock cannot be acquired to compute the block type
// before calling the function (e.g. when the caller is outside of the CoreCRT).
#define _UNKNOWN_BLOCK (-1)

typedef void (__CRTDECL* _CRT_DUMP_CLIENT)(void*, size_t);

#ifdef _M_CEE
typedef void(__clrcall* _CRT_DUMP_CLIENT_M)(void*, size_t);
#endif

struct _CrtMemBlockHeader;

typedef struct _CrtMemState
{
    struct _CrtMemBlockHeader* pBlockHeader;
    size_t lCounts[_MAX_BLOCKS];
    size_t lSizes[_MAX_BLOCKS];
    size_t lHighWaterCount;
    size_t lTotalCount;
} _CrtMemState;

#ifndef _DEBUG

#define _CrtGetAllocHook()                  ((_CRT_ALLOC_HOOK)0)
#define _CrtSetAllocHook(f)                 ((_CRT_ALLOC_HOOK)0)

#define _CrtGetDumpClient()                 ((_CRT_DUMP_CLIENT)0)
#define _CrtSetDumpClient(f)                ((_CRT_DUMP_CLIENT)0)

#define _CrtCheckMemory()                   ((int)1)
#define _CrtDoForAllClientObjects(f, c)     ((void)0)
#define _CrtDumpMemoryLeaks()               ((int)0)
#define _CrtIsMemoryBlock(p, t, r, f, l)    ((int)1)
#define _CrtIsValidHeapPointer(p)           ((int)1)
#define _CrtIsValidPointer(p, n, r)         ((int)1)
#define _CrtMemCheckpoint(s)                ((void)0)
#define _CrtMemDifference(s1, s2, s3)       ((int)0)
#define _CrtMemDumpAllObjectsSince(s)       ((void)0)
#define _CrtMemDumpStatistics(s)            ((void)0)
#define _CrtReportBlockType(p)              ((int)-1)
#define _CrtSetBreakAlloc(a)                ((long)0)
#define _CrtSetDbgFlag(f)                   ((int)0)


#else // ^^^ !_DEBUG ^^^ // vvv _DEBUG vvv //

#ifndef _M_CEE_PURE

_ACRTIMP int* __cdecl __p__crtDbgFlag(void);
_ACRTIMP long* __cdecl __p__crtBreakAlloc(void);

#define _crtDbgFlag    (*__p__crtDbgFlag())
#define _crtBreakAlloc (*__p__crtBreakAlloc())

_ACRTIMP _CRT_ALLOC_HOOK __cdecl _CrtGetAllocHook(void);

_ACRTIMP _CRT_ALLOC_HOOK __cdecl _CrtSetAllocHook(
    _In_opt_ _CRT_ALLOC_HOOK _PfnNewHook
);

_ACRTIMP _CRT_DUMP_CLIENT __cdecl _CrtGetDumpClient(void);

_ACRTIMP _CRT_DUMP_CLIENT __cdecl _CrtSetDumpClient(
    _In_opt_ _CRT_DUMP_CLIENT _PFnNewDump
);

#endif // _M_CEE_PURE

_ACRTIMP int __cdecl _CrtCheckMemory(void);

typedef void(__cdecl* _CrtDoForAllClientObjectsCallback)(void*, void*);

_ACRTIMP void __cdecl _CrtDoForAllClientObjects(
    _In_ _CrtDoForAllClientObjectsCallback _Callback,
    _In_ void* _Context
);

_ACRTIMP int __cdecl _CrtDumpMemoryLeaks(void);

_ACRTIMP int __cdecl _CrtIsMemoryBlock(
    _In_opt_  void const* _Block,
    _In_      unsigned int _Size,
    _Out_opt_ long* _RequestNumber,
    _Out_opt_ char** _FileName,
    _Out_opt_ int* _LineNumber
);

_Check_return_
_ACRTIMP int __cdecl _CrtIsValidHeapPointer(
    _In_opt_ void const* _Pointer
);

_Check_return_
_ACRTIMP int __cdecl _CrtIsValidPointer(
    _In_opt_ void const* _Pointer,
    _In_     unsigned int _Size,
    _In_     int          _ReadWrite
);

_ACRTIMP void __cdecl _CrtMemCheckpoint(
    _Out_ _CrtMemState* _State
);

_ACRTIMP int __cdecl _CrtMemDifference(
    _Out_ _CrtMemState* _State,
    _In_  _CrtMemState const* _OldState,
    _In_  _CrtMemState const* _NewState
);

_ACRTIMP void __cdecl _CrtMemDumpAllObjectsSince(
    _In_opt_ _CrtMemState const* _State
);

_ACRTIMP void __cdecl _CrtMemDumpStatistics(
    _In_ _CrtMemState const* _State
);

_Check_return_
_ACRTIMP int __cdecl _CrtReportBlockType(
    _In_opt_ void const* _Block
);

_ACRTIMP long __cdecl _CrtSetBreakAlloc(
    _In_ long _NewValue
);

_ACRTIMP int __cdecl _CrtSetDbgFlag(
    _In_ int _NewFlag
);

#endif // _DEBUG



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Debug Heap Routines
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#ifndef _DEBUG

#define _calloc_dbg(c, s, t, f, l)      calloc(c, s)
#define _expand_dbg(p, s, t, f, l)      _expand(p, s)
#define _free_dbg(p, t)                 free(p)
#define _malloc_dbg(s, t, f, l)         malloc(s)
#define _msize_dbg(p, t)                _msize(p)
#define _realloc_dbg(p, s, t, f, l)     realloc(p, s)
#define _recalloc_dbg(p, c, s, t, f, l) _recalloc(p, c, s)

#define _aligned_free_dbg(p)                              _aligned_free(p)
#define _aligned_malloc_dbg(s, a, f, l)                   _aligned_malloc(s, a)
#define _aligned_msize_dbg(p, a, o)                       _aligned_msize(p, a, o)
#define _aligned_offset_malloc_dbg(s, a, o, f, l)         _aligned_offset_malloc(s, a, o)
#define _aligned_offset_realloc_dbg(p, s, a, o, f, l)     _aligned_offset_realloc(p, s, a, o)
#define _aligned_offset_recalloc_dbg(p, c, s, a, o, f, l) _aligned_offset_recalloc(p, c, s, a, o)
#define _aligned_realloc_dbg(p, s, a, f, l)               _aligned_realloc(p, s, a)
#define _aligned_recalloc_dbg(p, c, s, a, f, l)           _aligned_recalloc(p, c, s, a)

#define _freea_dbg(p, t)         _freea(p)
#define _malloca_dbg(s, t, f, l) _malloca(s)

#define _dupenv_s_dbg(ps1, size, s2, t, f, l)  _dupenv_s(ps1, size, s2)
#define _fullpath_dbg(s1, s2, le, t, f, l)     _fullpath(s1, s2, le)
#define _getcwd_dbg(s, le, t, f, l)            _getcwd(s, le)
#define _getdcwd_dbg(d, s, le, t, f, l)        _getdcwd(d, s, le)
#define _getdcwd_lk_dbg(d, s, le, t, f, l)     _getdcwd(d, s, le)
#define _mbsdup_dbg(s, t, f, l)                _mbsdup(s)
#define _strdup_dbg(s, t, f, l)                _strdup(s)
#define _tempnam_dbg(s1, s2, t, f, l)          _tempnam(s1, s2)
#define _wcsdup_dbg(s, t, f, l)                _wcsdup(s)
#define _wdupenv_s_dbg(ps1, size, s2, t, f, l) _wdupenv_s(ps1, size, s2)
#define _wfullpath_dbg(s1, s2, le, t, f, l)    _wfullpath(s1, s2, le)
#define _wgetcwd_dbg(s, le, t, f, l)           _wgetcwd(s, le)
#define _wgetdcwd_dbg(d, s, le, t, f, l)       _wgetdcwd(d, s, le)
#define _wgetdcwd_lk_dbg(d, s, le, t, f, l)    _wgetdcwd(d, s, le)
#define _wtempnam_dbg(s1, s2, t, f, l)         _wtempnam(s1, s2)

#else // ^^^ !_DEBUG ^^^ // vvv _DEBUG vvv //

#ifdef _CRTDBG_MAP_ALLOC

#define calloc(c, s)       _calloc_dbg(c, s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define _expand(p, s)      _expand_dbg(p, s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define free(p)            _free_dbg(p, _NORMAL_BLOCK)
#define malloc(s)          _malloc_dbg(s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define _msize(p)          _msize_dbg(p, _NORMAL_BLOCK)
#define realloc(p, s)      _realloc_dbg(p, s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define _recalloc(p, c, s) _recalloc_dbg(p, c, s, _NORMAL_BLOCK, __FILE__, __LINE__)

#define _aligned_free(p)                        _aligned_free_dbg(p)
#define _aligned_malloc(s, a)                   _aligned_malloc_dbg(s, a, __FILE__, __LINE__)
#define _aligned_msize(p, a, o)                 _aligned_msize_dbg(p, a, o)
#define _aligned_offset_malloc(s, a, o)         _aligned_offset_malloc_dbg(s, a, o, __FILE__, __LINE__)
#define _aligned_offset_realloc(p, s, a, o)     _aligned_offset_realloc_dbg(p, s, a, o, __FILE__, __LINE__)
#define _aligned_offset_recalloc(p, c, s, a, o) _aligned_offset_recalloc_dbg(p, c, s, a, o, __FILE__, __LINE__)
#define _aligned_realloc(p, s, a)               _aligned_realloc_dbg(p, s, a, __FILE__, __LINE__)
#define _aligned_recalloc(p, c, s, a)           _aligned_recalloc_dbg(p, c, s, a, __FILE__, __LINE__)

#define _freea(p)   _freea_dbg(p, _NORMAL_BLOCK)
#define _malloca(s) _malloca_dbg(s, _NORMAL_BLOCK, __FILE__, __LINE__)

#define _dupenv_s(ps1, size, s2)  _dupenv_s_dbg(ps1, size, s2, _NORMAL_BLOCK, __FILE__, __LINE__)
#define _fullpath(s1, s2, le)     _fullpath_dbg(s1, s2, le, _NORMAL_BLOCK, __FILE__, __LINE__)
#define _getcwd(s, le)            _getcwd_dbg(s, le, _NORMAL_BLOCK, __FILE__, __LINE__)
#define _getdcwd(d, s, le)        _getdcwd_dbg(d, s, le, _NORMAL_BLOCK, __FILE__, __LINE__)
#define _mbsdup(s)                _strdup_dbg(s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define _strdup(s)                _strdup_dbg(s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define _tempnam(s1, s2)          _tempnam_dbg(s1, s2, _NORMAL_BLOCK, __FILE__, __LINE__)
#define _wcsdup(s)                _wcsdup_dbg(s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define _wdupenv_s(ps1, size, s2) _wdupenv_s_dbg(ps1, size, s2, _NORMAL_BLOCK, __FILE__, __LINE__)
#define _wfullpath(s1, s2, le)    _wfullpath_dbg(s1, s2, le, _NORMAL_BLOCK, __FILE__, __LINE__)
#define _wgetcwd(s, le)           _wgetcwd_dbg(s, le, _NORMAL_BLOCK, __FILE__, __LINE__)
#define _wgetdcwd(d, s, le)       _wgetdcwd_dbg(d, s, le, _NORMAL_BLOCK, __FILE__, __LINE__)
#define _wtempnam(s1, s2)         _wtempnam_dbg(s1, s2, _NORMAL_BLOCK, __FILE__, __LINE__)

#if defined(_CRT_INTERNAL_NONSTDC_NAMES) && _CRT_INTERNAL_NONSTDC_NAMES
#define   strdup(s)          _strdup_dbg(s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   wcsdup(s)          _wcsdup_dbg(s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   tempnam(s1, s2)    _tempnam_dbg(s1, s2, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   getcwd(s, le)      _getcwd_dbg(s, le, _NORMAL_BLOCK, __FILE__, __LINE__)
#endif

#endif // _CRTDBG_MAP_ALLOC

_ACRTIMP void __cdecl _aligned_free_dbg(
    _Pre_maybenull_ _Post_invalid_ void* _Block
);

_Check_return_ _Ret_maybenull_ _Post_writable_byte_size_(_Size)
_ACRTIMP _CRTALLOCATOR void* __cdecl _aligned_malloc_dbg(
    _In_       size_t      _Size,
    _In_       size_t      _Alignment,
    _In_opt_z_ char const* _FileName,
    _In_       int         _LineNumber
);

_ACRTIMP size_t __cdecl _aligned_msize_dbg(
    _Pre_notnull_ void* _Block,
    _In_          size_t _Alignment,
    _In_          size_t _Offset
);

_Check_return_ _Ret_maybenull_ _Post_writable_byte_size_(_Size)
_ACRTIMP _CRTALLOCATOR void* __cdecl _aligned_offset_malloc_dbg(
    _In_       size_t      _Size,
    _In_       size_t      _Alignment,
    _In_       size_t      _Offset,
    _In_opt_z_ char const* _FileName,
    _In_       int         _LineNumber
);

_Success_(return != 0) _Check_return_ _Ret_maybenull_ _Post_writable_byte_size_(_Size)
_ACRTIMP _CRTALLOCATOR void* __cdecl _aligned_offset_realloc_dbg(
    _Pre_maybenull_ _Post_invalid_ void* _Block,
    _In_                           size_t      _Size,
    _In_                           size_t      _Alignment,
    _In_                           size_t      _Offset,
    _In_opt_z_                     char const* _FileName,
    _In_                           int         _LineNumber
);

_Success_(return != 0) _Check_return_ _Ret_maybenull_ _Post_writable_byte_size_(_Count * _Size)
_ACRTIMP _CRTALLOCATOR void* __cdecl _aligned_offset_recalloc_dbg(
    _Pre_maybenull_ _Post_invalid_ void* _Block,
    _In_                           size_t      _Count,
    _In_                           size_t      _Size,
    _In_                           size_t      _Alignment,
    _In_                           size_t      _Offset,
    _In_opt_z_                     char const* _FileName,
    _In_                           int         _LineNumber
);

_Success_(return != 0) _Check_return_ _Ret_maybenull_ _Post_writable_byte_size_(_Size)
_ACRTIMP _CRTALLOCATOR void* __cdecl _aligned_realloc_dbg(
    _Pre_maybenull_ _Post_invalid_ void* _Block,
    _In_                           size_t      _Size,
    _In_                           size_t      _Alignment,
    _In_opt_z_                     char const* _FileName,
    _In_                           int         _LineNumber
);

_Success_(return != 0) _Check_return_ _Ret_maybenull_ _Post_writable_byte_size_(_Count * _Size)
_ACRTIMP _CRTALLOCATOR void* __cdecl _aligned_recalloc_dbg(
    _Pre_maybenull_ _Post_invalid_ void* _Block,
    _In_                           size_t      _Count,
    _In_                           size_t      _Size,
    _In_                           size_t      _Alignment,
    _In_opt_z_                     char const* _FileName,
    _In_                           int         _LineNumber
);

_Check_return_ _Ret_maybenull_ _Post_writable_byte_size_(_Count * _Size)
_ACRTIMP _CRTALLOCATOR void* __cdecl _calloc_dbg(
    _In_       size_t      _Count,
    _In_       size_t      _Size,
    _In_       int         _BlockUse,
    _In_opt_z_ char const* _FileName,
    _In_       int         _LineNumber
);

_Check_return_ _Ret_maybenull_ _Post_writable_byte_size_(_Size)
_ACRTIMP _CRTALLOCATOR void* __cdecl _expand_dbg(
    _Pre_notnull_ void* _Block,
    _In_          size_t      _Size,
    _In_          int         _BlockUse,
    _In_opt_z_    char const* _FileName,
    _In_          int         _LineNumber
);

_ACRTIMP void __cdecl _free_dbg(
    _Pre_maybenull_ _Post_invalid_ void* _Block,
    _In_                           int   _BlockUse
);

_Check_return_ _Ret_maybenull_ _Post_writable_byte_size_(_Size)
_ACRTIMP _CRTALLOCATOR void* __cdecl _malloc_dbg(
    _In_       size_t      _Size,
    _In_       int         _BlockUse,
    _In_opt_z_ char const* _FileName,
    _In_       int         _LineNumber
);

_ACRTIMP size_t __cdecl _msize_dbg(
    _Pre_notnull_ void* _Block,
    _In_          int   _BlockUse
);

_Success_(return != 0) _Check_return_ _Ret_maybenull_ _Post_writable_byte_size_(_Size)
_ACRTIMP _CRTALLOCATOR void* __cdecl _realloc_dbg(
    _Pre_maybenull_ _Post_invalid_ void* _Block,
    _In_                           size_t      _Size,
    _In_                           int         _BlockUse,
    _In_opt_z_                     char const* _FileName,
    _In_                           int         _LineNumber
);

_Success_(return != 0) _Check_return_ _Ret_maybenull_ _Post_writable_byte_size_(_Count * _Size)
_ACRTIMP _CRTALLOCATOR void* __cdecl _recalloc_dbg(
    _Pre_maybenull_ _Post_invalid_ void* _Block,
    _In_                           size_t      _Count,
    _In_                           size_t      _Size,
    _In_                           int         _BlockUse,
    _In_opt_z_                     char const* _FileName,
    _In_                           int         _LineNumber
);

_Success_(return == 0)
_Check_return_wat_
_DCRTIMP errno_t __cdecl _dupenv_s_dbg(
    _Outptr_result_buffer_maybenull_(*_PBufferSizeInBytes) char** _PBuffer,
    _Out_opt_                      size_t * _PBufferSizeInBytes,
    _In_z_                         char const* _VarName,
    _In_                           int          _BlockType,
    _In_opt_z_                     char const* _FileName,
    _In_                           int          _LineNumber
);

_Success_(return != 0)
_Check_return_ _Ret_maybenull_z_
_ACRTIMP _CRTALLOCATOR char* __cdecl _fullpath_dbg(
    _Out_writes_opt_z_(_SizeInBytes) char* _FullPath,
    _In_z_                           char const* _Path,
    _In_                             size_t      _SizeInBytes,
    _In_                             int         _BlockType,
    _In_opt_z_                       char const* _FileName,
    _In_                             int         _LineNumber
);

_Success_(return != 0)
_Check_return_ _Ret_maybenull_z_
_DCRTIMP _CRTALLOCATOR char* __cdecl _getcwd_dbg(
    _Out_writes_opt_z_(_SizeInBytes) char* _DstBuf,
    _In_                             int         _SizeInBytes,
    _In_                             int         _BlockType,
    _In_opt_z_                       char const* _FileName,
    _In_                             int         _LineNumber
);


_Success_(return != 0)
_Check_return_ _Ret_maybenull_z_
_DCRTIMP _CRTALLOCATOR char* __cdecl _getdcwd_dbg(
    _In_                             int         _Drive,
    _Out_writes_opt_z_(_SizeInBytes) char* _DstBuf,
    _In_                             int         _SizeInBytes,
    _In_                             int         _BlockType,
    _In_opt_z_                       char const* _FileName,
    _In_                             int         _LineNumber
);

_Check_return_ _Ret_maybenull_z_
_ACRTIMP _CRTALLOCATOR char* __cdecl _strdup_dbg(
    _In_opt_z_ char const* _String,
    _In_       int         _BlockUse,
    _In_opt_z_ char const* _FileName,
    _In_       int         _LineNumber
);

_Check_return_ _Ret_maybenull_z_
_ACRTIMP _CRTALLOCATOR char* __cdecl _tempnam_dbg(
    _In_opt_z_ char const* _DirName,
    _In_opt_z_ char const* _FilePrefix,
    _In_       int         _BlockType,
    _In_opt_z_ char const* _FileName,
    _In_       int         _LineNumber
);

_Success_(return != 0)
_Check_return_ _Ret_maybenull_z_
_ACRTIMP _CRTALLOCATOR wchar_t* __cdecl _wcsdup_dbg(
    _In_opt_z_ wchar_t const* _String,
    _In_       int            _BlockUse,
    _In_opt_z_ char const* _FileName,
    _In_       int            _LineNumber
);

_Success_(return == 0)
_Check_return_wat_
_DCRTIMP errno_t __cdecl _wdupenv_s_dbg(
    _Outptr_result_buffer_maybenull_(*_PBufferSizeInWords) wchar_t** _PBuffer,
    _Out_opt_                        size_t * _PBufferSizeInWords,
    _In_z_                           wchar_t const* _VarName,
    _In_                             int             _BlockType,
    _In_opt_z_                       char const* _FileName,
    _In_                             int             _LineNumber
);

_Success_(return != 0)
_Check_return_ _Ret_maybenull_z_
_ACRTIMP _CRTALLOCATOR wchar_t* __cdecl _wfullpath_dbg(
    _Out_writes_opt_z_(_SizeInWords) wchar_t* _FullPath,
    _In_z_                           wchar_t const* _Path,
    _In_                             size_t         _SizeInWords,
    _In_                             int            _BlockType,
    _In_opt_z_                       char const* _FileName,
    _In_                             int            _LineNumber
);

_Success_(return != 0)
_Check_return_ _Ret_maybenull_z_
_DCRTIMP _CRTALLOCATOR wchar_t* __cdecl _wgetcwd_dbg(
    _Out_writes_opt_z_(_SizeInWords) wchar_t* _DstBuf,
    _In_                             int         _SizeInWords,
    _In_                             int         _BlockType,
    _In_opt_z_                       char const* _FileName,
    _In_                             int         _LineNumber
);

_Success_(return != 0)
_Check_return_ _Ret_maybenull_z_
_DCRTIMP _CRTALLOCATOR wchar_t* __cdecl _wgetdcwd_dbg(
    _In_                             int         _Drive,
    _Out_writes_opt_z_(_SizeInWords) wchar_t* _DstBuf,
    _In_                             int         _SizeInWords,
    _In_                             int         _BlockType,
    _In_opt_z_                       char const* _FileName,
    _In_                             int         _LineNumber
);

_Check_return_ _Ret_maybenull_z_
_ACRTIMP _CRTALLOCATOR wchar_t* __cdecl _wtempnam_dbg(
    _In_opt_z_ wchar_t const* _DirName,
    _In_opt_z_ wchar_t const* _FilePrefix,
    _In_       int            _BlockType,
    _In_opt_z_ char const* _FileName,
    _In_       int            _LineNumber
);

#define _malloca_dbg(s, t, f, l) _malloc_dbg(s, t, f, l)
#define _freea_dbg(p, t)         _free_dbg(p, t)

#if defined __cplusplus && defined _CRTDBG_MAP_ALLOC
namespace std
{
    using ::_calloc_dbg;
    using ::_free_dbg;
    using ::_malloc_dbg;
    using ::_realloc_dbg;
}
#endif

#endif // _DEBUG



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Debug Reporting
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

#ifndef _DEBUG

#define _CrtSetDebugFillThreshold(t)        ((size_t)0)
#define _CrtSetReportFile(t, f)             ((_HFILE)0)
#define _CrtSetReportMode(t, f)             ((int)0)
#define _CrtGetReportHook()                 ((_CRT_REPORT_HOOK)0)
#define _CrtSetReportHook(f)                ((_CRT_REPORT_HOOK)0)
#define _CrtSetReportHook2(t, f)            ((int)0)
#define _CrtSetReportHookW2(t, f)           ((int)0)

#else // ^^^ !_DEBUG ^^^ // vvv _DEBUG vvv //

_ACRTIMP int __cdecl _CrtDbgReport(
    _In_       int         _ReportType,
    _In_opt_z_ char const* _FileName,
    _In_       int         _Linenumber,
    _In_opt_z_ char const* _ModuleName,
    _In_opt_z_ char const* _Format,
    ...);

_ACRTIMP int __cdecl _CrtDbgReportW(
    _In_       int            _ReportType,
    _In_opt_z_ wchar_t const* _FileName,
    _In_       int            _LineNumber,
    _In_opt_z_ wchar_t const* _ModuleName,
    _In_opt_z_ wchar_t const* _Format,
    ...);


_ACRTIMP int __cdecl _VCrtDbgReportA(
    _In_       int         _ReportType,
    _In_opt_   void* _ReturnAddress,
    _In_opt_z_ char const* _FileName,
    _In_       int         _LineNumber,
    _In_opt_z_ char const* _ModuleName,
    _In_opt_z_ char const* _Format,
    va_list     _ArgList
);

_ACRTIMP int __cdecl _VCrtDbgReportW(
    _In_       int            _ReportType,
    _In_opt_   void* _ReturnAddress,
    _In_opt_z_ wchar_t const* _FileName,
    _In_       int            _LineNumber,
    _In_opt_z_ wchar_t const* _ModuleName,
    _In_opt_z_ wchar_t const* _Format,
    va_list        _ArgList
);

_ACRTIMP size_t __cdecl _CrtSetDebugFillThreshold(
    _In_ size_t _NewDebugFillThreshold
);

_ACRTIMP size_t __cdecl _CrtGetDebugFillThreshold(void);

_ACRTIMP _HFILE __cdecl _CrtSetReportFile(
    _In_     int    _ReportType,
    _In_opt_ _HFILE _ReportFile
);

_ACRTIMP int __cdecl _CrtSetReportMode(
    _In_ int _ReportType,
    _In_ int _ReportMode
);

#ifndef _M_CEE_PURE

extern long _crtAssertBusy;

_ACRTIMP _CRT_REPORT_HOOK __cdecl _CrtGetReportHook(void);

// _CrtSetReportHook[[W]2]:
// For IJW, we need two versions:  one for clrcall and one for cdecl.
// For pure and native, we just need clrcall and cdecl, respectively.
_ACRTIMP _CRT_REPORT_HOOK __cdecl _CrtSetReportHook(
    _In_opt_ _CRT_REPORT_HOOK _PFnNewHook
);

_ACRTIMP int __cdecl _CrtSetReportHook2(
    _In_     int              _Mode,
    _In_opt_ _CRT_REPORT_HOOK _PFnNewHook
);

_ACRTIMP int __cdecl _CrtSetReportHookW2(
    _In_     int               _Mode,
    _In_opt_ _CRT_REPORT_HOOKW _PFnNewHook
);

#endif // !_M_CEE_PURE

#endif // _DEBUG




//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Assertions and Error Reporting Macros
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#ifndef _DEBUG

#define _CrtDbgBreak() ((void)0)

#ifndef _ASSERT_EXPR
#define _ASSERT_EXPR(expr, msg) ((void)0)
#endif

#ifndef _ASSERT
#define _ASSERT(expr) ((void)0)
#endif

#ifndef _ASSERTE
#define _ASSERTE(expr) ((void)0)
#endif

#define _RPT0(rptno, msg)
#define _RPTN(rptno, msg, ...)

#define _RPTW0(rptno, msg)
#define _RPTWN(rptno, msg, ...)

#define _RPTF0(rptno, msg)
#define _RPTFN(rptno, msg, ...)

#define _RPTFW0(rptno, msg)
#define _RPTFWN(rptno, msg, ...)

#else // ^^^ !_DEBUG ^^^ // vvv _DEBUG vvv //

#define _CrtDbgBreak() __debugbreak()

// !! is used to ensure that any overloaded operators used to evaluate expr
// do not end up at &&.
#ifndef _ASSERT_EXPR
#define _ASSERT_EXPR(expr, msg) \
            (void)(                                                                                     \
                (!!(expr)) ||                                                                           \
                (1 != _CrtDbgReportW(_CRT_ASSERT, _CRT_WIDE(__FILE__), __LINE__, NULL, L"%ls", msg)) || \
                (_CrtDbgBreak(), 0)                                                                     \
            )
#endif

#ifndef _ASSERT
#define _ASSERT(expr) _ASSERT_EXPR((expr), NULL)
#endif

#ifndef _ASSERTE
#define _ASSERTE(expr) _ASSERT_EXPR((expr), _CRT_WIDE(#expr))
#endif

#define _RPT_BASE(...)                           \
        (void) ((1 != _CrtDbgReport(__VA_ARGS__)) || \
                (_CrtDbgBreak(), 0))

#define _RPT_BASE_W(...)                          \
        (void) ((1 != _CrtDbgReportW(__VA_ARGS__)) || \
                (_CrtDbgBreak(), 0))

#define _RPT0(rptno, msg)      _RPT_BASE(rptno, NULL, 0, NULL, "%s", msg)
#define _RPTN(rptno, msg, ...) _RPT_BASE(rptno, NULL, 0, NULL, msg, __VA_ARGS__)

#define _RPTW0(rptno, msg)      _RPT_BASE_W(rptno, NULL, 0, NULL, L"%ls", msg)
#define _RPTWN(rptno, msg, ...) _RPT_BASE_W(rptno, NULL, 0, NULL, msg, __VA_ARGS__)

#define _RPTF0(rptno, msg)      _RPT_BASE(rptno, __FILE__, __LINE__, NULL, "%s", msg)
#define _RPTFN(rptno, msg, ...) _RPT_BASE(rptno, __FILE__, __LINE__, NULL, msg, __VA_ARGS__)

#define _RPTFW0(rptno, msg)      _RPT_BASE_W(rptno, _CRT_WIDE(__FILE__), __LINE__, NULL, L"%ls", msg)
#define _RPTFWN(rptno, msg, ...) _RPT_BASE_W(rptno, _CRT_WIDE(__FILE__), __LINE__, NULL, msg, __VA_ARGS__)

#endif // _DEBUG

// Asserts in debug.  Invokes Watson in both debug and release
#define _ASSERT_AND_INVOKE_WATSON(expr)                                              \
    {                                                                                \
        _ASSERTE((expr));                                                            \
        if (!(expr))                                                                 \
        {                                                                            \
            _invoke_watson(_CRT_WIDE(#expr), __FUNCTIONW__, __FILEW__, __LINE__, 0); \
        }                                                                            \
    }

// _ASSERT_BASE is provided only for backwards compatibility.
#ifndef _ASSERT_BASE
#define _ASSERT_BASE _ASSERT_EXPR
#endif

#define _RPT1 _RPTN
#define _RPT2 _RPTN
#define _RPT3 _RPTN
#define _RPT4 _RPTN
#define _RPT5 _RPTN

#define _RPTW1 _RPTWN
#define _RPTW2 _RPTWN
#define _RPTW3 _RPTWN
#define _RPTW4 _RPTWN
#define _RPTW5 _RPTWN

#define _RPTF1 _RPTFN
#define _RPTF2 _RPTFN
#define _RPTF3 _RPTFN
#define _RPTF4 _RPTFN
#define _RPTF5 _RPTFN

#define _RPTFW1 _RPTFWN
#define _RPTFW2 _RPTFWN
#define _RPTFW3 _RPTFWN
#define _RPTFW4 _RPTFWN
#define _RPTFW5 _RPTFWN



_CRT_END_C_HEADER
_UCRT_RESTORE_CLANG_WARNINGS
#pragma warning(pop) // _UCRT_DISABLED_WARNINGS
#endif // _INC_CRTDBG

//
// crtdefs.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Declarations used across the Visual C++ Libraries.  The lack of #pragma once
// is deliberate.
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// CRT DLL Export/Import Macros
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// used to annotate symbols exported from msvcp140
#ifndef _CRTIMP2
#if defined CRTDLL2 && defined _CRTBLD
#define _CRTIMP2 __declspec(dllexport)
#else
#define _CRTIMP2
#endif
#endif

// used to annotate symbols exported from msvcp140_1
#ifndef _CRT_SATELLITE_1
#if defined _BUILDING_SATELLITE_1 && defined _CRTBLD
#define _CRT_SATELLITE_1 __declspec(dllexport)
#else
#define _CRT_SATELLITE_1
#endif
#endif

// used to annotate symbols exported from msvcp140_2
#ifndef _CRT_SATELLITE_2
#if defined _BUILDING_SATELLITE_2 && defined _CRTBLD
#define _CRT_SATELLITE_2 __declspec(dllexport)
#else
#define _CRT_SATELLITE_2
#endif
#endif

// Symbols exported from msvcp140_codecvt_ids are annotated with _CRT_SATELLITE_CODECVT_IDS, except for symbols which
// are data members of classes exported from msvcp140 that must themselves be exported from msvcp140_codecvt_ids, which
// are annotated with _CRT_SATELLITE_CODECVT_IDS_NOIMPORT.
#ifndef _CRT_SATELLITE_CODECVT_IDS
#if defined _BUILDING_SATELLITE_CODECVT_IDS && defined _CRTBLD
#define _CRT_SATELLITE_CODECVT_IDS __declspec(dllexport)
#define _CRT_SATELLITE_CODECVT_IDS_NOIMPORT __declspec(dllexport)
#elif defined(_DLL)
#define _CRT_SATELLITE_CODECVT_IDS __declspec(dllimport)
#define _CRT_SATELLITE_CODECVT_IDS_NOIMPORT
#else
#define _CRT_SATELLITE_CODECVT_IDS
#define _CRT_SATELLITE_CODECVT_IDS_NOIMPORT
#endif
#endif

#ifndef _CONCRTIMP
#if defined CONCRTDLL && defined _CRTBLD
#define _CONCRTIMP __declspec(dllexport)
#else
#if defined _DLL && !defined _STATIC_CPPLIB
#define _CONCRTIMP __declspec(dllimport)
#else
#define _CONCRTIMP
#endif
#endif
#endif

#ifndef _MRTIMP2
#if defined CRTDLL2 && defined _CRTBLD
#define _MRTIMP2 __declspec(dllexport)
#elif defined MRTDLL && defined _CRTBLD
#define _MRTIMP2 _MRTIMP
#else
#define _MRTIMP2
#endif
#endif


#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

#if defined(MRTDLL) && defined(_CRTBLD)
// process-global is the default for code built with /clr or /clr:oldSyntax.
// appdomain-global is the default for code built with /clr:pure.
// Code in MSVCM is built with /clr, but is used by user code built with /clr:pure
// so it must conform to the expectations of /clr:pure clients.
// Use __PURE_APPDOMAIN_GLOBAL when a global needs to be appdomain-global for pure
// clients and process-global for mixed clients.
#define __PURE_APPDOMAIN_GLOBAL __declspec(appdomain)
#else
#define __PURE_APPDOMAIN_GLOBAL
#endif

#ifndef _CRT_MSVCP_CURRENT
#ifdef _CRT_WINDOWS
// Windows
#ifdef _DEBUG
#define _CRT_MSVCP_CURRENT "msvcpd_win.dll"
#else
#define _CRT_MSVCP_CURRENT "msvcp_win.dll"
#endif
#else // ^^^ defined(_CRT_WINDOWS) / !defined(_CRT_WINDOWS) vvv
// Visual Studio
#ifdef _DEBUG
#define _CRT_MSVCP_CURRENT "msvcp140d.dll"
#else
#define _CRT_MSVCP_CURRENT "msvcp140.dll"
#endif
#endif // ^^^ !defined(_CRT_WINDOWS) ^^^
#endif // !defined(_CRT_MSVCP_CURRENT)

#ifdef _ITERATOR_DEBUG_LEVEL // A. _ITERATOR_DEBUG_LEVEL is already defined.

// A1. Validate _ITERATOR_DEBUG_LEVEL.
#if _ITERATOR_DEBUG_LEVEL > 2 && defined(_DEBUG)
#error _ITERATOR_DEBUG_LEVEL > 2 is not supported in debug mode.
#elif _ITERATOR_DEBUG_LEVEL > 1 && !defined(_DEBUG)
#error _ITERATOR_DEBUG_LEVEL > 1 is not supported in release mode.
#endif

// A2. Inspect _HAS_ITERATOR_DEBUGGING.
#ifdef _HAS_ITERATOR_DEBUGGING // A2i. _HAS_ITERATOR_DEBUGGING is already defined, validate it.
#if _ITERATOR_DEBUG_LEVEL == 2 && _HAS_ITERATOR_DEBUGGING != 1
#error _ITERATOR_DEBUG_LEVEL == 2 must imply _HAS_ITERATOR_DEBUGGING == 1.
#elif _ITERATOR_DEBUG_LEVEL < 2 && _HAS_ITERATOR_DEBUGGING != 0
#error _ITERATOR_DEBUG_LEVEL < 2 must imply _HAS_ITERATOR_DEBUGGING == 0.
#endif
#else // A2ii. _HAS_ITERATOR_DEBUGGING is not yet defined, derive it.
#if _ITERATOR_DEBUG_LEVEL == 2
#define _HAS_ITERATOR_DEBUGGING 1
#else
#define _HAS_ITERATOR_DEBUGGING 0
#endif
#endif // ^^^ !defined(_HAS_ITERATOR_DEBUGGING) ^^^

// A3. Inspect _SECURE_SCL.
#ifdef _SECURE_SCL // A3i. _SECURE_SCL is already defined, validate it.
#if _ITERATOR_DEBUG_LEVEL > 0 && _SECURE_SCL != 1
#error _ITERATOR_DEBUG_LEVEL > 0 must imply _SECURE_SCL == 1.
#elif _ITERATOR_DEBUG_LEVEL == 0 && _SECURE_SCL != 0
#error _ITERATOR_DEBUG_LEVEL == 0 must imply _SECURE_SCL == 0.
#endif
#else // A3ii. _SECURE_SCL is not yet defined, derive it.
#if _ITERATOR_DEBUG_LEVEL > 0
#define _SECURE_SCL 1
#else
#define _SECURE_SCL 0
#endif
#endif // ^^^ !defined(_SECURE_SCL) ^^^

#else // B. _ITERATOR_DEBUG_LEVEL is not yet defined.

// B1. Inspect _HAS_ITERATOR_DEBUGGING.
#ifdef _HAS_ITERATOR_DEBUGGING // B1i. _HAS_ITERATOR_DEBUGGING is already defined, validate it.
#if _HAS_ITERATOR_DEBUGGING > 1
#error _HAS_ITERATOR_DEBUGGING must be either 0 or 1.
#elif _HAS_ITERATOR_DEBUGGING == 1 && !defined(_DEBUG)
#error _HAS_ITERATOR_DEBUGGING == 1 is not supported in release mode.
#endif
#else // B1ii. _HAS_ITERATOR_DEBUGGING is not yet defined, default it.
#ifdef _DEBUG
#define _HAS_ITERATOR_DEBUGGING 1
#else
#define _HAS_ITERATOR_DEBUGGING 0
#endif
#endif // ^^^ !defined(_HAS_ITERATOR_DEBUGGING) ^^^

// B2. Inspect _SECURE_SCL.
#ifdef _SECURE_SCL // B2i. _SECURE_SCL is already defined, validate it.
#if _SECURE_SCL > 1
#error _SECURE_SCL must be either 0 or 1.
#endif
#else // B2ii. _SECURE_SCL is not yet defined, default it.
#if _HAS_ITERATOR_DEBUGGING == 1
#define _SECURE_SCL 1
#else
#define _SECURE_SCL 0
#endif
#endif // ^^^ !defined(_SECURE_SCL) ^^^

// B3. Derive _ITERATOR_DEBUG_LEVEL.
#if _HAS_ITERATOR_DEBUGGING
#define _ITERATOR_DEBUG_LEVEL 2
#elif _SECURE_SCL
#define _ITERATOR_DEBUG_LEVEL 1
#else // ^^^ _SECURE_SCL / !_SECURE_SCL vvv
#define _ITERATOR_DEBUG_LEVEL 0
#endif // ^^^ !_HAS_ITERATOR_DEBUGGING && !_SECURE_SCL ^^^

#endif // ^^^ !defined(_ITERATOR_DEBUG_LEVEL) ^^^

#ifndef _ALLOW_MSC_VER_MISMATCH
#pragma detect_mismatch("_MSC_VER", "1900")
#endif // !defined(_ALLOW_MSC_VER_MISMATCH)

#ifndef _ALLOW_ITERATOR_DEBUG_LEVEL_MISMATCH
#pragma detect_mismatch("_ITERATOR_DEBUG_LEVEL", _STL_STRINGIZE(_ITERATOR_DEBUG_LEVEL))
#endif // !defined(_ALLOW_ITERATOR_DEBUG_LEVEL_MISMATCH)

#ifndef _ALLOW_RUNTIME_LIBRARY_MISMATCH
#if !defined(_DLL) && !defined(_DEBUG)
#pragma detect_mismatch("RuntimeLibrary", "MT_StaticRelease")
#elif !defined(_DLL) && defined(_DEBUG)
#pragma detect_mismatch("RuntimeLibrary", "MTd_StaticDebug")
#elif defined(_DLL) && !defined(_DEBUG)
#pragma detect_mismatch("RuntimeLibrary", "MD_DynamicRelease")
#elif defined(_DLL) && defined(_DEBUG)
#pragma detect_mismatch("RuntimeLibrary", "MDd_DynamicDebug")
#endif // defined(_DLL) etc.
#endif // !defined(_ALLOW_RUNTIME_LIBRARY_MISMATCH)

#ifndef _CONTAINER_DEBUG_LEVEL
#if _ITERATOR_DEBUG_LEVEL == 0
#define _CONTAINER_DEBUG_LEVEL 0
#else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 / _ITERATOR_DEBUG_LEVEL != 0 vvv
#define _CONTAINER_DEBUG_LEVEL 1
#endif // _ITERATOR_DEBUG_LEVEL == 0
#endif // !defined(_CONTAINER_DEBUG_LEVEL)

#if _ITERATOR_DEBUG_LEVEL != 0 && _CONTAINER_DEBUG_LEVEL == 0
#error _ITERATOR_DEBUG_LEVEL != 0 must imply _CONTAINER_DEBUG_LEVEL == 1.
#endif // _ITERATOR_DEBUG_LEVEL != 0 && _CONTAINER_DEBUG_LEVEL == 0

#ifndef _STL_CRT_SECURE_INVALID_PARAMETER
#ifdef _STL_CALL_ABORT_INSTEAD_OF_INVALID_PARAMETER
#define _STL_CRT_SECURE_INVALID_PARAMETER(expr) _CSTD abort()
#elif defined(_DEBUG) // avoid emitting unused long strings for function names; see GH-1956
#define _STL_CRT_SECURE_INVALID_PARAMETER(expr) ::_invalid_parameter(_CRT_WIDE(#expr), L"", __FILEW__, __LINE__, 0)
#else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
#define _STL_CRT_SECURE_INVALID_PARAMETER(expr) _CRT_SECURE_INVALID_PARAMETER(expr)
#endif // ^^^ !defined(_DEBUG) ^^^
#endif // !defined(_STL_CRT_SECURE_INVALID_PARAMETER)

#define _STL_REPORT_ERROR(mesg)                  \
    do {                                         \
        _RPTF0(_CRT_ASSERT, mesg);               \
        _STL_CRT_SECURE_INVALID_PARAMETER(mesg); \
    } while (false)

#ifdef __clang__
#define _STL_VERIFY(cond, mesg)                                                            \
    _Pragma("clang diagnostic push") _Pragma("clang diagnostic ignored \"-Wassume\"") do { \
        if (cond) { /* contextually convertible to bool paranoia */                        \
        } else {                                                                           \
            _STL_REPORT_ERROR(mesg);                                                       \
        }                                                                                  \
                                                                                           \
        _Analysis_assume_(cond);                                                           \
    }                                                                                      \
    while (false)                                                                          \
    _Pragma("clang diagnostic pop")
#else // ^^^ Clang / MSVC vvv
#define _STL_VERIFY(cond, mesg)                                     \
    do {                                                            \
        if (cond) { /* contextually convertible to bool paranoia */ \
        } else {                                                    \
            _STL_REPORT_ERROR(mesg);                                \
        }                                                           \
                                                                    \
        _Analysis_assume_(cond);                                    \
    } while (false)
#endif // ^^^ MSVC ^^^

#ifdef _DEBUG
#define _STL_ASSERT(cond, mesg) _STL_VERIFY(cond, mesg)
#else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
#define _STL_ASSERT(cond, mesg) _Analysis_assume_(cond)
#endif // ^^^ !defined(_DEBUG) ^^^

#ifdef _ENABLE_STL_INTERNAL_CHECK
#define _STL_INTERNAL_CHECK(...) _STL_VERIFY(__VA_ARGS__, "STL internal check: " #__VA_ARGS__)
#else // ^^^ defined(_ENABLE_STL_INTERNAL_CHECK) / !defined(_ENABLE_STL_INTERNAL_CHECK) vvv
#define _STL_INTERNAL_CHECK(...) _Analysis_assume_(__VA_ARGS__)
#endif // ^^^ !defined(_ENABLE_STL_INTERNAL_CHECK) ^^^

#ifndef _ENABLE_ATOMIC_REF_ALIGNMENT_CHECK
#ifdef _DEBUG
#define _ENABLE_ATOMIC_REF_ALIGNMENT_CHECK 1
#else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
#define _ENABLE_ATOMIC_REF_ALIGNMENT_CHECK 0
#endif // ^^^ !defined(_DEBUG) ^^^
#endif // !defined(_ENABLE_ATOMIC_REF_ALIGNMENT_CHECK)

#if _ENABLE_ATOMIC_REF_ALIGNMENT_CHECK
#define _ATOMIC_REF_CHECK_ALIGNMENT(cond, mesg) _STL_VERIFY(cond, mesg)
#else
#define _ATOMIC_REF_CHECK_ALIGNMENT(cond, mesg) _Analysis_assume_(cond)
#endif

// use_ansi.h internal header

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#ifndef _USE_ANSI_CPP
#define _USE_ANSI_CPP

#ifdef _CRTBLD
#define _CRT_NOPRAGMA_LIBS
#else
#undef _CRT_NOPRAGMA_LIBS
#endif

#ifndef _CRT_NOPRAGMA_LIBS

#ifndef _M_CEE_PURE

#undef _DEBUG_AFFIX
#undef _IDL_AFFIX
#undef _IDL_DEFAULT
#undef _LIB_STEM

#ifdef _DEBUG
#define _DEBUG_AFFIX "d"
#define _IDL_DEFAULT 2
#else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
#define _DEBUG_AFFIX ""
#define _IDL_DEFAULT 0
#endif // ^^^ !defined(_DEBUG) ^^^

#if defined(_DLL) && !defined(_STATIC_CPPLIB)
#define _LIB_STEM "msvcprt"
#else // ^^^ defined(_DLL) && !defined(_STATIC_CPPLIB) / !defined(_DLL) || defined(_STATIC_CPPLIB) vvv
#define _LIB_STEM "libcpmt"

#if _ITERATOR_DEBUG_LEVEL != _IDL_DEFAULT
#define _IDL_AFFIX _STL_STRINGIZE(_ITERATOR_DEBUG_LEVEL)
#endif // _ITERATOR_DEBUG_LEVEL != _IDL_DEFAULT
#endif // ^^^ !defined(_DLL) || defined(_STATIC_CPPLIB) ^^^

#ifndef _IDL_AFFIX
#define _IDL_AFFIX ""
#endif

#pragma comment(lib, _LIB_STEM _DEBUG_AFFIX _IDL_AFFIX)

#undef _DEBUG_AFFIX
#undef _IDL_AFFIX
#undef _IDL_DEFAULT
#undef _LIB_STEM

#endif // !defined(_M_CEE_PURE)

#endif // !defined(_CRT_NOPRAGMA_LIBS)

#endif // _USE_ANSI_CPP


#ifdef _STATIC_CPPLIB
#ifndef _DISABLE_DEPRECATE_STATIC_CPPLIB
#ifdef _DLL
_EMIT_STL_WARNING(STL4000, "_STATIC_CPPLIB is deprecated and will be REMOVED.");
#endif
#ifdef _M_CEE_MIXED
#error _STATIC_CPPLIB is not supported while building with /clr
#endif
#endif // !defined(_DISABLE_DEPRECATE_STATIC_CPPLIB)
#ifdef _M_CEE_PURE
#error _STATIC_CPPLIB cannot be used with /clr:pure (the resulting assembly would not be pure)
#endif
#endif // defined(_STATIC_CPPLIB)

#if defined(_M_CEE_PURE) && !defined(_SILENCE_CLR_PURE_DEPRECATION_WARNING)
_EMIT_STL_WARNING(STL4001, "/clr:pure is deprecated and will be REMOVED.");
#endif

#ifndef _MRTIMP2_PURE
#ifdef _M_CEE_PURE
#define _MRTIMP2_PURE
#else
#define _MRTIMP2_PURE _MRTIMP2
#endif
#endif // !defined(_MRTIMP2_PURE)

#if defined(_DLL) && !defined(_STATIC_CPPLIB) && !defined(_M_CEE_PURE)
#define _DLL_CPPLIB
#endif

#ifndef _CRTIMP2_PURE
#ifdef _M_CEE_PURE
#define _CRTIMP2_PURE
#else
#define _CRTIMP2_PURE _CRTIMP2
#endif
#endif // !defined(_CRTIMP2_PURE)

#ifndef _CRTIMP2_IMPORT
#if defined(CRTDLL2) && defined(_CRTBLD)
#define _CRTIMP2_IMPORT __declspec(dllexport)
#elif defined(_DLL) && !defined(_STATIC_CPPLIB)
#define _CRTIMP2_IMPORT __declspec(dllimport)
#else // ^^^ defined(_DLL) && !defined(_STATIC_CPPLIB) / !defined(_DLL) || defined(_STATIC_CPPLIB) vvv
#define _CRTIMP2_IMPORT
#endif // ^^^ !defined(_DLL) || defined(_STATIC_CPPLIB) ^^^
#endif // !defined(_CRTIMP2_IMPORT)

#ifndef _CRTIMP2_PURE_IMPORT
#ifdef _M_CEE_PURE
#define _CRTIMP2_PURE_IMPORT
#else
#define _CRTIMP2_PURE_IMPORT _CRTIMP2_IMPORT
#endif
#endif // !defined(_CRTIMP2_PURE_IMPORT)

#ifndef _CRTIMP2_PURE_IMPORT_UNLESS_CODECVT_ID_SATELLITE
#ifdef _BUILDING_SATELLITE_CODECVT_IDS
#define _CRTIMP2_PURE_IMPORT_UNLESS_CODECVT_ID_SATELLITE
#else
#define _CRTIMP2_PURE_IMPORT_UNLESS_CODECVT_ID_SATELLITE _CRTIMP2_PURE_IMPORT
#endif
#endif // !defined(_CRTIMP2_PURE_IMPORT_UNLESS_CODECVT_ID_SATELLITE)

#ifndef _CRTDATA2_IMPORT
#if defined(MRTDLL) && defined(_CRTBLD)
#define _CRTDATA2_IMPORT
#else
#define _CRTDATA2_IMPORT _CRTIMP2_IMPORT
#endif
#endif // !defined(_CRTDATA2_IMPORT)

#define _LOCK_LOCALE 0
#define _LOCK_STREAM 2
#define _LOCK_DEBUG  3

#ifndef _STD_ATOMIC_ALWAYS_USE_CMPXCHG16B
#if _STL_WIN32_WINNT >= _STL_WIN32_WINNT_WINBLUE && defined(_WIN64)
#define _STD_ATOMIC_ALWAYS_USE_CMPXCHG16B 1
#else // ^^^ modern 64-bit / less modern or 32-bit vvv
#define _STD_ATOMIC_ALWAYS_USE_CMPXCHG16B 0
#endif // _STL_WIN32_WINNT >= _STL_WIN32_WINNT_WINBLUE && defined(_WIN64)
#endif // !defined(_STD_ATOMIC_ALWAYS_USE_CMPXCHG16B)

#if _STD_ATOMIC_ALWAYS_USE_CMPXCHG16B == 0 && defined(_M_ARM64)
#error ARM64 requires _STD_ATOMIC_ALWAYS_USE_CMPXCHG16B to be 1.
#endif // _STD_ATOMIC_ALWAYS_USE_CMPXCHG16B == 0 && defined(_M_ARM64)

#if _STD_ATOMIC_ALWAYS_USE_CMPXCHG16B == 1 && !defined(_WIN64)
#error _STD_ATOMIC_ALWAYS_USE_CMPXCHG16B == 1 requires 64-bit.
#endif // _STD_ATOMIC_ALWAYS_USE_CMPXCHG16B == 1 && !defined(_WIN64)

_STD_BEGIN
enum _Uninitialized { // tag for suppressing initialization
    _Noinit
};

extern "C++" class _CRTIMP2_PURE_IMPORT _Lockit { // lock while object in existence -- MUST NEST
public:
#ifdef _M_CEE_PURE
    __CLR_OR_THIS_CALL _Lockit() noexcept : _Locktype(0) {
        _Lockit_ctor(this);
    }

    explicit __CLR_OR_THIS_CALL _Lockit(int _Kind) noexcept { // set the lock
        _Lockit_ctor(this, _Kind);
    }

    __CLR_OR_THIS_CALL ~_Lockit() noexcept { // clear the lock
        _Lockit_dtor(this);
    }
#else // ^^^ defined(_M_CEE_PURE) / !defined(_M_CEE_PURE) vvv
    __thiscall _Lockit() noexcept;
    explicit __thiscall _Lockit(int) noexcept; // set the lock
    __thiscall ~_Lockit() noexcept; // clear the lock
#endif // ^^^ !defined(_M_CEE_PURE) ^^^

    static void __cdecl _Lockit_ctor(int) noexcept;
    static void __cdecl _Lockit_dtor(int) noexcept;

private:
    static void __cdecl _Lockit_ctor(_Lockit*) noexcept;
    static void __cdecl _Lockit_ctor(_Lockit*, int) noexcept;
    static void __cdecl _Lockit_dtor(_Lockit*) noexcept;

public:
    __CLR_OR_THIS_CALL _Lockit(const _Lockit&) = delete;
    _Lockit& __CLR_OR_THIS_CALL operator=(const _Lockit&) = delete;

private:
    int _Locktype;
};

#ifdef _M_CEE_PURE
class _CRTIMP2_PURE_IMPORT _EmptyLockit { // empty lock class used for bin compat
private:
    int _Locktype;
};
#endif // defined(_M_CEE_PURE)

#ifdef _M_CEE
#ifndef _PREPARE_CONSTRAINED_REGIONS
#ifdef _M_CEE_PURE
#define _PREPARE_CONSTRAINED_REGIONS 1
#else // ^^^ defined(_M_CEE_PURE) / !defined(_M_CEE_PURE) vvv
#define _PREPARE_CONSTRAINED_REGIONS 0
#endif // ^^^ !defined(_M_CEE_PURE) ^^^
#endif // !defined(_PREPARE_CONSTRAINED_REGIONS)

#if _PREPARE_CONSTRAINED_REGIONS
#define _BEGIN_LOCK(_Kind)                                                                  \
    {                                                                                       \
        bool _MustReleaseLock = false;                                                      \
        int _LockKind         = _Kind;                                                      \
        System::Runtime::CompilerServices::RuntimeHelpers::PrepareConstrainedRegions();     \
        try {                                                                               \
            System::Runtime::CompilerServices::RuntimeHelpers::PrepareConstrainedRegions(); \
            try {                                                                           \
            } finally {                                                                     \
                _STD _Lockit::_Lockit_ctor(_LockKind);                                      \
                _MustReleaseLock = true;                                                    \
            }

#define _END_LOCK()                                \
    }                                              \
    finally {                                      \
        if (_MustReleaseLock) {                    \
            _STD _Lockit::_Lockit_dtor(_LockKind); \
        }                                          \
    }                                              \
    }

#else // ^^^ _PREPARE_CONSTRAINED_REGIONS / !_PREPARE_CONSTRAINED_REGIONS vvv
#define _BEGIN_LOCK(_Kind) \
    {                      \
        _STD _Lockit _Lock(_Kind);

#define _END_LOCK() }

#endif // ^^^ !_PREPARE_CONSTRAINED_REGIONS ^^^

#define _BEGIN_LOCINFO(_VarName) \
    _BEGIN_LOCK(_LOCK_LOCALE)    \
    _Locinfo _VarName;

#define _END_LOCINFO() _END_LOCK()

#else // ^^^ defined(_M_CEE) / !defined(_M_CEE) vvv
#define _BEGIN_LOCK(_Kind) \
    {                      \
        _STD _Lockit _Lock(_Kind);

#define _END_LOCK() }

#define _BEGIN_LOCINFO(_VarName) \
    {                            \
        _Locinfo _VarName;

#define _END_LOCINFO() }
#endif // ^^^ !defined(_M_CEE) ^^^

#if _HAS_EXCEPTIONS
#define _TRY_BEGIN try {
#define _CATCH(x) \
    }             \
    catch (x) {
#define _CATCH_ALL \
    }              \
    catch (...) {
#define _CATCH_END }

#define _RERAISE    throw
#define _THROW(...) throw(__VA_ARGS__)

#else // ^^^ _HAS_EXCEPTIONS / !_HAS_EXCEPTIONS vvv
#define _TRY_BEGIN \
    {              \
        if (1) {
#define _CATCH(x) \
    }             \
    else if (0) {
#define _CATCH_ALL \
    }              \
    else if (0) {
#define _CATCH_END \
    }              \
    }

#ifdef _DEBUG
#define _RAISE(x) _invoke_watson(_CRT_WIDE(#x), __FUNCTIONW__, __FILEW__, __LINE__, 0)
#else
#define _RAISE(x) _invoke_watson(nullptr, nullptr, nullptr, 0, 0)
#endif

#define _RERAISE
#define _THROW(...) (__VA_ARGS__)._Raise()
#endif // ^^^ !_HAS_EXCEPTIONS ^^^
_STD_END

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _YVALS

#if _STL_COMPILER_PREPROCESSOR

// cstdlib standard header (core)

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#ifndef _CSTDLIB_
#define _CSTDLIB_
#if _STL_COMPILER_PREPROCESSOR

//
// math.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The C Standard Library <math.h> header.  This header consists of two parts:
// <corecrt_math.h> contains the math library; <corecrt_math_defines.h> contains
// the nonstandard but useful constant definitions.  The headers are divided in
// this way for modularity (to support the C++ modules feature).
//
//
// corecrt_math.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The majority of the C Standard Library <math.h> functionality.
//
#pragma once
#ifndef _INC_MATH // include guard for 3rd party interop
#define _INC_MATH
#pragma warning(push)
#pragma warning(disable: _UCRT_DISABLED_WARNINGS)
_UCRT_DISABLE_CLANG_WARNINGS

_CRT_BEGIN_C_HEADER

#ifndef __assembler
// Definition of the _exception struct, which is passed to the matherr function
// when a floating point exception is detected:
struct _exception
{
    int    type;   // exception type - see below
    char* name;   // name of function where error occurred
    double arg1;   // first argument to function
    double arg2;   // second argument (if any) to function
    double retval; // value to be returned by function
};

// Definition of the _complex struct to be used by those who use the complex
// functions and want type checking.
#ifndef _COMPLEX_DEFINED
#define _COMPLEX_DEFINED

struct _complex
{
    double x, y; // real and imaginary parts
};

#if defined(_CRT_INTERNAL_NONSTDC_NAMES) && _CRT_INTERNAL_NONSTDC_NAMES && !defined __cplusplus
// Non-ANSI name for compatibility
#define complex _complex
#endif
#endif
#endif // __assembler



// On x86, when not using /arch:SSE2 or greater, floating point operations
// are performed using the x87 instruction set and FLT_EVAL_METHOD is 2.
// (When /fp:fast is used, floating point operations may be consistent, so
// we use the default types.)
#if defined _M_IX86 && _M_IX86_FP < 2 && !defined _M_FP_FAST
typedef long double float_t;
typedef long double double_t;
#else
typedef float  float_t;
typedef double double_t;
#endif



// Constant definitions for the exception type passed in the _exception struct
#define _DOMAIN     1   // argument domain error
#define _SING       2   // argument singularity
#define _OVERFLOW   3   // overflow range error
#define _UNDERFLOW  4   // underflow range error
#define _TLOSS      5   // total loss of precision
#define _PLOSS      6   // partial loss of precision

// Definitions of _HUGE and HUGE_VAL - respectively the XENIX and ANSI names
// for a value returned in case of error by a number of the floating point
// math routines.
#ifndef __assembler
#ifndef _M_CEE_PURE
extern double const _HUGE;
#else
double const _HUGE = System::Double::PositiveInfinity;
#endif
#endif

#ifndef _HUGE_ENUF
#define _HUGE_ENUF  1e+300  // _HUGE_ENUF*_HUGE_ENUF must overflow
#endif

#define INFINITY   ((float)(_HUGE_ENUF * _HUGE_ENUF))
#define HUGE_VAL   ((double)INFINITY)
#define HUGE_VALF  ((float)INFINITY)
#define HUGE_VALL  ((long double)INFINITY)
#ifndef _UCRT_NEGATIVE_NAN
// This operation creates a negative NAN adding a - to make it positive
#define NAN        (-(float)(INFINITY * 0.0F))
#else
// Keep this for backwards compatibility
#define NAN        ((float)(INFINITY * 0.0F))
#endif

#define _DENORM    (-2)
#define _FINITE    (-1)
#define _INFCODE   1
#define _NANCODE   2

#define FP_INFINITE  _INFCODE
#define FP_NAN       _NANCODE
#define FP_NORMAL    _FINITE
#define FP_SUBNORMAL _DENORM
#define FP_ZERO      0

#define _C2          1  // 0 if not 2's complement
#define FP_ILOGB0   (-0x7fffffff - _C2)
#define FP_ILOGBNAN 0x7fffffff

#define MATH_ERRNO        1
#define MATH_ERREXCEPT    2
#define math_errhandling  (MATH_ERRNO | MATH_ERREXCEPT)

// Values for use as arguments to the _fperrraise function
#define _FE_DIVBYZERO 0x04
#define _FE_INEXACT   0x20
#define _FE_INVALID   0x01
#define _FE_OVERFLOW  0x08
#define _FE_UNDERFLOW 0x10

#define _D0_C  3 // little-endian, small long doubles
#define _D1_C  2
#define _D2_C  1
#define _D3_C  0

#define _DBIAS 0x3fe
#define _DOFF  4

#define _F0_C  1 // little-endian
#define _F1_C  0

#define _FBIAS 0x7e
#define _FOFF  7
#define _FRND  1

#define _L0_C  3 // little-endian, 64-bit long doubles
#define _L1_C  2
#define _L2_C  1
#define _L3_C  0

#define _LBIAS 0x3fe
#define _LOFF  4

// IEEE 754 double properties
#define _DFRAC  ((unsigned short)((1 << _DOFF) - 1))
#define _DMASK  ((unsigned short)(0x7fff & ~_DFRAC))
#define _DMAX   ((unsigned short)((1 << (15 - _DOFF)) - 1))
#define _DSIGN  ((unsigned short)0x8000)

// IEEE 754 float properties
#define _FFRAC  ((unsigned short)((1 << _FOFF) - 1))
#define _FMASK  ((unsigned short)(0x7fff & ~_FFRAC))
#define _FMAX   ((unsigned short)((1 << (15 - _FOFF)) - 1))
#define _FSIGN  ((unsigned short)0x8000)

// IEEE 754 long double properties
#define _LFRAC  ((unsigned short)(-1))
#define _LMASK  ((unsigned short)0x7fff)
#define _LMAX   ((unsigned short)0x7fff)
#define _LSIGN  ((unsigned short)0x8000)

#define _DHUGE_EXP (int)(_DMAX * 900L / 1000)
#define _FHUGE_EXP (int)(_FMAX * 900L / 1000)
#define _LHUGE_EXP (int)(_LMAX * 900L / 1000)

#define _DSIGN_C(_Val)  (((_double_val *)(char*)&(_Val))->_Sh[_D0_C] & _DSIGN)
#define _FSIGN_C(_Val)  (((_float_val  *)(char*)&(_Val))->_Sh[_F0_C] & _FSIGN)
#define _LSIGN_C(_Val)  (((_ldouble_val*)(char*)&(_Val))->_Sh[_L0_C] & _LSIGN)

void __cdecl _fperrraise(_In_ int _Except);

_Check_return_ _ACRTIMP short __cdecl _dclass(_In_ double _X);
_Check_return_ _ACRTIMP short __cdecl _ldclass(_In_ long double _X);
_Check_return_ _ACRTIMP short __cdecl _fdclass(_In_ float _X);

_Check_return_ _ACRTIMP int __cdecl _dsign(_In_ double _X);
_Check_return_ _ACRTIMP int __cdecl _ldsign(_In_ long double _X);
_Check_return_ _ACRTIMP int __cdecl _fdsign(_In_ float _X);

_Check_return_ _ACRTIMP int __cdecl _dpcomp(_In_ double _X, _In_ double _Y);
_Check_return_ _ACRTIMP int __cdecl _ldpcomp(_In_ long double _X, _In_ long double _Y);
_Check_return_ _ACRTIMP int __cdecl _fdpcomp(_In_ float _X, _In_ float _Y);

_Check_return_ _ACRTIMP short __cdecl _dtest(_In_ double* _Px);
_Check_return_ _ACRTIMP short __cdecl _ldtest(_In_ long double* _Px);
_Check_return_ _ACRTIMP short __cdecl _fdtest(_In_ float* _Px);

_ACRTIMP short __cdecl _d_int(_Inout_ double* _Px, _In_ short _Xexp);
_ACRTIMP short __cdecl _ld_int(_Inout_ long double* _Px, _In_ short _Xexp);
_ACRTIMP short __cdecl _fd_int(_Inout_ float* _Px, _In_ short _Xexp);

_ACRTIMP short __cdecl _dscale(_Inout_ double* _Px, _In_ long _Lexp);
_ACRTIMP short __cdecl _ldscale(_Inout_ long double* _Px, _In_ long _Lexp);
_ACRTIMP short __cdecl _fdscale(_Inout_ float* _Px, _In_ long _Lexp);

_ACRTIMP short __cdecl _dunscale(_Out_ short* _Pex, _Inout_ double* _Px);
_ACRTIMP short __cdecl _ldunscale(_Out_ short* _Pex, _Inout_ long double* _Px);
_ACRTIMP short __cdecl _fdunscale(_Out_ short* _Pex, _Inout_ float* _Px);

_Check_return_ _ACRTIMP short __cdecl _dexp(_Inout_ double* _Px, _In_ double _Y, _In_ long _Eoff);
_Check_return_ _ACRTIMP short __cdecl _ldexp(_Inout_ long double* _Px, _In_ long double _Y, _In_ long _Eoff);
_Check_return_ _ACRTIMP short __cdecl _fdexp(_Inout_ float* _Px, _In_ float _Y, _In_ long _Eoff);

_Check_return_ _ACRTIMP short __cdecl _dnorm(_Inout_updates_(4) unsigned short* _Ps);
_Check_return_ _ACRTIMP short __cdecl _fdnorm(_Inout_updates_(2) unsigned short* _Ps);

_Check_return_ _ACRTIMP double __cdecl _dpoly(_In_ double _X, _In_reads_(_N) double const* _Tab, _In_ int _N);
_Check_return_ _ACRTIMP long double __cdecl _ldpoly(_In_ long double _X, _In_reads_(_N) long double const* _Tab, _In_ int _N);
_Check_return_ _ACRTIMP float __cdecl _fdpoly(_In_ float _X, _In_reads_(_N) float const* _Tab, _In_ int _N);

_Check_return_ _ACRTIMP double __cdecl _dlog(_In_ double _X, _In_ int _Baseflag);
_Check_return_ _ACRTIMP long double __cdecl _ldlog(_In_ long double _X, _In_ int _Baseflag);
_Check_return_ _ACRTIMP float __cdecl _fdlog(_In_ float _X, _In_ int _Baseflag);

_Check_return_ _ACRTIMP double __cdecl _dsin(_In_ double _X, _In_ unsigned int _Qoff);
_Check_return_ _ACRTIMP long double __cdecl _ldsin(_In_ long double _X, _In_ unsigned int _Qoff);
_Check_return_ _ACRTIMP float __cdecl _fdsin(_In_ float _X, _In_ unsigned int _Qoff);

// double declarations
typedef union
{   // pun floating type as integer array
    unsigned short _Sh[4];
    double _Val;
} _double_val;

// float declarations
typedef union
{   // pun floating type as integer array
    unsigned short _Sh[2];
    float _Val;
} _float_val;

// long double declarations
typedef union
{   // pun floating type as integer array
    unsigned short _Sh[4];
    long double _Val;
} _ldouble_val;

typedef union
{   // pun float types as integer array
    unsigned short _Word[4];
    float _Float;
    double _Double;
    long double _Long_double;
} _float_const;

extern const _float_const _Denorm_C, _Inf_C, _Nan_C, _Snan_C, _Hugeval_C;
extern const _float_const _FDenorm_C, _FInf_C, _FNan_C, _FSnan_C;
extern const _float_const _LDenorm_C, _LInf_C, _LNan_C, _LSnan_C;

extern const _float_const _Eps_C, _Rteps_C;
extern const _float_const _FEps_C, _FRteps_C;
extern const _float_const _LEps_C, _LRteps_C;

extern const double      _Zero_C, _Xbig_C;
extern const float       _FZero_C, _FXbig_C;
extern const long double _LZero_C, _LXbig_C;

#define _FP_LT  1
#define _FP_EQ  2
#define _FP_GT  4

#ifndef __cplusplus

#define _CLASS_ARG(_Val)                                  __pragma(warning(suppress:6334))(sizeof ((_Val) + (float)0) == sizeof (float) ? 'f' : sizeof ((_Val) + (double)0) == sizeof (double) ? 'd' : 'l')
#define _CLASSIFY(_Val, _FFunc, _DFunc, _LDFunc)          (_CLASS_ARG(_Val) == 'f' ? _FFunc((float)(_Val)) : _CLASS_ARG(_Val) == 'd' ? _DFunc((double)(_Val)) : _LDFunc((long double)(_Val)))
#define _CLASSIFY2(_Val1, _Val2, _FFunc, _DFunc, _LDFunc) (_CLASS_ARG((_Val1) + (_Val2)) == 'f' ? _FFunc((float)(_Val1), (float)(_Val2)) : _CLASS_ARG((_Val1) + (_Val2)) == 'd' ? _DFunc((double)(_Val1), (double)(_Val2)) : _LDFunc((long double)(_Val1), (long double)(_Val2)))

#define fpclassify(_Val)      (_CLASSIFY(_Val, _fdclass, _dclass, _ldclass))
#define _FPCOMPARE(_Val1, _Val2) (_CLASSIFY2(_Val1, _Val2, _fdpcomp, _dpcomp, _ldpcomp))

#define isfinite(_Val)      (fpclassify(_Val) <= 0)
#define isinf(_Val)         (fpclassify(_Val) == FP_INFINITE)
#define isnan(_Val)         (fpclassify(_Val) == FP_NAN)
#define isnormal(_Val)      (fpclassify(_Val) == FP_NORMAL)
#define signbit(_Val)       (_CLASSIFY(_Val, _fdsign, _dsign, _ldsign))

#define isgreater(x, y)      ((_FPCOMPARE(x, y) & _FP_GT) != 0)
#define isgreaterequal(x, y) ((_FPCOMPARE(x, y) & (_FP_EQ | _FP_GT)) != 0)
#define isless(x, y)         ((_FPCOMPARE(x, y) & _FP_LT) != 0)
#define islessequal(x, y)    ((_FPCOMPARE(x, y) & (_FP_LT | _FP_EQ)) != 0)
#define islessgreater(x, y)  ((_FPCOMPARE(x, y) & (_FP_LT | _FP_GT)) != 0)
#define isunordered(x, y)    (_FPCOMPARE(x, y) == 0)

#else // __cplusplus
extern "C++"
{
    _Check_return_ inline int fpclassify(_In_ float _X) throw()
    {
        return _fdtest(&_X);
    }

    _Check_return_ inline int fpclassify(_In_ double _X) throw()
    {
        return _dtest(&_X);
    }

    _Check_return_ inline int fpclassify(_In_ long double _X) throw()
    {
        return _ldtest(&_X);
    }

    _Check_return_ inline bool signbit(_In_ float _X) throw()
    {
        return _fdsign(_X) != 0;
    }

    _Check_return_ inline bool signbit(_In_ double _X) throw()
    {
        return _dsign(_X) != 0;
    }

    _Check_return_ inline bool signbit(_In_ long double _X) throw()
    {
        return _ldsign(_X) != 0;
    }

    _Check_return_ inline int _fpcomp(_In_ float _X, _In_ float _Y) throw()
    {
        return _fdpcomp(_X, _Y);
    }

    _Check_return_ inline int _fpcomp(_In_ double _X, _In_ double _Y) throw()
    {
        return _dpcomp(_X, _Y);
    }

    _Check_return_ inline int _fpcomp(_In_ long double _X, _In_ long double _Y) throw()
    {
        return _ldpcomp(_X, _Y);
    }

    template <class _Trc, class _Tre> struct _Combined_type
    {   // determine combined type
        typedef float _Type;
    };

    template <> struct _Combined_type<float, double>
    {   // determine combined type
        typedef double _Type;
    };

    template <> struct _Combined_type<float, long double>
    {   // determine combined type
        typedef long double _Type;
    };

    template <class _Ty, class _T2> struct _Real_widened
    {   // determine widened real type
        typedef long double _Type;
    };

    template <> struct _Real_widened<float, float>
    {   // determine widened real type
        typedef float _Type;
    };

    template <> struct _Real_widened<float, double>
    {   // determine widened real type
        typedef double _Type;
    };

    template <> struct _Real_widened<double, float>
    {   // determine widened real type
        typedef double _Type;
    };

    template <> struct _Real_widened<double, double>
    {   // determine widened real type
        typedef double _Type;
    };

    template <class _Ty> struct _Real_type
    {   // determine equivalent real type
        typedef double _Type;   // default is double
    };

    template <> struct _Real_type<float>
    {   // determine equivalent real type
        typedef float _Type;
    };

    template <> struct _Real_type<long double>
    {   // determine equivalent real type
        typedef long double _Type;
    };

    template <class _T1, class _T2>
    _Check_return_ inline int _fpcomp(_In_ _T1 _X, _In_ _T2 _Y) throw()
    {   // compare _Left and _Right
        typedef typename _Combined_type<float,
            typename _Real_widened<
            typename _Real_type<_T1>::_Type,
            typename _Real_type<_T2>::_Type>::_Type>::_Type _Tw;
        return _fpcomp((_Tw)_X, (_Tw)_Y);
    }

    template <class _Ty>
    _Check_return_ inline bool isfinite(_In_ _Ty _X) throw()
    {
        return fpclassify(_X) <= 0;
    }

    template <class _Ty>
    _Check_return_ inline bool isinf(_In_ _Ty _X) throw()
    {
        return fpclassify(_X) == FP_INFINITE;
    }

    template <class _Ty>
    _Check_return_ inline bool isnan(_In_ _Ty _X) throw()
    {
        return fpclassify(_X) == FP_NAN;
    }

    template <class _Ty>
    _Check_return_ inline bool isnormal(_In_ _Ty _X) throw()
    {
        return fpclassify(_X) == FP_NORMAL;
    }

    template <class _Ty1, class _Ty2>
    _Check_return_ inline bool isgreater(_In_ _Ty1 _X, _In_ _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & _FP_GT) != 0;
    }

    template <class _Ty1, class _Ty2>
    _Check_return_ inline bool isgreaterequal(_In_ _Ty1 _X, _In_ _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (_FP_EQ | _FP_GT)) != 0;
    }

    template <class _Ty1, class _Ty2>
    _Check_return_ inline bool isless(_In_ _Ty1 _X, _In_ _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & _FP_LT) != 0;
    }

    template <class _Ty1, class _Ty2>
    _Check_return_ inline bool islessequal(_In_ _Ty1 _X, _In_ _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (_FP_LT | _FP_EQ)) != 0;
    }

    template <class _Ty1, class _Ty2>
    _Check_return_ inline bool islessgreater(_In_ _Ty1 _X, _In_ _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (_FP_LT | _FP_GT)) != 0;
    }

    template <class _Ty1, class _Ty2>
    _Check_return_ inline bool isunordered(_In_ _Ty1 _X, _In_ _Ty2 _Y) throw()
    {
        return _fpcomp(_X, _Y) == 0;
    }
}  // extern "C++"
#endif // __cplusplus



#if _CRT_FUNCTIONS_REQUIRED

_Check_return_ int       __cdecl abs(_In_ int _X);
_Check_return_ long      __cdecl labs(_In_ long _X);
_Check_return_ long long __cdecl llabs(_In_ long long _X);

_Check_return_ double __cdecl acos(_In_ double _X);
_Check_return_ double __cdecl asin(_In_ double _X);
_Check_return_ double __cdecl atan(_In_ double _X);
_Check_return_ double __cdecl atan2(_In_ double _Y, _In_ double _X);

_Check_return_ double __cdecl cos(_In_ double _X);
_Check_return_ double __cdecl cosh(_In_ double _X);
_Check_return_ double __cdecl exp(_In_ double _X);
_Check_return_ _CRT_JIT_INTRINSIC double __cdecl fabs(_In_ double _X);
_Check_return_ double __cdecl fmod(_In_ double _X, _In_ double _Y);
_Check_return_ double __cdecl log(_In_ double _X);
_Check_return_ double __cdecl log10(_In_ double _X);
_Check_return_ double __cdecl pow(_In_ double _X, _In_ double _Y);
_Check_return_ double __cdecl sin(_In_ double _X);
_Check_return_ double __cdecl sinh(_In_ double _X);
_Check_return_ _CRT_JIT_INTRINSIC double __cdecl sqrt(_In_ double _X);
_Check_return_ double __cdecl tan(_In_ double _X);
_Check_return_ double __cdecl tanh(_In_ double _X);

_Check_return_ _ACRTIMP double    __cdecl acosh(_In_ double _X);
_Check_return_ _ACRTIMP double    __cdecl asinh(_In_ double _X);
_Check_return_ _ACRTIMP double    __cdecl atanh(_In_ double _X);
_Check_return_ _ACRTIMP  double    __cdecl atof(_In_z_ char const* _String);
_Check_return_ _ACRTIMP  double    __cdecl _atof_l(_In_z_ char const* _String, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP double    __cdecl _cabs(_In_ struct _complex _Complex_value);
_Check_return_ _ACRTIMP double    __cdecl cbrt(_In_ double _X);
_Check_return_ _ACRTIMP double    __cdecl ceil(_In_ double _X);
_Check_return_ _ACRTIMP double    __cdecl _chgsign(_In_ double _X);
_Check_return_ _ACRTIMP double    __cdecl copysign(_In_ double _Number, _In_ double _Sign);
_Check_return_ _ACRTIMP double    __cdecl _copysign(_In_ double _Number, _In_ double _Sign);
_Check_return_ _ACRTIMP double    __cdecl erf(_In_ double _X);
_Check_return_ _ACRTIMP double    __cdecl erfc(_In_ double _X);
_Check_return_ _ACRTIMP double    __cdecl exp2(_In_ double _X);
_Check_return_ _ACRTIMP double    __cdecl expm1(_In_ double _X);
_Check_return_ _ACRTIMP double    __cdecl fdim(_In_ double _X, _In_ double _Y);
_Check_return_ _ACRTIMP double    __cdecl floor(_In_ double _X);
_Check_return_ _ACRTIMP double    __cdecl fma(_In_ double _X, _In_ double _Y, _In_ double _Z);
_Check_return_ _ACRTIMP double    __cdecl fmax(_In_ double _X, _In_ double _Y);
_Check_return_ _ACRTIMP double    __cdecl fmin(_In_ double _X, _In_ double _Y);
_Check_return_ _ACRTIMP double    __cdecl frexp(_In_ double _X, _Out_ int* _Y);
_Check_return_ _ACRTIMP double    __cdecl hypot(_In_ double _X, _In_ double _Y);
_Check_return_ _ACRTIMP double    __cdecl _hypot(_In_ double _X, _In_ double _Y);
_Check_return_ _ACRTIMP int       __cdecl ilogb(_In_ double _X);
_Check_return_ _ACRTIMP double    __cdecl ldexp(_In_ double _X, _In_ int _Y);
_Check_return_ _ACRTIMP double    __cdecl lgamma(_In_ double _X);
_Check_return_ _ACRTIMP long long __cdecl llrint(_In_ double _X);
_Check_return_ _ACRTIMP long long __cdecl llround(_In_ double _X);
_Check_return_ _ACRTIMP double    __cdecl log1p(_In_ double _X);
_Check_return_ _ACRTIMP double    __cdecl log2(_In_ double _X);
_Check_return_ _ACRTIMP double    __cdecl logb(_In_ double _X);
_Check_return_ _ACRTIMP long      __cdecl lrint(_In_ double _X);
_Check_return_ _ACRTIMP long      __cdecl lround(_In_ double _X);

int __CRTDECL _matherr(_Inout_ struct _exception* _Except);

_Check_return_ _ACRTIMP double __cdecl modf(_In_ double _X, _Out_ double* _Y);
_Check_return_ _ACRTIMP double __cdecl nan(_In_ char const* _X);
_Check_return_ _ACRTIMP double __cdecl nearbyint(_In_ double _X);
_Check_return_ _ACRTIMP double __cdecl nextafter(_In_ double _X, _In_ double _Y);
_Check_return_ _ACRTIMP double __cdecl nexttoward(_In_ double _X, _In_ long double _Y);
_Check_return_ _ACRTIMP double __cdecl remainder(_In_ double _X, _In_ double _Y);
_Check_return_ _ACRTIMP double __cdecl remquo(_In_ double _X, _In_ double _Y, _Out_ int* _Z);
_Check_return_ _ACRTIMP double __cdecl rint(_In_ double _X);
_Check_return_ _ACRTIMP double __cdecl round(_In_ double _X);
_Check_return_ _ACRTIMP double __cdecl scalbln(_In_ double _X, _In_ long _Y);
_Check_return_ _ACRTIMP double __cdecl scalbn(_In_ double _X, _In_ int _Y);
_Check_return_ _ACRTIMP double __cdecl tgamma(_In_ double _X);
_Check_return_ _ACRTIMP double __cdecl trunc(_In_ double _X);
_Check_return_ _ACRTIMP double __cdecl _j0(_In_ double _X);
_Check_return_ _ACRTIMP double __cdecl _j1(_In_ double _X);
_Check_return_ _ACRTIMP double __cdecl _jn(int _X, _In_ double _Y);
_Check_return_ _ACRTIMP double __cdecl _y0(_In_ double _X);
_Check_return_ _ACRTIMP double __cdecl _y1(_In_ double _X);
_Check_return_ _ACRTIMP double __cdecl _yn(_In_ int _X, _In_ double _Y);

_Check_return_ _ACRTIMP float     __cdecl acoshf(_In_ float _X);
_Check_return_ _ACRTIMP float     __cdecl asinhf(_In_ float _X);
_Check_return_ _ACRTIMP float     __cdecl atanhf(_In_ float _X);
_Check_return_ _ACRTIMP float     __cdecl cbrtf(_In_ float _X);
_Check_return_ _ACRTIMP float     __cdecl _chgsignf(_In_ float _X);
_Check_return_ _ACRTIMP float     __cdecl copysignf(_In_ float _Number, _In_ float _Sign);
_Check_return_ _ACRTIMP float     __cdecl _copysignf(_In_ float _Number, _In_ float _Sign);
_Check_return_ _ACRTIMP float     __cdecl erff(_In_ float _X);
_Check_return_ _ACRTIMP float     __cdecl erfcf(_In_ float _X);
_Check_return_ _ACRTIMP float     __cdecl expm1f(_In_ float _X);
_Check_return_ _ACRTIMP float     __cdecl exp2f(_In_ float _X);
_Check_return_ _ACRTIMP float     __cdecl fdimf(_In_ float _X, _In_ float _Y);
_Check_return_ _ACRTIMP float     __cdecl fmaf(_In_ float _X, _In_ float _Y, _In_ float _Z);
_Check_return_ _ACRTIMP float     __cdecl fmaxf(_In_ float _X, _In_ float _Y);
_Check_return_ _ACRTIMP float     __cdecl fminf(_In_ float _X, _In_ float _Y);
_Check_return_ _ACRTIMP float     __cdecl _hypotf(_In_ float _X, _In_ float _Y);
_Check_return_ _ACRTIMP int       __cdecl ilogbf(_In_ float _X);
_Check_return_ _ACRTIMP float     __cdecl lgammaf(_In_ float _X);
_Check_return_ _ACRTIMP long long __cdecl llrintf(_In_ float _X);
_Check_return_ _ACRTIMP long long __cdecl llroundf(_In_ float _X);
_Check_return_ _ACRTIMP float     __cdecl log1pf(_In_ float _X);
_Check_return_ _ACRTIMP float     __cdecl log2f(_In_ float _X);
_Check_return_ _ACRTIMP float     __cdecl logbf(_In_ float _X);
_Check_return_ _ACRTIMP long      __cdecl lrintf(_In_ float _X);
_Check_return_ _ACRTIMP long      __cdecl lroundf(_In_ float _X);
_Check_return_ _ACRTIMP float     __cdecl nanf(_In_ char const* _X);
_Check_return_ _ACRTIMP float     __cdecl nearbyintf(_In_ float _X);
_Check_return_ _ACRTIMP float     __cdecl nextafterf(_In_ float _X, _In_ float _Y);
_Check_return_ _ACRTIMP float     __cdecl nexttowardf(_In_ float _X, _In_ long double _Y);
_Check_return_ _ACRTIMP float     __cdecl remainderf(_In_ float _X, _In_ float _Y);
_Check_return_ _ACRTIMP float     __cdecl remquof(_In_ float _X, _In_ float _Y, _Out_ int* _Z);
_Check_return_ _ACRTIMP float     __cdecl rintf(_In_ float _X);
_Check_return_ _ACRTIMP float     __cdecl roundf(_In_ float _X);
_Check_return_ _ACRTIMP float     __cdecl scalblnf(_In_ float _X, _In_ long _Y);
_Check_return_ _ACRTIMP float     __cdecl scalbnf(_In_ float _X, _In_ int _Y);
_Check_return_ _ACRTIMP float     __cdecl tgammaf(_In_ float _X);
_Check_return_ _ACRTIMP float     __cdecl truncf(_In_ float _X);

#if defined _M_IX86

_Check_return_ _ACRTIMP int  __cdecl _set_SSE2_enable(_In_ int _Flag);

#endif

#if defined _M_X64

_Check_return_ _ACRTIMP float __cdecl _logbf(_In_ float _X);
_Check_return_ _ACRTIMP float __cdecl _nextafterf(_In_ float _X, _In_ float _Y);
_Check_return_ _ACRTIMP int   __cdecl _finitef(_In_ float _X);
_Check_return_ _ACRTIMP int   __cdecl _isnanf(_In_ float _X);
_Check_return_ _ACRTIMP int   __cdecl _fpclassf(_In_ float _X);

_Check_return_ _ACRTIMP int   __cdecl _set_FMA3_enable(_In_ int _Flag);
_Check_return_ _ACRTIMP int   __cdecl _get_FMA3_enable(void);

#elif defined _M_ARM || defined _M_ARM64 || defined _M_HYBRID_X86_ARM64

_Check_return_ _ACRTIMP int   __cdecl _finitef(_In_ float _X);
_Check_return_ _ACRTIMP float __cdecl _logbf(_In_ float _X);

#endif



#if defined _M_X64 || defined _M_ARM || defined _M_ARM64 || defined _M_HYBRID_X86_ARM64 || defined _CORECRT_BUILD_APISET || defined _M_ARM64EC

_Check_return_ _ACRTIMP float __cdecl acosf(_In_ float _X);
_Check_return_ _ACRTIMP float __cdecl asinf(_In_ float _X);
_Check_return_ _ACRTIMP float __cdecl atan2f(_In_ float _Y, _In_ float _X);
_Check_return_ _ACRTIMP float __cdecl atanf(_In_ float _X);
_Check_return_ _ACRTIMP float __cdecl ceilf(_In_ float _X);
_Check_return_ _ACRTIMP float __cdecl cosf(_In_ float _X);
_Check_return_ _ACRTIMP float __cdecl coshf(_In_ float _X);
_Check_return_ _ACRTIMP float __cdecl expf(_In_ float _X);

#else

_Check_return_ __inline float __CRTDECL acosf(_In_ float _X)
{
    return (float)acos(_X);
}

_Check_return_ __inline float __CRTDECL asinf(_In_ float _X)
{
    return (float)asin(_X);
}

_Check_return_ __inline float __CRTDECL atan2f(_In_ float _Y, _In_ float _X)
{
    return (float)atan2(_Y, _X);
}

_Check_return_ __inline float __CRTDECL atanf(_In_ float _X)
{
    return (float)atan(_X);
}

_Check_return_ __inline float __CRTDECL ceilf(_In_ float _X)
{
    return (float)ceil(_X);
}

_Check_return_ __inline float __CRTDECL cosf(_In_ float _X)
{
    return (float)cos(_X);
}

_Check_return_ __inline float __CRTDECL coshf(_In_ float _X)
{
    return (float)cosh(_X);
}

_Check_return_ __inline float __CRTDECL expf(_In_ float _X)
{
    return (float)exp(_X);
}

#endif

#if defined _M_ARM || defined _M_ARM64 || defined _M_HYBRID_X86_ARM64 || defined _M_ARM64EC

_Check_return_ _CRT_JIT_INTRINSIC _ACRTIMP float __cdecl fabsf(_In_ float  _X);

#if defined _M_ARM64EC
#pragma intrinsic(fabsf)
#endif

#else

_Check_return_ __inline float __CRTDECL fabsf(_In_ float _X)
{
    return (float)fabs(_X);
}

#endif

#if defined _M_X64 || defined _M_ARM || defined _M_ARM64 || defined _M_HYBRID_X86_ARM64 || defined _M_ARM64EC

_Check_return_ _ACRTIMP float __cdecl floorf(_In_ float _X);
_Check_return_ _ACRTIMP float __cdecl fmodf(_In_ float _X, _In_ float _Y);

#else

_Check_return_ __inline float __CRTDECL floorf(_In_ float _X)
{
    return (float)floor(_X);
}

_Check_return_ __inline float __CRTDECL fmodf(_In_ float _X, _In_ float _Y)
{
    return (float)fmod(_X, _Y);
}

#endif

_Check_return_ __inline float __CRTDECL frexpf(_In_ float _X, _Out_ int* _Y)
{
    return (float)frexp(_X, _Y);
}

_Check_return_ __inline float __CRTDECL hypotf(_In_ float _X, _In_ float _Y)
{
    return _hypotf(_X, _Y);
}

_Check_return_ __inline float __CRTDECL ldexpf(_In_ float _X, _In_ int _Y)
{
    return (float)ldexp(_X, _Y);
}

#if defined _M_X64 || defined _M_ARM || defined _M_ARM64 || defined _M_HYBRID_X86_ARM64 || defined _CORECRT_BUILD_APISET || defined _M_ARM64EC

_Check_return_ _ACRTIMP float  __cdecl log10f(_In_ float _X);
_Check_return_ _ACRTIMP float  __cdecl logf(_In_ float _X);
_Check_return_ _ACRTIMP float  __cdecl modff(_In_ float _X, _Out_ float* _Y);
_Check_return_ _ACRTIMP float  __cdecl powf(_In_ float _X, _In_ float _Y);
_Check_return_ _ACRTIMP float  __cdecl sinf(_In_ float _X);
_Check_return_ _ACRTIMP float  __cdecl sinhf(_In_ float _X);
_Check_return_ _ACRTIMP float  __cdecl sqrtf(_In_ float _X);
_Check_return_ _ACRTIMP float  __cdecl tanf(_In_ float _X);
_Check_return_ _ACRTIMP float  __cdecl tanhf(_In_ float _X);

#else

_Check_return_ __inline float __CRTDECL log10f(_In_ float _X)
{
    return (float)log10(_X);
}

_Check_return_ __inline float __CRTDECL logf(_In_ float _X)
{
    return (float)log(_X);
}

_Check_return_ __inline float __CRTDECL modff(_In_ float _X, _Out_ float* _Y)
{
    double _F, _I;
    _F = modf(_X, &_I);
    *_Y = (float)_I;
    return (float)_F;
}

_Check_return_ __inline float __CRTDECL powf(_In_ float _X, _In_ float _Y)
{
    return (float)pow(_X, _Y);
}

_Check_return_ __inline float __CRTDECL sinf(_In_ float _X)
{
    return (float)sin(_X);
}

_Check_return_ __inline float __CRTDECL sinhf(_In_ float _X)
{
    return (float)sinh(_X);
}

_Check_return_ __inline float __CRTDECL sqrtf(_In_ float _X)
{
    return (float)sqrt(_X);
}

_Check_return_ __inline float __CRTDECL tanf(_In_ float _X)
{
    return (float)tan(_X);
}

_Check_return_ __inline float __CRTDECL tanhf(_In_ float _X)
{
    return (float)tanh(_X);
}

#endif

_Check_return_ _ACRTIMP long double __cdecl acoshl(_In_ long double _X);

_Check_return_ __inline long double __CRTDECL acosl(_In_ long double _X)
{
    return acos((double)_X);
}

_Check_return_ _ACRTIMP long double __cdecl asinhl(_In_ long double _X);

_Check_return_ __inline long double __CRTDECL asinl(_In_ long double _X)
{
    return asin((double)_X);
}

_Check_return_ __inline long double __CRTDECL atan2l(_In_ long double _Y, _In_ long double _X)
{
    return atan2((double)_Y, (double)_X);
}

_Check_return_ _ACRTIMP long double __cdecl atanhl(_In_ long double _X);

_Check_return_ __inline long double __CRTDECL atanl(_In_ long double _X)
{
    return atan((double)_X);
}

_Check_return_ _ACRTIMP long double __cdecl cbrtl(_In_ long double _X);

_Check_return_ __inline long double __CRTDECL ceill(_In_ long double _X)
{
    return ceil((double)_X);
}

_Check_return_ __inline long double __CRTDECL _chgsignl(_In_ long double _X)
{
    return _chgsign((double)_X);
}

_Check_return_ _ACRTIMP long double __cdecl copysignl(_In_ long double _Number, _In_ long double _Sign);

_Check_return_ __inline long double __CRTDECL _copysignl(_In_ long double _Number, _In_ long double _Sign)
{
    return _copysign((double)_Number, (double)_Sign);
}

_Check_return_ __inline long double __CRTDECL coshl(_In_ long double _X)
{
    return cosh((double)_X);
}

_Check_return_ __inline long double __CRTDECL cosl(_In_ long double _X)
{
    return cos((double)_X);
}

_Check_return_ _ACRTIMP long double __cdecl erfl(_In_ long double _X);
_Check_return_ _ACRTIMP long double __cdecl erfcl(_In_ long double _X);

_Check_return_ __inline long double __CRTDECL expl(_In_ long double _X)
{
    return exp((double)_X);
}

_Check_return_ _ACRTIMP long double __cdecl exp2l(_In_ long double _X);
_Check_return_ _ACRTIMP long double __cdecl expm1l(_In_ long double _X);

_Check_return_ __inline long double __CRTDECL fabsl(_In_ long double _X)
{
    return fabs((double)_X);
}

_Check_return_ _ACRTIMP long double __cdecl fdiml(_In_ long double _X, _In_ long double _Y);

_Check_return_ __inline long double __CRTDECL floorl(_In_ long double _X)
{
    return floor((double)_X);
}

_Check_return_ _ACRTIMP long double __cdecl fmal(_In_ long double _X, _In_ long double _Y, _In_ long double _Z);
_Check_return_ _ACRTIMP long double __cdecl fmaxl(_In_ long double _X, _In_ long double _Y);
_Check_return_ _ACRTIMP long double __cdecl fminl(_In_ long double _X, _In_ long double _Y);

_Check_return_ __inline long double __CRTDECL fmodl(_In_ long double _X, _In_ long double _Y)
{
    return fmod((double)_X, (double)_Y);
}

_Check_return_ __inline long double __CRTDECL frexpl(_In_ long double _X, _Out_ int* _Y)
{
    return frexp((double)_X, _Y);
}

_Check_return_ _ACRTIMP int __cdecl ilogbl(_In_ long double _X);

_Check_return_ __inline long double __CRTDECL _hypotl(_In_ long double _X, _In_ long double _Y)
{
    return _hypot((double)_X, (double)_Y);
}

_Check_return_ __inline long double __CRTDECL hypotl(_In_ long double _X, _In_ long double _Y)
{
    return _hypot((double)_X, (double)_Y);
}

_Check_return_ __inline long double __CRTDECL ldexpl(_In_ long double _X, _In_ int _Y)
{
    return ldexp((double)_X, _Y);
}

_Check_return_ _ACRTIMP long double __cdecl lgammal(_In_ long double _X);
_Check_return_ _ACRTIMP long long __cdecl llrintl(_In_ long double _X);
_Check_return_ _ACRTIMP long long __cdecl llroundl(_In_ long double _X);

_Check_return_ __inline long double __CRTDECL logl(_In_ long double _X)
{
    return log((double)_X);
}

_Check_return_ __inline long double __CRTDECL log10l(_In_ long double _X)
{
    return log10((double)_X);
}

_Check_return_ _ACRTIMP long double __cdecl log1pl(_In_ long double _X);
_Check_return_ _ACRTIMP long double __cdecl log2l(_In_ long double _X);
_Check_return_ _ACRTIMP long double __cdecl logbl(_In_ long double _X);
_Check_return_ _ACRTIMP long __cdecl lrintl(_In_ long double _X);
_Check_return_ _ACRTIMP long __cdecl lroundl(_In_ long double _X);

_Check_return_ __inline long double __CRTDECL modfl(_In_ long double _X, _Out_ long double* _Y)
{
    double _F, _I;
    _F = modf((double)_X, &_I);
    *_Y = _I;
    return _F;
}

_Check_return_ _ACRTIMP long double __cdecl nanl(_In_ char const* _X);
_Check_return_ _ACRTIMP long double __cdecl nearbyintl(_In_ long double _X);
_Check_return_ _ACRTIMP long double __cdecl nextafterl(_In_ long double _X, _In_ long double _Y);
_Check_return_ _ACRTIMP long double __cdecl nexttowardl(_In_ long double _X, _In_ long double _Y);

_Check_return_ __inline long double __CRTDECL powl(_In_ long double _X, _In_ long double _Y)
{
    return pow((double)_X, (double)_Y);
}

_Check_return_ _ACRTIMP long double __cdecl remainderl(_In_ long double _X, _In_ long double _Y);
_Check_return_ _ACRTIMP long double __cdecl remquol(_In_ long double _X, _In_ long double _Y, _Out_ int* _Z);
_Check_return_ _ACRTIMP long double __cdecl rintl(_In_ long double _X);
_Check_return_ _ACRTIMP long double __cdecl roundl(_In_ long double _X);
_Check_return_ _ACRTIMP long double __cdecl scalblnl(_In_ long double _X, _In_ long _Y);
_Check_return_ _ACRTIMP long double __cdecl scalbnl(_In_ long double _X, _In_ int _Y);

_Check_return_ __inline long double __CRTDECL sinhl(_In_ long double _X)
{
    return sinh((double)_X);
}

_Check_return_ __inline long double __CRTDECL sinl(_In_ long double _X)
{
    return sin((double)_X);
}

_Check_return_ __inline long double __CRTDECL sqrtl(_In_ long double _X)
{
    return sqrt((double)_X);
}

_Check_return_ __inline long double __CRTDECL tanhl(_In_ long double _X)
{
    return tanh((double)_X);
}

_Check_return_ __inline long double __CRTDECL tanl(_In_ long double _X)
{
    return tan((double)_X);
}

_Check_return_ _ACRTIMP long double __cdecl tgammal(_In_ long double _X);
_Check_return_ _ACRTIMP long double __cdecl truncl(_In_ long double _X);

#ifndef __cplusplus
#define _matherrl _matherr
#endif

#endif // _CRT_FUNCTIONS_REQUIRED

#if defined(_CRT_INTERNAL_NONSTDC_NAMES) && _CRT_INTERNAL_NONSTDC_NAMES

#define DOMAIN      _DOMAIN
#define SING        _SING
#define OVERFLOW    _OVERFLOW
#define UNDERFLOW   _UNDERFLOW
#define TLOSS       _TLOSS
#define PLOSS       _PLOSS

#define matherr     _matherr

#ifndef __assembler
#ifndef _M_CEE_PURE
extern double HUGE;
#else
double const HUGE = _HUGE;
#endif

_CRT_NONSTDC_DEPRECATE(_j0) _Check_return_ _ACRTIMP double __cdecl j0(_In_ double _X);
_CRT_NONSTDC_DEPRECATE(_j1) _Check_return_ _ACRTIMP double __cdecl j1(_In_ double _X);
_CRT_NONSTDC_DEPRECATE(_jn) _Check_return_ _ACRTIMP double __cdecl jn(_In_ int _X, _In_ double _Y);
_CRT_NONSTDC_DEPRECATE(_y0) _Check_return_ _ACRTIMP double __cdecl y0(_In_ double _X);
_CRT_NONSTDC_DEPRECATE(_y1) _Check_return_ _ACRTIMP double __cdecl y1(_In_ double _X);
_CRT_NONSTDC_DEPRECATE(_yn) _Check_return_ _ACRTIMP double __cdecl yn(_In_ int _X, _In_ double _Y);
#endif // !__assembler

#endif // _CRT_INTERNAL_NONSTDC_NAMES

_CRT_END_C_HEADER
_UCRT_RESTORE_CLANG_WARNINGS
#pragma warning(pop) // _UCRT_DISABLED_WARNINGS
#endif /* _INC_MATH */


//
// stdlib.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The C Standard Library <stdlib.h> header.
//
#pragma once
#ifndef _INC_STDLIB // include guard for 3rd party interop
#define _INC_STDLIB

//
// corecrt_malloc.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The memory allocation library.  These pieces of the allocation library are
// shared by both <stdlib.h> and <malloc.h>.
//
#pragma once
#pragma warning(push)
#pragma warning(disable: _UCRT_DISABLED_WARNINGS)
_UCRT_DISABLE_CLANG_WARNINGS

_CRT_BEGIN_C_HEADER



#if defined _DEBUG && defined _CRTDBG_MAP_ALLOC
#pragma push_macro("_aligned_free")
#pragma push_macro("_aligned_malloc")
#pragma push_macro("_aligned_msize")
#pragma push_macro("_aligned_offset_malloc")
#pragma push_macro("_aligned_offset_realloc")
#pragma push_macro("_aligned_offset_recalloc")
#pragma push_macro("_aligned_realloc")
#pragma push_macro("_aligned_recalloc")
#pragma push_macro("_expand")
#pragma push_macro("_freea")
#pragma push_macro("_msize")
#pragma push_macro("_recalloc")
#pragma push_macro("calloc")
#pragma push_macro("free")
#pragma push_macro("malloc")
#pragma push_macro("realloc")

#undef _aligned_free
#undef _aligned_malloc
#undef _aligned_msize
#undef _aligned_offset_malloc
#undef _aligned_offset_realloc
#undef _aligned_offset_recalloc
#undef _aligned_realloc
#undef _aligned_recalloc
#undef _expand
#undef _freea
#undef _msize
#undef _recalloc
#undef calloc
#undef free
#undef malloc
#undef realloc
#endif

_Check_return_ _Ret_maybenull_ _Post_writable_byte_size_(_Count* _Size)
_ACRTIMP _CRTALLOCATOR _CRTRESTRICT
void* __cdecl _calloc_base(
    _In_ size_t _Count,
    _In_ size_t _Size
);

_Check_return_ _Ret_maybenull_ _Post_writable_byte_size_(_Count* _Size)
_ACRTIMP _CRT_JIT_INTRINSIC _CRTALLOCATOR _CRTRESTRICT _CRT_HYBRIDPATCHABLE
void* __cdecl calloc(
    _In_ _CRT_GUARDOVERFLOW size_t _Count,
    _In_ _CRT_GUARDOVERFLOW size_t _Size
);

_Check_return_
_ACRTIMP int __cdecl _callnewh(
    _In_ size_t _Size
);

_Check_return_ _Ret_maybenull_ _Post_writable_byte_size_(_Size)
_ACRTIMP _CRTALLOCATOR _CRT_HYBRIDPATCHABLE
void* __cdecl _expand(
    _Pre_notnull_           void* _Block,
    _In_ _CRT_GUARDOVERFLOW size_t _Size
);

_ACRTIMP
void __cdecl _free_base(
    _Pre_maybenull_ _Post_invalid_ void* _Block
);

_ACRTIMP _CRT_HYBRIDPATCHABLE
void __cdecl free(
    _Pre_maybenull_ _Post_invalid_ void* _Block
);

_Check_return_ _Ret_maybenull_ _Post_writable_byte_size_(_Size)
_ACRTIMP _CRTALLOCATOR _CRTRESTRICT
void* __cdecl _malloc_base(
    _In_ size_t _Size
);

_Check_return_ _Ret_maybenull_ _Post_writable_byte_size_(_Size)
_ACRTIMP _CRTALLOCATOR _CRT_JIT_INTRINSIC _CRTRESTRICT _CRT_HYBRIDPATCHABLE
void* __cdecl malloc(
    _In_ _CRT_GUARDOVERFLOW size_t _Size
);

_Check_return_
_ACRTIMP
size_t __cdecl _msize_base(
    _Pre_notnull_ void* _Block
) _CRT_NOEXCEPT;

_Check_return_
_ACRTIMP _CRT_HYBRIDPATCHABLE
size_t __cdecl _msize(
    _Pre_notnull_ void* _Block
);

_Success_(return != 0) _Check_return_ _Ret_maybenull_ _Post_writable_byte_size_(_Size)
_ACRTIMP _CRTALLOCATOR _CRTRESTRICT
void* __cdecl _realloc_base(
    _Pre_maybenull_ _Post_invalid_  void* _Block,
    _In_                            size_t _Size
);

_Success_(return != 0) _Check_return_ _Ret_maybenull_ _Post_writable_byte_size_(_Size)
_ACRTIMP _CRTALLOCATOR _CRTRESTRICT _CRT_HYBRIDPATCHABLE
void* __cdecl realloc(
    _Pre_maybenull_ _Post_invalid_ void* _Block,
    _In_ _CRT_GUARDOVERFLOW        size_t _Size
);

_Success_(return != 0) _Check_return_ _Ret_maybenull_ _Post_writable_byte_size_(_Count * _Size)
_ACRTIMP _CRTALLOCATOR _CRTRESTRICT
void* __cdecl _recalloc_base(
    _Pre_maybenull_ _Post_invalid_ void* _Block,
    _In_                           size_t _Count,
    _In_                           size_t _Size
);

_Success_(return != 0) _Check_return_ _Ret_maybenull_ _Post_writable_byte_size_(_Count * _Size)
_ACRTIMP _CRTALLOCATOR _CRTRESTRICT
void* __cdecl _recalloc(
    _Pre_maybenull_ _Post_invalid_ void* _Block,
    _In_ _CRT_GUARDOVERFLOW        size_t _Count,
    _In_ _CRT_GUARDOVERFLOW        size_t _Size
);

_ACRTIMP
void __cdecl _aligned_free(
    _Pre_maybenull_ _Post_invalid_ void* _Block
);

_Check_return_ _Ret_maybenull_ _Post_writable_byte_size_(_Size)
_ACRTIMP _CRTALLOCATOR _CRTRESTRICT
void* __cdecl _aligned_malloc(
    _In_ _CRT_GUARDOVERFLOW size_t _Size,
    _In_                    size_t _Alignment
);

_Check_return_ _Ret_maybenull_ _Post_writable_byte_size_(_Size)
_ACRTIMP _CRTALLOCATOR _CRTRESTRICT
void* __cdecl _aligned_offset_malloc(
    _In_ _CRT_GUARDOVERFLOW size_t _Size,
    _In_                    size_t _Alignment,
    _In_                    size_t _Offset
);

_Check_return_
_ACRTIMP
size_t __cdecl _aligned_msize(
    _Pre_notnull_ void* _Block,
    _In_          size_t _Alignment,
    _In_          size_t _Offset
);

_Success_(return != 0) _Check_return_ _Ret_maybenull_ _Post_writable_byte_size_(_Size)
_ACRTIMP _CRTALLOCATOR _CRTRESTRICT
void* __cdecl _aligned_offset_realloc(
    _Pre_maybenull_ _Post_invalid_ void* _Block,
    _In_ _CRT_GUARDOVERFLOW        size_t _Size,
    _In_                           size_t _Alignment,
    _In_                           size_t _Offset
);

_Success_(return != 0) _Check_return_ _Ret_maybenull_ _Post_writable_byte_size_(_Count * _Size)
_ACRTIMP _CRTALLOCATOR _CRTRESTRICT
void* __cdecl _aligned_offset_recalloc(
    _Pre_maybenull_ _Post_invalid_ void* _Block,
    _In_ _CRT_GUARDOVERFLOW        size_t _Count,
    _In_ _CRT_GUARDOVERFLOW        size_t _Size,
    _In_                           size_t _Alignment,
    _In_                           size_t _Offset
);

_Success_(return != 0) _Check_return_ _Ret_maybenull_ _Post_writable_byte_size_(_Size)
_ACRTIMP _CRTALLOCATOR _CRTRESTRICT
void* __cdecl _aligned_realloc(
    _Pre_maybenull_ _Post_invalid_ void* _Block,
    _In_ _CRT_GUARDOVERFLOW        size_t _Size,
    _In_                           size_t _Alignment
);

_Success_(return != 0) _Check_return_ _Ret_maybenull_ _Post_writable_byte_size_(_Count * _Size)
_ACRTIMP _CRTALLOCATOR _CRTRESTRICT
void* __cdecl _aligned_recalloc(
    _Pre_maybenull_ _Post_invalid_ void* _Block,
    _In_ _CRT_GUARDOVERFLOW        size_t _Count,
    _In_ _CRT_GUARDOVERFLOW        size_t _Size,
    _In_                           size_t _Alignment
);

#if defined _DEBUG && defined _CRTDBG_MAP_ALLOC
#pragma pop_macro("realloc")
#pragma pop_macro("malloc")
#pragma pop_macro("free")
#pragma pop_macro("calloc")
#pragma pop_macro("_recalloc")
#pragma pop_macro("_msize")
#pragma pop_macro("_freea")
#pragma pop_macro("_expand")
#pragma pop_macro("_aligned_recalloc")
#pragma pop_macro("_aligned_realloc")
#pragma pop_macro("_aligned_offset_recalloc")
#pragma pop_macro("_aligned_offset_realloc")
#pragma pop_macro("_aligned_offset_malloc")
#pragma pop_macro("_aligned_msize")
#pragma pop_macro("_aligned_malloc")
#pragma pop_macro("_aligned_free")
#endif



_CRT_END_C_HEADER
_UCRT_RESTORE_CLANG_WARNINGS
#pragma warning(pop) // _UCRT_DISABLED_WARNINGS

//
// corecrt_search.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Declarations of functions for sorting and searching.  These declarations are
// split out so that they may be included by both <stdlib.h> and <search.h>.
// <stdlib.h> does not include <search.h> to avoid introducing conflicts with
// other user headers named <search.h>.
//
#pragma once


#pragma warning(push)
#pragma warning(disable: _UCRT_DISABLED_WARNINGS)
_UCRT_DISABLE_CLANG_WARNINGS

_CRT_BEGIN_C_HEADER


typedef int(__cdecl* _CoreCrtSecureSearchSortCompareFunction)(void*, void const*, void const*);
typedef int(__cdecl* _CoreCrtNonSecureSearchSortCompareFunction)(void const*, void const*);


#if __STDC_WANT_SECURE_LIB__

_Check_return_
_ACRTIMP void* __cdecl bsearch_s(
    _In_                                               void const* _Key,
    _In_reads_bytes_(_NumOfElements* _SizeOfElements) void const* _Base,
    _In_                                               rsize_t     _NumOfElements,
    _In_                                               rsize_t     _SizeOfElements,
    _In_                   _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
    _In_opt_                                           void* _Context
);

_ACRTIMP void __cdecl qsort_s(
    _Inout_updates_bytes_(_NumOfElements* _SizeOfElements) void* _Base,
    _In_                                                    rsize_t _NumOfElements,
    _In_                                                    rsize_t _SizeOfElements,
    _In_                    _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
    _In_opt_                                                void* _Context
);

#endif // __STDC_WANT_SECURE_LIB__



_Check_return_
_ACRTIMP void* __cdecl bsearch(
    _In_                                               void const* _Key,
    _In_reads_bytes_(_NumOfElements* _SizeOfElements) void const* _Base,
    _In_                                               size_t      _NumOfElements,
    _In_                                               size_t      _SizeOfElements,
    _In_                _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
);

_ACRTIMP void __cdecl qsort(
    _Inout_updates_bytes_(_NumOfElements* _SizeOfElements) void* _Base,
    _In_                                                    size_t _NumOfElements,
    _In_                                                    size_t _SizeOfElements,
    _In_                _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
);

_Check_return_
_ACRTIMP void* __cdecl _lfind_s(
    _In_                                                  void const* _Key,
    _In_reads_bytes_((*_NumOfElements)* _SizeOfElements) void const* _Base,
    _Inout_                                               unsigned int* _NumOfElements,
    _In_                                                  size_t        _SizeOfElements,
    _In_                        _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
    _In_                                                  void* _Context
);

_Check_return_
_ACRTIMP void* __cdecl _lfind(
    _In_                                                  void const* _Key,
    _In_reads_bytes_((*_NumOfElements)* _SizeOfElements) void const* _Base,
    _Inout_                                               unsigned int* _NumOfElements,
    _In_                                                  unsigned int  _SizeOfElements,
    _In_                     _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
);

_Check_return_
_ACRTIMP void* __cdecl _lsearch_s(
    _In_                                                        void const* _Key,
    _Inout_updates_bytes_((*_NumOfElements)* _SizeOfElements) void* _Base,
    _Inout_                                                     unsigned int* _NumOfElements,
    _In_                                                        size_t        _SizeOfElements,
    _In_                              _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
    _In_                                                        void* _Context
);

_Check_return_
_ACRTIMP void* __cdecl _lsearch(
    _In_                                                        void const* _Key,
    _Inout_updates_bytes_((*_NumOfElements)* _SizeOfElements) void* _Base,
    _Inout_                                                     unsigned int* _NumOfElements,
    _In_                                                        unsigned int  _SizeOfElements,
    _In_                           _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
);



// Managed search routines
#if defined __cplusplus && defined _M_CEE
extern "C++"
{
    typedef int(__clrcall* _CoreCrtMgdSecureSearchSortCompareFunction)(void*, void const*, void const*);
    typedef int(__clrcall* _CoreCrtMgdNonSecureSearchSortCompareFunction)(void const*, void const*);

#if __STDC_WANT_SECURE_LIB__

    _Check_return_
        void* __clrcall bsearch_s(
            _In_                                               void const* _Key,
            _In_reads_bytes_(_NumOfElements* _SizeOfElements) void const* _Base,
            _In_                                               rsize_t     _NumOfElements,
            _In_                                               rsize_t     _SizeOfElements,
            _In_                _CoreCrtMgdSecureSearchSortCompareFunction _CompareFunction,
            _In_                                               void* _Context);

    void __clrcall qsort_s(
        _Inout_updates_bytes_(_NumOfElements* _SizeOfElements) void* _Base,
        _In_                                                    rsize_t _NumOfElements,
        _In_                                                    rsize_t _SizeOfElements,
        _In_                 _CoreCrtMgdSecureSearchSortCompareFunction _CompareFunction,
        _In_                                                    void* _Context);

#endif // __STDC_WANT_SECURE_LIB__

    _Check_return_
        void* __clrcall bsearch(
            _In_                                               void const* _Key,
            _In_reads_bytes_(_NumOfElements* _SizeOfElements) void const* _Base,
            _In_                                               size_t _NumOfElements,
            _In_                                               size_t _SizeOfElements,
            _In_        _CoreCrtMgdNonSecureSearchSortCompareFunction _CompareFunction
        );

    _Check_return_
        void* __clrcall _lfind_s(
            _In_                                               void const* _Key,
            _In_reads_bytes_(_NumOfElements* _SizeOfElements) void const* _Base,
            _Inout_                                            unsigned int* _NumOfElements,
            _In_                                               size_t        _SizeOfElements,
            _In_                  _CoreCrtMgdSecureSearchSortCompareFunction _CompareFunction,
            _In_                                               void* _Context
        );

    _Check_return_
        void* __clrcall _lfind(
            _In_                                                  void const* _Key,
            _In_reads_bytes_((*_NumOfElements)* _SizeOfElements) void const* _Base,
            _Inout_                                               unsigned int* _NumOfElements,
            _In_                                                  unsigned int  _SizeOfElements,
            _In_                  _CoreCrtMgdNonSecureSearchSortCompareFunction _CompareFunction
        );

    _Check_return_
        void* __clrcall _lsearch_s(
            _In_                                                  void const* _Key,
            _In_reads_bytes_((*_NumOfElements)* _SizeOfElements) void* _Base,
            _In_                                                  unsigned int* _NumOfElements,
            _In_                                                  size_t        _SizeOfElements,
            _In_                     _CoreCrtMgdSecureSearchSortCompareFunction _CompareFunction,
            _In_                                                  void* _Context
        );

    _Check_return_
        void* __clrcall _lsearch(
            _In_                                                       void const* _Key,
            _Inout_updates_bytes_((*_NumOfElements)* _SizeOfElements) void* _Base,
            _Inout_                                                    unsigned int* _NumOfElements,
            _In_                                                       unsigned int  _SizeOfElements,
            _In_                       _CoreCrtMgdNonSecureSearchSortCompareFunction _CompareFunction
        );

    void __clrcall qsort(
        _Inout_updates_bytes_(_NumOfElements* _SizeOfElements) void* _Base,
        _In_                                                    size_t _NumOfElements,
        _In_                                                    size_t _SizeOfElements,
        _In_             _CoreCrtMgdNonSecureSearchSortCompareFunction _CompareFunction
    );
}
#endif // defined __cplusplus && defined _M_CEE



#if defined(_CRT_INTERNAL_NONSTDC_NAMES) && _CRT_INTERNAL_NONSTDC_NAMES

_Check_return_ _CRT_NONSTDC_DEPRECATE(_lfind)
_ACRTIMP void* __cdecl lfind(
    _In_                                                  void const* _Key,
    _In_reads_bytes_((*_NumOfElements)* _SizeOfElements) void const* _Base,
    _Inout_                                               unsigned int* _NumOfElements,
    _In_                                                  unsigned int  _SizeOfElements,
    _In_                     _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
);

_Check_return_ _CRT_NONSTDC_DEPRECATE(_lsearch)
_ACRTIMP void* __cdecl lsearch(
    _In_                                                       void const* _Key,
    _Inout_updates_bytes_((*_NumOfElements)* _SizeOfElements) void* _Base,
    _Inout_                                                    unsigned int* _NumOfElements,
    _In_                                                       unsigned int  _SizeOfElements,
    _In_                          _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
);

#endif // _CRT_INTERNAL_NONSTDC_NAMES



_CRT_END_C_HEADER
_UCRT_RESTORE_CLANG_WARNINGS
#pragma warning(pop) // _UCRT_DISABLED_WARNINGS

//
// corecrt_wstdlib.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// This file declares the wide character (wchar_t) C Standard Library functions
// that are declared by both <stdlib.h> and <wchar.h>.
//
#pragma once

#pragma warning(push)
#pragma warning(disable: _UCRT_DISABLED_WARNINGS)
_UCRT_DISABLE_CLANG_WARNINGS

_CRT_BEGIN_C_HEADER



// Maximum number of elements, including null terminator (and negative sign
// where appropriate), needed for integer-to-string conversions for several
// bases and integer types.
#define _MAX_ITOSTR_BASE16_COUNT   (8  + 1)
#define _MAX_ITOSTR_BASE10_COUNT   (1 + 10 + 1)
#define _MAX_ITOSTR_BASE8_COUNT    (11 + 1)
#define _MAX_ITOSTR_BASE2_COUNT    (32 + 1)

#define _MAX_LTOSTR_BASE16_COUNT   (8  + 1)
#define _MAX_LTOSTR_BASE10_COUNT   (1 + 10 + 1)
#define _MAX_LTOSTR_BASE8_COUNT    (11 + 1)
#define _MAX_LTOSTR_BASE2_COUNT    (32 + 1)

#define _MAX_ULTOSTR_BASE16_COUNT  (8  + 1)
#define _MAX_ULTOSTR_BASE10_COUNT  (10 + 1)
#define _MAX_ULTOSTR_BASE8_COUNT   (11 + 1)
#define _MAX_ULTOSTR_BASE2_COUNT   (32 + 1)

#define _MAX_I64TOSTR_BASE16_COUNT (16 + 1)
#define _MAX_I64TOSTR_BASE10_COUNT (1 + 19 + 1)
#define _MAX_I64TOSTR_BASE8_COUNT  (22 + 1)
#define _MAX_I64TOSTR_BASE2_COUNT  (64 + 1)

#define _MAX_U64TOSTR_BASE16_COUNT (16 + 1)
#define _MAX_U64TOSTR_BASE10_COUNT (20 + 1)
#define _MAX_U64TOSTR_BASE8_COUNT  (22 + 1)
#define _MAX_U64TOSTR_BASE2_COUNT  (64 + 1)


#if _CRT_FUNCTIONS_REQUIRED

_Success_(return == 0)
_Check_return_wat_
_ACRTIMP errno_t __cdecl _itow_s(
    _In_                         int      _Value,
    _Out_writes_z_(_BufferCount) wchar_t* _Buffer,
    _In_                         size_t   _BufferCount,
    _In_                         int      _Radix
);

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1(
    errno_t, _itow_s,
    _In_ int, _Value,
    wchar_t, _Buffer,
    _In_ int, _Radix
)

__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1(
    wchar_t*, __RETURN_POLICY_DST, _ACRTIMP, _itow,
    _In_                    int, _Value,
    _Pre_notnull_ _Post_z_, wchar_t, _Buffer,
    _In_                    int, _Radix
)

_Success_(return == 0)
_Check_return_wat_
_ACRTIMP errno_t __cdecl _ltow_s(
    _In_                         long     _Value,
    _Out_writes_z_(_BufferCount) wchar_t* _Buffer,
    _In_                         size_t   _BufferCount,
    _In_                         int      _Radix
);

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1(
    errno_t, _ltow_s,
    _In_ long, _Value,
    wchar_t, _Buffer,
    _In_ int, _Radix
)

__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1(
    wchar_t*, __RETURN_POLICY_DST, _ACRTIMP, _ltow,
    _In_                    long, _Value,
    _Pre_notnull_ _Post_z_, wchar_t, _Buffer,
    _In_                    int, _Radix
)

_Check_return_wat_
_ACRTIMP errno_t __cdecl _ultow_s(
    _In_                         unsigned long _Value,
    _Out_writes_z_(_BufferCount) wchar_t* _Buffer,
    _In_                         size_t        _BufferCount,
    _In_                         int           _Radix
);

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1(
    errno_t, _ultow_s,
    _In_ unsigned long, _Value,
    wchar_t, _Buffer,
    _In_ int, _Radix
)

__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1(
    wchar_t*, __RETURN_POLICY_DST, _ACRTIMP, _ultow,
    _In_                    unsigned long, _Value,
    _Pre_notnull_ _Post_z_, wchar_t, _Buffer,
    _In_                    int, _Radix
)

_Check_return_
_ACRTIMP double __cdecl wcstod(
    _In_z_                   wchar_t const* _String,
    _Out_opt_ _Deref_post_z_ wchar_t** _EndPtr
);

_Check_return_
_ACRTIMP double __cdecl _wcstod_l(
    _In_z_                   wchar_t const* _String,
    _Out_opt_ _Deref_post_z_ wchar_t** _EndPtr,
    _In_opt_                 _locale_t      _Locale
);

_Check_return_
_ACRTIMP long __cdecl wcstol(
    _In_z_                   wchar_t const* _String,
    _Out_opt_ _Deref_post_z_ wchar_t** _EndPtr,
    _In_                     int            _Radix
);

_Check_return_
_ACRTIMP long __cdecl _wcstol_l(
    _In_z_                   wchar_t const* _String,
    _Out_opt_ _Deref_post_z_ wchar_t** _EndPtr,
    _In_                     int            _Radix,
    _In_opt_                 _locale_t      _Locale
);

_Check_return_
_ACRTIMP long long __cdecl wcstoll(
    _In_z_                   wchar_t const* _String,
    _Out_opt_ _Deref_post_z_ wchar_t** _EndPtr,
    _In_                     int            _Radix
);

_Check_return_
_ACRTIMP long long __cdecl _wcstoll_l(
    _In_z_                   wchar_t const* _String,
    _Out_opt_ _Deref_post_z_ wchar_t** _EndPtr,
    _In_                     int            _Radix,
    _In_opt_                 _locale_t      _Locale
);

_Check_return_
_ACRTIMP unsigned long __cdecl wcstoul(
    _In_z_                   wchar_t const* _String,
    _Out_opt_ _Deref_post_z_ wchar_t** _EndPtr,
    _In_                     int            _Radix
);

_Check_return_
_ACRTIMP unsigned long __cdecl _wcstoul_l(
    _In_z_                   wchar_t const* _String,
    _Out_opt_ _Deref_post_z_ wchar_t** _EndPtr,
    _In_                     int            _Radix,
    _In_opt_                 _locale_t      _Locale
);

_Check_return_
_ACRTIMP unsigned long long __cdecl wcstoull(
    _In_z_                   wchar_t const* _String,
    _Out_opt_ _Deref_post_z_ wchar_t** _EndPtr,
    _In_                     int            _Radix
);

_Check_return_
_ACRTIMP unsigned long long __cdecl _wcstoull_l(
    _In_z_                   wchar_t const* _String,
    _Out_opt_ _Deref_post_z_ wchar_t** _EndPtr,
    _In_                     int            _Radix,
    _In_opt_                 _locale_t      _Locale
);

_Check_return_
_ACRTIMP long double __cdecl wcstold(
    _In_z_                   wchar_t const* _String,
    _Out_opt_ _Deref_post_z_ wchar_t** _EndPtr
);

_Check_return_
_ACRTIMP long double __cdecl _wcstold_l(
    _In_z_                   wchar_t const* _String,
    _Out_opt_ _Deref_post_z_ wchar_t** _EndPtr,
    _In_opt_                 _locale_t      _Locale
);

_Check_return_
_ACRTIMP float __cdecl wcstof(
    _In_z_                   wchar_t const* _String,
    _Out_opt_ _Deref_post_z_ wchar_t** _EndPtr
);

_Check_return_
_ACRTIMP float __cdecl _wcstof_l(
    _In_z_                   wchar_t const* _String,
    _Out_opt_ _Deref_post_z_ wchar_t** _EndPtr,
    _In_opt_                 _locale_t      _Locale
);

_Check_return_
_ACRTIMP double __cdecl _wtof(
    _In_z_ wchar_t const* _String
);

_Check_return_
_ACRTIMP double __cdecl _wtof_l(
    _In_z_   wchar_t const* _String,
    _In_opt_ _locale_t      _Locale
);

_Check_return_
_ACRTIMP int __cdecl _wtoi(
    _In_z_ wchar_t const* _String
);

_Check_return_
_ACRTIMP int __cdecl _wtoi_l(
    _In_z_   wchar_t const* _String,
    _In_opt_ _locale_t      _Locale
);

_Check_return_
_ACRTIMP long __cdecl _wtol(
    _In_z_ wchar_t const* _String
);

_Check_return_
_ACRTIMP long __cdecl _wtol_l(
    _In_z_   wchar_t const* _String,
    _In_opt_ _locale_t      _Locale
);

_Check_return_
_ACRTIMP long long __cdecl _wtoll(
    _In_z_ wchar_t const* _String
);

_Check_return_
_ACRTIMP long long __cdecl _wtoll_l(
    _In_z_   wchar_t const* _String,
    _In_opt_ _locale_t      _Locale
);

_Check_return_wat_
_ACRTIMP errno_t __cdecl _i64tow_s(
    _In_                         __int64  _Value,
    _Out_writes_z_(_BufferCount) wchar_t* _Buffer,
    _In_                         size_t   _BufferCount,
    _In_                         int      _Radix
);

_CRT_INSECURE_DEPRECATE(_i64tow_s)
_ACRTIMP wchar_t* __cdecl _i64tow(
    _In_                   __int64  _Value,
    _Pre_notnull_ _Post_z_ wchar_t* _Buffer,
    _In_                   int      _Radix
);

_Check_return_wat_
_ACRTIMP errno_t __cdecl _ui64tow_s(
    _In_                         unsigned __int64 _Value,
    _Out_writes_z_(_BufferCount) wchar_t* _Buffer,
    _In_                         size_t           _BufferCount,
    _In_                         int              _Radix
);

_CRT_INSECURE_DEPRECATE(_ui64tow_s)
_ACRTIMP wchar_t* __cdecl _ui64tow(
    _In_                   unsigned __int64 _Value,
    _Pre_notnull_ _Post_z_ wchar_t* _Buffer,
    _In_                   int              _Radix
);

_Check_return_
_ACRTIMP __int64 __cdecl _wtoi64(
    _In_z_ wchar_t const* _String
);

_Check_return_
_ACRTIMP __int64 __cdecl _wtoi64_l(
    _In_z_   wchar_t const* _String,
    _In_opt_ _locale_t      _Locale
);

_Check_return_
_ACRTIMP __int64 __cdecl _wcstoi64(
    _In_z_                   wchar_t const* _String,
    _Out_opt_ _Deref_post_z_ wchar_t** _EndPtr,
    _In_                     int            _Radix
);

_Check_return_
_ACRTIMP __int64 __cdecl _wcstoi64_l(
    _In_z_                   wchar_t const* _String,
    _Out_opt_ _Deref_post_z_ wchar_t** _EndPtr,
    _In_                     int            _Radix,
    _In_opt_                 _locale_t      _Locale
);

_Check_return_
_ACRTIMP unsigned __int64 __cdecl _wcstoui64(
    _In_z_                   wchar_t const* _String,
    _Out_opt_ _Deref_post_z_ wchar_t** _EndPtr,
    _In_                     int            _Radix
);

_Check_return_
_ACRTIMP unsigned __int64 __cdecl _wcstoui64_l(
    _In_z_                   wchar_t const* _String,
    _Out_opt_ _Deref_post_z_ wchar_t** _EndPtr,
    _In_                     int            _Radix,
    _In_opt_                 _locale_t      _Locale
);

#pragma push_macro("_wfullpath")
#undef _wfullpath

_Success_(return != 0)
_Check_return_
_ACRTIMP _CRTALLOCATOR wchar_t* __cdecl _wfullpath(
    _Out_writes_opt_z_(_BufferCount) wchar_t* _Buffer,
    _In_z_                           wchar_t const* _Path,
    _In_                             size_t         _BufferCount
);

#pragma pop_macro("_wfullpath")

_Check_return_wat_
_ACRTIMP errno_t __cdecl _wmakepath_s(
    _Out_writes_z_(_BufferCount) wchar_t* _Buffer,
    _In_                         size_t         _BufferCount,
    _In_opt_z_                   wchar_t const* _Drive,
    _In_opt_z_                   wchar_t const* _Dir,
    _In_opt_z_                   wchar_t const* _Filename,
    _In_opt_z_                   wchar_t const* _Ext
);

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_4(
    errno_t, _wmakepath_s,
    wchar_t, _Buffer,
    _In_opt_z_ wchar_t const*, _Drive,
    _In_opt_z_ wchar_t const*, _Dir,
    _In_opt_z_ wchar_t const*, _Filename,
    _In_opt_z_ wchar_t const*, _Ext
)

__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4(
    void, __RETURN_POLICY_VOID, _ACRTIMP, _wmakepath,
    _Pre_notnull_ _Post_z_, wchar_t, _Buffer,
    _In_opt_z_              wchar_t const*, _Drive,
    _In_opt_z_              wchar_t const*, _Dir,
    _In_opt_z_              wchar_t const*, _Filename,
    _In_opt_z_              wchar_t const*, _Ext
)

_ACRTIMP void __cdecl _wperror(
    _In_opt_z_ wchar_t const* _ErrorMessage
);

_CRT_INSECURE_DEPRECATE(_wsplitpath_s)
_ACRTIMP void __cdecl _wsplitpath(
    _In_z_                   wchar_t const* _FullPath,
    _Pre_maybenull_ _Post_z_ wchar_t* _Drive,
    _Pre_maybenull_ _Post_z_ wchar_t* _Dir,
    _Pre_maybenull_ _Post_z_ wchar_t* _Filename,
    _Pre_maybenull_ _Post_z_ wchar_t* _Ext
);

_ACRTIMP errno_t __cdecl _wsplitpath_s(
    _In_z_                             wchar_t const* _FullPath,
    _Out_writes_opt_z_(_DriveCount)    wchar_t* _Drive,
    _In_                               size_t         _DriveCount,
    _Out_writes_opt_z_(_DirCount)      wchar_t* _Dir,
    _In_                               size_t         _DirCount,
    _Out_writes_opt_z_(_FilenameCount) wchar_t* _Filename,
    _In_                               size_t         _FilenameCount,
    _Out_writes_opt_z_(_ExtCount)      wchar_t* _Ext,
    _In_                               size_t         _ExtCount
);

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_SPLITPATH(
    errno_t, _wsplitpath_s,
    wchar_t, _Path
)

#pragma push_macro("_wdupenv_s")
#undef _wdupenv_s

_Check_return_wat_
_DCRTIMP errno_t __cdecl _wdupenv_s(
    _Outptr_result_buffer_maybenull_(*_BufferCount) _Outptr_result_maybenull_z_ wchar_t** _Buffer,
    _Out_opt_                                                                   size_t * _BufferCount,
    _In_z_                                                                      wchar_t const* _VarName
);

#pragma pop_macro("_wdupenv_s")

_Check_return_ _CRT_INSECURE_DEPRECATE(_wdupenv_s)
_DCRTIMP wchar_t* __cdecl _wgetenv(
    _In_z_ wchar_t const* _VarName
);

_Success_(return == 0)
_Check_return_wat_
_DCRTIMP errno_t __cdecl _wgetenv_s(
    _Out_                            size_t * _RequiredCount,
    _Out_writes_opt_z_(_BufferCount) wchar_t* _Buffer,
    _In_                             size_t         _BufferCount,
    _In_z_                           wchar_t const* _VarName
);

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1(
    _Success_(return == 0)
    errno_t, _wgetenv_s,
    _Out_  size_t*, _RequiredCount,
    wchar_t, _Buffer,
    _In_z_ wchar_t const*, _VarName
)

_Check_return_
_DCRTIMP int __cdecl _wputenv(
    _In_z_ wchar_t const* _EnvString
);

_Check_return_wat_
_DCRTIMP errno_t __cdecl _wputenv_s(
    _In_z_ wchar_t const* _Name,
    _In_z_ wchar_t const* _Value
);

_DCRTIMP errno_t __cdecl _wsearchenv_s(
    _In_z_                       wchar_t const* _Filename,
    _In_z_                       wchar_t const* _VarName,
    _Out_writes_z_(_BufferCount) wchar_t* _Buffer,
    _In_                         size_t         _BufferCount
);

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_2_0(
    errno_t, _wsearchenv_s,
    _In_z_ wchar_t const*, _Filename,
    _In_z_ wchar_t const*, _VarName,
    wchar_t, _ResultPath
)

__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_2_0(
    void, __RETURN_POLICY_VOID, _DCRTIMP, _wsearchenv,
    _In_z_                  wchar_t const*, _Filename,
    _In_z_                  wchar_t const*, _VarName,
    _Pre_notnull_ _Post_z_, wchar_t, _ResultPath
)

_DCRTIMP int __cdecl _wsystem(
    _In_opt_z_ wchar_t const* _Command
);

#endif // _CRT_FUNCTIONS_REQUIRED



_CRT_END_C_HEADER
_UCRT_RESTORE_CLANG_WARNINGS
#pragma warning(pop) // _UCRT_DISABLED_WARNINGS

//
// limits.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The C Standard Library <limits.h> header.
//
#pragma once
#define _INC_LIMITS


#pragma warning(push)
#pragma warning(disable: _VCRUNTIME_DISABLED_WARNINGS)

_CRT_BEGIN_C_HEADER

#define CHAR_BIT      8
#define SCHAR_MIN   (-128)
#define SCHAR_MAX     127
#define UCHAR_MAX     0xff

#ifndef _CHAR_UNSIGNED
#define CHAR_MIN    SCHAR_MIN
#define CHAR_MAX    SCHAR_MAX
#else
#define CHAR_MIN    0
#define CHAR_MAX    UCHAR_MAX
#endif

#define MB_LEN_MAX    5
#define SHRT_MIN    (-32768)
#define SHRT_MAX      32767
#define USHRT_MAX     0xffff
#define INT_MIN     (-2147483647 - 1)
#define INT_MAX       2147483647
#define UINT_MAX      0xffffffff
#define LONG_MIN    (-2147483647L - 1)
#define LONG_MAX      2147483647L
#define ULONG_MAX     0xffffffffUL
#define LLONG_MAX     9223372036854775807i64
#define LLONG_MIN   (-9223372036854775807i64 - 1)
#define ULLONG_MAX    0xffffffffffffffffui64

#define _I8_MIN     (-127i8 - 1)
#define _I8_MAX       127i8
#define _UI8_MAX      0xffui8

#define _I16_MIN    (-32767i16 - 1)
#define _I16_MAX      32767i16
#define _UI16_MAX     0xffffui16

#define _I32_MIN    (-2147483647i32 - 1)
#define _I32_MAX      2147483647i32
#define _UI32_MAX     0xffffffffui32

#define _I64_MIN    (-9223372036854775807i64 - 1)
#define _I64_MAX      9223372036854775807i64
#define _UI64_MAX     0xffffffffffffffffui64

#ifndef SIZE_MAX
// SIZE_MAX definition must match exactly with stdint.h for modules support.
#ifdef _WIN64
#define SIZE_MAX 0xffffffffffffffffui64
#else
#define SIZE_MAX 0xffffffffui32
#endif
#endif

#if __STDC_WANT_SECURE_LIB__
#ifndef RSIZE_MAX
#define RSIZE_MAX (SIZE_MAX >> 1)
#endif
#endif

_CRT_END_C_HEADER

#pragma warning(pop) // _VCRUNTIME_DISABLED_WARNINGS

#pragma warning(push)
#pragma warning(disable: _UCRT_DISABLED_WARNINGS)
_UCRT_DISABLE_CLANG_WARNINGS

_CRT_BEGIN_C_HEADER



#ifndef _countof
#define _countof __crt_countof
#endif



// Minimum and maximum macros
#define __max(a,b) (((a) > (b)) ? (a) : (b))
#define __min(a,b) (((a) < (b)) ? (a) : (b))



    _ACRTIMP void __cdecl _swab(
        _Inout_updates_(_SizeInBytes) _Post_readable_size_(_SizeInBytes) char* _Buf1,
        _Inout_updates_(_SizeInBytes) _Post_readable_size_(_SizeInBytes) char* _Buf2,
        _In_                                                             int   _SizeInBytes
    );



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Exit and Abort
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// Argument values for exit()
#define EXIT_SUCCESS 0
#define EXIT_FAILURE 1

#if _CRT_FUNCTIONS_REQUIRED
_ACRTIMP __declspec(noreturn) void __cdecl exit(_In_ int _Code);
_ACRTIMP __declspec(noreturn) void __cdecl _exit(_In_ int _Code);
_ACRTIMP __declspec(noreturn) void __cdecl _Exit(_In_ int _Code);
_ACRTIMP __declspec(noreturn) void __cdecl quick_exit(_In_ int _Code);
_ACRTIMP __declspec(noreturn) void __cdecl abort(void);
#endif // _CRT_FUNCTIONS_REQUIRED

// Argument values for _set_abort_behavior().
#define _WRITE_ABORT_MSG  0x1 // debug only, has no effect in release
#define _CALL_REPORTFAULT 0x2

_ACRTIMP unsigned int __cdecl _set_abort_behavior(
    _In_ unsigned int _Flags,
    _In_ unsigned int _Mask
);



#ifndef _CRT_ONEXIT_T_DEFINED
#define _CRT_ONEXIT_T_DEFINED

typedef int (__CRTDECL* _onexit_t)(void);
#ifdef _M_CEE
typedef int(__clrcall* _onexit_m_t)(void);
#endif
#endif

#if defined(_CRT_INTERNAL_NONSTDC_NAMES) && _CRT_INTERNAL_NONSTDC_NAMES
// Non-ANSI name for compatibility
#define onexit_t _onexit_t
#endif



#ifdef _M_CEE
#pragma warning (push)
#pragma warning (disable: 4985) // Attributes not present on previous declaration

_Check_return_ int __clrcall _atexit_m_appdomain(_In_opt_ void(__clrcall* _Function)(void));

_onexit_m_t __clrcall _onexit_m_appdomain(_onexit_m_t _Function);

#ifdef _M_CEE_MIXED
#ifdef __cplusplus
[System::Security::SecurityCritical]
#endif
_Check_return_ int __clrcall _atexit_m(_In_opt_ void(__clrcall* _Function)(void));

_onexit_m_t __clrcall _onexit_m(_onexit_m_t _Function);
#else
#ifdef __cplusplus
[System::Security::SecurityCritical]
#endif
_Check_return_ inline int __clrcall _atexit_m(_In_opt_ void(__clrcall* _Function)(void))
{
    return _atexit_m_appdomain(_Function);
}

inline _onexit_m_t __clrcall _onexit_m(_onexit_t _Function)
{
    return _onexit_m_appdomain(_Function);
}
#endif
#pragma warning (pop)
#endif



#ifdef _M_CEE_PURE
// In pure mode, atexit is the same as atexit_m_appdomain
extern "C++"
{

#ifdef __cplusplus
    [System::Security::SecurityCritical]
#endif
        inline  int __clrcall atexit(void(__clrcall* _Function)(void))
    {
        return _atexit_m_appdomain(_Function);
    }

    inline _onexit_t __clrcall _onexit(_onexit_t _Function)
    {
        return _onexit_m_appdomain(_Function);
    }

} // extern "C++"
#else
int       __cdecl atexit(void(__cdecl*)(void));
_onexit_t __cdecl _onexit(_In_opt_ _onexit_t _Func);
#endif

int __cdecl at_quick_exit(void(__cdecl*)(void));



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Global State (errno, global handlers, etc.)
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#ifndef _M_CEE_PURE
    // a purecall handler procedure. Never returns normally
typedef void(__cdecl* _purecall_handler)(void);

// Invalid parameter handler function pointer type
typedef void(__cdecl* _invalid_parameter_handler)(
    wchar_t const*,
    wchar_t const*,
    wchar_t const*,
    unsigned int,
    uintptr_t
    );

// Establishes a purecall handler
_VCRTIMP _purecall_handler __cdecl _set_purecall_handler(
    _In_opt_ _purecall_handler _Handler
);

_VCRTIMP _purecall_handler __cdecl _get_purecall_handler(void);

// Establishes an invalid parameter handler
_ACRTIMP _invalid_parameter_handler __cdecl _set_invalid_parameter_handler(
    _In_opt_ _invalid_parameter_handler _Handler
);

_ACRTIMP _invalid_parameter_handler __cdecl _get_invalid_parameter_handler(void);

_ACRTIMP _invalid_parameter_handler __cdecl _set_thread_local_invalid_parameter_handler(
    _In_opt_ _invalid_parameter_handler _Handler
);

_ACRTIMP _invalid_parameter_handler __cdecl _get_thread_local_invalid_parameter_handler(void);
#endif


#if defined __cplusplus && defined _M_CEE_PURE
extern "C++"
{
    typedef void(__clrcall* _purecall_handler)(void);
    typedef _purecall_handler _purecall_handler_m;

    _MRTIMP _purecall_handler __cdecl _set_purecall_handler(
        _In_opt_ _purecall_handler _Handler
    );
} // extern "C++"
#endif



// Argument values for _set_error_mode().
#define _OUT_TO_DEFAULT 0
#define _OUT_TO_STDERR  1
#define _OUT_TO_MSGBOX  2
#define _REPORT_ERRMODE 3

_Check_return_opt_ _ACRTIMP int __cdecl _set_error_mode(_In_ int _Mode);



#if _CRT_FUNCTIONS_REQUIRED
_ACRTIMP int* __cdecl _errno(void);
#define errno (*_errno())

_ACRTIMP errno_t __cdecl _set_errno(_In_ int _Value);
_ACRTIMP errno_t __cdecl _get_errno(_Out_ int* _Value);

_ACRTIMP unsigned long* __cdecl __doserrno(void);
#define _doserrno (*__doserrno())

_ACRTIMP errno_t __cdecl _set_doserrno(_In_ unsigned long _Value);
_ACRTIMP errno_t __cdecl _get_doserrno(_Out_ unsigned long* _Value);

// This is non-const for backwards compatibility; do not modify it.
_ACRTIMP _CRT_INSECURE_DEPRECATE(strerror) char** __cdecl __sys_errlist(void);
#define _sys_errlist (__sys_errlist())

_ACRTIMP _CRT_INSECURE_DEPRECATE(strerror) int* __cdecl __sys_nerr(void);
#define _sys_nerr (*__sys_nerr())

_ACRTIMP void __cdecl perror(_In_opt_z_ char const* _ErrMsg);
#endif // _CRT_FUNCTIONS_REQUIRED



// These point to the executable module name.
_CRT_INSECURE_DEPRECATE_GLOBALS(_get_pgmptr) _ACRTIMP char** __cdecl __p__pgmptr(void);
_CRT_INSECURE_DEPRECATE_GLOBALS(_get_wpgmptr) _ACRTIMP wchar_t** __cdecl __p__wpgmptr(void);
_CRT_INSECURE_DEPRECATE_GLOBALS(_get_fmode) _ACRTIMP int* __cdecl __p__fmode(void);

#ifdef _CRT_DECLARE_GLOBAL_VARIABLES_DIRECTLY
_CRT_INSECURE_DEPRECATE_GLOBALS(_get_pgmptr) extern char* _pgmptr;
_CRT_INSECURE_DEPRECATE_GLOBALS(_get_wpgmptr) extern wchar_t* _wpgmptr;
#ifndef _CORECRT_BUILD
_CRT_INSECURE_DEPRECATE_GLOBALS(_get_fmode) extern int      _fmode;
#endif
#else
#define _pgmptr  (*__p__pgmptr ())
#define _wpgmptr (*__p__wpgmptr())
#define _fmode   (*__p__fmode  ())
#endif

_Success_(return == 0)
_ACRTIMP errno_t __cdecl _get_pgmptr(_Outptr_result_z_ char** _Value);

_Success_(return == 0)
_ACRTIMP errno_t __cdecl _get_wpgmptr(_Outptr_result_z_ wchar_t** _Value);

_ACRTIMP errno_t __cdecl _set_fmode(_In_              int       _Mode);

_ACRTIMP errno_t __cdecl _get_fmode(_Out_             int* _PMode);



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Math
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
typedef struct _div_t
{
    int quot;
    int rem;
} div_t;

typedef struct _ldiv_t
{
    long quot;
    long rem;
} ldiv_t;

typedef struct _lldiv_t
{
    long long quot;
    long long rem;
} lldiv_t;

_Check_return_ int       __cdecl abs(_In_ int       _Number);
_Check_return_ long      __cdecl labs(_In_ long      _Number);
_Check_return_ long long __cdecl llabs(_In_ long long _Number);
_Check_return_ __int64   __cdecl _abs64(_In_ __int64   _Number);

_Check_return_ unsigned short   __cdecl _byteswap_ushort(_In_ unsigned short   _Number);
_Check_return_ unsigned long    __cdecl _byteswap_ulong(_In_ unsigned long    _Number);
_Check_return_ unsigned __int64 __cdecl _byteswap_uint64(_In_ unsigned __int64 _Number);

_Check_return_ _ACRTIMP div_t   __cdecl div(_In_ int       _Numerator, _In_ int       _Denominator);
_Check_return_ _ACRTIMP ldiv_t  __cdecl ldiv(_In_ long      _Numerator, _In_ long      _Denominator);
_Check_return_ _ACRTIMP lldiv_t __cdecl lldiv(_In_ long long _Numerator, _In_ long long _Denominator);

// These functions have declspecs in their declarations in the Windows headers,
// which cause PREfast to fire 6540.
#pragma warning(push)
#pragma warning(disable: 6540)

unsigned int __cdecl _rotl(
    _In_ unsigned int _Value,
    _In_ int          _Shift
);

_Check_return_
unsigned long __cdecl _lrotl(
    _In_ unsigned long _Value,
    _In_ int           _Shift
);

unsigned __int64 __cdecl _rotl64(
    _In_ unsigned __int64 _Value,
    _In_ int              _Shift
);

unsigned int __cdecl _rotr(
    _In_ unsigned int _Value,
    _In_ int          _Shift
);

_Check_return_
unsigned long __cdecl _lrotr(
    _In_ unsigned long _Value,
    _In_ int           _Shift
);

unsigned __int64 __cdecl _rotr64(
    _In_ unsigned __int64 _Value,
    _In_ int              _Shift
);

#pragma warning(pop)



// Maximum value that can be returned by the rand function:
#define RAND_MAX 0x7fff

_ACRTIMP void __cdecl srand(_In_ unsigned int _Seed);

_Check_return_ _ACRTIMP int __cdecl rand(void);

#if defined _CRT_RAND_S || defined _CRTBLD
_ACRTIMP errno_t __cdecl rand_s(_Out_ unsigned int* _RandomValue);
#endif



#ifdef __cplusplus
extern "C++"
{
    inline long abs(long const _X) throw()
    {
        return labs(_X);
    }

    inline long long abs(long long const _X) throw()
    {
        return llabs(_X);
    }

    inline ldiv_t div(long const _A1, long const _A2) throw()
    {
        return ldiv(_A1, _A2);
    }

    inline lldiv_t div(long long const _A1, long long const _A2) throw()
    {
        return lldiv(_A1, _A2);
    }
}
#endif // __cplusplus




// Structs used to fool the compiler into not generating floating point
// instructions when copying and pushing [long] double values
#define _CRT_DOUBLE_DEC

#ifndef _LDSUPPORT

#pragma pack(push, 4)
typedef struct
{
    unsigned char ld[10];
} _LDOUBLE;
#pragma pack(pop)

#define _PTR_LD(x) ((unsigned char*)(&(x)->ld))

#else // _LDSUPPORT

    // push and pop long, which is #defined as __int64 by a spec2k test
#pragma push_macro("long")
#undef long
typedef long double _LDOUBLE;
#pragma pop_macro("long")

#define _PTR_LD(x) ((unsigned char  *)(x))

#endif // _LDSUPPORT

typedef struct
{
    double x;
} _CRT_DOUBLE;

typedef struct
{
    float f;
} _CRT_FLOAT;

// push and pop long, which is #defined as __int64 by a spec2k test
#pragma push_macro("long")
#undef long

typedef struct
{
    long double x;
} _LONGDOUBLE;

#pragma pop_macro("long")

#pragma pack(push, 4)
typedef struct
{
    unsigned char ld12[12];
} _LDBL12;
#pragma pack(pop)



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Narrow String to Number Conversions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
_Check_return_                    _ACRTIMP double    __cdecl atof(_In_z_ char const* _String);
_Check_return_ _CRT_JIT_INTRINSIC _ACRTIMP int       __cdecl atoi(_In_z_ char const* _String);
_Check_return_                    _ACRTIMP long      __cdecl atol(_In_z_ char const* _String);
_Check_return_                    _ACRTIMP long long __cdecl atoll(_In_z_ char const* _String);
_Check_return_                    _ACRTIMP __int64   __cdecl _atoi64(_In_z_ char const* _String);

_Check_return_ _ACRTIMP double    __cdecl _atof_l(_In_z_ char const* _String, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP int       __cdecl _atoi_l(_In_z_ char const* _String, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP long      __cdecl _atol_l(_In_z_ char const* _String, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP long long __cdecl _atoll_l(_In_z_ char const* _String, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP __int64   __cdecl _atoi64_l(_In_z_ char const* _String, _In_opt_ _locale_t _Locale);

_Check_return_ _ACRTIMP int __cdecl _atoflt(_Out_ _CRT_FLOAT * _Result, _In_z_ char const* _String);
_Check_return_ _ACRTIMP int __cdecl _atodbl(_Out_ _CRT_DOUBLE * _Result, _In_z_ char* _String);
_Check_return_ _ACRTIMP int __cdecl _atoldbl(_Out_ _LDOUBLE * _Result, _In_z_ char* _String);

_Check_return_
_ACRTIMP int __cdecl _atoflt_l(
    _Out_    _CRT_FLOAT * _Result,
    _In_z_   char const* _String,
    _In_opt_ _locale_t   _Locale
);

_Check_return_
_ACRTIMP int __cdecl _atodbl_l(
    _Out_    _CRT_DOUBLE * _Result,
    _In_z_   char* _String,
    _In_opt_ _locale_t    _Locale
);


_Check_return_
_ACRTIMP int __cdecl _atoldbl_l(
    _Out_    _LDOUBLE * _Result,
    _In_z_   char* _String,
    _In_opt_ _locale_t _Locale
);

_Check_return_
_ACRTIMP float __cdecl strtof(
    _In_z_                   char const* _String,
    _Out_opt_ _Deref_post_z_ char** _EndPtr
);

_Check_return_
_ACRTIMP float __cdecl _strtof_l(
    _In_z_                   char const* _String,
    _Out_opt_ _Deref_post_z_ char** _EndPtr,
    _In_opt_                 _locale_t   _Locale
);

_Check_return_
_ACRTIMP double __cdecl strtod(
    _In_z_                   char const* _String,
    _Out_opt_ _Deref_post_z_ char** _EndPtr
);

_Check_return_
_ACRTIMP double __cdecl _strtod_l(
    _In_z_                   char const* _String,
    _Out_opt_ _Deref_post_z_ char** _EndPtr,
    _In_opt_                 _locale_t   _Locale
);

_Check_return_
_ACRTIMP long double __cdecl strtold(
    _In_z_                   char const* _String,
    _Out_opt_ _Deref_post_z_ char** _EndPtr
);

_Check_return_
_ACRTIMP long double __cdecl _strtold_l(
    _In_z_                   char const* _String,
    _Out_opt_ _Deref_post_z_ char** _EndPtr,
    _In_opt_                 _locale_t   _Locale
);

_Check_return_
_ACRTIMP long __cdecl strtol(
    _In_z_                   char const* _String,
    _Out_opt_ _Deref_post_z_ char** _EndPtr,
    _In_                     int         _Radix
);

_Check_return_
_ACRTIMP long __cdecl _strtol_l(
    _In_z_                   char const* _String,
    _Out_opt_ _Deref_post_z_ char** _EndPtr,
    _In_                     int         _Radix,
    _In_opt_                 _locale_t   _Locale
);

_Check_return_
_ACRTIMP long long __cdecl strtoll(
    _In_z_                   char const* _String,
    _Out_opt_ _Deref_post_z_ char** _EndPtr,
    _In_                     int         _Radix
);

_Check_return_
_ACRTIMP long long __cdecl _strtoll_l(
    _In_z_                   char const* _String,
    _Out_opt_ _Deref_post_z_ char** _EndPtr,
    _In_                     int         _Radix,
    _In_opt_                 _locale_t   _Locale
);

_Check_return_
_ACRTIMP unsigned long __cdecl strtoul(
    _In_z_                   char const* _String,
    _Out_opt_ _Deref_post_z_ char** _EndPtr,
    _In_                     int         _Radix
);

_Check_return_
_ACRTIMP unsigned long __cdecl _strtoul_l(
    _In_z_                   char const* _String,
    _Out_opt_ _Deref_post_z_ char** _EndPtr,
    _In_                     int         _Radix,
    _In_opt_                 _locale_t   _Locale
);

_Check_return_
_ACRTIMP unsigned long long __cdecl strtoull(
    _In_z_                   char const* _String,
    _Out_opt_ _Deref_post_z_ char** _EndPtr,
    _In_                     int         _Radix
);

_Check_return_
_ACRTIMP unsigned long long __cdecl _strtoull_l(
    _In_z_                   char const* _String,
    _Out_opt_ _Deref_post_z_ char** _EndPtr,
    _In_                     int         _Radix,
    _In_opt_                 _locale_t   _Locale
);

_Check_return_
_ACRTIMP __int64 __cdecl _strtoi64(
    _In_z_                   char const* _String,
    _Out_opt_ _Deref_post_z_ char** _EndPtr,
    _In_                     int         _Radix
);

_Check_return_
_ACRTIMP __int64 __cdecl _strtoi64_l(
    _In_z_                   char const* _String,
    _Out_opt_ _Deref_post_z_ char** _EndPtr,
    _In_                     int         _Radix,
    _In_opt_                 _locale_t   _Locale
);

_Check_return_
_ACRTIMP unsigned __int64 __cdecl _strtoui64(
    _In_z_                   char const* _String,
    _Out_opt_ _Deref_post_z_ char** _EndPtr,
    _In_                     int         _Radix
);

_Check_return_
_ACRTIMP unsigned __int64 __cdecl _strtoui64_l(
    _In_z_                   char const* _String,
    _Out_opt_ _Deref_post_z_ char** _EndPtr,
    _In_                     int         _Radix,
    _In_opt_                 _locale_t   _Locale
);



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Number to Narrow String Conversions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
_Success_(return == 0)
_Check_return_opt_
_ACRTIMP errno_t __cdecl _itoa_s(
    _In_                         int    _Value,
    _Out_writes_z_(_BufferCount) char* _Buffer,
    _In_                         size_t _BufferCount,
    _In_                         int    _Radix
);

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1(
    _Success_(return == 0)
    errno_t, _itoa_s,
    _In_ int, _Value,
    char, _Buffer,
    _In_ int, _Radix
)

__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1(
    char*, __RETURN_POLICY_DST, _ACRTIMP, _itoa,
    _In_                    int, _Value,
    _Pre_notnull_ _Post_z_, char, _Buffer,
    _In_                    int, _Radix
)

_Success_(return == 0)
_Check_return_opt_
_ACRTIMP errno_t __cdecl _ltoa_s(
    _In_                         long   _Value,
    _Out_writes_z_(_BufferCount) char* _Buffer,
    _In_                         size_t _BufferCount,
    _In_                         int    _Radix
);

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1(
    errno_t, _ltoa_s,
    _In_ long, _Value,
    char, _Buffer,
    _In_ int, _Radix
)

__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1(
    char*, __RETURN_POLICY_DST, _ACRTIMP, _ltoa,
    _In_                    long, _Value,
    _Pre_notnull_ _Post_z_, char, _Buffer,
    _In_                    int, _Radix
)

_Success_(return == 0)
_Check_return_opt_
_ACRTIMP errno_t __cdecl _ultoa_s(
    _In_                         unsigned long _Value,
    _Out_writes_z_(_BufferCount) char* _Buffer,
    _In_                         size_t        _BufferCount,
    _In_                         int           _Radix
);

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1(
    errno_t, _ultoa_s,
    _In_ unsigned long, _Value,
    char, _Buffer,
    _In_ int, _Radix
)

__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1(
    char*, __RETURN_POLICY_DST, _ACRTIMP, _ultoa,
    _In_                    unsigned long, _Value,
    _Pre_notnull_ _Post_z_, char, _Buffer,
    _In_                    int, _Radix
)

_Success_(return == 0)
_Check_return_opt_
_ACRTIMP errno_t __cdecl _i64toa_s(
    _In_                         __int64 _Value,
    _Out_writes_z_(_BufferCount) char* _Buffer,
    _In_                         size_t  _BufferCount,
    _In_                         int     _Radix
);

_Success_(return == 0)
_CRT_INSECURE_DEPRECATE(_i64toa_s)
_ACRTIMP char* __cdecl _i64toa(
    _In_                   __int64 _Value,
    _Pre_notnull_ _Post_z_ char* _Buffer,
    _In_                   int     _Radix
);

_Success_(return == 0)
_Check_return_opt_
_ACRTIMP errno_t __cdecl _ui64toa_s(
    _In_                         unsigned __int64 _Value,
    _Out_writes_z_(_BufferCount) char* _Buffer,
    _In_                         size_t           _BufferCount,
    _In_                         int              _Radix
);

_CRT_INSECURE_DEPRECATE(_ui64toa_s)
_ACRTIMP char* __cdecl _ui64toa(
    _In_                   unsigned __int64 _Value,
    _Pre_notnull_ _Post_z_ char* _Buffer,
    _In_                   int              _Radix
);



// _CVTBUFSIZE is the maximum size for the per-thread conversion buffer.  It
// should be at least as long as the number of digits in the largest double
// precision value (?.?e308 in IEEE arithmetic).  We will use the same size
// buffer as is used in the printf support routines.
//
// (This value actually allows 40 additional decimal places; even though there
// are only 16 digits of accuracy in a double precision IEEE number, the user may
// ask for more to effect zero padding.)
#define _CVTBUFSIZE (309 + 40) // # of digits in max. dp value + slop

_Success_(return == 0)
_Check_return_wat_
_ACRTIMP errno_t __cdecl _ecvt_s(
    _Out_writes_z_(_BufferCount) char* _Buffer,
    _In_  size_t                       _BufferCount,
    _In_  double                       _Value,
    _In_  int                          _DigitCount,
    _Out_ int* _PtDec,
    _Out_ int* _PtSign
);

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_4(
    errno_t, _ecvt_s,
    char, _Buffer,
    _In_  double, _Value,
    _In_  int, _DigitCount,
    _Out_ int*, _PtDec,
    _Out_ int*, _PtSign
)

_Check_return_ _CRT_INSECURE_DEPRECATE(_ecvt_s)
_ACRTIMP char* __cdecl _ecvt(
    _In_  double _Value,
    _In_  int    _DigitCount,
    _Out_ int* _PtDec,
    _Out_ int* _PtSign
);

_Success_(return == 0)
_Check_return_wat_
_ACRTIMP errno_t __cdecl _fcvt_s(
    _Out_writes_z_(_BufferCount) char* _Buffer,
    _In_                         size_t _BufferCount,
    _In_                         double _Value,
    _In_                         int    _FractionalDigitCount,
    _Out_                        int* _PtDec,
    _Out_                        int* _PtSign
);

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_4(
    _Success_(return == 0)
    errno_t, _fcvt_s,
    char, _Buffer,
    _In_  double, _Value,
    _In_  int, _FractionalDigitCount,
    _Out_ int*, _PtDec,
    _Out_ int*, _PtSign
)

_Success_(return == 0)
_Check_return_ _CRT_INSECURE_DEPRECATE(_fcvt_s)
_ACRTIMP char* __cdecl _fcvt(
    _In_  double _Value,
    _In_  int    _FractionalDigitCount,
    _Out_ int* _PtDec,
    _Out_ int* _PtSign
);

_Success_(return == 0)
_ACRTIMP errno_t __cdecl _gcvt_s(
    _Out_writes_z_(_BufferCount) char* _Buffer,
    _In_                         size_t _BufferCount,
    _In_                         double _Value,
    _In_                         int    _DigitCount
);

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(
    _Success_(return == 0)
    errno_t, _gcvt_s,
    char, _Buffer,
    _In_ double, _Value,
    _In_ int, _DigitCount
)

_CRT_INSECURE_DEPRECATE(_gcvt_s)
_ACRTIMP char* __cdecl _gcvt(
    _In_                   double _Value,
    _In_                   int    _DigitCount,
    _Pre_notnull_ _Post_z_ char* _Buffer
);



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Multibyte String Operations and Conversions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// Maximum number of bytes in multi-byte character in the current locale
// (also defined in ctype.h).
#ifndef MB_CUR_MAX
#if defined _CRT_DISABLE_PERFCRIT_LOCKS && !defined _DLL
#define MB_CUR_MAX __mb_cur_max
#else
#define MB_CUR_MAX ___mb_cur_max_func()
#endif

#ifdef _CRT_DECLARE_GLOBAL_VARIABLES_DIRECTLY
extern int __mb_cur_max;
#else
#define __mb_cur_max (___mb_cur_max_func())
#endif

_Post_satisfies_(return > 0 && return < MB_LEN_MAX)
    _ACRTIMP int __cdecl ___mb_cur_max_func(void);

_Post_satisfies_(return > 0 && return < MB_LEN_MAX)
    _ACRTIMP int __cdecl ___mb_cur_max_l_func(_locale_t _Locale);
#endif



_Check_return_
_ACRTIMP int __cdecl mblen(
    _In_reads_bytes_opt_(_MaxCount) _Pre_opt_z_ char const* _Ch,
    _In_                                        size_t      _MaxCount
);

_Check_return_
_ACRTIMP int __cdecl _mblen_l(
    _In_reads_bytes_opt_(_MaxCount) _Pre_opt_z_ char const* _Ch,
    _In_                                        size_t      _MaxCount,
    _In_opt_                                    _locale_t   _Locale
);

_Check_return_
_Post_satisfies_(return <= _String_length_(_String))
_ACRTIMP size_t __cdecl _mbstrlen(
    _In_z_ char const* _String
);

_Check_return_
_Post_satisfies_(return <= _String_length_(_String) || return == (size_t)-1)
_ACRTIMP size_t __cdecl _mbstrlen_l(
    _In_z_   char const* _String,
    _In_opt_ _locale_t   _Locale
);

_Check_return_
_Post_satisfies_((return <= _String_length_(_String) && return <= _MaxCount) || return == (size_t)-1)
_ACRTIMP size_t __cdecl _mbstrnlen(
    _In_z_ char const* _String,
    _In_   size_t      _MaxCount
);

_Post_satisfies_((return <= _String_length_(_String) && return <= _MaxCount) || return == (size_t)-1)
_Check_return_
_ACRTIMP size_t __cdecl _mbstrnlen_l(
    _In_z_   char const* _String,
    _In_     size_t      _MaxCount,
    _In_opt_ _locale_t   _Locale
);

_Success_(return != -1)
_ACRTIMP int __cdecl mbtowc(
    _Pre_notnull_ _Post_z_               wchar_t* _DstCh,
    _In_reads_or_z_opt_(_SrcSizeInBytes) char const* _SrcCh,
    _In_                                 size_t      _SrcSizeInBytes
);

_Success_(return != -1)
_ACRTIMP int __cdecl _mbtowc_l(
    _Pre_notnull_ _Post_z_               wchar_t* _DstCh,
    _In_reads_or_z_opt_(_SrcSizeInBytes) char const* _SrcCh,
    _In_                                 size_t      _SrcSizeInBytes,
    _In_opt_                             _locale_t   _Locale
);

_Check_return_opt_
_ACRTIMP errno_t __cdecl mbstowcs_s(
    _Out_opt_                                                 size_t * _PtNumOfCharConverted,
    _Out_writes_to_opt_(_SizeInWords, *_PtNumOfCharConverted) wchar_t* _DstBuf,
    _In_                                                      size_t      _SizeInWords,
    _In_reads_or_z_(_MaxCount)                                char const* _SrcBuf,
    _In_                                                      size_t      _MaxCount
);

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_2(
    errno_t, mbstowcs_s,
    _Out_opt_ size_t*, _PtNumOfCharConverted,
    _Post_z_  wchar_t, _Dest,
    _In_z_    char const*, _Source,
    _In_      size_t, _MaxCount
)

__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_SIZE(
    _ACRTIMP, mbstowcs,
    _Out_writes_opt_z_(_MaxCount), wchar_t, _Dest,
    _In_z_                         char const*, _Source,
    _In_                           size_t, _MaxCount
)

_Check_return_opt_
_ACRTIMP errno_t __cdecl _mbstowcs_s_l(
    _Out_opt_                                                 size_t * _PtNumOfCharConverted,
    _Out_writes_to_opt_(_SizeInWords, *_PtNumOfCharConverted) wchar_t* _DstBuf,
    _In_                                                      size_t      _SizeInWords,
    _In_reads_or_z_(_MaxCount)                                char const* _SrcBuf,
    _In_                                                      size_t      _MaxCount,
    _In_opt_                                                  _locale_t   _Locale
);

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_3(
    errno_t, _mbstowcs_s_l,
    _Out_opt_ size_t*, _PtNumOfCharConverted,
    _Post_z_  wchar_t, _Dest,
    _In_z_    char const*, _Source,
    _In_      size_t, _MaxCount,
    _In_opt_  _locale_t, _Locale
)

__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_SIZE_EX(
    _ACRTIMP, _mbstowcs_l, _mbstowcs_s_l,
    _Out_writes_opt_z_(_Size)  wchar_t,
    _Out_writes_z_(_MaxCount), wchar_t, _Dest,
    _In_z_                     char const*, _Source,
    _In_                       size_t, _MaxCount,
    _In_opt_                   _locale_t, _Locale
)




_CRT_INSECURE_DEPRECATE(wctomb_s)
_ACRTIMP int __cdecl wctomb(
    _Out_writes_opt_z_(MB_LEN_MAX) char* _MbCh,
    _In_                           wchar_t _WCh
);

_CRT_INSECURE_DEPRECATE(_wctomb_s_l)
_ACRTIMP int __cdecl _wctomb_l(
    _Pre_maybenull_ _Post_z_ char* _MbCh,
    _In_                     wchar_t   _WCh,
    _In_opt_                 _locale_t _Locale
);

#if __STDC_WANT_SECURE_LIB__

_Check_return_wat_
_ACRTIMP errno_t __cdecl wctomb_s(
    _Out_opt_                                                int* _SizeConverted,
    _Out_writes_bytes_to_opt_(_SizeInBytes, *_SizeConverted) char* _MbCh,
    _In_                                                     rsize_t _SizeInBytes,
    _In_                                                     wchar_t _WCh
);

#endif // __STDC_WANT_SECURE_LIB__

_Check_return_wat_
_ACRTIMP errno_t __cdecl _wctomb_s_l(
    _Out_opt_                        int* _SizeConverted,
    _Out_writes_opt_z_(_SizeInBytes) char* _MbCh,
    _In_                             size_t    _SizeInBytes,
    _In_                             wchar_t   _WCh,
    _In_opt_                         _locale_t _Locale);

_Check_return_wat_
_ACRTIMP errno_t __cdecl wcstombs_s(
    _Out_opt_                                                          size_t * _PtNumOfCharConverted,
    _Out_writes_bytes_to_opt_(_DstSizeInBytes, *_PtNumOfCharConverted) char* _Dst,
    _In_                                                               size_t         _DstSizeInBytes,
    _In_z_                                                             wchar_t const* _Src,
    _In_                                                               size_t         _MaxCountInBytes
);

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_2(
    errno_t, wcstombs_s,
    _Out_opt_                     size_t*, _PtNumOfCharConverted,
    _Out_writes_bytes_opt_(_Size) char, _Dest,
    _In_z_                        wchar_t const*, _Source,
    _In_                          size_t, _MaxCount
)

__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_SIZE(
    _ACRTIMP, wcstombs,
    _Out_writes_opt_(_MaxCount), char, _Dest,
    _In_z_                         wchar_t const*, _Source,
    _In_                           size_t, _MaxCount
)

_Check_return_wat_
_ACRTIMP errno_t __cdecl _wcstombs_s_l(
    _Out_opt_                                                          size_t * _PtNumOfCharConverted,
    _Out_writes_bytes_to_opt_(_DstSizeInBytes, *_PtNumOfCharConverted) char* _Dst,
    _In_                                                               size_t         _DstSizeInBytes,
    _In_z_                                                             wchar_t const* _Src,
    _In_                                                               size_t         _MaxCountInBytes,
    _In_opt_                                                           _locale_t      _Locale
);

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_3(
    errno_t, _wcstombs_s_l,
    _Out_opt_               size_t*, _PtNumOfCharConverted,
    _Out_writes_opt_(_Size) char, _Dest,
    _In_z_                  wchar_t const*, _Source,
    _In_                    size_t, _MaxCount,
    _In_opt_                _locale_t, _Locale
)

__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_SIZE_EX(
    _ACRTIMP, _wcstombs_l, _wcstombs_s_l,
    _Out_writes_opt_z_(_Size)  char,
    _Out_writes_(_MaxCount), char, _Dest,
    _In_z_                     wchar_t const*, _Source,
    _In_                       size_t, _MaxCount,
    _In_opt_                   _locale_t, _Locale
)



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Path Manipulation
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// Sizes for buffers used by the _makepath() and _splitpath() functions.
// note that the sizes include space for 0-terminator
#define _MAX_PATH   260 // max. length of full pathname
#define _MAX_DRIVE  3   // max. length of drive component
#define _MAX_DIR    256 // max. length of path component
#define _MAX_FNAME  256 // max. length of file name component
#define _MAX_EXT    256 // max. length of extension component


#pragma push_macro("_fullpath")
#undef _fullpath

_Success_(return != 0)
_Check_return_
_ACRTIMP _CRTALLOCATOR char* __cdecl _fullpath(
    _Out_writes_opt_z_(_BufferCount) char* _Buffer,
    _In_z_                           char const* _Path,
    _In_                             size_t      _BufferCount
);

#pragma pop_macro("_fullpath")

_Check_return_wat_
_ACRTIMP errno_t __cdecl _makepath_s(
    _Out_writes_z_(_BufferCount) char* _Buffer,
    _In_                         size_t      _BufferCount,
    _In_opt_z_                   char const* _Drive,
    _In_opt_z_                   char const* _Dir,
    _In_opt_z_                   char const* _Filename,
    _In_opt_z_                   char const* _Ext
);

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_4(
    errno_t, _makepath_s,
    char, _Buffer,
    _In_opt_z_ char const*, _Drive,
    _In_opt_z_ char const*, _Dir,
    _In_opt_z_ char const*, _Filename,
    _In_opt_z_ char const*, _Ext
)

__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4(
    void, __RETURN_POLICY_VOID, _ACRTIMP, _makepath,
    _Pre_notnull_ _Post_z_, char, _Buffer,
    _In_opt_z_              char const*, _Drive,
    _In_opt_z_              char const*, _Dir,
    _In_opt_z_              char const*, _Filename,
    _In_opt_z_              char const*, _Ext
)

_CRT_INSECURE_DEPRECATE(_splitpath_s)
_ACRTIMP void __cdecl _splitpath(
    _In_z_                   char const* _FullPath,
    _Pre_maybenull_ _Post_z_ char* _Drive,
    _Pre_maybenull_ _Post_z_ char* _Dir,
    _Pre_maybenull_ _Post_z_ char* _Filename,
    _Pre_maybenull_ _Post_z_ char* _Ext
);

_Check_return_wat_
_ACRTIMP errno_t __cdecl _splitpath_s(
    _In_z_                             char const* _FullPath,
    _Out_writes_opt_z_(_DriveCount)    char* _Drive,
    _In_                               size_t      _DriveCount,
    _Out_writes_opt_z_(_DirCount)      char* _Dir,
    _In_                               size_t      _DirCount,
    _Out_writes_opt_z_(_FilenameCount) char* _Filename,
    _In_                               size_t      _FilenameCount,
    _Out_writes_opt_z_(_ExtCount)      char* _Ext,
    _In_                               size_t      _ExtCount
);

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_SPLITPATH(errno_t, _splitpath_s, char, _Dest)

#if __STDC_WANT_SECURE_LIB__

_Check_return_opt_
_Success_(return == 0)
_DCRTIMP errno_t __cdecl getenv_s(
    _Out_                            size_t * _RequiredCount,
    _Out_writes_opt_z_(_BufferCount) char* _Buffer,
    _In_                             rsize_t     _BufferCount,
    _In_z_                           char const* _VarName
);

#endif // __STDC_WANT_SECURE_LIB__




_ACRTIMP int* __cdecl __p___argc(void);
_ACRTIMP char*** __cdecl __p___argv(void);
_ACRTIMP wchar_t*** __cdecl __p___wargv(void);

#ifdef _CRT_DECLARE_GLOBAL_VARIABLES_DIRECTLY
extern int       __argc;
extern char** __argv;
extern wchar_t** __wargv;
#else
#define __argc  (*__p___argc())  // Pointer to number of command line arguments
#define __argv  (*__p___argv())  // Pointer to table of narrow command line arguments
#define __wargv (*__p___wargv()) // Pointer to table of wide command line arguments
#endif

_DCRTIMP char*** __cdecl __p__environ(void);
_DCRTIMP wchar_t*** __cdecl __p__wenviron(void);

#ifndef _CRT_BEST_PRACTICES_USAGE
#define _CRT_V12_LEGACY_FUNCTIONALITY
#endif

#ifndef _CRT_V12_LEGACY_FUNCTIONALITY
// Deprecated symbol: Do not expose environment global pointers unless
// legacy access is specifically requested
#define _environ    crt_usage_error__do_not_reference_global_pointer_directly__environ
#define _wenviron   crt_usage_error__do_not_reference_global_pointer_directly__wenviron
#else
#define _environ  (*__p__environ())  // Pointer to narrow environment table
#define _wenviron (*__p__wenviron()) // Pointer to wide environment table
#endif



// Sizes for buffers used by the getenv/putenv family of functions.
#define _MAX_ENV 32767


#if _CRT_FUNCTIONS_REQUIRED

_Check_return_ _CRT_INSECURE_DEPRECATE(_dupenv_s)
_DCRTIMP char* __cdecl getenv(
    _In_z_ char const* _VarName
);

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1(
    errno_t, getenv_s,
    _Out_  size_t*, _RequiredCount,
    char, _Buffer,
    _In_z_ char const*, _VarName
)

#if defined(_DEBUG) && defined(_CRTDBG_MAP_ALLOC)
#pragma push_macro("_dupenv_s")
#undef _dupenv_s
#endif

_Check_return_opt_
_DCRTIMP errno_t __cdecl _dupenv_s(
    _Outptr_result_buffer_maybenull_(*_BufferCount) _Outptr_result_maybenull_z_ char** _Buffer,
    _Out_opt_                                                                   size_t * _BufferCount,
    _In_z_                                                                      char const* _VarName
);

#if defined(_DEBUG) && defined(_CRTDBG_MAP_ALLOC)
#pragma pop_macro("_dupenv_s")
#endif

_DCRTIMP int __cdecl system(
    _In_opt_z_ char const* _Command
);

// The functions below have declspecs in their declarations in the Windows
// headers, causing PREfast to fire 6540 here
#pragma warning(push)
#pragma warning(disable: 6540)

_Check_return_
_DCRTIMP int __cdecl _putenv(
    _In_z_ char const* _EnvString
);

_Check_return_wat_
_DCRTIMP errno_t __cdecl _putenv_s(
    _In_z_ char const* _Name,
    _In_z_ char const* _Value
);

#pragma warning(pop)

_DCRTIMP errno_t __cdecl _searchenv_s(
    _In_z_                       char const* _Filename,
    _In_z_                       char const* _VarName,
    _Out_writes_z_(_BufferCount) char* _Buffer,
    _In_                         size_t      _BufferCount
);

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_2_0(
    errno_t, _searchenv_s,
    _In_z_ char const*, _Filename,
    _In_z_ char const*, _VarName,
    char, _Buffer
)

__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_2_0(
    void, __RETURN_POLICY_VOID, _DCRTIMP, _searchenv,
    _In_z_                  char const*, _Filename,
    _In_z_                  char const*, _VarName,
    _Pre_notnull_ _Post_z_, char, _Buffer
)

// The Win32 API SetErrorMode, Beep and Sleep should be used instead.
_CRT_OBSOLETE(SetErrorMode)
_DCRTIMP void __cdecl _seterrormode(
    _In_ int _Mode
);

_CRT_OBSOLETE(Beep)
_DCRTIMP void __cdecl _beep(
    _In_ unsigned _Frequency,
    _In_ unsigned _Duration
);

_CRT_OBSOLETE(Sleep)
_DCRTIMP void __cdecl _sleep(
    _In_ unsigned long _Duration
);

#endif // _CRT_FUNCTIONS_REQUIRED


//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Non-ANSI Names for Compatibility
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#if defined(_CRT_INTERNAL_NONSTDC_NAMES) && _CRT_INTERNAL_NONSTDC_NAMES

#ifndef __cplusplus
#define max(a,b) (((a) > (b)) ? (a) : (b))
#define min(a,b) (((a) < (b)) ? (a) : (b))
#endif

#define sys_errlist _sys_errlist
#define sys_nerr    _sys_nerr

#pragma warning(push)
#pragma warning(disable: 4141) // Using deprecated twice

_Check_return_ _CRT_NONSTDC_DEPRECATE(_ecvt) _CRT_INSECURE_DEPRECATE(_ecvt_s)
_ACRTIMP char* __cdecl ecvt(
    _In_  double _Value,
    _In_  int    _DigitCount,
    _Out_ int* _PtDec,
    _Out_ int* _PtSign
);

_Check_return_ _CRT_NONSTDC_DEPRECATE(_fcvt) _CRT_INSECURE_DEPRECATE(_fcvt_s)
_ACRTIMP char* __cdecl fcvt(
    _In_  double _Value,
    _In_  int    _FractionalDigitCount,
    _Out_ int* _PtDec,
    _Out_ int* _PtSign
);

_CRT_NONSTDC_DEPRECATE(_gcvt) _CRT_INSECURE_DEPRECATE(_fcvt_s)
_ACRTIMP char* __cdecl gcvt(
    _In_                   double _Value,
    _In_                   int    _DigitCount,
    _Pre_notnull_ _Post_z_ char* _DstBuf
);

_CRT_NONSTDC_DEPRECATE(_itoa) _CRT_INSECURE_DEPRECATE(_itoa_s)
_ACRTIMP char* __cdecl itoa(
    _In_                   int   _Value,
    _Pre_notnull_ _Post_z_ char* _Buffer,
    _In_                   int   _Radix
);

_CRT_NONSTDC_DEPRECATE(_ltoa) _CRT_INSECURE_DEPRECATE(_ltoa_s)
_ACRTIMP char* __cdecl ltoa(
    _In_                   long  _Value,
    _Pre_notnull_ _Post_z_ char* _Buffer,
    _In_                   int   _Radix
);


_CRT_NONSTDC_DEPRECATE(_swab)
_ACRTIMP void __cdecl swab(
    _Inout_updates_z_(_SizeInBytes) char* _Buf1,
    _Inout_updates_z_(_SizeInBytes) char* _Buf2,
    _In_                            int   _SizeInBytes
);

_CRT_NONSTDC_DEPRECATE(_ultoa) _CRT_INSECURE_DEPRECATE(_ultoa_s)
_ACRTIMP char* __cdecl ultoa(
    _In_                   unsigned long _Value,
    _Pre_notnull_ _Post_z_ char* _Buffer,
    _In_                   int           _Radix
);

#define environ _environ

_Check_return_ _CRT_NONSTDC_DEPRECATE(_putenv)
_DCRTIMP int __cdecl putenv(
    _In_z_ char const* _EnvString
);

#pragma warning(pop)

onexit_t __cdecl onexit(_In_opt_ onexit_t _Func);

#endif // _CRT_INTERNAL_NONSTDC_NAMES



_CRT_END_C_HEADER
_UCRT_RESTORE_CLANG_WARNINGS
#pragma warning(pop) // _UCRT_DISABLED_WARNINGS
#endif // _INC_STDLIB


#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_EXTERN_CXX_WORKAROUND
// <stdlib.h> has abs(long) and abs(long long)
_NODISCARD _Check_return_ inline double abs(_In_ double _Xx) noexcept /* strengthened */ {
    return _CSTD fabs(_Xx);
}

_NODISCARD _Check_return_ inline float abs(_In_ float _Xx) noexcept /* strengthened */ {
    return _CSTD fabsf(_Xx);
}

_NODISCARD _Check_return_ inline long double abs(_In_ long double _Xx) noexcept /* strengthened */ {
    return _CSTD fabsl(_Xx);
}
_END_EXTERN_CXX_WORKAROUND

_STD_BEGIN
_EXPORT_STD using _CSTD size_t;
_EXPORT_STD using _CSTD div_t;
_EXPORT_STD using _CSTD ldiv_t;
_EXPORT_STD using _CSTD abort;
_EXPORT_STD using _CSTD abs;
_EXPORT_STD using _CSTD atexit;
_EXPORT_STD using _CSTD atof;
_EXPORT_STD using _CSTD atoi;
_EXPORT_STD using _CSTD atol;
_EXPORT_STD using _CSTD bsearch;
_EXPORT_STD using _CSTD calloc;
_EXPORT_STD using _CSTD div;
_EXPORT_STD using _CSTD exit;
_EXPORT_STD using _CSTD free;
_EXPORT_STD using _CSTD labs;
_EXPORT_STD using _CSTD ldiv;
_EXPORT_STD using _CSTD malloc;
_EXPORT_STD using _CSTD mblen;
_EXPORT_STD using _CSTD mbstowcs;
_EXPORT_STD using _CSTD mbtowc;
_EXPORT_STD using _CSTD qsort;
_EXPORT_STD using _CSTD rand;
_EXPORT_STD using _CSTD realloc;
_EXPORT_STD using _CSTD srand;
_EXPORT_STD using _CSTD strtod;
_EXPORT_STD using _CSTD strtol;
_EXPORT_STD using _CSTD strtoul;
_EXPORT_STD using _CSTD wcstombs;
_EXPORT_STD using _CSTD wctomb;

_EXPORT_STD using _CSTD lldiv_t;

_EXPORT_STD using _CSTD getenv;
_EXPORT_STD using _CSTD system;

_EXPORT_STD using _CSTD atoll;
_EXPORT_STD using _CSTD llabs;
_EXPORT_STD using _CSTD lldiv;
_EXPORT_STD using _CSTD strtof;
_EXPORT_STD using _CSTD strtold;
_EXPORT_STD using _CSTD strtoll;
_EXPORT_STD using _CSTD strtoull;

_EXPORT_STD using _CSTD _Exit;
_EXPORT_STD using _CSTD at_quick_exit;
_EXPORT_STD using _CSTD quick_exit;
_STD_END

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)

#endif // _STL_COMPILER_PREPROCESSOR
#endif // _CSTDLIB_

// xtr1common internal header (core)

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#ifndef _XTR1COMMON_
#define _XTR1COMMON_
#if _STL_COMPILER_PREPROCESSOR

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

// TRANSITION, non-_Ugly attribute tokens
#pragma push_macro("msvc")
#pragma push_macro("known_semantics")
#undef msvc
#undef known_semantics

_STD_BEGIN
_EXPORT_STD template <class _Ty, _Ty _Val>
struct integral_constant {
    static constexpr _Ty value = _Val;

    using value_type = _Ty;
    using type = integral_constant;

    constexpr operator value_type() const noexcept {
        return value;
    }

    _NODISCARD constexpr value_type operator()() const noexcept {
        return value;
    }
};

_EXPORT_STD template <bool _Val>
using bool_constant = integral_constant<bool, _Val>;

_EXPORT_STD using true_type = bool_constant<true>;
_EXPORT_STD using false_type = bool_constant<false>;

_EXPORT_STD template <bool _Test, class _Ty = void>
struct enable_if {}; // no member "type" when !_Test

template <class _Ty>
struct enable_if<true, _Ty> { // type is _Ty for _Test
    using type = _Ty;
};

_EXPORT_STD template <bool _Test, class _Ty = void>
using enable_if_t = typename enable_if<_Test, _Ty>::type;

_EXPORT_STD template <bool _Test, class _Ty1, class _Ty2>
struct conditional { // Choose _Ty1 if _Test is true, and _Ty2 otherwise
    using type = _Ty1;
};

template <class _Ty1, class _Ty2>
struct conditional<false, _Ty1, _Ty2> {
    using type = _Ty2;
};

_EXPORT_STD template <bool _Test, class _Ty1, class _Ty2>
using conditional_t = typename conditional<_Test, _Ty1, _Ty2>::type;

#ifdef __clang__
_EXPORT_STD template <class _Ty1, class _Ty2>
_INLINE_VAR constexpr bool is_same_v = __is_same(_Ty1, _Ty2);

_EXPORT_STD template <class _Ty1, class _Ty2>
struct is_same : bool_constant<__is_same(_Ty1, _Ty2)> {};
#else // ^^^ Clang / not Clang vvv
_EXPORT_STD template <class, class>
_INLINE_VAR constexpr bool is_same_v = false; // determine whether arguments are the same type
template <class _Ty>
_INLINE_VAR constexpr bool is_same_v<_Ty, _Ty> = true;

_EXPORT_STD template <class _Ty1, class _Ty2>
struct is_same : bool_constant<is_same_v<_Ty1, _Ty2>> {};
#endif // ^^^ not Clang ^^^

_EXPORT_STD template <class _Ty>
struct remove_const { // remove top-level const qualifier
    using type = _Ty;
};

template <class _Ty>
struct remove_const<const _Ty> {
    using type = _Ty;
};

_EXPORT_STD template <class _Ty>
using remove_const_t = typename remove_const<_Ty>::type;

_EXPORT_STD template <class _Ty>
struct remove_volatile { // remove top-level volatile qualifier
    using type = _Ty;
};

template <class _Ty>
struct remove_volatile<volatile _Ty> {
    using type = _Ty;
};

_EXPORT_STD template <class _Ty>
using remove_volatile_t = typename remove_volatile<_Ty>::type;

_EXPORT_STD template <class _Ty>
struct remove_cv { // remove top-level const and volatile qualifiers
    using type = _Ty;

    template <template <class> class _Fn>
    using _Apply = _Fn<_Ty>; // apply cv-qualifiers from the class template argument to _Fn<_Ty>
};

template <class _Ty>
struct remove_cv<const _Ty> {
    using type = _Ty;

    template <template <class> class _Fn>
    using _Apply = const _Fn<_Ty>;
};

template <class _Ty>
struct remove_cv<volatile _Ty> {
    using type = _Ty;

    template <template <class> class _Fn>
    using _Apply = volatile _Fn<_Ty>;
};

template <class _Ty>
struct remove_cv<const volatile _Ty> {
    using type = _Ty;

    template <template <class> class _Fn>
    using _Apply = const volatile _Fn<_Ty>;
};

_EXPORT_STD template <class _Ty>
using remove_cv_t = typename remove_cv<_Ty>::type;

template <bool _First_value, class _First, class... _Rest>
struct _Disjunction { // handle true trait or last trait
    using type = _First;
};

template <class _False, class _Next, class... _Rest>
struct _Disjunction<false, _False, _Next, _Rest...> { // first trait is false, try the next trait
    using type = typename _Disjunction<_Next::value, _Next, _Rest...>::type;
};

_EXPORT_STD template <class... _Traits>
struct disjunction : false_type {}; // If _Traits is empty, false_type

template <class _First, class... _Rest>
struct disjunction<_First, _Rest...> : _Disjunction<_First::value, _First, _Rest...>::type {
    // the first true trait in _Traits, or the last trait if none are true
};

_EXPORT_STD template <class... _Traits>
_INLINE_VAR constexpr bool disjunction_v = disjunction<_Traits...>::value;

template <class _Ty, class... _Types>
_INLINE_VAR constexpr bool _Is_any_of_v = // true if and only if _Ty is in _Types
#if _HAS_CXX17
(is_same_v<_Ty, _Types> || ...);
#else // ^^^ _HAS_CXX17 / !_HAS_CXX17 vvv
disjunction_v<is_same<_Ty, _Types>...>;
#endif // ^^^ !_HAS_CXX17 ^^^

_NODISCARD constexpr bool _Is_constant_evaluated() noexcept { // Internal function for any standard mode
    return __builtin_is_constant_evaluated();
}

#if _HAS_CXX20
_EXPORT_STD _NODISCARD constexpr bool is_constant_evaluated() noexcept {
    return __builtin_is_constant_evaluated();
}
#endif // _HAS_CXX20

_EXPORT_STD template <class _Ty>
_INLINE_VAR constexpr bool is_integral_v = _Is_any_of_v<remove_cv_t<_Ty>, bool, char, signed char, unsigned char,
    wchar_t,
#ifdef __cpp_char8_t
    char8_t,
#endif // defined(__cpp_char8_t)
    char16_t, char32_t, short, unsigned short, int, unsigned int, long, unsigned long, long long, unsigned long long>;

_EXPORT_STD template <class _Ty>
struct is_integral : bool_constant<is_integral_v<_Ty>> {};

_EXPORT_STD template <class _Ty>
_INLINE_VAR constexpr bool is_floating_point_v = _Is_any_of_v<remove_cv_t<_Ty>, float, double, long double>;

_EXPORT_STD template <class _Ty>
struct is_floating_point : bool_constant<is_floating_point_v<_Ty>> {};

_EXPORT_STD template <class _Ty>
_INLINE_VAR constexpr bool is_arithmetic_v = // determine whether _Ty is an arithmetic type
is_integral_v<_Ty> || is_floating_point_v<_Ty>;

_EXPORT_STD template <class _Ty>
struct is_arithmetic : bool_constant<is_arithmetic_v<_Ty>> {};

_EXPORT_STD template <class _Ty>
struct remove_reference {
    using type = _Ty;
    using _Const_thru_ref_type = const _Ty;
};

template <class _Ty>
struct remove_reference<_Ty&> {
    using type = _Ty;
    using _Const_thru_ref_type = const _Ty&;
};

template <class _Ty>
struct remove_reference<_Ty&&> {
    using type = _Ty;
    using _Const_thru_ref_type = const _Ty&&;
};

_EXPORT_STD template <class _Ty>
using remove_reference_t = typename remove_reference<_Ty>::type;

template <class _Ty>
using _Const_thru_ref = typename remove_reference<_Ty>::_Const_thru_ref_type;

template <class _Ty>
using _Remove_cvref_t _MSVC_KNOWN_SEMANTICS = remove_cv_t<remove_reference_t<_Ty>>;

#if _HAS_CXX20
_EXPORT_STD template <class _Ty>
using remove_cvref_t = _Remove_cvref_t<_Ty>;

_EXPORT_STD template <class _Ty>
struct remove_cvref {
    using type = remove_cvref_t<_Ty>;
};
#endif // _HAS_CXX20

_STD_END

// TRANSITION, non-_Ugly attribute tokens
#pragma pop_macro("known_semantics")
#pragma pop_macro("msvc")

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _XTR1COMMON_


#if !defined(__clang__) && !defined(__CUDACC__) && !defined(__INTEL_COMPILER) \
    && !defined(_M_CEE) // TRANSITION, VSO-1663104
#define _HAS_CMATH_INTRINSICS 1
#else // ^^^ intrinsics available / intrinsics unavailable vvv
#define _HAS_CMATH_INTRINSICS 0
#endif // ^^^ intrinsics unavailable ^^^

#if _HAS_CMATH_INTRINSICS
#include _STL_INTRIN_HEADER
#endif // _HAS_CMATH_INTRINSICS

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_EXTERN_CXX_WORKAROUND
_NODISCARD _Check_return_ inline float acos(_In_ float _Xx) noexcept /* strengthened */ {
    return _CSTD acosf(_Xx);
}

_NODISCARD _Check_return_ inline float acosh(_In_ float _Xx) noexcept /* strengthened */ {
    return _CSTD acoshf(_Xx);
}

_NODISCARD _Check_return_ inline float asin(_In_ float _Xx) noexcept /* strengthened */ {
    return _CSTD asinf(_Xx);
}

_NODISCARD _Check_return_ inline float asinh(_In_ float _Xx) noexcept /* strengthened */ {
    return _CSTD asinhf(_Xx);
}

_NODISCARD _Check_return_ inline float atan(_In_ float _Xx) noexcept /* strengthened */ {
    return _CSTD atanf(_Xx);
}

_NODISCARD _Check_return_ inline float atanh(_In_ float _Xx) noexcept /* strengthened */ {
    return _CSTD atanhf(_Xx);
}

_NODISCARD _Check_return_ inline float atan2(_In_ float _Yx, _In_ float _Xx) noexcept /* strengthened */ {
    return _CSTD atan2f(_Yx, _Xx);
}

_NODISCARD _Check_return_ inline float cbrt(_In_ float _Xx) noexcept /* strengthened */ {
    return _CSTD cbrtf(_Xx);
}

_NODISCARD _Check_return_ inline float ceil(_In_ float _Xx) noexcept /* strengthened */ {
#if _HAS_CMATH_INTRINSICS
    return __ceilf(_Xx);
#elif defined(__clang__)
    return __builtin_ceilf(_Xx);
#else // ^^^ defined(__clang__) / intrinsics unavailable vvv
    return _CSTD ceilf(_Xx);
#endif // ^^^ intrinsics unavailable ^^^
}

_NODISCARD _Check_return_ inline float copysign(_In_ float _Number, _In_ float _Sign) noexcept /* strengthened */ {
#if _HAS_CMATH_INTRINSICS
    return __copysignf(_Number, _Sign);
#elif defined(__clang__)
    return __builtin_copysignf(_Number, _Sign);
#else // ^^^ defined(__clang__) / intrinsics unavailable vvv
    return _CSTD copysignf(_Number, _Sign);
#endif // ^^^ intrinsics unavailable ^^^
}

_NODISCARD _Check_return_ inline float cos(_In_ float _Xx) noexcept /* strengthened */ {
    return _CSTD cosf(_Xx);
}

_NODISCARD _Check_return_ inline float cosh(_In_ float _Xx) noexcept /* strengthened */ {
    return _CSTD coshf(_Xx);
}

_NODISCARD _Check_return_ inline float erf(_In_ float _Xx) noexcept /* strengthened */ {
    return _CSTD erff(_Xx);
}

_NODISCARD _Check_return_ inline float erfc(_In_ float _Xx) noexcept /* strengthened */ {
    return _CSTD erfcf(_Xx);
}

_NODISCARD _Check_return_ inline float exp(_In_ float _Xx) noexcept /* strengthened */ {
    return _CSTD expf(_Xx);
}

_NODISCARD _Check_return_ inline float exp2(_In_ float _Xx) noexcept /* strengthened */ {
    return _CSTD exp2f(_Xx);
}

_NODISCARD _Check_return_ inline float expm1(_In_ float _Xx) noexcept /* strengthened */ {
    return _CSTD expm1f(_Xx);
}

_NODISCARD _Check_return_ inline float fabs(_In_ float _Xx) noexcept /* strengthened */ {
    return _CSTD fabsf(_Xx);
}

_NODISCARD _Check_return_ inline float fdim(_In_ float _Xx, _In_ float _Yx) noexcept /* strengthened */ {
    return _CSTD fdimf(_Xx, _Yx);
}

_NODISCARD _Check_return_ inline float floor(_In_ float _Xx) noexcept /* strengthened */ {
#if _HAS_CMATH_INTRINSICS
    return __floorf(_Xx);
#elif defined(__clang__)
    return __builtin_floorf(_Xx);
#else // ^^^ defined(__clang__) / intrinsics unavailable vvv
    return _CSTD floorf(_Xx);
#endif // ^^^ intrinsics unavailable ^^^
}

_NODISCARD _Check_return_ inline float fma(_In_ float _Xx, _In_ float _Yx, _In_ float _Zx) noexcept /* strengthened */ {
    return _CSTD fmaf(_Xx, _Yx, _Zx);
}

_NODISCARD _Check_return_ inline float fmax(_In_ float _Xx, _In_ float _Yx) noexcept /* strengthened */ {
    return _CSTD fmaxf(_Xx, _Yx);
}

_NODISCARD _Check_return_ inline float fmin(_In_ float _Xx, _In_ float _Yx) noexcept /* strengthened */ {
    return _CSTD fminf(_Xx, _Yx);
}

_NODISCARD _Check_return_ inline float fmod(_In_ float _Xx, _In_ float _Yx) noexcept /* strengthened */ {
    return _CSTD fmodf(_Xx, _Yx);
}

inline float frexp(_In_ float _Xx, _Out_ int* _Yx) noexcept /* strengthened */ {
    return _CSTD frexpf(_Xx, _Yx);
}

_NODISCARD _Check_return_ inline float hypot(_In_ float _Xx, _In_ float _Yx) noexcept /* strengthened */ {
    return _CSTD hypotf(_Xx, _Yx);
}

_NODISCARD _Check_return_ inline int ilogb(_In_ float _Xx) noexcept /* strengthened */ {
    return _CSTD ilogbf(_Xx);
}

_NODISCARD _Check_return_ inline float ldexp(_In_ float _Xx, _In_ int _Yx) noexcept /* strengthened */ {
    return _CSTD ldexpf(_Xx, _Yx);
}

_NODISCARD _Check_return_ inline float lgamma(_In_ float _Xx) noexcept /* strengthened */ {
    return _CSTD lgammaf(_Xx);
}

_NODISCARD _Check_return_ inline long long llrint(_In_ float _Xx) noexcept /* strengthened */ {
    return _CSTD llrintf(_Xx);
}

_NODISCARD _Check_return_ inline long long llround(_In_ float _Xx) noexcept /* strengthened */ {
    return _CSTD llroundf(_Xx);
}

_NODISCARD _Check_return_ inline float log(_In_ float _Xx) noexcept /* strengthened */ {
    return _CSTD logf(_Xx);
}

_NODISCARD _Check_return_ inline float log10(_In_ float _Xx) noexcept /* strengthened */ {
    return _CSTD log10f(_Xx);
}

_NODISCARD _Check_return_ inline float log1p(_In_ float _Xx) noexcept /* strengthened */ {
    return _CSTD log1pf(_Xx);
}

_NODISCARD _Check_return_ inline float log2(_In_ float _Xx) noexcept /* strengthened */ {
    return _CSTD log2f(_Xx);
}

_NODISCARD _Check_return_ inline float logb(_In_ float _Xx) noexcept /* strengthened */ {
    return _CSTD logbf(_Xx);
}

_NODISCARD _Check_return_ inline long lrint(_In_ float _Xx) noexcept /* strengthened */ {
    return _CSTD lrintf(_Xx);
}

_NODISCARD _Check_return_ inline long lround(_In_ float _Xx) noexcept /* strengthened */ {
    return _CSTD lroundf(_Xx);
}

inline float modf(_In_ float _Xx, _Out_ float* _Yx) noexcept /* strengthened */ {
    return _CSTD modff(_Xx, _Yx);
}

_NODISCARD _Check_return_ inline float nearbyint(_In_ float _Xx) noexcept /* strengthened */ {
    return _CSTD nearbyintf(_Xx);
}

_NODISCARD _Check_return_ inline float nextafter(_In_ float _Xx, _In_ float _Yx) noexcept /* strengthened */ {
    return _CSTD nextafterf(_Xx, _Yx);
}

_NODISCARD _Check_return_ inline float nexttoward(_In_ float _Xx, _In_ long double _Yx) noexcept /* strengthened */ {
    return _CSTD nexttowardf(_Xx, _Yx);
}

_NODISCARD _Check_return_ inline float pow(_In_ float _Xx, _In_ float _Yx) noexcept /* strengthened */ {
    return _CSTD powf(_Xx, _Yx);
}

_NODISCARD _Check_return_ inline float remainder(_In_ float _Xx, _In_ float _Yx) noexcept /* strengthened */ {
    return _CSTD remainderf(_Xx, _Yx);
}

inline float remquo(_In_ float _Xx, _In_ float _Yx, _Out_ int* _Zx) noexcept /* strengthened */ {
    return _CSTD remquof(_Xx, _Yx, _Zx);
}

_NODISCARD _Check_return_ inline float rint(_In_ float _Xx) noexcept /* strengthened */ {
    return _CSTD rintf(_Xx);
}

_NODISCARD _Check_return_ inline float round(_In_ float _Xx) noexcept /* strengthened */ {
#if _HAS_CMATH_INTRINSICS
    return __roundf(_Xx);
#elif defined(__clang__)
    return __builtin_roundf(_Xx);
#else // ^^^ defined(__clang__) / intrinsics unavailable vvv
    return _CSTD roundf(_Xx);
#endif // ^^^ intrinsics unavailable ^^^
}

_NODISCARD _Check_return_ inline float scalbln(_In_ float _Xx, _In_ long _Yx) noexcept /* strengthened */ {
    return _CSTD scalblnf(_Xx, _Yx);
}

_NODISCARD _Check_return_ inline float scalbn(_In_ float _Xx, _In_ int _Yx) noexcept /* strengthened */ {
    return _CSTD scalbnf(_Xx, _Yx);
}

_NODISCARD _Check_return_ inline float sin(_In_ float _Xx) noexcept /* strengthened */ {
    return _CSTD sinf(_Xx);
}

_NODISCARD _Check_return_ inline float sinh(_In_ float _Xx) noexcept /* strengthened */ {
    return _CSTD sinhf(_Xx);
}

_NODISCARD _Check_return_ inline float sqrt(_In_ float _Xx) noexcept /* strengthened */ {
    return _CSTD sqrtf(_Xx);
}

_NODISCARD _Check_return_ inline float tan(_In_ float _Xx) noexcept /* strengthened */ {
    return _CSTD tanf(_Xx);
}

_NODISCARD _Check_return_ inline float tanh(_In_ float _Xx) noexcept /* strengthened */ {
    return _CSTD tanhf(_Xx);
}

_NODISCARD _Check_return_ inline float tgamma(_In_ float _Xx) noexcept /* strengthened */ {
    return _CSTD tgammaf(_Xx);
}

_NODISCARD _Check_return_ inline float trunc(_In_ float _Xx) noexcept /* strengthened */ {
#if _HAS_CMATH_INTRINSICS
    return __truncf(_Xx);
#elif defined(__clang__)
    return __builtin_truncf(_Xx);
#else // ^^^ defined(__clang__) / intrinsics unavailable vvv
    return _CSTD truncf(_Xx);
#endif // ^^^ intrinsics unavailable ^^^
}

_NODISCARD _Check_return_ inline long double acos(_In_ long double _Xx) noexcept /* strengthened */ {
    return _CSTD acosl(_Xx);
}

_NODISCARD _Check_return_ inline long double acosh(_In_ long double _Xx) noexcept /* strengthened */ {
    return _CSTD acoshl(_Xx);
}

_NODISCARD _Check_return_ inline long double asin(_In_ long double _Xx) noexcept /* strengthened */ {
    return _CSTD asinl(_Xx);
}

_NODISCARD _Check_return_ inline long double asinh(_In_ long double _Xx) noexcept /* strengthened */ {
    return _CSTD asinhl(_Xx);
}

_NODISCARD _Check_return_ inline long double atan(_In_ long double _Xx) noexcept /* strengthened */ {
    return _CSTD atanl(_Xx);
}

_NODISCARD _Check_return_ inline long double atanh(_In_ long double _Xx) noexcept /* strengthened */ {
    return _CSTD atanhl(_Xx);
}

_NODISCARD _Check_return_ inline long double atan2(_In_ long double _Yx, _In_ long double _Xx) noexcept
/* strengthened */ {
    return _CSTD atan2l(_Yx, _Xx);
}

_NODISCARD _Check_return_ inline long double cbrt(_In_ long double _Xx) noexcept /* strengthened */ {
    return _CSTD cbrtl(_Xx);
}

_NODISCARD _Check_return_ inline long double ceil(_In_ long double _Xx) noexcept /* strengthened */ {
#if _HAS_CMATH_INTRINSICS
    return __ceil(static_cast<double>(_Xx));
#elif defined(__clang__)
    return __builtin_ceill(_Xx);
#else // ^^^ defined(__clang__) / intrinsics unavailable vvv
    return _CSTD ceill(_Xx);
#endif // ^^^ intrinsics unavailable ^^^
}

_NODISCARD _Check_return_ inline long double copysign(_In_ long double _Number, _In_ long double _Sign) noexcept
/* strengthened */ {
#if _HAS_CMATH_INTRINSICS
    return __copysign(static_cast<double>(_Number), static_cast<double>(_Sign));
#elif defined(__clang__)
    return __builtin_copysignl(_Number, _Sign);
#else // ^^^ defined(__clang__) / intrinsics unavailable vvv
    return _CSTD copysignl(_Number, _Sign);
#endif // ^^^ intrinsics unavailable ^^^
}

_NODISCARD _Check_return_ inline long double cos(_In_ long double _Xx) noexcept /* strengthened */ {
    return _CSTD cosl(_Xx);
}

_NODISCARD _Check_return_ inline long double cosh(_In_ long double _Xx) noexcept /* strengthened */ {
    return _CSTD coshl(_Xx);
}

_NODISCARD _Check_return_ inline long double erf(_In_ long double _Xx) noexcept /* strengthened */ {
    return _CSTD erfl(_Xx);
}

_NODISCARD _Check_return_ inline long double erfc(_In_ long double _Xx) noexcept /* strengthened */ {
    return _CSTD erfcl(_Xx);
}

_NODISCARD _Check_return_ inline long double exp(_In_ long double _Xx) noexcept /* strengthened */ {
    return _CSTD expl(_Xx);
}

_NODISCARD _Check_return_ inline long double exp2(_In_ long double _Xx) noexcept /* strengthened */ {
    return _CSTD exp2l(_Xx);
}

_NODISCARD _Check_return_ inline long double expm1(_In_ long double _Xx) noexcept /* strengthened */ {
    return _CSTD expm1l(_Xx);
}

_NODISCARD _Check_return_ inline long double fabs(_In_ long double _Xx) noexcept /* strengthened */ {
    return _CSTD fabsl(_Xx);
}

_NODISCARD _Check_return_ inline long double fdim(_In_ long double _Xx, _In_ long double _Yx) noexcept
/* strengthened */ {
    return _CSTD fdiml(_Xx, _Yx);
}

_NODISCARD _Check_return_ inline long double floor(_In_ long double _Xx) noexcept /* strengthened */ {
#if _HAS_CMATH_INTRINSICS
    return __floor(static_cast<double>(_Xx));
#elif defined(__clang__)
    return __builtin_floorl(_Xx);
#else // ^^^ defined(__clang__) / intrinsics unavailable vvv
    return _CSTD floorl(_Xx);
#endif // ^^^ intrinsics unavailable ^^^
}

_NODISCARD _Check_return_ inline long double fma(
    _In_ long double _Xx, _In_ long double _Yx, _In_ long double _Zx) noexcept /* strengthened */ {
    return _CSTD fmal(_Xx, _Yx, _Zx);
}

_NODISCARD _Check_return_ inline long double fmax(_In_ long double _Xx, _In_ long double _Yx) noexcept
/* strengthened */ {
    return _CSTD fmaxl(_Xx, _Yx);
}

_NODISCARD _Check_return_ inline long double fmin(_In_ long double _Xx, _In_ long double _Yx) noexcept
/* strengthened */ {
    return _CSTD fminl(_Xx, _Yx);
}

_NODISCARD _Check_return_ inline long double fmod(_In_ long double _Xx, _In_ long double _Yx) noexcept
/* strengthened */ {
    return _CSTD fmodl(_Xx, _Yx);
}

inline long double frexp(_In_ long double _Xx, _Out_ int* _Yx) noexcept /* strengthened */ {
    return _CSTD frexpl(_Xx, _Yx);
}

_NODISCARD _Check_return_ inline long double hypot(_In_ long double _Xx, _In_ long double _Yx) noexcept
/* strengthened */ {
    return _CSTD hypotl(_Xx, _Yx);
}

_NODISCARD _Check_return_ inline int ilogb(_In_ long double _Xx) noexcept /* strengthened */ {
    return _CSTD ilogbl(_Xx);
}

_NODISCARD _Check_return_ inline long double ldexp(_In_ long double _Xx, _In_ int _Yx) noexcept /* strengthened */ {
    return _CSTD ldexpl(_Xx, _Yx);
}

_NODISCARD _Check_return_ inline long double lgamma(_In_ long double _Xx) noexcept /* strengthened */ {
    return _CSTD lgammal(_Xx);
}

_NODISCARD _Check_return_ inline long long llrint(_In_ long double _Xx) noexcept /* strengthened */ {
    return _CSTD llrintl(_Xx);
}

_NODISCARD _Check_return_ inline long long llround(_In_ long double _Xx) noexcept /* strengthened */ {
    return _CSTD llroundl(_Xx);
}

_NODISCARD _Check_return_ inline long double log(_In_ long double _Xx) noexcept /* strengthened */ {
    return _CSTD logl(_Xx);
}

_NODISCARD _Check_return_ inline long double log10(_In_ long double _Xx) noexcept /* strengthened */ {
    return _CSTD log10l(_Xx);
}

_NODISCARD _Check_return_ inline long double log1p(_In_ long double _Xx) noexcept /* strengthened */ {
    return _CSTD log1pl(_Xx);
}

_NODISCARD _Check_return_ inline long double log2(_In_ long double _Xx) noexcept /* strengthened */ {
    return _CSTD log2l(_Xx);
}

_NODISCARD _Check_return_ inline long double logb(_In_ long double _Xx) noexcept /* strengthened */ {
    return _CSTD logbl(_Xx);
}

_NODISCARD _Check_return_ inline long lrint(_In_ long double _Xx) noexcept /* strengthened */ {
    return _CSTD lrintl(_Xx);
}

_NODISCARD _Check_return_ inline long lround(_In_ long double _Xx) noexcept /* strengthened */ {
    return _CSTD lroundl(_Xx);
}

inline long double modf(_In_ long double _Xx, _Out_ long double* _Yx) noexcept /* strengthened */ {
    return _CSTD modfl(_Xx, _Yx);
}

_NODISCARD _Check_return_ inline long double nearbyint(_In_ long double _Xx) noexcept /* strengthened */ {
    return _CSTD nearbyintl(_Xx);
}

_NODISCARD _Check_return_ inline long double nextafter(_In_ long double _Xx, _In_ long double _Yx) noexcept
/* strengthened */ {
    return _CSTD nextafterl(_Xx, _Yx);
}

_NODISCARD _Check_return_ inline long double nexttoward(_In_ long double _Xx, _In_ long double _Yx) noexcept
/* strengthened */ {
    return _CSTD nexttowardl(_Xx, _Yx);
}

_NODISCARD _Check_return_ inline long double pow(_In_ long double _Xx, _In_ long double _Yx) noexcept
/* strengthened */ {
    return _CSTD powl(_Xx, _Yx);
}

_NODISCARD _Check_return_ inline long double remainder(_In_ long double _Xx, _In_ long double _Yx) noexcept
/* strengthened */ {
    return _CSTD remainderl(_Xx, _Yx);
}

inline long double remquo(_In_ long double _Xx, _In_ long double _Yx, _Out_ int* _Zx) noexcept /* strengthened */ {
    return _CSTD remquol(_Xx, _Yx, _Zx);
}

_NODISCARD _Check_return_ inline long double rint(_In_ long double _Xx) noexcept /* strengthened */ {
    return _CSTD rintl(_Xx);
}

_NODISCARD _Check_return_ inline long double round(_In_ long double _Xx) noexcept /* strengthened */ {
#if _HAS_CMATH_INTRINSICS
    return __round(static_cast<double>(_Xx));
#elif defined(__clang__)
    return __builtin_roundl(_Xx);
#else // ^^^ defined(__clang__) / intrinsics unavailable vvv
    return _CSTD roundl(_Xx);
#endif // ^^^ intrinsics unavailable ^^^
}

_NODISCARD _Check_return_ inline long double scalbln(_In_ long double _Xx, _In_ long _Yx) noexcept /* strengthened */ {
    return _CSTD scalblnl(_Xx, _Yx);
}

_NODISCARD _Check_return_ inline long double scalbn(_In_ long double _Xx, _In_ int _Yx) noexcept /* strengthened */ {
    return _CSTD scalbnl(_Xx, _Yx);
}

_NODISCARD _Check_return_ inline long double sin(_In_ long double _Xx) noexcept /* strengthened */ {
    return _CSTD sinl(_Xx);
}

_NODISCARD _Check_return_ inline long double sinh(_In_ long double _Xx) noexcept /* strengthened */ {
    return _CSTD sinhl(_Xx);
}

_NODISCARD _Check_return_ inline long double sqrt(_In_ long double _Xx) noexcept /* strengthened */ {
    return _CSTD sqrtl(_Xx);
}

_NODISCARD _Check_return_ inline long double tan(_In_ long double _Xx) noexcept /* strengthened */ {
    return _CSTD tanl(_Xx);
}

_NODISCARD _Check_return_ inline long double tanh(_In_ long double _Xx) noexcept /* strengthened */ {
    return _CSTD tanhl(_Xx);
}

_NODISCARD _Check_return_ inline long double tgamma(_In_ long double _Xx) noexcept /* strengthened */ {
    return _CSTD tgammal(_Xx);
}

_NODISCARD _Check_return_ inline long double trunc(_In_ long double _Xx) noexcept /* strengthened */ {
#if _HAS_CMATH_INTRINSICS
    return __trunc(static_cast<double>(_Xx));
#elif defined(__clang__)
    return __builtin_truncl(_Xx);
#else // ^^^ defined(__clang__) / intrinsics unavailable vvv
    return _CSTD truncl(_Xx);
#endif // ^^^ intrinsics unavailable ^^^
}
_END_EXTERN_CXX_WORKAROUND

_STD_BEGIN
template <class _Ty1, class _Ty2>
using _Common_float_type_t = conditional_t<is_same_v<_Ty1, long double> || is_same_v<_Ty2, long double>, long double,
    conditional_t<is_same_v<_Ty1, float>&& is_same_v<_Ty2, float>, float,
    double>>; // find type for two-argument math function
_STD_END

_EXTERN_CXX_WORKAROUND
template <class _Ty, _STD enable_if_t<_STD is_integral_v<_Ty>, int> = 0>
double frexp(_Ty _Value, _Out_ int* const _Exp) noexcept /* strengthened */ {
    return _CSTD frexp(static_cast<double>(_Value), _Exp);
}

template <class _Ty1, class _Ty2, class _Ty3,
    _STD enable_if_t<_STD is_arithmetic_v<_Ty1>&& _STD is_arithmetic_v<_Ty2>&& _STD is_arithmetic_v<_Ty3>, int> = 0>
_NODISCARD _STD _Common_float_type_t<_Ty1, _STD _Common_float_type_t<_Ty2, _Ty3>> fma(
    _Ty1 _Left, _Ty2 _Middle, _Ty3 _Right) noexcept /* strengthened */ {
    using _Common = _STD _Common_float_type_t<_Ty1, _STD _Common_float_type_t<_Ty2, _Ty3>>;
    if constexpr (_STD is_same_v<_Common, float>) {
        return _CSTD fmaf(static_cast<_Common>(_Left), static_cast<_Common>(_Middle), static_cast<_Common>(_Right));
    }
    else if constexpr (_STD is_same_v<_Common, double>) {
        return _CSTD fma(static_cast<_Common>(_Left), static_cast<_Common>(_Middle), static_cast<_Common>(_Right));
    }
    else {
        return _CSTD fmal(static_cast<_Common>(_Left), static_cast<_Common>(_Middle), static_cast<_Common>(_Right));
    }
}

template <class _Ty1, class _Ty2, _STD enable_if_t<_STD is_arithmetic_v<_Ty1>&& _STD is_arithmetic_v<_Ty2>, int> = 0>
_STD _Common_float_type_t<_Ty1, _Ty2> remquo(_Ty1 _Left, _Ty2 _Right, int* _Pquo) noexcept /* strengthened */ {
    using _Common = _STD _Common_float_type_t<_Ty1, _Ty2>;
    if constexpr (_STD is_same_v<_Common, float>) {
        return _CSTD remquof(static_cast<_Common>(_Left), static_cast<_Common>(_Right), _Pquo);
    }
    else if constexpr (_STD is_same_v<_Common, double>) {
        return _CSTD remquo(static_cast<_Common>(_Left), static_cast<_Common>(_Right), _Pquo);
    }
    else {
        return _CSTD remquol(static_cast<_Common>(_Left), static_cast<_Common>(_Right), _Pquo);
    }
}

#define _GENERIC_MATH1_BASE(NAME, RET, FUN)                                  \
    template <class _Ty, _STD enable_if_t<_STD is_integral_v<_Ty>, int> = 0> \
    _NODISCARD RET NAME(_Ty _Left) noexcept /* strengthened */ {             \
        return FUN(static_cast<double>(_Left));                              \
    }

#define _GENERIC_MATH1R(FUN, RET) _GENERIC_MATH1_BASE(FUN, RET, _CSTD FUN)
#define _GENERIC_MATH1(FUN)       _GENERIC_MATH1R(FUN, double)

#if _HAS_CMATH_INTRINSICS
#define _GENERIC_MATH1I(FUN, CLANG_INTRIN, MSVC_INTRIN) _GENERIC_MATH1_BASE(FUN, double, MSVC_INTRIN)
#elif defined(__clang__)
#define _GENERIC_MATH1I(FUN, CLANG_INTRIN, MSVC_INTRIN) _GENERIC_MATH1_BASE(FUN, double, CLANG_INTRIN)
#else // ^^^ defined(__clang__) / intrinsics unavailable vvv
#define _GENERIC_MATH1I(FUN, CLANG_INTRIN, MSVC_INTRIN) _GENERIC_MATH1_BASE(FUN, double, _CSTD FUN)
#endif // ^^^ intrinsics unavailable ^^^

#define _GENERIC_MATH1X(FUN, ARG2)                                             \
    template <class _Ty, _STD enable_if_t<_STD is_integral_v<_Ty>, int> = 0>   \
    _NODISCARD double FUN(_Ty _Left, ARG2 _Arg2) noexcept /* strengthened */ { \
        return _CSTD FUN(static_cast<double>(_Left), _Arg2);                   \
    }

// When the arguments are both floats or both long doubles, overload resolution prefers the
// non-template overloads to the templates generated from this macro. The templates generated from
// this macro are only selected by overload resolution when both arguments have integral type, or
// when the types of the two arguments differ, in which case _Common_float_type_t is either double
// or long double. Note that double and long double have the same underlying representation on our
// supported platforms.
#define _GENERIC_MATH2_BASE(NAME, FUN)                                                                           \
    template <class _Ty1, class _Ty2,                                                                            \
        _STD enable_if_t<_STD is_arithmetic_v<_Ty1> && _STD is_arithmetic_v<_Ty2>, int> = 0>                     \
    _NODISCARD _STD _Common_float_type_t<_Ty1, _Ty2> NAME(_Ty1 _Left, _Ty2 _Right) noexcept /* strengthened */ { \
        return FUN(static_cast<double>(_Left), static_cast<double>(_Right));                                     \
    }

#define _GENERIC_MATH2(FUN) _GENERIC_MATH2_BASE(FUN, _CSTD FUN)

#if _HAS_CMATH_INTRINSICS
#define _GENERIC_MATH2I(FUN, CLANG_INTRIN, MSVC_INTRIN) _GENERIC_MATH2_BASE(FUN, MSVC_INTRIN)
#elif defined(__clang__)
#define _GENERIC_MATH2I(FUN, CLANG_INTRIN, MSVC_INTRIN) _GENERIC_MATH2_BASE(FUN, CLANG_INTRIN)
#else // ^^^ defined(__clang__) / intrinsics unavailable vvv
#define _GENERIC_MATH2I(FUN, CLANG_INTRIN, MSVC_INTRIN) _GENERIC_MATH2_BASE(FUN, _CSTD FUN)
#endif // ^^^ intrinsics unavailable ^^^

// The following order matches N4950 [cmath.syn].
_GENERIC_MATH1(acos)
_GENERIC_MATH1(asin)
_GENERIC_MATH1(atan)
_GENERIC_MATH2(atan2)
_GENERIC_MATH1(cos)
_GENERIC_MATH1(sin)
_GENERIC_MATH1(tan)
_GENERIC_MATH1(acosh)
_GENERIC_MATH1(asinh)
_GENERIC_MATH1(atanh)
_GENERIC_MATH1(cosh)
_GENERIC_MATH1(sinh)
_GENERIC_MATH1(tanh)
_GENERIC_MATH1(exp)
_GENERIC_MATH1(exp2)
_GENERIC_MATH1(expm1)
// frexp() is hand-crafted
_GENERIC_MATH1R(ilogb, int)
_GENERIC_MATH1X(ldexp, int)
_GENERIC_MATH1(log)
_GENERIC_MATH1(log10)
_GENERIC_MATH1(log1p)
_GENERIC_MATH1(log2)
_GENERIC_MATH1(logb)
// No modf(), types must match
_GENERIC_MATH1X(scalbn, int)
_GENERIC_MATH1X(scalbln, long)
_GENERIC_MATH1(cbrt)
// abs() has integer overloads
_GENERIC_MATH1(fabs)
_GENERIC_MATH2(hypot)
// 3-arg hypot() is hand-crafted
_GENERIC_MATH2(pow)
_GENERIC_MATH1(sqrt)
_GENERIC_MATH1(erf)
_GENERIC_MATH1(erfc)
_GENERIC_MATH1(lgamma)
_GENERIC_MATH1(tgamma)
_GENERIC_MATH1I(ceil, __builtin_ceil, __ceil)
_GENERIC_MATH1I(floor, __builtin_floor, __floor)
_GENERIC_MATH1(nearbyint)
_GENERIC_MATH1(rint)
_GENERIC_MATH1R(lrint, long)
_GENERIC_MATH1R(llrint, long long)
_GENERIC_MATH1I(round, __builtin_round, __round)
_GENERIC_MATH1R(lround, long)
_GENERIC_MATH1R(llround, long long)
_GENERIC_MATH1I(trunc, __builtin_trunc, __trunc)
_GENERIC_MATH2(fmod)
_GENERIC_MATH2(remainder)
// remquo() is hand-crafted
_GENERIC_MATH2I(copysign, __builtin_copysign, __copysign)
// nan(const char*) is exempt
_GENERIC_MATH2(nextafter)
_GENERIC_MATH1X(nexttoward, long double)
_GENERIC_MATH2(fdim)
_GENERIC_MATH2(fmax)
_GENERIC_MATH2(fmin)
// fma() is hand-crafted
// lerp() is hand-crafted
// The "classification/comparison functions" (fpclassify(), etc.) are exempt, LWG-1327

#undef _GENERIC_MATH1_BASE
#undef _GENERIC_MATH1R
#undef _GENERIC_MATH1
#undef _GENERIC_MATH1I
#undef _GENERIC_MATH1X
#undef _GENERIC_MATH2_BASE
#undef _GENERIC_MATH2
#undef _GENERIC_MATH2I
#undef _HAS_CMATH_INTRINSICS
_END_EXTERN_CXX_WORKAROUND

_STD_BEGIN
_EXPORT_STD using _CSTD abs;
_EXPORT_STD using _CSTD acos;
_EXPORT_STD using _CSTD asin;
_EXPORT_STD using _CSTD atan;
_EXPORT_STD using _CSTD atan2;
_EXPORT_STD using _CSTD ceil;
_EXPORT_STD using _CSTD cos;
_EXPORT_STD using _CSTD cosh;
_EXPORT_STD using _CSTD exp;
_EXPORT_STD using _CSTD fabs;
_EXPORT_STD using _CSTD floor;
_EXPORT_STD using _CSTD fmod;
_EXPORT_STD using _CSTD frexp;
_EXPORT_STD using _CSTD ldexp;
_EXPORT_STD using _CSTD log;
_EXPORT_STD using _CSTD log10;
_EXPORT_STD using _CSTD modf;
_EXPORT_STD using _CSTD pow;
_EXPORT_STD using _CSTD sin;
_EXPORT_STD using _CSTD sinh;
_EXPORT_STD using _CSTD sqrt;
_EXPORT_STD using _CSTD tan;
_EXPORT_STD using _CSTD tanh;

_EXPORT_STD using _CSTD acosf;
_EXPORT_STD using _CSTD asinf;
_EXPORT_STD using _CSTD atanf;
_EXPORT_STD using _CSTD atan2f;
_EXPORT_STD using _CSTD ceilf;
_EXPORT_STD using _CSTD cosf;
_EXPORT_STD using _CSTD coshf;
_EXPORT_STD using _CSTD expf;
_EXPORT_STD using _CSTD fabsf;
_EXPORT_STD using _CSTD floorf;
_EXPORT_STD using _CSTD fmodf;
_EXPORT_STD using _CSTD frexpf;
_EXPORT_STD using _CSTD ldexpf;
_EXPORT_STD using _CSTD logf;
_EXPORT_STD using _CSTD log10f;
_EXPORT_STD using _CSTD modff;
_EXPORT_STD using _CSTD powf;
_EXPORT_STD using _CSTD sinf;
_EXPORT_STD using _CSTD sinhf;
_EXPORT_STD using _CSTD sqrtf;
_EXPORT_STD using _CSTD tanf;
_EXPORT_STD using _CSTD tanhf;

_EXPORT_STD using _CSTD acosl;
_EXPORT_STD using _CSTD asinl;
_EXPORT_STD using _CSTD atanl;
_EXPORT_STD using _CSTD atan2l;
_EXPORT_STD using _CSTD ceill;
_EXPORT_STD using _CSTD cosl;
_EXPORT_STD using _CSTD coshl;
_EXPORT_STD using _CSTD expl;
_EXPORT_STD using _CSTD fabsl;
_EXPORT_STD using _CSTD floorl;
_EXPORT_STD using _CSTD fmodl;
_EXPORT_STD using _CSTD frexpl;
_EXPORT_STD using _CSTD ldexpl;
_EXPORT_STD using _CSTD logl;
_EXPORT_STD using _CSTD log10l;
_EXPORT_STD using _CSTD modfl;
_EXPORT_STD using _CSTD powl;
_EXPORT_STD using _CSTD sinl;
_EXPORT_STD using _CSTD sinhl;
_EXPORT_STD using _CSTD sqrtl;
_EXPORT_STD using _CSTD tanl;
_EXPORT_STD using _CSTD tanhl;

_EXPORT_STD using _CSTD float_t;
_EXPORT_STD using _CSTD double_t;

_EXPORT_STD using _CSTD acosh;
_EXPORT_STD using _CSTD asinh;
_EXPORT_STD using _CSTD atanh;
_EXPORT_STD using _CSTD cbrt;
_EXPORT_STD using _CSTD erf;
_EXPORT_STD using _CSTD erfc;
_EXPORT_STD using _CSTD expm1;
_EXPORT_STD using _CSTD exp2;

inline namespace _Binary_hypot {
    _EXPORT_STD using _CSTD hypot;
} // namespace _Binary_hypot

_EXPORT_STD using _CSTD ilogb;
_EXPORT_STD using _CSTD lgamma;
_EXPORT_STD using _CSTD log1p;
_EXPORT_STD using _CSTD log2;
_EXPORT_STD using _CSTD logb;
_EXPORT_STD using _CSTD llrint;
_EXPORT_STD using _CSTD lrint;
_EXPORT_STD using _CSTD nearbyint;
_EXPORT_STD using _CSTD rint;
_EXPORT_STD using _CSTD llround;
_EXPORT_STD using _CSTD lround;
_EXPORT_STD using _CSTD fdim;
_EXPORT_STD using _CSTD fma;
_EXPORT_STD using _CSTD fmax;
_EXPORT_STD using _CSTD fmin;
_EXPORT_STD using _CSTD round;
_EXPORT_STD using _CSTD trunc;
_EXPORT_STD using _CSTD remainder;
_EXPORT_STD using _CSTD remquo;
_EXPORT_STD using _CSTD copysign;
_EXPORT_STD using _CSTD nan;
_EXPORT_STD using _CSTD nextafter;
_EXPORT_STD using _CSTD scalbn;
_EXPORT_STD using _CSTD scalbln;
_EXPORT_STD using _CSTD nexttoward;
_EXPORT_STD using _CSTD tgamma;

_EXPORT_STD using _CSTD acoshf;
_EXPORT_STD using _CSTD asinhf;
_EXPORT_STD using _CSTD atanhf;
_EXPORT_STD using _CSTD cbrtf;
_EXPORT_STD using _CSTD erff;
_EXPORT_STD using _CSTD erfcf;
_EXPORT_STD using _CSTD expm1f;
_EXPORT_STD using _CSTD exp2f;
_EXPORT_STD using _CSTD hypotf;
_EXPORT_STD using _CSTD ilogbf;
_EXPORT_STD using _CSTD lgammaf;
_EXPORT_STD using _CSTD log1pf;
_EXPORT_STD using _CSTD log2f;
_EXPORT_STD using _CSTD logbf;
_EXPORT_STD using _CSTD llrintf;
_EXPORT_STD using _CSTD lrintf;
_EXPORT_STD using _CSTD nearbyintf;
_EXPORT_STD using _CSTD rintf;
_EXPORT_STD using _CSTD llroundf;
_EXPORT_STD using _CSTD lroundf;
_EXPORT_STD using _CSTD fdimf;
_EXPORT_STD using _CSTD fmaf;
_EXPORT_STD using _CSTD fmaxf;
_EXPORT_STD using _CSTD fminf;
_EXPORT_STD using _CSTD roundf;
_EXPORT_STD using _CSTD truncf;
_EXPORT_STD using _CSTD remainderf;
_EXPORT_STD using _CSTD remquof;
_EXPORT_STD using _CSTD copysignf;
_EXPORT_STD using _CSTD nanf;
_EXPORT_STD using _CSTD nextafterf;
_EXPORT_STD using _CSTD scalbnf;
_EXPORT_STD using _CSTD scalblnf;
_EXPORT_STD using _CSTD nexttowardf;
_EXPORT_STD using _CSTD tgammaf;

_EXPORT_STD using _CSTD acoshl;
_EXPORT_STD using _CSTD asinhl;
_EXPORT_STD using _CSTD atanhl;
_EXPORT_STD using _CSTD cbrtl;
_EXPORT_STD using _CSTD erfl;
_EXPORT_STD using _CSTD erfcl;
_EXPORT_STD using _CSTD expm1l;
_EXPORT_STD using _CSTD exp2l;
_EXPORT_STD using _CSTD hypotl;
_EXPORT_STD using _CSTD ilogbl;
_EXPORT_STD using _CSTD lgammal;
_EXPORT_STD using _CSTD log1pl;
_EXPORT_STD using _CSTD log2l;
_EXPORT_STD using _CSTD logbl;
_EXPORT_STD using _CSTD llrintl;
_EXPORT_STD using _CSTD lrintl;
_EXPORT_STD using _CSTD nearbyintl;
_EXPORT_STD using _CSTD rintl;
_EXPORT_STD using _CSTD llroundl;
_EXPORT_STD using _CSTD lroundl;
_EXPORT_STD using _CSTD fdiml;
_EXPORT_STD using _CSTD fmal;
_EXPORT_STD using _CSTD fmaxl;
_EXPORT_STD using _CSTD fminl;
_EXPORT_STD using _CSTD roundl;
_EXPORT_STD using _CSTD truncl;
_EXPORT_STD using _CSTD remainderl;
_EXPORT_STD using _CSTD remquol;
_EXPORT_STD using _CSTD copysignl;
_EXPORT_STD using _CSTD nanl;
_EXPORT_STD using _CSTD nextafterl;
_EXPORT_STD using _CSTD scalbnl;
_EXPORT_STD using _CSTD scalblnl;
_EXPORT_STD using _CSTD nexttowardl;
_EXPORT_STD using _CSTD tgammal;

_EXPORT_STD using _CSTD fpclassify;
_EXPORT_STD using _CSTD signbit;
_EXPORT_STD using _CSTD isfinite;
_EXPORT_STD using _CSTD isinf;
_EXPORT_STD using _CSTD isnan;
_EXPORT_STD using _CSTD isnormal;
_EXPORT_STD using _CSTD isgreater;
_EXPORT_STD using _CSTD isgreaterequal;
_EXPORT_STD using _CSTD isless;
_EXPORT_STD using _CSTD islessequal;
_EXPORT_STD using _CSTD islessgreater;
_EXPORT_STD using _CSTD isunordered;
_STD_END

#if _HAS_CXX17
extern "C" {
    _NODISCARD _CRT_SATELLITE_2 double __stdcall __std_smf_assoc_laguerre(unsigned int, unsigned int, double) noexcept;
    _NODISCARD _CRT_SATELLITE_2 float __stdcall __std_smf_assoc_laguerref(unsigned int, unsigned int, float) noexcept;
    _NODISCARD _CRT_SATELLITE_2 double __stdcall __std_smf_assoc_legendre(unsigned int, unsigned int, double) noexcept;
    _NODISCARD _CRT_SATELLITE_2 float __stdcall __std_smf_assoc_legendref(unsigned int, unsigned int, float) noexcept;
    _NODISCARD _CRT_SATELLITE_2 double __stdcall __std_smf_beta(double, double) noexcept;
    _NODISCARD _CRT_SATELLITE_2 float __stdcall __std_smf_betaf(float, float) noexcept;
    _NODISCARD _CRT_SATELLITE_2 double __stdcall __std_smf_comp_ellint_1(double) noexcept;
    _NODISCARD _CRT_SATELLITE_2 float __stdcall __std_smf_comp_ellint_1f(float) noexcept;
    _NODISCARD _CRT_SATELLITE_2 double __stdcall __std_smf_comp_ellint_2(double) noexcept;
    _NODISCARD _CRT_SATELLITE_2 float __stdcall __std_smf_comp_ellint_2f(float) noexcept;
    _NODISCARD _CRT_SATELLITE_2 double __stdcall __std_smf_comp_ellint_3(double, double) noexcept;
    _NODISCARD _CRT_SATELLITE_2 float __stdcall __std_smf_comp_ellint_3f(float, float) noexcept;
    _NODISCARD _CRT_SATELLITE_2 double __stdcall __std_smf_cyl_bessel_i(double, double) noexcept;
    _NODISCARD _CRT_SATELLITE_2 float __stdcall __std_smf_cyl_bessel_if(float, float) noexcept;
    _NODISCARD _CRT_SATELLITE_2 double __stdcall __std_smf_cyl_bessel_j(double, double) noexcept;
    _NODISCARD _CRT_SATELLITE_2 float __stdcall __std_smf_cyl_bessel_jf(float, float) noexcept;
    _NODISCARD _CRT_SATELLITE_2 double __stdcall __std_smf_cyl_bessel_k(double, double) noexcept;
    _NODISCARD _CRT_SATELLITE_2 float __stdcall __std_smf_cyl_bessel_kf(float, float) noexcept;
    _NODISCARD _CRT_SATELLITE_2 double __stdcall __std_smf_cyl_neumann(double, double) noexcept;
    _NODISCARD _CRT_SATELLITE_2 float __stdcall __std_smf_cyl_neumannf(float, float) noexcept;
    _NODISCARD _CRT_SATELLITE_2 double __stdcall __std_smf_ellint_1(double, double) noexcept;
    _NODISCARD _CRT_SATELLITE_2 float __stdcall __std_smf_ellint_1f(float, float) noexcept;
    _NODISCARD _CRT_SATELLITE_2 double __stdcall __std_smf_ellint_2(double, double) noexcept;
    _NODISCARD _CRT_SATELLITE_2 float __stdcall __std_smf_ellint_2f(float, float) noexcept;
    _NODISCARD _CRT_SATELLITE_2 double __stdcall __std_smf_ellint_3(double, double, double) noexcept;
    _NODISCARD _CRT_SATELLITE_2 float __stdcall __std_smf_ellint_3f(float, float, float) noexcept;
    _NODISCARD _CRT_SATELLITE_2 double __stdcall __std_smf_expint(double) noexcept;
    _NODISCARD _CRT_SATELLITE_2 float __stdcall __std_smf_expintf(float) noexcept;
    _NODISCARD _CRT_SATELLITE_2 double __stdcall __std_smf_hermite(unsigned int, double) noexcept;
    _NODISCARD _CRT_SATELLITE_2 float __stdcall __std_smf_hermitef(unsigned int, float) noexcept;
    _NODISCARD _CRT_SATELLITE_2 double __stdcall __std_smf_laguerre(unsigned int, double) noexcept;
    _NODISCARD _CRT_SATELLITE_2 float __stdcall __std_smf_laguerref(unsigned int, float) noexcept;
    _NODISCARD _CRT_SATELLITE_2 double __stdcall __std_smf_legendre(unsigned int, double) noexcept;
    _NODISCARD _CRT_SATELLITE_2 float __stdcall __std_smf_legendref(unsigned int, float) noexcept;
    _NODISCARD _CRT_SATELLITE_2 double __stdcall __std_smf_riemann_zeta(double) noexcept;
    _NODISCARD _CRT_SATELLITE_2 float __stdcall __std_smf_riemann_zetaf(float) noexcept;
    _NODISCARD _CRT_SATELLITE_2 double __stdcall __std_smf_sph_bessel(unsigned int, double) noexcept;
    _NODISCARD _CRT_SATELLITE_2 float __stdcall __std_smf_sph_besself(unsigned int, float) noexcept;
    _NODISCARD _CRT_SATELLITE_2 double __stdcall __std_smf_sph_legendre(unsigned int, unsigned int, double) noexcept;
    _NODISCARD _CRT_SATELLITE_2 float __stdcall __std_smf_sph_legendref(unsigned int, unsigned int, float) noexcept;
    _NODISCARD _CRT_SATELLITE_2 double __stdcall __std_smf_sph_neumann(unsigned int, double) noexcept;
    _NODISCARD _CRT_SATELLITE_2 float __stdcall __std_smf_sph_neumannf(unsigned int, float) noexcept;
    _NODISCARD _CRT_SATELLITE_2 double __stdcall __std_smf_hypot3(double, double, double) noexcept;
    _NODISCARD _CRT_SATELLITE_2 float __stdcall __std_smf_hypot3f(float, float, float) noexcept;
} // extern "C"

_STD_BEGIN
_EXPORT_STD _NODISCARD inline double assoc_laguerre(
    const unsigned int _Degree, const unsigned int _Order, const double _Value) noexcept /* strengthened */ {
    return __std_smf_assoc_laguerre(_Degree, _Order, _Value);
}

_EXPORT_STD _NODISCARD inline float assoc_laguerref(
    const unsigned int _Degree, const unsigned int _Order, const float _Value) noexcept /* strengthened */ {
    return __std_smf_assoc_laguerref(_Degree, _Order, _Value);
}

_EXPORT_STD _NODISCARD inline long double assoc_laguerrel(
    const unsigned int _Degree, const unsigned int _Order, const long double _Value) noexcept /* strengthened */ {
    return __std_smf_assoc_laguerre(_Degree, _Order, static_cast<double>(_Value));
}

_EXPORT_STD _NODISCARD inline double assoc_legendre(
    const unsigned int _Degree, const unsigned int _Order, const double _Value) noexcept /* strengthened */ {
    return __std_smf_assoc_legendre(_Degree, _Order, _Value);
}

_EXPORT_STD _NODISCARD inline float assoc_legendref(
    const unsigned int _Degree, const unsigned int _Order, const float _Value) noexcept /* strengthened */ {
    return __std_smf_assoc_legendref(_Degree, _Order, _Value);
}

_EXPORT_STD _NODISCARD inline long double assoc_legendrel(
    const unsigned int _Degree, const unsigned int _Order, const long double _Value) noexcept /* strengthened */ {
    return __std_smf_assoc_legendre(_Degree, _Order, static_cast<double>(_Value));
}

_EXPORT_STD _NODISCARD inline double beta(const double _Arg1, const double _Arg2) noexcept /* strengthened */ {
    return __std_smf_beta(_Arg1, _Arg2);
}

_EXPORT_STD _NODISCARD inline float betaf(const float _Arg1, const float _Arg2) noexcept /* strengthened */ {
    return __std_smf_betaf(_Arg1, _Arg2);
}

_EXPORT_STD _NODISCARD inline long double betal(const long double _Arg1, const long double _Arg2) noexcept
/* strengthened */ {
    return __std_smf_beta(static_cast<double>(_Arg1), static_cast<double>(_Arg2));
}

_EXPORT_STD _NODISCARD inline double comp_ellint_1(const double _Arg) noexcept /* strengthened */ {
    return __std_smf_comp_ellint_1(_Arg);
}

_EXPORT_STD _NODISCARD inline float comp_ellint_1f(const float _Arg) noexcept /* strengthened */ {
    return __std_smf_comp_ellint_1f(_Arg);
}

_EXPORT_STD _NODISCARD inline long double comp_ellint_1l(const long double _Arg) noexcept /* strengthened */ {
    return __std_smf_comp_ellint_1(static_cast<double>(_Arg));
}

_EXPORT_STD _NODISCARD inline double comp_ellint_2(const double _Arg) noexcept /* strengthened */ {
    return __std_smf_comp_ellint_2(_Arg);
}

_EXPORT_STD _NODISCARD inline float comp_ellint_2f(const float _Arg) noexcept /* strengthened */ {
    return __std_smf_comp_ellint_2f(_Arg);
}

_EXPORT_STD _NODISCARD inline long double comp_ellint_2l(const long double _Arg) noexcept /* strengthened */ {
    return __std_smf_comp_ellint_2(static_cast<double>(_Arg));
}

_EXPORT_STD _NODISCARD inline double comp_ellint_3(const double _Arg1, const double _Arg2) noexcept /* strengthened */ {
    return __std_smf_comp_ellint_3(_Arg1, _Arg2);
}

_EXPORT_STD _NODISCARD inline float comp_ellint_3f(const float _Arg1, const float _Arg2) noexcept /* strengthened */ {
    return __std_smf_comp_ellint_3f(_Arg1, _Arg2);
}

_EXPORT_STD _NODISCARD inline long double comp_ellint_3l(const long double _Arg1, const long double _Arg2) noexcept
/* strengthened */ {
    return __std_smf_comp_ellint_3(static_cast<double>(_Arg1), static_cast<double>(_Arg2));
}

_EXPORT_STD _NODISCARD inline double cyl_bessel_i(const double _Arg1, const double _Arg2) noexcept /* strengthened */ {
    return __std_smf_cyl_bessel_i(_Arg1, _Arg2);
}

_EXPORT_STD _NODISCARD inline float cyl_bessel_if(const float _Arg1, const float _Arg2) noexcept /* strengthened */ {
    return __std_smf_cyl_bessel_if(_Arg1, _Arg2);
}

_EXPORT_STD _NODISCARD inline long double cyl_bessel_il(const long double _Arg1, const long double _Arg2) noexcept
/* strengthened */ {
    return __std_smf_cyl_bessel_i(static_cast<double>(_Arg1), static_cast<double>(_Arg2));
}

_EXPORT_STD _NODISCARD inline double cyl_bessel_j(const double _Arg1, const double _Arg2) noexcept /* strengthened */ {
    return __std_smf_cyl_bessel_j(_Arg1, _Arg2);
}

_EXPORT_STD _NODISCARD inline float cyl_bessel_jf(const float _Arg1, const float _Arg2) noexcept /* strengthened */ {
    return __std_smf_cyl_bessel_jf(_Arg1, _Arg2);
}

_EXPORT_STD _NODISCARD inline long double cyl_bessel_jl(const long double _Arg1, const long double _Arg2) noexcept
/* strengthened */ {
    return __std_smf_cyl_bessel_j(static_cast<double>(_Arg1), static_cast<double>(_Arg2));
}

_EXPORT_STD _NODISCARD inline double cyl_bessel_k(const double _Arg1, const double _Arg2) noexcept /* strengthened */ {
    return __std_smf_cyl_bessel_k(_Arg1, _Arg2);
}

_EXPORT_STD _NODISCARD inline float cyl_bessel_kf(const float _Arg1, const float _Arg2) noexcept /* strengthened */ {
    return __std_smf_cyl_bessel_kf(_Arg1, _Arg2);
}

_EXPORT_STD _NODISCARD inline long double cyl_bessel_kl(const long double _Arg1, const long double _Arg2) noexcept
/* strengthened */ {
    return __std_smf_cyl_bessel_k(static_cast<double>(_Arg1), static_cast<double>(_Arg2));
}

_EXPORT_STD _NODISCARD inline double cyl_neumann(const double _Arg1, const double _Arg2) noexcept /* strengthened */ {
    return __std_smf_cyl_neumann(_Arg1, _Arg2);
}

_EXPORT_STD _NODISCARD inline float cyl_neumannf(const float _Arg1, const float _Arg2) noexcept /* strengthened */ {
    return __std_smf_cyl_neumannf(_Arg1, _Arg2);
}

_EXPORT_STD _NODISCARD inline long double cyl_neumannl(const long double _Arg1, const long double _Arg2) noexcept
/* strengthened */ {
    return __std_smf_cyl_neumann(static_cast<double>(_Arg1), static_cast<double>(_Arg2));
}

_EXPORT_STD _NODISCARD inline double ellint_1(const double _Arg1, const double _Arg2) noexcept /* strengthened */ {
    return __std_smf_ellint_1(_Arg1, _Arg2);
}

_EXPORT_STD _NODISCARD inline float ellint_1f(const float _Arg1, const float _Arg2) noexcept /* strengthened */ {
    return __std_smf_ellint_1f(_Arg1, _Arg2);
}

_EXPORT_STD _NODISCARD inline long double ellint_1l(const long double _Arg1, const long double _Arg2) noexcept
/* strengthened */ {
    return __std_smf_ellint_1(static_cast<double>(_Arg1), static_cast<double>(_Arg2));
}

_EXPORT_STD _NODISCARD inline double ellint_2(const double _Arg1, const double _Arg2) noexcept /* strengthened */ {
    return __std_smf_ellint_2(_Arg1, _Arg2);
}

_EXPORT_STD _NODISCARD inline float ellint_2f(const float _Arg1, const float _Arg2) noexcept /* strengthened */ {
    return __std_smf_ellint_2f(_Arg1, _Arg2);
}

_EXPORT_STD _NODISCARD inline long double ellint_2l(const long double _Arg1, const long double _Arg2) noexcept
/* strengthened */ {
    return __std_smf_ellint_2(static_cast<double>(_Arg1), static_cast<double>(_Arg2));
}

_EXPORT_STD _NODISCARD inline double ellint_3(const double _Arg1, const double _Arg2, const double _Arg3) noexcept
/* strengthened */ {
    return __std_smf_ellint_3(_Arg1, _Arg2, _Arg3);
}

_EXPORT_STD _NODISCARD inline float ellint_3f(const float _Arg1, const float _Arg2, const float _Arg3) noexcept
/* strengthened */ {
    return __std_smf_ellint_3f(_Arg1, _Arg2, _Arg3);
}

_EXPORT_STD _NODISCARD inline long double ellint_3l(
    const long double _Arg1, const long double _Arg2, const long double _Arg3) noexcept /* strengthened */ {
    return __std_smf_ellint_3(static_cast<double>(_Arg1), static_cast<double>(_Arg2), static_cast<double>(_Arg3));
}

_EXPORT_STD _NODISCARD inline double expint(const double _Arg) noexcept /* strengthened */ {
    return __std_smf_expint(_Arg);
}

_EXPORT_STD _NODISCARD inline float expintf(const float _Arg) noexcept /* strengthened */ {
    return __std_smf_expintf(_Arg);
}

_EXPORT_STD _NODISCARD inline long double expintl(const long double _Arg) noexcept /* strengthened */ {
    return __std_smf_expint(static_cast<double>(_Arg));
}

_EXPORT_STD _NODISCARD inline double hermite(const unsigned int _Arg1, const double _Arg2) noexcept /* strengthened */ {
    return __std_smf_hermite(_Arg1, _Arg2);
}

_EXPORT_STD _NODISCARD inline float hermitef(const unsigned int _Arg1, const float _Arg2) noexcept /* strengthened */ {
    return __std_smf_hermitef(_Arg1, _Arg2);
}

_EXPORT_STD _NODISCARD inline long double hermitel(const unsigned int _Arg1, const long double _Arg2) noexcept
/* strengthened */ {
    return __std_smf_hermite(_Arg1, static_cast<double>(_Arg2));
}

_EXPORT_STD _NODISCARD inline double laguerre(const unsigned int _Arg1, const double _Arg2) noexcept
/* strengthened */ {
    return __std_smf_laguerre(_Arg1, _Arg2);
}

_EXPORT_STD _NODISCARD inline float laguerref(const unsigned int _Arg1, const float _Arg2) noexcept /* strengthened */ {
    return __std_smf_laguerref(_Arg1, _Arg2);
}

_EXPORT_STD _NODISCARD inline long double laguerrel(const unsigned int _Arg1, const long double _Arg2) noexcept
/* strengthened */ {
    return __std_smf_laguerre(_Arg1, static_cast<double>(_Arg2));
}

_EXPORT_STD _NODISCARD inline double legendre(const unsigned int _Degree, const double _Value) noexcept
/* strengthened */ {
    return __std_smf_legendre(_Degree, _Value);
}

_EXPORT_STD _NODISCARD inline float legendref(const unsigned int _Degree, const float _Value) noexcept
/* strengthened */ {
    return __std_smf_legendref(_Degree, _Value);
}

_EXPORT_STD _NODISCARD inline long double legendrel(const unsigned int _Degree, const long double _Value) noexcept
/* strengthened */ {
    return __std_smf_legendre(_Degree, static_cast<double>(_Value));
}

_EXPORT_STD _NODISCARD inline double riemann_zeta(const double _Arg) noexcept /* strengthened */ {
    return __std_smf_riemann_zeta(_Arg);
}
_EXPORT_STD _NODISCARD inline float riemann_zetaf(const float _Arg) noexcept /* strengthened */ {
    return __std_smf_riemann_zetaf(_Arg);
}

_EXPORT_STD _NODISCARD inline long double riemann_zetal(const long double _Arg) noexcept /* strengthened */ {
    return __std_smf_riemann_zeta(static_cast<double>(_Arg));
}

_EXPORT_STD _NODISCARD inline double sph_bessel(const unsigned int _Arg1, const double _Arg2) noexcept
/* strengthened */ {
    return __std_smf_sph_bessel(_Arg1, _Arg2);
}

_EXPORT_STD _NODISCARD inline float sph_besself(const unsigned int _Arg1, const float _Arg2) noexcept
/* strengthened */ {
    return __std_smf_sph_besself(_Arg1, _Arg2);
}

_EXPORT_STD _NODISCARD inline long double sph_bessell(const unsigned int _Arg1, const long double _Arg2) noexcept
/* strengthened */ {
    return __std_smf_sph_bessel(_Arg1, static_cast<double>(_Arg2));
}

_EXPORT_STD _NODISCARD inline double sph_legendre(
    const unsigned int _Arg1, const unsigned int _Arg2, const double _Theta) noexcept
    /* strengthened */ {
    return __std_smf_sph_legendre(_Arg1, _Arg2, _Theta);
}

_EXPORT_STD _NODISCARD inline float sph_legendref(
    const unsigned int _Arg1, const unsigned int _Arg2, const float _Theta) noexcept
    /* strengthened */ {
    return __std_smf_sph_legendref(_Arg1, _Arg2, _Theta);
}

_EXPORT_STD _NODISCARD inline long double sph_legendrel(
    const unsigned int _Arg1, const unsigned int _Arg2, const long double _Theta) noexcept /* strengthened */ {
    return __std_smf_sph_legendre(_Arg1, _Arg2, static_cast<double>(_Theta));
}

_EXPORT_STD _NODISCARD inline double sph_neumann(const unsigned int _Arg1, const double _Arg2) noexcept
/* strengthened */ {
    return __std_smf_sph_neumann(_Arg1, _Arg2);
}

_EXPORT_STD _NODISCARD inline float sph_neumannf(const unsigned int _Arg1, const float _Arg2) noexcept
/* strengthened */ {
    return __std_smf_sph_neumannf(_Arg1, _Arg2);
}

_EXPORT_STD _NODISCARD inline long double sph_neumannl(const unsigned int _Arg1, const long double _Arg2) noexcept
/* strengthened */ {
    return __std_smf_sph_neumann(_Arg1, static_cast<double>(_Arg2));
}

#define _GENERIC_MATH_SPECIAL1(NAME)                                                  \
    _EXPORT_STD template <class _Ty, enable_if_t<is_arithmetic_v<_Ty>, int> = 0>      \
    _NODISCARD auto NAME(const _Ty _Arg) noexcept /* strengthened */ {                \
        using _Common = conditional_t<is_integral_v<_Ty>, double, _Ty>;               \
        if constexpr (is_same_v<_Common, float>) {                                    \
            return __std_smf_##NAME##f(_Arg);                                         \
        } else {                                                                      \
            return static_cast<_Common>(__std_smf_##NAME(static_cast<double>(_Arg))); \
        }                                                                             \
    }

#define _GENERIC_MATH_SPECIAL2(NAME)                                                                               \
    _EXPORT_STD template <class _Ty1, class _Ty2,                                                                  \
        enable_if_t<is_arithmetic_v<_Ty1> && is_arithmetic_v<_Ty2>, int> = 0>                                      \
    _NODISCARD auto NAME(const _Ty1 _Arg1, const _Ty2 _Arg2) noexcept /* strengthened */ {                         \
        using _Common = _Common_float_type_t<_Ty1, _Ty2>;                                                          \
        if constexpr (is_same_v<_Common, float>) {                                                                 \
            return __std_smf_##NAME##f(_Arg1, _Arg2);                                                              \
        } else {                                                                                                   \
            return static_cast<_Common>(__std_smf_##NAME(static_cast<double>(_Arg1), static_cast<double>(_Arg2))); \
        }                                                                                                          \
    }

#define _GENERIC_MATH_SPECIAL3(NAME)                                                                                   \
    _EXPORT_STD template <class _Ty1, class _Ty2, class _Ty3,                                                          \
        enable_if_t<is_arithmetic_v<_Ty1> && is_arithmetic_v<_Ty2> && is_arithmetic_v<_Ty3>, int> = 0>                 \
    _NODISCARD auto NAME(const _Ty1 _Arg1, const _Ty2 _Arg2, const _Ty3 _Arg3) noexcept /* strengthened */ {           \
        using _Common = _Common_float_type_t<_Ty1, _Common_float_type_t<_Ty2, _Ty3>>;                                  \
        if constexpr (is_same_v<_Common, float>) {                                                                     \
            return __std_smf_##NAME##f(_Arg1, _Arg2, _Arg3);                                                           \
        } else {                                                                                                       \
            return static_cast<_Common>(                                                                               \
                __std_smf_##NAME(static_cast<double>(_Arg1), static_cast<double>(_Arg2), static_cast<double>(_Arg3))); \
        }                                                                                                              \
    }

#define _GENERIC_MATH_SPECIAL_UINT1(NAME)                                                         \
    _EXPORT_STD template <class _Ty, enable_if_t<is_arithmetic_v<_Ty>, int> = 0>                  \
    _NODISCARD auto NAME(const unsigned int _Arg1, const _Ty _Arg2) noexcept /* strengthened */ { \
        using _Common = conditional_t<is_integral_v<_Ty>, double, _Ty>;                           \
        if constexpr (is_same_v<_Common, float>) {                                                \
            return __std_smf_##NAME##f(_Arg1, _Arg2);                                             \
        } else {                                                                                  \
            return static_cast<_Common>(__std_smf_##NAME(_Arg1, static_cast<double>(_Arg2)));     \
        }                                                                                         \
    }

#define _GENERIC_MATH_SPECIAL_UINT2(NAME)                                                                  \
    _EXPORT_STD template <class _Ty, enable_if_t<is_arithmetic_v<_Ty>, int> = 0>                           \
    _NODISCARD auto NAME(                                                                                  \
        const unsigned int _Arg1, const unsigned int _Arg2, const _Ty _Arg3) noexcept /* strengthened */ { \
        using _Common = conditional_t<is_integral_v<_Ty>, double, _Ty>;                                    \
        if constexpr (is_same_v<_Common, float>) {                                                         \
            return __std_smf_##NAME##f(_Arg1, _Arg2, _Arg3);                                               \
        } else {                                                                                           \
            return static_cast<_Common>(__std_smf_##NAME(_Arg1, _Arg2, static_cast<double>(_Arg3)));       \
        }                                                                                                  \
    }

// per LWG-3234 and LWG-3693
_GENERIC_MATH_SPECIAL_UINT2(assoc_laguerre)
_GENERIC_MATH_SPECIAL_UINT2(assoc_legendre)
_GENERIC_MATH_SPECIAL2(beta)
_GENERIC_MATH_SPECIAL1(comp_ellint_1)
_GENERIC_MATH_SPECIAL1(comp_ellint_2)
_GENERIC_MATH_SPECIAL2(comp_ellint_3)
_GENERIC_MATH_SPECIAL2(cyl_bessel_i)
_GENERIC_MATH_SPECIAL2(cyl_bessel_j)
_GENERIC_MATH_SPECIAL2(cyl_bessel_k)
_GENERIC_MATH_SPECIAL2(cyl_neumann)
_GENERIC_MATH_SPECIAL2(ellint_1)
_GENERIC_MATH_SPECIAL2(ellint_2)
_GENERIC_MATH_SPECIAL3(ellint_3)
_GENERIC_MATH_SPECIAL1(expint)
_GENERIC_MATH_SPECIAL_UINT1(hermite)
_GENERIC_MATH_SPECIAL_UINT1(laguerre)
_GENERIC_MATH_SPECIAL_UINT1(legendre)
_GENERIC_MATH_SPECIAL1(riemann_zeta)
_GENERIC_MATH_SPECIAL_UINT1(sph_bessel)
_GENERIC_MATH_SPECIAL_UINT2(sph_legendre)
_GENERIC_MATH_SPECIAL_UINT1(sph_neumann)

#undef _GENERIC_MATH_SPECIAL1
#undef _GENERIC_MATH_SPECIAL2
#undef _GENERIC_MATH_SPECIAL3
#undef _GENERIC_MATH_SPECIAL_UINT1
#undef _GENERIC_MATH_SPECIAL_UINT2

_EXPORT_STD _NODISCARD inline double hypot(const double _Dx, const double _Dy, const double _Dz) noexcept
/* strengthened */ {
    return __std_smf_hypot3(_Dx, _Dy, _Dz);
}

_EXPORT_STD _NODISCARD inline float hypot(const float _Dx, const float _Dy, const float _Dz) noexcept
/* strengthened */ {
    return __std_smf_hypot3f(_Dx, _Dy, _Dz);
}

_EXPORT_STD _NODISCARD inline long double hypot(
    const long double _Dx, const long double _Dy, const long double _Dz) noexcept /* strengthened */ {
    return __std_smf_hypot3(static_cast<double>(_Dx), static_cast<double>(_Dy), static_cast<double>(_Dz));
}

_EXPORT_STD template <class _Ty1, class _Ty2, class _Ty3,
    enable_if_t<is_arithmetic_v<_Ty1>&& is_arithmetic_v<_Ty2>&& is_arithmetic_v<_Ty3>, int> = 0>
    _NODISCARD auto hypot(const _Ty1 _Dx, const _Ty2 _Dy, const _Ty3 _Dz) noexcept /* strengthened */ {
    // N4950 [cmath.syn]/3 "Sufficient additional overloads"
    // Note that this template is selected by overload resolution only when at least one
    // argument is double/long double/integral but not all three are double or long double.
    using _Common = _Common_float_type_t<_Ty1, _Common_float_type_t<_Ty2, _Ty3>>; // TRANSITION, fold expressions
    const auto _Result = __std_smf_hypot3(static_cast<double>(_Dx), static_cast<double>(_Dy), static_cast<double>(_Dz));
    return static_cast<_Common>(_Result);
}

#if _HAS_CXX20
template <class _Ty>
_NODISCARD constexpr _Ty _Linear_for_lerp(const _Ty _ArgA, const _Ty _ArgB, const _Ty _ArgT) noexcept {
    if (_STD is_constant_evaluated()) {
        auto _Smaller = _ArgT;
        auto _Larger = _ArgB - _ArgA;
        auto _Abs_smaller = _Float_abs(_Smaller);
        auto _Abs_larger = _Float_abs(_Larger);
        if (_Abs_larger < _Abs_smaller) {
            _STD swap(_Smaller, _Larger);
            _STD swap(_Abs_smaller, _Abs_larger);
        }

        if (_Abs_smaller > 1) {
            // _Larger is too large to be subnormal, so scaling by 0.5 is exact, and the product _Smaller * _Larger is
            // large enough that if _ArgA is subnormal, it will be too small to contribute anyway and this way can
            // sometimes avoid overflow problems.
            return 2 * (_Ty{ 0.5 } *_ArgA + _Smaller * (_Ty{ 0.5 } *_Larger));
        }
        else {
            return _ArgA + _Smaller * _Larger;
        }
    }

    return _STD fma(_ArgT, _ArgB - _ArgA, _ArgA);
}

template <class _Ty>
_NODISCARD constexpr _Ty _Common_lerp(const _Ty _ArgA, const _Ty _ArgB, const _Ty _ArgT) noexcept {
    // on a line intersecting {(0.0, _ArgA), (1.0, _ArgB)}, return the Y value for X == _ArgT

    const bool _T_is_finite = _Is_finite(_ArgT);
    if (_T_is_finite && _Is_finite(_ArgA) && _Is_finite(_ArgB)) {
        // 99% case, put it first; this block comes from P0811R3
        if ((_ArgA <= 0 && _ArgB >= 0) || (_ArgA >= 0 && _ArgB <= 0)) {
            // exact, monotonic, bounded, determinate, and (for _ArgA == _ArgB == 0) consistent:
            return _ArgT * _ArgB + (1 - _ArgT) * _ArgA;
        }

        if (_ArgT == 1) {
            // exact
            return _ArgB;
        }

        // exact at _ArgT == 0, monotonic except near _ArgT == 1, bounded, determinate, and consistent:
        const auto _Candidate = _Linear_for_lerp(_ArgA, _ArgB, _ArgT);
        // monotonic near _ArgT == 1:
        if ((_ArgT > 1) == (_ArgB > _ArgA)) {
            if (_ArgB > _Candidate) {
                return _ArgB;
            }
        }
        else {
            if (_Candidate > _ArgB) {
                return _ArgB;
            }
        }

        return _Candidate;
    }

    if (_STD is_constant_evaluated()) {
        if (_Is_nan(_ArgA)) {
            return _ArgA;
        }

        if (_Is_nan(_ArgB)) {
            return _ArgB;
        }

        if (_Is_nan(_ArgT)) {
            return _ArgT;
        }
    }
    else {
        // raise FE_INVALID if at least one of _ArgA, _ArgB, and _ArgT is signaling NaN
        if (_Is_nan(_ArgA) || _Is_nan(_ArgB)) {
            return (_ArgA + _ArgB) + _ArgT;
        }

        if (_Is_nan(_ArgT)) {
            return _ArgT + _ArgT;
        }
    }

    if (_T_is_finite) {
        // _ArgT is finite, _ArgA and/or _ArgB is infinity
        if (_ArgT < 0) {
            // if _ArgT < 0:     return infinity in the "direction" of _ArgA if that exists, NaN otherwise
            return _ArgA - _ArgB;
        }
        else if (_ArgT <= 1) {
            // if _ArgT == 0:    return _ArgA (infinity) if _ArgB is finite, NaN otherwise
            // if 0 < _ArgT < 1: return infinity "between" _ArgA and _ArgB if that exists, NaN otherwise
            // if _ArgT == 1:    return _ArgB (infinity) if _ArgA is finite, NaN otherwise
            return _ArgT * _ArgB + (1 - _ArgT) * _ArgA;
        }
        else {
            // if _ArgT > 1:     return infinity in the "direction" of _ArgB if that exists, NaN otherwise
            return _ArgB - _ArgA;
        }
    }
    else {
        // _ArgT is an infinity; return infinity in the "direction" of _ArgA and _ArgB if that exists, NaN otherwise
        return _ArgT * (_ArgB - _ArgA);
    }
}

_EXPORT_STD _NODISCARD constexpr inline float lerp(const float _ArgA, const float _ArgB, const float _ArgT) noexcept {
    return _Common_lerp(_ArgA, _ArgB, _ArgT);
}

_EXPORT_STD _NODISCARD constexpr inline double lerp(
    const double _ArgA, const double _ArgB, const double _ArgT) noexcept {
    return _Common_lerp(_ArgA, _ArgB, _ArgT);
}

_EXPORT_STD _NODISCARD constexpr inline long double lerp(
    const long double _ArgA, const long double _ArgB, const long double _ArgT) noexcept {
    return _Common_lerp(_ArgA, _ArgB, _ArgT);
}

_EXPORT_STD template <class _Ty1, class _Ty2, class _Ty3,
    enable_if_t<is_arithmetic_v<_Ty1>&& is_arithmetic_v<_Ty2>&& is_arithmetic_v<_Ty3>, int> = 0>
    _NODISCARD constexpr auto lerp(const _Ty1 _ArgA, const _Ty2 _ArgB, const _Ty3 _ArgT) noexcept {
    using _Tgt = conditional_t<_Is_any_of_v<long double, _Ty1, _Ty2, _Ty3>, long double, double>;
    return _Common_lerp(static_cast<_Tgt>(_ArgA), static_cast<_Tgt>(_ArgB), static_cast<_Tgt>(_ArgT));
}
#endif // _HAS_CXX20
_STD_END
#endif // _HAS_CXX17

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)

#endif // _STL_COMPILER_PREPROCESSOR
#endif // _CMATH_

// iterator standard header
#ifndef _ITERATOR_
#define _ITERATOR_
#if _STL_COMPILER_PREPROCESSOR
// iosfwd standard header

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#ifndef _IOSFWD_
#define _IOSFWD_
#if _STL_COMPILER_PREPROCESSOR

// cstdio standard header (core)

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#ifndef _CSTDIO_
#define _CSTDIO_
#if _STL_COMPILER_PREPROCESSOR

//
// stdio.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The C Standard Library <stdio.h> header.
//
#pragma once
#ifndef _INC_STDIO // include guard for 3rd party interop
#define _INC_STDIO


//
// corecrt_wstdio.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// This file declares the wide character (wchar_t) I/O functionality, shared by
// <stdio.h> and <wchar.h>.  It also defines several core I/O types, which are
// also shared by those two headers.
//
#pragma once

//
// corecrt_stdio_config.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Per-module <stdio.h> configuration.
//
#pragma once

#pragma warning(push)
#pragma warning(disable: _UCRT_DISABLED_WARNINGS)
_UCRT_DISABLE_CLANG_WARNINGS

_CRT_BEGIN_C_HEADER

#if !defined _NO_CRT_STDIO_INLINE && !_CRT_FUNCTIONS_REQUIRED
#define _NO_CRT_STDIO_INLINE
#endif

#if defined _NO_CRT_STDIO_INLINE
#undef _CRT_STDIO_INLINE
#define _CRT_STDIO_INLINE
#elif !defined _CRT_STDIO_INLINE
#define _CRT_STDIO_INLINE __inline
#endif

#if !defined RC_INVOKED // RC has no target architecture
#if defined _M_IX86
#define _CRT_INTERNAL_STDIO_SYMBOL_PREFIX "_"
#elif defined _M_X64 || defined _M_ARM || defined _M_ARM64
#define _CRT_INTERNAL_STDIO_SYMBOL_PREFIX ""
#else
#error Unsupported architecture
#endif
#endif



// Predefine _CRT_STDIO_ISO_WIDE_SPECIFIERS to use ISO-conforming behavior for
// the wide string printf and scanf functions (%s, %c, and %[] specifiers).
//
// Predefine _CRT_STDIO_LEGACY_WIDE_SPECIFIERS to use VC++ 2013 and earlier behavior for
// the wide string printf and scanf functions (%s, %c, and %[] specifiers).
//
// Predefine _CRT_STDIO_ARBITRARY_WIDE_SPECIFIERS when building code that does
// not use these format specifiers without a length modifier and thus can be
// used with either the legacy (default) or the conforming mode.  (This option
// is intended for use by static libraries).
#if !defined RC_INVOKED // _CRT_STDIO_LEGACY_WIDE_SPECIFIERS et al. are too long for rc
#if defined _CRT_STDIO_ISO_WIDE_SPECIFIERS
#if defined _CRT_STDIO_LEGACY_WIDE_SPECIFIERS
#error _CRT_STDIO_ISO_WIDE_SPECIFIERS and _CRT_STDIO_LEGACY_WIDE_SPECIFIERS cannot be defined together.
#endif

#if !defined _M_CEE_PURE
#pragma comment(lib, "iso_stdio_wide_specifiers")
#pragma comment(linker, "/include:" _CRT_INTERNAL_STDIO_SYMBOL_PREFIX "__PLEASE_LINK_WITH_iso_stdio_wide_specifiers.lib")
#endif
#elif defined _CRT_STDIO_LEGACY_WIDE_SPECIFIERS
#if !defined _M_CEE_PURE
#pragma comment(lib, "legacy_stdio_wide_specifiers")
#pragma comment(linker, "/include:" _CRT_INTERNAL_STDIO_SYMBOL_PREFIX "__PLEASE_LINK_WITH_legacy_stdio_wide_specifiers.lib")
#endif
#endif

#if defined __cplusplus && !defined _CRT_STDIO_ARBITRARY_WIDE_SPECIFIERS
#ifdef _CRT_STDIO_ISO_WIDE_SPECIFIERS
#pragma detect_mismatch("_CRT_STDIO_ISO_WIDE_SPECIFIERS", "1")
#else
#pragma detect_mismatch("_CRT_STDIO_ISO_WIDE_SPECIFIERS", "0")
#endif
#endif
#endif

// If we're compiling mixed managed code, make sure these inline functions are
// compiled as native to ensure that there is only one instance of each of the
// function-local static variables.
#if defined _M_CEE && !defined _M_CEE_PURE
#pragma managed(push, off)
#endif

#if _CRT_FUNCTIONS_REQUIRED
    // This function must not be inlined into callers to avoid ODR violations.  The
    // static local variable has different names in C and in C++ translation units.
    _Check_return_ _Ret_notnull_
    _CRT_INLINE_PURE_SECURITYCRITICAL_ATTRIBUTE
    __declspec(noinline) __inline unsigned __int64* __CRTDECL __local_stdio_printf_options(void)
{
    static unsigned __int64 _OptionsStorage;
    return &_OptionsStorage;
}

// This function must not be inlined into callers to avoid ODR violations.  The
// static local variable has different names in C and in C++ translation units.
_Check_return_ _Ret_notnull_
_CRT_INLINE_PURE_SECURITYCRITICAL_ATTRIBUTE
__declspec(noinline) __inline unsigned __int64* __CRTDECL __local_stdio_scanf_options(void)
{
    static unsigned __int64 _OptionsStorage;
    return &_OptionsStorage;
}
#endif

#if defined _M_CEE && !defined _M_CEE_PURE
#pragma managed(pop)
#endif

#define _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS (*__local_stdio_printf_options())
#define _CRT_INTERNAL_LOCAL_SCANF_OPTIONS  (*__local_stdio_scanf_options ())



#define _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION (1ULL << 0)
#define _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR       (1ULL << 1)
#define _CRT_INTERNAL_PRINTF_LEGACY_WIDE_SPECIFIERS           (1ULL << 2)
#define _CRT_INTERNAL_PRINTF_LEGACY_MSVCRT_COMPATIBILITY      (1ULL << 3)
#define _CRT_INTERNAL_PRINTF_LEGACY_THREE_DIGIT_EXPONENTS     (1ULL << 4)
#define _CRT_INTERNAL_PRINTF_STANDARD_ROUNDING                (1ULL << 5)


#define _CRT_INTERNAL_SCANF_SECURECRT                   (1ULL << 0)
#define _CRT_INTERNAL_SCANF_LEGACY_WIDE_SPECIFIERS      (1ULL << 1)
#define _CRT_INTERNAL_SCANF_LEGACY_MSVCRT_COMPATIBILITY (1ULL << 2)



_CRT_END_C_HEADER
_UCRT_RESTORE_CLANG_WARNINGS
#pragma warning(pop) // _UCRT_DISABLED_WARNINGS


#pragma warning(push)
#pragma warning(disable: _UCRT_DISABLED_WARNINGS)
_UCRT_DISABLE_CLANG_WARNINGS

_CRT_BEGIN_C_HEADER

//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Stream I/O Declarations Required by this Header
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#ifndef _FILE_DEFINED
#define _FILE_DEFINED
typedef struct _iobuf
{
    void* _Placeholder;
} FILE;
#endif

_ACRTIMP_ALT FILE* __cdecl __acrt_iob_func(unsigned _Ix);

#define stdin  (__acrt_iob_func(0))
#define stdout (__acrt_iob_func(1))
#define stderr (__acrt_iob_func(2))

#define WEOF ((wint_t)(0xFFFF))



#if _CRT_FUNCTIONS_REQUIRED
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Wide Character Stream I/O Functions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
_Check_return_opt_
_ACRTIMP wint_t __cdecl fgetwc(
    _Inout_ FILE* _Stream
);

_Check_return_opt_
_ACRTIMP wint_t __cdecl _fgetwchar(void);

_Check_return_opt_
_ACRTIMP wint_t __cdecl fputwc(
    _In_    wchar_t _Character,
    _Inout_ FILE* _Stream);

_Check_return_opt_
_ACRTIMP wint_t __cdecl _fputwchar(
    _In_ wchar_t _Character
);

_Check_return_
_ACRTIMP wint_t __cdecl getwc(
    _Inout_ FILE* _Stream
);

_Check_return_
_ACRTIMP wint_t __cdecl getwchar(void);


_Check_return_opt_
_Success_(return == _Buffer)
_ACRTIMP wchar_t* __cdecl fgetws(
    _Out_writes_z_(_BufferCount) wchar_t* _Buffer,
    _In_                         int      _BufferCount,
    _Inout_                      FILE * _Stream
);

_Check_return_opt_
_ACRTIMP int __cdecl fputws(
    _In_z_  wchar_t const* _Buffer,
    _Inout_ FILE * _Stream
);

_Check_return_opt_
_Success_(return != 0)
_ACRTIMP wchar_t* __cdecl _getws_s(
    _Out_writes_z_(_BufferCount) wchar_t* _Buffer,
    _In_                         size_t   _BufferCount
);

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(
    _Success_(return != 0)
    wchar_t*, _getws_s,
    _Always_(_Post_z_) wchar_t, _Buffer
)

_Check_return_opt_
_ACRTIMP wint_t __cdecl putwc(
    _In_    wchar_t _Character,
    _Inout_ FILE * _Stream
);

_Check_return_opt_
_ACRTIMP wint_t __cdecl putwchar(
    _In_ wchar_t _Character
);

_Check_return_opt_
_ACRTIMP int __cdecl _putws(
    _In_z_ wchar_t const* _Buffer
);

_Check_return_opt_
_ACRTIMP wint_t __cdecl ungetwc(
    _In_    wint_t _Character,
    _Inout_ FILE * _Stream
);

_Check_return_
_ACRTIMP FILE* __cdecl _wfdopen(
    _In_   int            _FileHandle,
    _In_z_ wchar_t const* _Mode
);

_Check_return_ _CRT_INSECURE_DEPRECATE(_wfopen_s)
_ACRTIMP FILE* __cdecl _wfopen(
    _In_z_ wchar_t const* _FileName,
    _In_z_ wchar_t const* _Mode
);

_Check_return_wat_
_ACRTIMP errno_t __cdecl _wfopen_s(
    _Outptr_result_maybenull_ FILE * *_Stream,
    _In_z_                    wchar_t const* _FileName,
    _In_z_                    wchar_t const* _Mode
);

_Check_return_
_CRT_INSECURE_DEPRECATE(_wfreopen_s)
_ACRTIMP FILE* __cdecl _wfreopen(
    _In_z_  wchar_t const* _FileName,
    _In_z_  wchar_t const* _Mode,
    _Inout_ FILE * _OldStream
);

_Check_return_wat_
_ACRTIMP errno_t __cdecl _wfreopen_s(
    _Outptr_result_maybenull_ FILE * *_Stream,
    _In_z_                    wchar_t const* _FileName,
    _In_z_                    wchar_t const* _Mode,
    _Inout_                   FILE * _OldStream
);

_Check_return_
_ACRTIMP FILE* __cdecl _wfsopen(
    _In_z_ wchar_t const* _FileName,
    _In_z_ wchar_t const* _Mode,
    _In_   int            _ShFlag
);

_ACRTIMP void __cdecl _wperror(
    _In_opt_z_ wchar_t const* _ErrorMessage
);

#ifdef _CRT_USE_WINAPI_FAMILY_DESKTOP_APP

_Check_return_
_DCRTIMP FILE* __cdecl _wpopen(
    _In_z_ wchar_t const* _Command,
    _In_z_ wchar_t const* _Mode
);

#endif

_ACRTIMP int __cdecl _wremove(
    _In_z_ wchar_t const* _FileName
);

#pragma push_macro("_wtempnam")
#undef _wtempnam

_Check_return_
_ACRTIMP _CRTALLOCATOR wchar_t* __cdecl _wtempnam(
    _In_opt_z_ wchar_t const* _Directory,
    _In_opt_z_ wchar_t const* _FilePrefix
);

#pragma pop_macro("_wtempnam")

_Success_(return == 0)
_Check_return_wat_
_ACRTIMP errno_t __cdecl _wtmpnam_s(
    _Out_writes_z_(_BufferCount) wchar_t* _Buffer,
    _In_                         size_t   _BufferCount
);

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(
    _Success_(return == 0)
    errno_t, _wtmpnam_s,
    _Always_(_Post_z_) wchar_t, _Buffer
)

__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0(
    _Success_(return != 0)
    wchar_t*, __RETURN_POLICY_DST, _ACRTIMP, _wtmpnam,
    _Pre_maybenull_ _Always_(_Post_z_), wchar_t, _Buffer
)



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// I/O Synchronization and _nolock family of I/O functions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
_Check_return_opt_
_ACRTIMP wint_t __cdecl _fgetwc_nolock(
    _Inout_ FILE * _Stream
);

_Check_return_opt_
_ACRTIMP wint_t __cdecl _fputwc_nolock(
    _In_    wchar_t _Character,
    _Inout_ FILE * _Stream
);

_Check_return_opt_
_ACRTIMP wint_t __cdecl _getwc_nolock(
    _Inout_ FILE * _Stream
);

_Check_return_opt_
_ACRTIMP wint_t __cdecl _putwc_nolock(
    _In_    wchar_t _Character,
    _Inout_ FILE * _Stream
);

_Check_return_opt_
_ACRTIMP wint_t __cdecl _ungetwc_nolock(
    _In_    wint_t _Character,
    _Inout_ FILE * _Stream
);

#if defined _CRT_DISABLE_PERFCRIT_LOCKS && !defined _DLL
#define fgetwc(stream)     _getwc_nolock(stream)
#define fputwc(c, stream)  _putwc_nolock(c, stream)
#define ungetwc(c, stream) _ungetwc_nolock(c, stream)
#endif



// Variadic functions are not supported in managed code under /clr
#ifdef _M_CEE_MIXED
#pragma managed(push, off)
#endif



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Wide Character Formatted Output Functions (Stream)
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
_Check_return_opt_
_ACRTIMP int __cdecl __stdio_common_vfwprintf(
    _In_                                    unsigned __int64 _Options,
    _Inout_                                 FILE * _Stream,
    _In_z_ _Printf_format_string_params_(2) wchar_t const* _Format,
    _In_opt_                                _locale_t        _Locale,
    va_list          _ArgList
);

_Check_return_opt_
_ACRTIMP int __cdecl __stdio_common_vfwprintf_s(
    _In_                                    unsigned __int64 _Options,
    _Inout_                                 FILE * _Stream,
    _In_z_ _Printf_format_string_params_(2) wchar_t const* _Format,
    _In_opt_                                _locale_t        _Locale,
    va_list          _ArgList
);

_Check_return_opt_
_ACRTIMP int __cdecl __stdio_common_vfwprintf_p(
    _In_                                    unsigned __int64 _Options,
    _Inout_                                 FILE * _Stream,
    _In_z_ _Printf_format_string_params_(2) wchar_t const* _Format,
    _In_opt_                                _locale_t        _Locale,
    va_list          _ArgList
);

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _vfwprintf_l(
    _Inout_                                 FILE* const _Stream,
    _In_z_ _Printf_format_string_params_(2) wchar_t const* const _Format,
    _In_opt_                                _locale_t      const _Locale,
    va_list              _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return __stdio_common_vfwprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);
}
#endif

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL vfwprintf(
    _Inout_                       FILE* const _Stream,
    _In_z_ _Printf_format_string_ wchar_t const* const _Format,
    va_list              _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return _vfwprintf_l(_Stream, _Format, NULL, _ArgList);
}
#endif

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _vfwprintf_s_l(
    _Inout_                                 FILE* const _Stream,
    _In_z_ _Printf_format_string_params_(2) wchar_t const* const _Format,
    _In_opt_                                _locale_t      const _Locale,
    va_list              _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return __stdio_common_vfwprintf_s(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);
}
#endif

#if __STDC_WANT_SECURE_LIB__

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL vfwprintf_s(
    _Inout_                       FILE* const _Stream,
    _In_z_ _Printf_format_string_ wchar_t const* const _Format,
    va_list              _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return _vfwprintf_s_l(_Stream, _Format, NULL, _ArgList);
}
#endif

#endif

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _vfwprintf_p_l(
    _Inout_                                 FILE* const _Stream,
    _In_z_ _Printf_format_string_params_(2) wchar_t const* const _Format,
    _In_opt_                                _locale_t      const _Locale,
    va_list              _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return __stdio_common_vfwprintf_p(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);
}
#endif

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _vfwprintf_p(
    _Inout_                       FILE* const _Stream,
    _In_z_ _Printf_format_string_ wchar_t const* const _Format,
    va_list              _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return _vfwprintf_p_l(_Stream, _Format, NULL, _ArgList);
}
#endif

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _vwprintf_l(
    _In_z_ _Printf_format_string_params_(2) wchar_t const* const _Format,
    _In_opt_                                _locale_t      const _Locale,
    va_list              _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return _vfwprintf_l(stdout, _Format, _Locale, _ArgList);
}
#endif

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL vwprintf(
    _In_z_ _Printf_format_string_ wchar_t const* const _Format,
    va_list              _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return _vfwprintf_l(stdout, _Format, NULL, _ArgList);
}
#endif

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _vwprintf_s_l(
    _In_z_ _Printf_format_string_params_(2) wchar_t const* const _Format,
    _In_opt_                                _locale_t      const _Locale,
    va_list              _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return _vfwprintf_s_l(stdout, _Format, _Locale, _ArgList);
}
#endif

#if __STDC_WANT_SECURE_LIB__

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL vwprintf_s(
    _In_z_ _Printf_format_string_ wchar_t const* const _Format,
    va_list              _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return _vfwprintf_s_l(stdout, _Format, NULL, _ArgList);
}
#endif

#endif

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _vwprintf_p_l(
    _In_z_ _Printf_format_string_params_(2) wchar_t const* const _Format,
    _In_opt_                                _locale_t      const _Locale,
    va_list              _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return _vfwprintf_p_l(stdout, _Format, _Locale, _ArgList);
}
#endif

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _vwprintf_p(
    _In_z_ _Printf_format_string_ wchar_t const* const _Format,
    va_list              _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return _vfwprintf_p_l(stdout, _Format, NULL, _ArgList);
}
#endif

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _fwprintf_l(
    _Inout_                                 FILE* const _Stream,
    _In_z_ _Printf_format_string_params_(0) wchar_t const* const _Format,
    _In_opt_                                _locale_t      const _Locale,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Locale);
    _Result = _vfwprintf_l(_Stream, _Format, _Locale, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL fwprintf(
    _Inout_                       FILE* const _Stream,
    _In_z_ _Printf_format_string_ wchar_t const* const _Format,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Format);
    _Result = _vfwprintf_l(_Stream, _Format, NULL, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _fwprintf_s_l(
    _Inout_                                 FILE* const _Stream,
    _In_z_ _Printf_format_string_params_(0) wchar_t const* const _Format,
    _In_opt_                                _locale_t      const _Locale,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Locale);
    _Result = _vfwprintf_s_l(_Stream, _Format, _Locale, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

#if __STDC_WANT_SECURE_LIB__

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL fwprintf_s(
    _Inout_                       FILE* const _Stream,
    _In_z_ _Printf_format_string_ wchar_t const* const _Format,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Format);
    _Result = _vfwprintf_s_l(_Stream, _Format, NULL, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

#endif

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _fwprintf_p_l(
    _Inout_                                 FILE* const _Stream,
    _In_z_ _Printf_format_string_params_(0) wchar_t const* const _Format,
    _In_opt_                                _locale_t      const _Locale,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Locale);
    _Result = _vfwprintf_p_l(_Stream, _Format, _Locale, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _fwprintf_p(
    _Inout_                       FILE* const _Stream,
    _In_z_ _Printf_format_string_ wchar_t const* const _Format,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Format);
    _Result = _vfwprintf_p_l(_Stream, _Format, NULL, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _wprintf_l(
    _In_z_ _Printf_format_string_params_(0) wchar_t const* const _Format,
    _In_opt_                                _locale_t      const _Locale,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Locale);
    _Result = _vfwprintf_l(stdout, _Format, _Locale, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL wprintf(
    _In_z_ _Printf_format_string_ wchar_t const* const _Format,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Format);
    _Result = _vfwprintf_l(stdout, _Format, NULL, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _wprintf_s_l(
    _In_z_ _Printf_format_string_params_(0) wchar_t const* const _Format,
    _In_opt_                                _locale_t      const _Locale,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Locale);
    _Result = _vfwprintf_s_l(stdout, _Format, _Locale, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

#if __STDC_WANT_SECURE_LIB__

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL wprintf_s(
    _In_z_ _Printf_format_string_ wchar_t const* const _Format,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Format);
    _Result = _vfwprintf_s_l(stdout, _Format, NULL, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

#endif

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _wprintf_p_l(
    _In_z_ _Printf_format_string_params_(0) wchar_t const* const _Format,
    _In_opt_                                _locale_t      const _Locale,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Locale);
    _Result = _vfwprintf_p_l(stdout, _Format, _Locale, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _wprintf_p(
    _In_z_ _Printf_format_string_ wchar_t const* const _Format,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Format);
    _Result = _vfwprintf_p_l(stdout, _Format, NULL, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif


//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Wide Character Formatted Input Functions (Stream)
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
_Check_return_opt_
_ACRTIMP int __cdecl __stdio_common_vfwscanf(
    _In_                                   unsigned __int64 _Options,
    _Inout_                                FILE * _Stream,
    _In_z_ _Scanf_format_string_params_(2) wchar_t const* _Format,
    _In_opt_                               _locale_t        _Locale,
    va_list          _ArgList
);

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _vfwscanf_l(
    _Inout_ FILE* const _Stream,
    _In_z_ _Printf_format_string_ wchar_t const* const _Format,
    _In_opt_                      _locale_t      const _Locale,
    va_list              _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return __stdio_common_vfwscanf(
        _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
        _Stream, _Format, _Locale, _ArgList);
}
#endif

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL vfwscanf(
    _Inout_ FILE* const _Stream,
    _In_z_ _Printf_format_string_ wchar_t const* const _Format,
    va_list              _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return _vfwscanf_l(_Stream, _Format, NULL, _ArgList);
}
#endif

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _vfwscanf_s_l(
    _Inout_                       FILE* const _Stream,
    _In_z_ _Printf_format_string_ wchar_t const* const _Format,
    _In_opt_                      _locale_t      const _Locale,
    va_list              _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return __stdio_common_vfwscanf(
        _CRT_INTERNAL_LOCAL_SCANF_OPTIONS | _CRT_INTERNAL_SCANF_SECURECRT,
        _Stream, _Format, _Locale, _ArgList);
}
#endif

#if __STDC_WANT_SECURE_LIB__

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL vfwscanf_s(
    _Inout_                       FILE* const _Stream,
    _In_z_ _Printf_format_string_ wchar_t const* const _Format,
    va_list              _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return _vfwscanf_s_l(_Stream, _Format, NULL, _ArgList);
}
#endif

#endif

_CRT_STDIO_INLINE int __CRTDECL _vwscanf_l(
    _In_z_ _Printf_format_string_ wchar_t const* const _Format,
    _In_opt_                      _locale_t      const _Locale,
    va_list              _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return _vfwscanf_l(stdin, _Format, _Locale, _ArgList);
}
#endif

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL vwscanf(
    _In_z_ _Printf_format_string_ wchar_t const* const _Format,
    va_list              _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return _vfwscanf_l(stdin, _Format, NULL, _ArgList);
}
#endif

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _vwscanf_s_l(
    _In_z_ _Printf_format_string_ wchar_t const* const _Format,
    _In_opt_                      _locale_t      const _Locale,
    va_list              _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return _vfwscanf_s_l(stdin, _Format, _Locale, _ArgList);
}
#endif

#if __STDC_WANT_SECURE_LIB__

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL vwscanf_s(
    _In_z_ _Printf_format_string_ wchar_t const* const _Format,
    va_list              _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return _vfwscanf_s_l(stdin, _Format, NULL, _ArgList);
}
#endif

#endif

_Check_return_opt_ _CRT_INSECURE_DEPRECATE(_fwscanf_s_l)
_CRT_STDIO_INLINE int __CRTDECL _fwscanf_l(
    _Inout_                                FILE* const _Stream,
    _In_z_ _Scanf_format_string_params_(0) wchar_t const* const _Format,
    _In_opt_                               _locale_t      const _Locale,
    ...)
#if defined _NO_CRT_STDIO_INLINE // SCANF
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Locale);
    _Result = _vfwscanf_l(_Stream, _Format, _Locale, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

_Check_return_ _CRT_INSECURE_DEPRECATE(fwscanf_s)
_CRT_STDIO_INLINE int __CRTDECL fwscanf(
    _Inout_                      FILE* const _Stream,
    _In_z_ _Scanf_format_string_ wchar_t const* const _Format,
    ...)
#if defined _NO_CRT_STDIO_INLINE // SCANF
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Format);
    _Result = _vfwscanf_l(_Stream, _Format, NULL, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _fwscanf_s_l(
    _Inout_                                  FILE* const _Stream,
    _In_z_ _Scanf_s_format_string_params_(0) wchar_t const* const _Format,
    _In_opt_                                 _locale_t      const _Locale,
    ...)
#if defined _NO_CRT_STDIO_INLINE // SCANF
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Locale);
    _Result = _vfwscanf_s_l(_Stream, _Format, _Locale, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

#if __STDC_WANT_SECURE_LIB__

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL fwscanf_s(
    _Inout_                        FILE* const _Stream,
    _In_z_ _Scanf_s_format_string_ wchar_t const* const _Format,
    ...)
#if defined _NO_CRT_STDIO_INLINE // SCANF
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Format);
    _Result = _vfwscanf_s_l(_Stream, _Format, NULL, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

#endif

_Check_return_opt_ _CRT_INSECURE_DEPRECATE(_wscanf_s_l)
_CRT_STDIO_INLINE int __CRTDECL _wscanf_l(
    _In_z_ _Scanf_format_string_params_(0) wchar_t const* const _Format,
    _In_opt_                               _locale_t      const _Locale,
    ...)
#if defined _NO_CRT_STDIO_INLINE // SCANF
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Locale);
    _Result = _vfwscanf_l(stdin, _Format, _Locale, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

_Check_return_ _CRT_INSECURE_DEPRECATE(wscanf_s)
_CRT_STDIO_INLINE int __CRTDECL wscanf(
    _In_z_ _Scanf_format_string_ wchar_t const* const _Format,
    ...)
#if defined _NO_CRT_STDIO_INLINE // SCANF
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Format);
    _Result = _vfwscanf_l(stdin, _Format, NULL, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _wscanf_s_l(
    _In_z_ _Scanf_s_format_string_params_(0) wchar_t const* const _Format,
    _In_opt_                                 _locale_t      const _Locale,
    ...)
#if defined _NO_CRT_STDIO_INLINE // SCANF
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Locale);
    _Result = _vfwscanf_s_l(stdin, _Format, _Locale, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

#if __STDC_WANT_SECURE_LIB__

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL wscanf_s(
    _In_z_ _Scanf_s_format_string_ wchar_t const* const _Format,
    ...)
#if defined _NO_CRT_STDIO_INLINE // SCANF
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Format);
    _Result = _vfwscanf_s_l(stdin, _Format, NULL, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

#endif



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Wide Character Formatted Output Functions (String)
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#ifndef _CRT_NON_CONFORMING_SWPRINTFS
#define _SWPRINTFS_DEPRECATED _CRT_DEPRECATE_TEXT(                       \
                "function has been changed to conform with the ISO C standard, " \
                "adding an extra character count parameter. To use the traditional " \
                "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")
#else
#define _SWPRINTFS_DEPRECATED
#endif

_Success_(return >= 0)
_Check_return_opt_
_ACRTIMP int __cdecl __stdio_common_vswprintf(
    _In_                                    unsigned __int64 _Options,
    _Out_writes_opt_z_(_BufferCount)        wchar_t* _Buffer,
    _In_                                    size_t           _BufferCount,
    _In_z_ _Printf_format_string_params_(2) wchar_t const* _Format,
    _In_opt_                                _locale_t        _Locale,
    va_list          _ArgList
);

_Success_(return >= 0)
_Check_return_opt_
_ACRTIMP int __cdecl __stdio_common_vswprintf_s(
    _In_                                    unsigned __int64 _Options,
    _Out_writes_z_(_BufferCount)            wchar_t* _Buffer,
    _In_                                    size_t           _BufferCount,
    _In_z_ _Printf_format_string_params_(2) wchar_t const* _Format,
    _In_opt_                                _locale_t        _Locale,
    va_list          _ArgList
);

_Success_(return >= 0)
_Check_return_opt_
_ACRTIMP int __cdecl __stdio_common_vsnwprintf_s(
    _In_                                    unsigned __int64 _Options,
    _Out_writes_opt_z_(_BufferCount)        wchar_t* _Buffer,
    _In_                                    size_t           _BufferCount,
    _In_                                    size_t           _MaxCount,
    _In_z_ _Printf_format_string_params_(2) wchar_t const* _Format,
    _In_opt_                                _locale_t        _Locale,
    va_list          _ArgList
);

_Success_(return >= 0)
_Check_return_opt_
_ACRTIMP int __cdecl __stdio_common_vswprintf_p(
    _In_                                    unsigned __int64 _Options,
    _Out_writes_z_(_BufferCount)            wchar_t* _Buffer,
    _In_                                    size_t           _BufferCount,
    _In_z_ _Printf_format_string_params_(2) wchar_t const* _Format,
    _In_opt_                                _locale_t        _Locale,
    va_list          _ArgList
);

_Success_(return >= 0)
_Check_return_opt_ _CRT_INSECURE_DEPRECATE(_vsnwprintf_s_l)
_CRT_STDIO_INLINE int __CRTDECL _vsnwprintf_l(
    _Out_writes_opt_(_BufferCount) _Post_maybez_ wchar_t* const _Buffer,
    _In_                                         size_t         const _BufferCount,
    _In_z_ _Printf_format_string_params_(2)      wchar_t const* const _Format,
    _In_opt_                                     _locale_t      const _Locale,
    va_list              _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    int const _Result = __stdio_common_vswprintf(
        _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
        _Buffer, _BufferCount, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}
#endif

_Success_(return >= 0)
_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _vsnwprintf_s_l(
    _Out_writes_opt_(_BufferCount) _Always_(_Post_z_) wchar_t* const _Buffer,
    _In_                                              size_t         const _BufferCount,
    _In_                                              size_t         const _MaxCount,
    _In_z_ _Printf_format_string_params_(2)           wchar_t const* const _Format,
    _In_opt_                                          _locale_t      const _Locale,
    va_list              _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    int const _Result = __stdio_common_vsnwprintf_s(
        _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
        _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}
#endif

_Success_(return >= 0)
_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _vsnwprintf_s(
    _Out_writes_opt_(_BufferCount) _Always_(_Post_z_) wchar_t* const _Buffer,
    _In_                                              size_t         const _BufferCount,
    _In_                                              size_t         const _MaxCount,
    _In_z_ _Printf_format_string_                     wchar_t const* const _Format,
    va_list              _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);
}
#endif

__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_ARGLIST_EX(
    _Success_(return >= 0)
    int, __RETURN_POLICY_SAME, _CRT_STDIO_INLINE, __CRTDECL, _snwprintf, _vsnwprintf,
    _Pre_notnull_ _Post_maybez_                   wchar_t,
    _Out_writes_opt_(_BufferCount) _Post_maybez_, wchar_t, _Buffer,
    _In_                                          size_t, _BufferCount,
    _In_z_ _Printf_format_string_                 wchar_t const*, _Format
)

_Success_(return >= 0)
_Check_return_opt_ _CRT_INSECURE_DEPRECATE(_vsnwprintf_s)
_CRT_STDIO_INLINE int __CRTDECL _vsnwprintf(
    _Out_writes_opt_(_BufferCount) _Post_maybez_ wchar_t* _Buffer,
    _In_                                         size_t         _BufferCount,
    _In_z_ _Printf_format_string_                wchar_t const* _Format,
    va_list        _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return _vsnwprintf_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
}
#endif

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(
    _Success_(return >= 0)
    int, _vsnwprintf_s,
    _Always_(_Post_z_)            wchar_t, _Buffer,
    _In_                          size_t, _BufferCount,
    _In_z_ _Printf_format_string_ wchar_t const*, _Format,
    va_list, _ArgList
)

_Success_(return >= 0)
_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _vswprintf_c_l(
    _Out_writes_opt_(_BufferCount) _Always_(_Post_z_) wchar_t* const _Buffer,
    _In_                                              size_t         const _BufferCount,
    _In_z_ _Printf_format_string_params_(2)           wchar_t const* const _Format,
    _In_opt_                                          _locale_t      const _Locale,
    va_list              _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    int const _Result = __stdio_common_vswprintf(
        _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
        _Buffer, _BufferCount, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}
#endif

_Success_(return >= 0)
_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _vswprintf_c(
    _Out_writes_opt_(_BufferCount) _Always_(_Post_z_) wchar_t* const _Buffer,
    _In_                                              size_t         const _BufferCount,
    _In_z_ _Printf_format_string_                     wchar_t const* const _Format,
    va_list              _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return _vswprintf_c_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
}
#endif

_Success_(return >= 0)
_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _vswprintf_l(
    _Out_writes_opt_(_BufferCount) _Always_(_Post_z_) wchar_t* const _Buffer,
    _In_                                              size_t         const _BufferCount,
    _In_z_ _Printf_format_string_params_(2)           wchar_t const* const _Format,
    _In_opt_                                          _locale_t      const _Locale,
    va_list              _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
}
#endif

_Success_(return >= 0)
_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL __vswprintf_l(
    _Pre_notnull_ _Always_(_Post_z_)        wchar_t* const _Buffer,
    _In_z_ _Printf_format_string_params_(2) wchar_t const* const _Format,
    _In_opt_                                _locale_t      const _Locale,
    va_list              _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
}
#endif

_Success_(return >= 0)
_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _vswprintf(
    _Pre_notnull_ _Always_(_Post_z_) wchar_t* const _Buffer,
    _In_z_ _Printf_format_string_    wchar_t const* const _Format,
    va_list              _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return _vswprintf_l(_Buffer, (size_t)-1, _Format, NULL, _ArgList);
}
#endif

_Success_(return >= 0)
_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL vswprintf(
    _Out_writes_opt_(_BufferCount) _Always_(_Post_z_) wchar_t* const _Buffer,
    _In_                                              size_t         const _BufferCount,
    _In_z_ _Printf_format_string_params_(1)           wchar_t const* const _Format,
    va_list              _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return _vswprintf_c_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
}
#endif

_Success_(return >= 0)
_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _vswprintf_s_l(
    _Out_writes_(_BufferCount) _Always_(_Post_z_) wchar_t* const _Buffer,
    _In_                                          size_t         const _BufferCount,
    _In_z_ _Printf_format_string_params_(2)       wchar_t const* const _Format,
    _In_opt_                                      _locale_t      const _Locale,
    va_list              _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    int const _Result = __stdio_common_vswprintf_s(
        _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
        _Buffer, _BufferCount, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}
#endif

#if __STDC_WANT_SECURE_LIB__

_Success_(return >= 0)
_CRT_STDIO_INLINE int __CRTDECL vswprintf_s(
    _Out_writes_(_BufferCount) _Always_(_Post_z_) wchar_t* const _Buffer,
    _In_                                          size_t         const _BufferCount,
    _In_z_ _Printf_format_string_                 wchar_t const* const _Format,
    va_list              _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return _vswprintf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
}
#endif

#endif

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(
    _Success_(return >= 0)
    int, vswprintf_s,
    _Always_(_Post_z_)            wchar_t, _Buffer,
    _In_z_ _Printf_format_string_ wchar_t const*, _Format,
    va_list, _ArgList
)

_Success_(return >= 0)
_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _vswprintf_p_l(
    _Out_writes_(_BufferCount) _Always_(_Post_z_) wchar_t* const _Buffer,
    _In_                                          size_t         const _BufferCount,
    _In_z_ _Printf_format_string_params_(2)       wchar_t const* const _Format,
    _In_opt_                                      _locale_t      const _Locale,
    va_list              _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    int const _Result = __stdio_common_vswprintf_p(
        _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
        _Buffer, _BufferCount, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}
#endif

_Success_(return >= 0)
_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _vswprintf_p(
    _Out_writes_(_BufferCount) _Always_(_Post_z_) wchar_t* const _Buffer,
    _In_                                          size_t         const _BufferCount,
    _In_z_ _Printf_format_string_                 wchar_t const* const _Format,
    va_list              _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return _vswprintf_p_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
}
#endif

_Success_(return >= 0)
_Check_return_
_CRT_STDIO_INLINE int __CRTDECL _vscwprintf_l(
    _In_z_ _Printf_format_string_params_(2) wchar_t const* const _Format,
    _In_opt_                                _locale_t      const _Locale,
    va_list              _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    int const _Result = __stdio_common_vswprintf(
        _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
        NULL, 0, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}
#endif

_Success_(return >= 0)
_Check_return_
_CRT_STDIO_INLINE int __CRTDECL _vscwprintf(
    _In_z_ _Printf_format_string_ wchar_t const* const _Format,
    va_list              _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return _vscwprintf_l(_Format, NULL, _ArgList);
}
#endif

_Success_(return >= 0)
_Check_return_
_CRT_STDIO_INLINE int __CRTDECL _vscwprintf_p_l(
    _In_z_ _Printf_format_string_params_(2) wchar_t const* const _Format,
    _In_opt_                                _locale_t      const _Locale,
    va_list              _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    int const _Result = __stdio_common_vswprintf_p(
        _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
        NULL, 0, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}
#endif

_Success_(return >= 0)
_Check_return_
_CRT_STDIO_INLINE int __CRTDECL _vscwprintf_p(
    _In_z_ _Printf_format_string_ wchar_t const* const _Format,
    va_list              _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return _vscwprintf_p_l(_Format, NULL, _ArgList);
}
#endif

_Success_(return >= 0)
_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL __swprintf_l(
    _Pre_notnull_ _Always_(_Post_z_)        wchar_t* const _Buffer,
    _In_z_ _Printf_format_string_params_(2) wchar_t const* const _Format,
    _In_opt_                                _locale_t      const _Locale,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Locale);
    _Result = __vswprintf_l(_Buffer, _Format, _Locale, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

_Success_(return >= 0)
_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _swprintf_l(
    _Out_writes_opt_(_BufferCount) _Always_(_Post_z_) wchar_t* const _Buffer,
    _In_                                              size_t         const _BufferCount,
    _In_z_ _Printf_format_string_params_(0)           wchar_t const* const _Format,
    _In_opt_                                          _locale_t      const _Locale,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Locale);
    _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

_Success_(return >= 0)
_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _swprintf(
    _Pre_notnull_ _Always_(_Post_z_) wchar_t* const _Buffer,
    _In_z_ _Printf_format_string_    wchar_t const* const _Format,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Format);
    _Result = __vswprintf_l(_Buffer, _Format, NULL, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

_Success_(return >= 0)
_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL swprintf(
    _Out_writes_opt_(_BufferCount) _Always_(_Post_z_) wchar_t* const _Buffer,
    _In_                                              size_t         const _BufferCount,
    _In_z_ _Printf_format_string_                     wchar_t const* const _Format,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Format);
    _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_ARGLIST_EX(
    _Success_(return >= 0)
    int, __RETURN_POLICY_SAME, _CRT_STDIO_INLINE, __CRTDECL, __swprintf_l, __vswprintf_l, _vswprintf_s_l,
    _Pre_notnull_ _Always_(_Post_z_)        wchar_t,
    _Pre_notnull_ _Always_(_Post_z_), wchar_t, _Buffer,
    _In_z_ _Printf_format_string_params_(2) wchar_t const*, _Format,
    _In_opt_                                _locale_t, _Locale
)

__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_ARGLIST_EX(
    _Success_(return >= 0)
    int, __RETURN_POLICY_SAME, _CRT_STDIO_INLINE, __CRTDECL, _swprintf, swprintf_s, _vswprintf, vswprintf_s,
    _Pre_notnull_ _Always_(_Post_z_), wchar_t, _Buffer,
    _In_z_ _Printf_format_string_     wchar_t const*, _Format
)

_Success_(return >= 0)
_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _swprintf_s_l(
    _Out_writes_(_BufferCount) _Always_(_Post_z_) wchar_t* const _Buffer,
    _In_                                          size_t         const _BufferCount,
    _In_z_ _Printf_format_string_params_(0)       wchar_t const* const _Format,
    _In_opt_                                      _locale_t      const _Locale,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Locale);
    _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

#if __STDC_WANT_SECURE_LIB__

_Success_(return >= 0)
_CRT_STDIO_INLINE int __CRTDECL swprintf_s(
    _Out_writes_(_BufferCount) _Always_(_Post_z_) wchar_t* const _Buffer,
    _In_                                          size_t         const _BufferCount,
    _In_z_ _Printf_format_string_                 wchar_t const* const _Format,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Format);
    _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

#endif

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1_ARGLIST(
    _Success_(return >= 0)
    int, swprintf_s, vswprintf_s,
    _Always_(_Post_z_)            wchar_t, _Buffer,
    _In_z_ _Printf_format_string_ wchar_t const*, _Format
)

_Success_(return >= 0)
_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _swprintf_p_l(
    _Out_writes_(_BufferCount) _Always_(_Post_z_) wchar_t* const _Buffer,
    _In_                                          size_t         const _BufferCount,
    _In_z_ _Printf_format_string_params_(0)       wchar_t const* const _Format,
    _In_opt_                                      _locale_t      const _Locale,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Locale);
    _Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

_Success_(return >= 0)
_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _swprintf_p(
    _Out_writes_(_BufferCount) _Always_(_Post_z_) wchar_t* const _Buffer,
    _In_                                          size_t         const _BufferCount,
    _In_z_ _Printf_format_string_                 wchar_t const* const _Format,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Format);
    _Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

_Success_(return >= 0)
_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _swprintf_c_l(
    _Out_writes_opt_(_BufferCount) _Always_(_Post_z_) wchar_t* const _Buffer,
    _In_                                              size_t         const _BufferCount,
    _In_z_ _Printf_format_string_params_(0)           wchar_t const* const _Format,
    _In_opt_                                          _locale_t      const _Locale,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Locale);
    _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

_Success_(return >= 0)
_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _swprintf_c(
    _Out_writes_opt_(_BufferCount) _Always_(_Post_z_) wchar_t* const _Buffer,
    _In_                                              size_t         const _BufferCount,
    _In_z_ _Printf_format_string_                     wchar_t const* const _Format,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Format);
    _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

_Success_(return >= 0)
_Check_return_opt_ _CRT_INSECURE_DEPRECATE(_snwprintf_s_l)
_CRT_STDIO_INLINE int __CRTDECL _snwprintf_l(
    _Out_writes_opt_(_BufferCount) _Post_maybez_ wchar_t* const _Buffer,
    _In_                                         size_t         const _BufferCount,
    _In_z_ _Printf_format_string_params_(0)      wchar_t const* const _Format,
    _In_opt_                                     _locale_t      const _Locale,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Locale);

    _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);

    __crt_va_end(_ArgList);
    return _Result;
}
#endif

_Success_(return >= 0)
_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _snwprintf(
    _Out_writes_opt_(_BufferCount) _Post_maybez_ wchar_t* _Buffer,
    _In_                                         size_t         _BufferCount,
    _In_z_ _Printf_format_string_                wchar_t const* _Format,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Format);

    _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);

    __crt_va_end(_ArgList);
    return _Result;
}
#endif

_Success_(return >= 0)
_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _snwprintf_s_l(
    _Out_writes_opt_(_BufferCount) _Always_(_Post_z_) wchar_t* const _Buffer,
    _In_                                              size_t         const _BufferCount,
    _In_                                              size_t         const _MaxCount,
    _In_z_ _Printf_format_string_params_(0)           wchar_t const* const _Format,
    _In_opt_                                          _locale_t      const _Locale,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Locale);
    _Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

_Success_(return >= 0)
_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _snwprintf_s(
    _Out_writes_opt_(_BufferCount) _Always_(_Post_z_) wchar_t* const _Buffer,
    _In_                                              size_t         const _BufferCount,
    _In_                                              size_t         const _MaxCount,
    _In_z_ _Printf_format_string_                     wchar_t const* const _Format,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Format);
    _Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2_ARGLIST(
    _Success_(return >= 0)
    int, _snwprintf_s, _vsnwprintf_s,
    _Always_(_Post_z_)            wchar_t, _Buffer,
    _In_                          size_t, _BufferCount,
    _In_z_ _Printf_format_string_ wchar_t const*, _Format
)

_Check_return_
_CRT_STDIO_INLINE int __CRTDECL _scwprintf_l(
    _In_z_ _Printf_format_string_params_(0) wchar_t const* const _Format,
    _In_opt_                                _locale_t      const _Locale,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Locale);
    _Result = _vscwprintf_l(_Format, _Locale, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

_Success_(return >= 0)
_Check_return_
_CRT_STDIO_INLINE int __CRTDECL _scwprintf(
    _In_z_ _Printf_format_string_ wchar_t const* const _Format,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Format);
    _Result = _vscwprintf_l(_Format, NULL, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

_Success_(return >= 0)
_Check_return_
_CRT_STDIO_INLINE int __CRTDECL _scwprintf_p_l(
    _In_z_ _Printf_format_string_params_(0) wchar_t const* const _Format,
    _In_opt_                                _locale_t      const _Locale,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Locale);
    _Result = _vscwprintf_p_l(_Format, _Locale, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

_Success_(return >= 0)
_Check_return_
_CRT_STDIO_INLINE int __CRTDECL _scwprintf_p(
    _In_z_ _Printf_format_string_ wchar_t const* const _Format,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Format);
    _Result = _vscwprintf_p_l(_Format, NULL, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif


#if !defined RC_INVOKED && !defined __midl && !defined _INC_SWPRINTF_INL_
// C4141: double deprecation
// C6054: string may not be zero-terminated
#pragma warning(push)
#pragma warning(disable: 4141 6054)

#ifdef __cplusplus

extern "C++" _SWPRINTFS_DEPRECATED _CRT_INSECURE_DEPRECATE(swprintf_s)
inline int swprintf(
    _Pre_notnull_ _Post_z_        wchar_t* const _Buffer,
    _In_z_ _Printf_format_string_ wchar_t const* const _Format,
    ...) throw()
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Format);
    _Result = vswprintf(_Buffer, _CRT_INT_MAX, _Format, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}

extern "C++" _SWPRINTFS_DEPRECATED _CRT_INSECURE_DEPRECATE(vswprintf_s)
inline int __CRTDECL vswprintf(
    _Pre_notnull_ _Post_z_        wchar_t* const _Buffer,
    _In_z_ _Printf_format_string_ wchar_t const* const _Format,
    va_list              _ArgList
) throw()
{
    return vswprintf(_Buffer, _CRT_INT_MAX, _Format, _ArgList);
}

extern "C++" _SWPRINTFS_DEPRECATED _CRT_INSECURE_DEPRECATE(_swprintf_s_l)
inline int _swprintf_l(
    _Pre_notnull_ _Post_z_                  wchar_t* const _Buffer,
    _In_z_ _Printf_format_string_params_(0) wchar_t const* const _Format,
    _In_opt_                                _locale_t      const _Locale,
    ...) throw()
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Locale);
    _Result = _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}

extern "C++" _SWPRINTFS_DEPRECATED _CRT_INSECURE_DEPRECATE(_vswprintf_s_l)
inline int __CRTDECL _vswprintf_l(
    _Pre_notnull_ _Post_z_                  wchar_t* const _Buffer,
    _In_z_ _Printf_format_string_params_(2) wchar_t const* const _Format,
    _In_opt_                                _locale_t      const _Locale,
    va_list              _ArgList
) throw()
{
    return _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
}

#endif  // __cplusplus

#pragma warning(pop)
#endif  // !_INC_SWPRINTF_INL_

#if defined _CRT_NON_CONFORMING_SWPRINTFS && !defined __cplusplus
#define swprintf     _swprintf
#define vswprintf    _vswprintf
#define _swprintf_l  __swprintf_l
#define _vswprintf_l __vswprintf_l
#endif


//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Wide Character Formatted Input Functions (String)
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
_Success_(return >= 0)
_ACRTIMP int __cdecl __stdio_common_vswscanf(
    _In_                                   unsigned __int64 _Options,
    _In_reads_(_BufferCount) _Pre_z_       wchar_t const* _Buffer,
    _In_                                   size_t           _BufferCount,
    _In_z_ _Scanf_format_string_params_(2) wchar_t const* _Format,
    _In_opt_                               _locale_t        _Locale,
    va_list          _ArgList
);

_Success_(return >= 0)
_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _vswscanf_l(
    _In_z_                        wchar_t const* const _Buffer,
    _In_z_ _Printf_format_string_ wchar_t const* const _Format,
    _In_opt_                      _locale_t      const _Locale,
    va_list              _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return __stdio_common_vswscanf(
        _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
        _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
}
#endif

_Success_(return >= 0)
_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL vswscanf(
    _In_z_                        wchar_t const* _Buffer,
    _In_z_ _Printf_format_string_ wchar_t const* _Format,
    va_list        _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return _vswscanf_l(_Buffer, _Format, NULL, _ArgList);
}
#endif

_Success_(return >= 0)
_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _vswscanf_s_l(
    _In_z_                        wchar_t const* const _Buffer,
    _In_z_ _Printf_format_string_ wchar_t const* const _Format,
    _In_opt_                      _locale_t      const _Locale,
    va_list              _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return __stdio_common_vswscanf(
        _CRT_INTERNAL_LOCAL_SCANF_OPTIONS | _CRT_INTERNAL_SCANF_SECURECRT,
        _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
}
#endif

#if __STDC_WANT_SECURE_LIB__

_Success_(return >= 0)
_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL vswscanf_s(
    _In_z_                        wchar_t const* const _Buffer,
    _In_z_ _Printf_format_string_ wchar_t const* const _Format,
    va_list              _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return _vswscanf_s_l(_Buffer, _Format, NULL, _ArgList);
}
#endif

#endif

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(
    _Success_(return >= 0)
    int, vswscanf_s,
    _In_z_                        wchar_t, _Buffer,
    _In_z_ _Printf_format_string_ wchar_t const*, _Format,
    va_list, _ArgList
)

_Success_(return >= 0)
_Check_return_opt_ _CRT_INSECURE_DEPRECATE(_vsnwscanf_s_l)
_CRT_STDIO_INLINE int __CRTDECL _vsnwscanf_l(
    _In_reads_(_BufferCount) _Pre_z_       wchar_t const* const _Buffer,
    _In_                                   size_t         const _BufferCount,
    _In_z_ _Scanf_format_string_params_(2) wchar_t const* const _Format,
    _In_opt_                               _locale_t      const _Locale,
    va_list              _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return __stdio_common_vswscanf(
        _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
        _Buffer, _BufferCount, _Format, _Locale, _ArgList);
}
#endif

_Success_(return >= 0)
_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _vsnwscanf_s_l(
    _In_reads_(_BufferCount) _Pre_z_         wchar_t const* const _Buffer,
    _In_                                     size_t         const _BufferCount,
    _In_z_ _Scanf_s_format_string_params_(2) wchar_t const* const _Format,
    _In_opt_                                 _locale_t      const _Locale,
    va_list              _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return __stdio_common_vswscanf(
        _CRT_INTERNAL_LOCAL_SCANF_OPTIONS | _CRT_INTERNAL_SCANF_SECURECRT,
        _Buffer, _BufferCount, _Format, _Locale, _ArgList);
}
#endif

_Success_(return >= 0)
_Check_return_opt_ _CRT_INSECURE_DEPRECATE(_swscanf_s_l)
_CRT_STDIO_INLINE int __CRTDECL _swscanf_l(
    _In_z_                                 wchar_t const* const _Buffer,
    _In_z_ _Scanf_format_string_params_(0) wchar_t const* const _Format,
    _In_opt_                               _locale_t            _Locale,
    ...)
#if defined _NO_CRT_STDIO_INLINE // SCANF
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Locale);
    _Result = _vswscanf_l(_Buffer, _Format, _Locale, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

_Success_(return >= 0)
_Check_return_ _CRT_INSECURE_DEPRECATE(swscanf_s)
_CRT_STDIO_INLINE int __CRTDECL swscanf(
    _In_z_                       wchar_t const* const _Buffer,
    _In_z_ _Scanf_format_string_ wchar_t const* const _Format,
    ...)
#if defined _NO_CRT_STDIO_INLINE // SCANF
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Format);
    _Result = _vswscanf_l(_Buffer, _Format, NULL, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

_Success_(return >= 0)
_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _swscanf_s_l(
    _In_z_                                   wchar_t const* const _Buffer,
    _In_z_ _Scanf_s_format_string_params_(0) wchar_t const* const _Format,
    _In_opt_                                 _locale_t      const _Locale,
    ...)
#if defined _NO_CRT_STDIO_INLINE // SCANF
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Locale);
    _Result = _vswscanf_s_l(_Buffer, _Format, _Locale, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

#if __STDC_WANT_SECURE_LIB__

_Success_(return >= 0)
_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL swscanf_s(
    _In_z_                         wchar_t const* const _Buffer,
    _In_z_ _Scanf_s_format_string_ wchar_t const* const _Format,
    ...)
#if defined _NO_CRT_STDIO_INLINE // SCANF
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Format);
    _Result = _vswscanf_s_l(_Buffer, _Format, NULL, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

#endif

_Success_(return >= 0)
_Check_return_opt_ _CRT_INSECURE_DEPRECATE(_snwscanf_s_l)
_CRT_STDIO_INLINE int __CRTDECL _snwscanf_l(
    _In_reads_(_BufferCount) _Pre_z_       wchar_t const* const _Buffer,
    _In_                                   size_t         const _BufferCount,
    _In_z_ _Scanf_format_string_params_(0) wchar_t const* const _Format,
    _In_opt_                               _locale_t      const _Locale,
    ...)
#if defined _NO_CRT_STDIO_INLINE // SCANF
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Locale);

    _Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);

    __crt_va_end(_ArgList);
    return _Result;
}
#endif

_Success_(return >= 0)
_Check_return_opt_ _CRT_INSECURE_DEPRECATE(_snwscanf_s)
_CRT_STDIO_INLINE int __CRTDECL _snwscanf(
    _In_reads_(_BufferCount) _Pre_z_ wchar_t const* const _Buffer,
    _In_                             size_t         const _BufferCount,
    _In_z_ _Scanf_format_string_     wchar_t const* const _Format,
    ...)
#if defined _NO_CRT_STDIO_INLINE // SCANF
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Format);

    _Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);

    __crt_va_end(_ArgList);
    return _Result;
}
#endif

_Success_(return >= 0)
_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _snwscanf_s_l(
    _In_reads_(_BufferCount) _Pre_z_         wchar_t const* const _Buffer,
    _In_                                     size_t         const _BufferCount,
    _In_z_ _Scanf_s_format_string_params_(0) wchar_t const* const _Format,
    _In_opt_                                 _locale_t      const _Locale,
    ...)
#if defined _NO_CRT_STDIO_INLINE // SCANF
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Locale);
    _Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

_Success_(return >= 0)
_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _snwscanf_s(
    _In_reads_(_BufferCount) _Pre_z_  wchar_t const* const _Buffer,
    _In_                              size_t         const _BufferCount,
    _In_z_ _Scanf_s_format_string_    wchar_t const* const _Format,
    ...)
#if defined _NO_CRT_STDIO_INLINE // SCANF
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Format);
    _Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

#ifdef _M_CEE_MIXED
#pragma managed(pop)
#endif
#endif // _CRT_FUNCTIONS_REQUIRED

_CRT_END_C_HEADER
_UCRT_RESTORE_CLANG_WARNINGS
#pragma warning(pop) // _UCRT_DISABLED_WARNINGS


#pragma warning(push)
#pragma warning(disable: _UCRT_DISABLED_WARNINGS)
_UCRT_DISABLE_CLANG_WARNINGS

_CRT_BEGIN_C_HEADER

/* Buffered I/O macros */

#define BUFSIZ  512



/*
 * Default number of supported streams. _NFILE is confusing and obsolete, but
 * supported anyway for backwards compatibility.
 */
#define _NFILE      _NSTREAM_

#define _NSTREAM_   512

 /*
  * Number of entries in _iob[] (declared below). Note that _NSTREAM_ must be
  * greater than or equal to _IOB_ENTRIES.
  */
#define _IOB_ENTRIES 3

#define EOF    (-1)

#define _IOFBF 0x0000
#define _IOLBF 0x0040
#define _IONBF 0x0004



#define L_tmpnam   260 // _MAX_PATH
#if __STDC_WANT_SECURE_LIB__
#define L_tmpnam_s L_tmpnam
#endif



  /* Seek method constants */

#define SEEK_CUR    1
#define SEEK_END    2
#define SEEK_SET    0


#define FILENAME_MAX    260
#define FOPEN_MAX       20
#define _SYS_OPEN       20
#define TMP_MAX         _CRT_INT_MAX
#if __STDC_WANT_SECURE_LIB__
#define TMP_MAX_S       TMP_MAX
#define _TMP_MAX_S      TMP_MAX
#endif


    typedef __int64 fpos_t;



#if _CRT_FUNCTIONS_REQUIRED

_Check_return_opt_
_ACRTIMP errno_t __cdecl _get_stream_buffer_pointers(
    _In_      FILE* _Stream,
    _Out_opt_ char*** _Base,
    _Out_opt_ char*** _Pointer,
    _Out_opt_ int** _Count
);


//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Narrow Character Stream I/O Functions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#if __STDC_WANT_SECURE_LIB__

_Check_return_wat_
_ACRTIMP errno_t __cdecl clearerr_s(
    _Inout_ FILE* _Stream
);

_Check_return_wat_
_Success_(return == 0)
_ACRTIMP errno_t __cdecl fopen_s(
    _Outptr_result_nullonfailure_ FILE * *_Stream,
    _In_z_                        char const* _FileName,
    _In_z_                        char const* _Mode
);

_Check_return_opt_
_Success_(return != 0)
_ACRTIMP size_t __cdecl fread_s(
    _Out_writes_bytes_to_(_BufferSize, _ElementSize * _ElementCount)   void* _Buffer,
    _In_range_(>= , _ElementSize * _ElementCount)                       size_t _BufferSize,
    _In_                                                               size_t _ElementSize,
    _In_                                                               size_t _ElementCount,
    _Inout_                                                            FILE * _Stream
);

_Check_return_wat_
_ACRTIMP errno_t __cdecl freopen_s(
    _Outptr_result_maybenull_ FILE * *_Stream,
    _In_z_                    char const* _FileName,
    _In_z_                    char const* _Mode,
    _Inout_                   FILE * _OldStream
);

_Success_(return != 0)
_ACRTIMP char* __cdecl gets_s(
    _Out_writes_z_(_Size) char* _Buffer,
    _In_                  rsize_t _Size
);

_Check_return_wat_
_ACRTIMP errno_t __cdecl tmpfile_s(
    _Out_opt_ _Deref_post_valid_ FILE * *_Stream
);

_Success_(return == 0)
_Check_return_wat_
_ACRTIMP errno_t __cdecl tmpnam_s(
    _Out_writes_z_(_Size) char* _Buffer,
    _In_                  rsize_t _Size
);

#endif

_ACRTIMP void __cdecl clearerr(
    _Inout_ FILE * _Stream
);

_Success_(return != -1)
_Check_return_opt_
_ACRTIMP int __cdecl fclose(
    _Inout_ FILE * _Stream
);

_Check_return_opt_
_ACRTIMP int __cdecl _fcloseall(void);

_Check_return_
_ACRTIMP FILE* __cdecl _fdopen(
    _In_   int         _FileHandle,
    _In_z_ char const* _Mode
);

_Check_return_
_ACRTIMP int __cdecl feof(
    _In_ FILE * _Stream
);

_Check_return_
_ACRTIMP int __cdecl ferror(
    _In_ FILE * _Stream
);

_Check_return_opt_
_ACRTIMP int __cdecl fflush(
    _Inout_opt_ FILE * _Stream
);

_Success_(return != EOF)
_Check_return_opt_
_ACRTIMP int __cdecl fgetc(
    _Inout_ FILE * _Stream
);

_Check_return_opt_
_ACRTIMP int __cdecl _fgetchar(void);

_Success_(return != EOF)
_Check_return_opt_
_ACRTIMP int __cdecl fgetpos(
    _Inout_ FILE * _Stream,
    _Out_   fpos_t * _Position
);

_Success_(return == _Buffer)
_Check_return_opt_
_ACRTIMP char* __cdecl fgets(
    _Out_writes_z_(_MaxCount) char* _Buffer,
    _In_                      int   _MaxCount,
    _Inout_                   FILE * _Stream
);

_Check_return_
_ACRTIMP int __cdecl _fileno(
    _In_ FILE * _Stream
);

_Check_return_opt_
_ACRTIMP int __cdecl _flushall(void);

_Check_return_ _CRT_INSECURE_DEPRECATE(fopen_s)
_ACRTIMP FILE* __cdecl fopen(
    _In_z_ char const* _FileName,
    _In_z_ char const* _Mode
);


_Success_(return != EOF)
_Check_return_opt_
_ACRTIMP int __cdecl fputc(
    _In_    int   _Character,
    _Inout_ FILE * _Stream
);

_Check_return_opt_
_ACRTIMP int __cdecl _fputchar(
    _In_ int _Character
);

_Success_(return != EOF)
_Check_return_opt_
_ACRTIMP int __cdecl fputs(
    _In_z_  char const* _Buffer,
    _Inout_ FILE * _Stream
);

_Check_return_opt_
_ACRTIMP size_t __cdecl fread(
    _Out_writes_bytes_(_ElementSize * _ElementCount) void* _Buffer,
    _In_                                             size_t _ElementSize,
    _In_                                             size_t _ElementCount,
    _Inout_                                          FILE * _Stream
);

_Success_(return != 0)
_Check_return_ _CRT_INSECURE_DEPRECATE(freopen_s)
_ACRTIMP FILE* __cdecl freopen(
    _In_z_  char const* _FileName,
    _In_z_  char const* _Mode,
    _Inout_ FILE * _Stream
);

_Check_return_
_ACRTIMP FILE* __cdecl _fsopen(
    _In_z_ char const* _FileName,
    _In_z_ char const* _Mode,
    _In_   int         _ShFlag
);

_Success_(return == 0)
_Check_return_opt_
_ACRTIMP int __cdecl fsetpos(
    _Inout_ FILE * _Stream,
    _In_    fpos_t const* _Position
);

_Success_(return == 0)
_Check_return_opt_
_ACRTIMP int __cdecl fseek(
    _Inout_ FILE * _Stream,
    _In_    long  _Offset,
    _In_    int   _Origin
);

_Success_(return == 0)
_Check_return_opt_
_ACRTIMP int __cdecl _fseeki64(
    _Inout_ FILE * _Stream,
    _In_    __int64 _Offset,
    _In_    int     _Origin
);

_Success_(return != -1)
_Check_return_
_ACRTIMP long __cdecl ftell(
    _Inout_ FILE * _Stream
);

_Success_(return != -1)
_Check_return_
_ACRTIMP __int64 __cdecl _ftelli64(
    _Inout_ FILE * _Stream
);

_Check_return_opt_
_ACRTIMP size_t __cdecl fwrite(
    _In_reads_bytes_(_ElementSize * _ElementCount) void const* _Buffer,
    _In_                                           size_t      _ElementSize,
    _In_                                           size_t      _ElementCount,
    _Inout_                                        FILE * _Stream
);

_Success_(return != EOF)
_Check_return_
_ACRTIMP int __cdecl getc(
    _Inout_ FILE * _Stream
);

_Check_return_
_ACRTIMP int __cdecl getchar(void);

_Check_return_
_ACRTIMP int __cdecl _getmaxstdio(void);

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(
    char*, gets_s,
    char, _Buffer)

    _Check_return_
    _ACRTIMP int __cdecl _getw(
        _Inout_ FILE * _Stream
    );

_ACRTIMP void __cdecl perror(
    _In_opt_z_ char const* _ErrorMessage
);

#if defined _CRT_USE_WINAPI_FAMILY_DESKTOP_APP

_Success_(return != -1)
_Check_return_opt_
_DCRTIMP int __cdecl _pclose(
    _Inout_ FILE * _Stream
);

_Check_return_
_DCRTIMP FILE* __cdecl _popen(
    _In_z_ char const* _Command,
    _In_z_ char const* _Mode
);

#endif

_Success_(return != EOF)
_Check_return_opt_
_ACRTIMP int __cdecl putc(
    _In_    int   _Character,
    _Inout_ FILE * _Stream
);

_Check_return_opt_
_ACRTIMP int __cdecl putchar(
    _In_ int _Character
);

_Check_return_opt_
_ACRTIMP int __cdecl puts(
    _In_z_ char const* _Buffer
);

_Success_(return != -1)
_Check_return_opt_
_ACRTIMP int __cdecl _putw(
    _In_    int   _Word,
    _Inout_ FILE * _Stream
);

_ACRTIMP int __cdecl remove(
    _In_z_ char const* _FileName
);

_Check_return_
_ACRTIMP int __cdecl rename(
    _In_z_ char const* _OldFileName,
    _In_z_ char const* _NewFileName
);

_ACRTIMP int __cdecl _unlink(
    _In_z_ char const* _FileName
);

#if defined(_CRT_INTERNAL_NONSTDC_NAMES) && _CRT_INTERNAL_NONSTDC_NAMES

_CRT_NONSTDC_DEPRECATE(_unlink)
_ACRTIMP int __cdecl unlink(
    _In_z_ char const* _FileName
);

#endif

_ACRTIMP void __cdecl rewind(
    _Inout_ FILE * _Stream
);

_Check_return_opt_
_ACRTIMP int __cdecl _rmtmp(void);

_CRT_INSECURE_DEPRECATE(setvbuf)
_ACRTIMP void __cdecl setbuf(
    _Inout_                                             FILE * _Stream,
    _Inout_updates_opt_(BUFSIZ) _Post_readable_size_(0) char* _Buffer
);

_Check_return_opt_
_ACRTIMP int __cdecl _setmaxstdio(
    _In_ int _Maximum
);

_Success_(return == 0)
_Check_return_opt_
_ACRTIMP int __cdecl setvbuf(
    _Inout_                      FILE * _Stream,
    _Inout_updates_opt_(_Size)   char* _Buffer,
    _In_                         int    _Mode,
    _In_                         size_t _Size
);

#if defined _DEBUG && defined _CRTDBG_MAP_ALLOC
#pragma push_macro("_tempnam")
#undef _tempnam
#endif

_Check_return_
_ACRTIMP _CRTALLOCATOR char* __cdecl _tempnam(
    _In_opt_z_ char const* _DirectoryName,
    _In_opt_z_ char const* _FilePrefix
);

#if defined _DEBUG && defined _CRTDBG_MAP_ALLOC
#pragma pop_macro("_tempnam")
#endif

_Check_return_ _CRT_INSECURE_DEPRECATE(tmpfile_s)
_ACRTIMP FILE* __cdecl tmpfile(void);

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(
    _Success_(return == 0)
    errno_t, tmpnam_s,
    _Always_(_Post_z_) char, _Buffer
)

__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0(
    _Success_(return != 0)
    char*, __RETURN_POLICY_DST, _ACRTIMP, tmpnam,
    _Pre_maybenull_ _Always_(_Post_z_), char, _Buffer
)

_Success_(return != EOF)
_Check_return_opt_
_ACRTIMP int __cdecl ungetc(
    _In_    int   _Character,
    _Inout_ FILE * _Stream
);



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// I/O Synchronization and _nolock family of I/O functions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
_ACRTIMP void __cdecl _lock_file(
    _Inout_ FILE * _Stream
);

_ACRTIMP void __cdecl _unlock_file(
    _Inout_ FILE * _Stream
);

_Success_(return != EOF)
_Check_return_opt_
_ACRTIMP int __cdecl _fclose_nolock(
    _Inout_ FILE * _Stream
);

_Success_(return != EOF)
_Check_return_opt_
_ACRTIMP int __cdecl _fflush_nolock(
    _Inout_opt_ FILE * _Stream
);

_Success_(return != EOF)
_Check_return_opt_
_ACRTIMP int __cdecl _fgetc_nolock(
    _Inout_ FILE * _Stream
);

_Success_(return != EOF)
_Check_return_opt_
_ACRTIMP int __cdecl _fputc_nolock(
    _In_    int   _Character,
    _Inout_ FILE * _Stream
);

_Check_return_opt_
_ACRTIMP size_t __cdecl _fread_nolock(
    _Out_writes_bytes_(_ElementSize * _ElementCount) void* _Buffer,
    _In_                                             size_t _ElementSize,
    _In_                                             size_t _ElementCount,
    _Inout_                                          FILE * _Stream
);

_Check_return_opt_
_Success_(return != 0)
_ACRTIMP size_t __cdecl _fread_nolock_s(
    _Out_writes_bytes_to_(_BufferSize, _ElementSize * _ElementCount) void* _Buffer,
    _In_range_(>= , _ElementSize * _ElementCount)                     size_t _BufferSize,
    _In_                                                             size_t _ElementSize,
    _In_                                                             size_t _ElementCount,
    _Inout_                                                          FILE * _Stream
);

_Check_return_opt_
_ACRTIMP int __cdecl _fseek_nolock(
    _Inout_ FILE * _Stream,
    _In_    long  _Offset,
    _In_    int   _Origin
);

_Check_return_opt_
_ACRTIMP int __cdecl _fseeki64_nolock(
    _Inout_ FILE * _Stream,
    _In_    __int64 _Offset,
    _In_    int     _Origin
);

_Check_return_
_ACRTIMP long __cdecl _ftell_nolock(
    _Inout_ FILE * _Stream
);

_Check_return_
_ACRTIMP __int64 __cdecl _ftelli64_nolock(
    _Inout_ FILE * _Stream
);

_Check_return_opt_
_ACRTIMP size_t __cdecl _fwrite_nolock(
    _In_reads_bytes_(_ElementSize * _ElementCount) void const* _Buffer,
    _In_                                           size_t      _ElementSize,
    _In_                                           size_t      _ElementCount,
    _Inout_                                        FILE * _Stream
);

_Check_return_opt_
_ACRTIMP int __cdecl _getc_nolock(
    _Inout_ FILE * _Stream
);

_Check_return_opt_
_ACRTIMP int __cdecl _putc_nolock(
    _In_    int   _Character,
    _Inout_ FILE * _Stream
);

_Check_return_opt_
_ACRTIMP int __cdecl _ungetc_nolock(
    _In_    int   _Character,
    _Inout_ FILE * _Stream
);

#define _getchar_nolock()     _getc_nolock(stdin)
#define _putchar_nolock(_Ch)  _putc_nolock(_Ch, stdout)
#define _getwchar_nolock()    _getwc_nolock(stdin)
#define _putwchar_nolock(_Ch) _putwc_nolock(_Ch, stdout)



#if defined _CRT_DISABLE_PERFCRIT_LOCKS && !defined _DLL
#define fclose(_Stream)                                           _fclose_nolock(_Stream)
#define fflush(_Stream)                                           _fflush_nolock(_Stream)
#define fgetc(_Stream)                                            _fgetc_nolock(_Stream)
#define fputc(_Ch, _Stream)                                       _fputc_nolock(_Ch, _Stream)
#define fread(_DstBuf, _ElementSize, _Count, _Stream)             _fread_nolock(_DstBuf, _ElementSize, _Count, _Stream)
#define fread_s(_DstBuf, _DstSize, _ElementSize, _Count, _Stream) _fread_nolock_s(_DstBuf, _DstSize, _ElementSize, _Count, _Stream)
#define fseek(_Stream, _Offset, _Origin)                          _fseek_nolock(_Stream, _Offset, _Origin)
#define _fseeki64(_Stream, _Offset, _Origin)                      _fseeki64_nolock(_Stream, _Offset, _Origin)
#define ftell(_Stream)                                            _ftell_nolock(_Stream)
#define _ftelli64(_Stream)                                        _ftelli64_nolock(_Stream)
#define fwrite(_SrcBuf, _ElementSize, _Count, _Stream)            _fwrite_nolock(_SrcBuf, _ElementSize, _Count, _Stream)
#define getc(_Stream)                                             _getc_nolock(_Stream)
#define putc(_Ch, _Stream)                                        _putc_nolock(_Ch, _Stream)
#define ungetc(_Ch, _Stream)                                      _ungetc_nolock(_Ch, _Stream)
#endif



_ACRTIMP int* __cdecl __p__commode(void);

#ifdef _CRT_DECLARE_GLOBAL_VARIABLES_DIRECTLY
extern int _commode;
#else
#define _commode (*__p__commode())
#endif



// Variadic functions are not supported in managed code under /clr
#if defined _M_CEE_MIXED
#pragma managed(push, off)
#endif

//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Narrow Character Formatted Output Functions (Stream)
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
_ACRTIMP int __cdecl __stdio_common_vfprintf(
    _In_                                    unsigned __int64 _Options,
    _Inout_                                 FILE * _Stream,
    _In_z_ _Printf_format_string_params_(2) char const* _Format,
    _In_opt_                                _locale_t        _Locale,
    va_list          _ArgList
);

_ACRTIMP int __cdecl __stdio_common_vfprintf_s(
    _In_                                    unsigned __int64 _Options,
    _Inout_                                 FILE * _Stream,
    _In_z_ _Printf_format_string_params_(2) char const* _Format,
    _In_opt_                                _locale_t        _Locale,
    va_list          _ArgList
);

_Success_(return >= 0)
_ACRTIMP int __cdecl __stdio_common_vfprintf_p(
    _In_                                    unsigned __int64 _Options,
    _Inout_                                 FILE * _Stream,
    _In_z_ _Printf_format_string_params_(2) char const* _Format,
    _In_opt_                                _locale_t        _Locale,
    va_list          _ArgList
);

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _vfprintf_l(
    _Inout_  FILE* const _Stream,
    _In_z_   char const* const _Format,
    _In_opt_ _locale_t   const _Locale,
    va_list           _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);
}
#endif

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL vfprintf(
    _Inout_                       FILE* const _Stream,
    _In_z_ _Printf_format_string_ char const* const _Format,
    va_list           _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return _vfprintf_l(_Stream, _Format, NULL, _ArgList);
}
#endif

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _vfprintf_s_l(
    _Inout_  FILE* const _Stream,
    _In_z_   char const* const _Format,
    _In_opt_ _locale_t   const _Locale,
    va_list           _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return __stdio_common_vfprintf_s(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);
}
#endif

#if __STDC_WANT_SECURE_LIB__

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL vfprintf_s(
    _Inout_                       FILE* const _Stream,
    _In_z_ _Printf_format_string_ char const* const _Format,
    va_list           _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return _vfprintf_s_l(_Stream, _Format, NULL, _ArgList);
}
#endif

#endif

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _vfprintf_p_l(
    _Inout_  FILE* const _Stream,
    _In_z_   char const* const _Format,
    _In_opt_ _locale_t   const _Locale,
    va_list           _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return __stdio_common_vfprintf_p(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);
}
#endif

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _vfprintf_p(
    _Inout_                       FILE* const _Stream,
    _In_z_ _Printf_format_string_ char const* const _Format,
    va_list           _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return _vfprintf_p_l(_Stream, _Format, NULL, _ArgList);
}
#endif

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _vprintf_l(
    _In_z_ _Printf_format_string_params_(2) char const* const _Format,
    _In_opt_                                _locale_t   const _Locale,
    va_list           _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return _vfprintf_l(stdout, _Format, _Locale, _ArgList);
}
#endif

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL vprintf(
    _In_z_ _Printf_format_string_ char const* const _Format,
    va_list           _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return _vfprintf_l(stdout, _Format, NULL, _ArgList);
}
#endif

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _vprintf_s_l(
    _In_z_ _Printf_format_string_params_(2) char const* const _Format,
    _In_opt_                                _locale_t   const _Locale,
    va_list           _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return _vfprintf_s_l(stdout, _Format, _Locale, _ArgList);
}
#endif

#if __STDC_WANT_SECURE_LIB__

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL vprintf_s(
    _In_z_ _Printf_format_string_ char const* const _Format,
    va_list           _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return _vfprintf_s_l(stdout, _Format, NULL, _ArgList);
}
#endif

#endif

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _vprintf_p_l(
    _In_z_ _Printf_format_string_params_(2) char const* const _Format,
    _In_opt_                                _locale_t   const _Locale,
    va_list           _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return _vfprintf_p_l(stdout, _Format, _Locale, _ArgList);
}
#endif

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _vprintf_p(
    _In_z_ _Printf_format_string_ char const* const _Format,
    va_list           _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return _vfprintf_p_l(stdout, _Format, NULL, _ArgList);
}
#endif

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _fprintf_l(
    _Inout_                                 FILE* const _Stream,
    _In_z_ _Printf_format_string_params_(0) char const* const _Format,
    _In_opt_                                _locale_t   const _Locale,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Locale);
    _Result = _vfprintf_l(_Stream, _Format, _Locale, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL fprintf(
    _Inout_                       FILE* const _Stream,
    _In_z_ _Printf_format_string_ char const* const _Format,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Format);
    _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

_ACRTIMP int __cdecl _set_printf_count_output(
    _In_ int _Value
);

_ACRTIMP int __cdecl _get_printf_count_output(void);

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _fprintf_s_l(
    _Inout_                                 FILE* const _Stream,
    _In_z_ _Printf_format_string_params_(0) char const* const _Format,
    _In_opt_                                _locale_t   const _Locale,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Locale);
    _Result = _vfprintf_s_l(_Stream, _Format, _Locale, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

#if __STDC_WANT_SECURE_LIB__

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL fprintf_s(
    _Inout_                       FILE* const _Stream,
    _In_z_ _Printf_format_string_ char const* const _Format,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Format);
    _Result = _vfprintf_s_l(_Stream, _Format, NULL, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

#endif

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _fprintf_p_l(
    _Inout_                                 FILE* const _Stream,
    _In_z_ _Printf_format_string_params_(0) char const* const _Format,
    _In_opt_                                _locale_t   const _Locale,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Locale);
    _Result = _vfprintf_p_l(_Stream, _Format, _Locale, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _fprintf_p(
    _Inout_                       FILE* const _Stream,
    _In_z_ _Printf_format_string_ char const* const _Format,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Format);
    _Result = _vfprintf_p_l(_Stream, _Format, NULL, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _printf_l(
    _In_z_ _Printf_format_string_params_(0) char const* const _Format,
    _In_opt_                                _locale_t   const _Locale,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Locale);
    _Result = _vfprintf_l(stdout, _Format, _Locale, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL printf(
    _In_z_ _Printf_format_string_ char const* const _Format,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Format);
    _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _printf_s_l(
    _In_z_ _Printf_format_string_params_(0) char const* const _Format,
    _In_opt_                                _locale_t   const _Locale,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Locale);
    _Result = _vfprintf_s_l(stdout, _Format, _Locale, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

#if __STDC_WANT_SECURE_LIB__

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL printf_s(
    _In_z_ _Printf_format_string_ char const* const _Format,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Format);
    _Result = _vfprintf_s_l(stdout, _Format, NULL, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

#endif

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _printf_p_l(
    _In_z_ _Printf_format_string_params_(0) char const* const _Format,
    _In_opt_                                _locale_t   const _Locale,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Locale);
    _Result = _vfprintf_p_l(stdout, _Format, _Locale, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _printf_p(
    _In_z_ _Printf_format_string_ char const* const _Format,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Format);
    _Result = _vfprintf_p_l(stdout, _Format, NULL, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif


//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Narrow Character Formatted Input Functions (Stream)
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
_ACRTIMP int __cdecl __stdio_common_vfscanf(
    _In_                                   unsigned __int64 _Options,
    _Inout_                                FILE * _Stream,
    _In_z_ _Scanf_format_string_params_(2) char const* _Format,
    _In_opt_                               _locale_t        _Locale,
    va_list          _Arglist
);

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _vfscanf_l(
    _Inout_                       FILE* const _Stream,
    _In_z_ _Printf_format_string_ char const* const _Format,
    _In_opt_                      _locale_t   const _Locale,
    va_list           _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return __stdio_common_vfscanf(
        _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
        _Stream, _Format, _Locale, _ArgList);
}
#endif

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL vfscanf(
    _Inout_                       FILE* const _Stream,
    _In_z_ _Printf_format_string_ char const* const _Format,
    va_list           _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return _vfscanf_l(_Stream, _Format, NULL, _ArgList);
}
#endif

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _vfscanf_s_l(
    _Inout_                       FILE* const _Stream,
    _In_z_ _Printf_format_string_ char const* const _Format,
    _In_opt_                      _locale_t   const _Locale,
    va_list           _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return __stdio_common_vfscanf(
        _CRT_INTERNAL_LOCAL_SCANF_OPTIONS | _CRT_INTERNAL_SCANF_SECURECRT,
        _Stream, _Format, _Locale, _ArgList);
}
#endif


#if __STDC_WANT_SECURE_LIB__

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL vfscanf_s(
    _Inout_                       FILE* const _Stream,
    _In_z_ _Printf_format_string_ char const* const _Format,
    va_list           _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return _vfscanf_s_l(_Stream, _Format, NULL, _ArgList);
}
#endif

#endif

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _vscanf_l(
    _In_z_ _Printf_format_string_ char const* const _Format,
    _In_opt_                      _locale_t   const _Locale,
    va_list           _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return _vfscanf_l(stdin, _Format, _Locale, _ArgList);
}
#endif

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL vscanf(
    _In_z_ _Printf_format_string_ char const* const _Format,
    va_list           _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return _vfscanf_l(stdin, _Format, NULL, _ArgList);
}
#endif

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _vscanf_s_l(
    _In_z_ _Printf_format_string_ char const* const _Format,
    _In_opt_                      _locale_t   const _Locale,
    va_list           _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return _vfscanf_s_l(stdin, _Format, _Locale, _ArgList);
}
#endif

#if __STDC_WANT_SECURE_LIB__

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL vscanf_s(
    _In_z_ _Printf_format_string_ char const* const _Format,
    va_list           _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return _vfscanf_s_l(stdin, _Format, NULL, _ArgList);
}
#endif

#endif

_Check_return_opt_ _CRT_INSECURE_DEPRECATE(_fscanf_s_l)
_CRT_STDIO_INLINE int __CRTDECL _fscanf_l(
    _Inout_                                FILE* const _Stream,
    _In_z_ _Scanf_format_string_params_(0) char const* const _Format,
    _In_opt_                               _locale_t   const _Locale,
    ...)
#if defined _NO_CRT_STDIO_INLINE // SCANF
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Locale);
    _Result = _vfscanf_l(_Stream, _Format, _Locale, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

_Check_return_ _CRT_INSECURE_DEPRECATE(fscanf_s)
_CRT_STDIO_INLINE int __CRTDECL fscanf(
    _Inout_                      FILE* const _Stream,
    _In_z_ _Scanf_format_string_ char const* const _Format,
    ...)
#if defined _NO_CRT_STDIO_INLINE // SCANF
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Format);
    _Result = _vfscanf_l(_Stream, _Format, NULL, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _fscanf_s_l(
    _Inout_                                  FILE* const _Stream,
    _In_z_ _Scanf_s_format_string_params_(0) char const* const _Format,
    _In_opt_                                 _locale_t   const _Locale,
    ...)
#if defined _NO_CRT_STDIO_INLINE // SCANF
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Locale);
    _Result = _vfscanf_s_l(_Stream, _Format, _Locale, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

#if __STDC_WANT_SECURE_LIB__

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL fscanf_s(
    _Inout_                        FILE* const _Stream,
    _In_z_ _Scanf_s_format_string_ char const* const _Format,
    ...)
#if defined _NO_CRT_STDIO_INLINE // SCANF
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Format);
    _Result = _vfscanf_s_l(_Stream, _Format, NULL, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

#endif

_Check_return_opt_ _CRT_INSECURE_DEPRECATE(_scanf_s_l)
_CRT_STDIO_INLINE int __CRTDECL _scanf_l(
    _In_z_ _Scanf_format_string_params_(0) char const* const _Format,
    _In_opt_                               _locale_t   const _Locale,
    ...)
#if defined _NO_CRT_STDIO_INLINE // SCANF
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Locale);
    _Result = _vfscanf_l(stdin, _Format, _Locale, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

_Check_return_ _CRT_INSECURE_DEPRECATE(scanf_s)
_CRT_STDIO_INLINE int __CRTDECL scanf(
    _In_z_ _Scanf_format_string_ char const* const _Format,
    ...)
#if defined _NO_CRT_STDIO_INLINE // SCANF
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Format);
    _Result = _vfscanf_l(stdin, _Format, NULL, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _scanf_s_l(
    _In_z_ _Scanf_s_format_string_params_(0) char const* const _Format,
    _In_opt_                                 _locale_t   const _Locale,
    ...)
#if defined _NO_CRT_STDIO_INLINE // SCANF
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Locale);
    _Result = _vfscanf_s_l(stdin, _Format, _Locale, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

#if __STDC_WANT_SECURE_LIB__

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL scanf_s(
    _In_z_ _Scanf_s_format_string_ char const* const _Format,
    ...)
#if defined _NO_CRT_STDIO_INLINE // SCANF
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Format);
    _Result = _vfscanf_s_l(stdin, _Format, NULL, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

#endif



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Narrow Character Formatted Output Functions (String)
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
_Success_(return >= 0)
_ACRTIMP int __cdecl __stdio_common_vsprintf(
    _In_                                    unsigned __int64 _Options,
    _Out_writes_opt_z_(_BufferCount)        char* _Buffer,
    _In_                                    size_t           _BufferCount,
    _In_z_ _Printf_format_string_params_(2) char const* _Format,
    _In_opt_                                _locale_t        _Locale,
    va_list          _ArgList
);

_Success_(return >= 0)
_ACRTIMP int __cdecl __stdio_common_vsprintf_s(
    _In_                                    unsigned __int64 _Options,
    _Out_writes_z_(_BufferCount)            char* _Buffer,
    _In_                                    size_t           _BufferCount,
    _In_z_ _Printf_format_string_params_(2) char const* _Format,
    _In_opt_                                _locale_t        _Locale,
    va_list          _ArgList
);

_Success_(return >= 0)
_ACRTIMP int __cdecl __stdio_common_vsnprintf_s(
    _In_                                    unsigned __int64 _Options,
    _Out_writes_opt_z_(_BufferCount)        char* _Buffer,
    _In_                                    size_t           _BufferCount,
    _In_                                    size_t           _MaxCount,
    _In_z_ _Printf_format_string_params_(2) char const* _Format,
    _In_opt_                                _locale_t        _Locale,
    va_list          _ArgList
);

_Success_(return >= 0)
_ACRTIMP int __cdecl __stdio_common_vsprintf_p(
    _In_                                    unsigned __int64 _Options,
    _Out_writes_z_(_BufferCount)            char* _Buffer,
    _In_                                    size_t           _BufferCount,
    _In_z_ _Printf_format_string_params_(2) char const* _Format,
    _In_opt_                                _locale_t        _Locale,
    va_list          _ArgList
);

_Success_(return >= 0)
_Check_return_opt_ _CRT_INSECURE_DEPRECATE(_vsnprintf_s_l)
_CRT_STDIO_INLINE int __CRTDECL _vsnprintf_l(
    _Out_writes_opt_(_BufferCount) _Post_maybez_ char* const _Buffer,
    _In_                                         size_t      const _BufferCount,
    _In_z_ _Printf_format_string_params_(2)      char const* const _Format,
    _In_opt_                                     _locale_t   const _Locale,
    va_list           _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    int const _Result = __stdio_common_vsprintf(
        _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
        _Buffer, _BufferCount, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}
#endif

_Success_(return >= 0)
_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _vsnprintf(
    _Out_writes_opt_(_BufferCount) _Post_maybez_ char* const _Buffer,
    _In_                                        size_t      const _BufferCount,
    _In_z_ _Printf_format_string_               char const* const _Format,
    va_list           _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return _vsnprintf_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
}
#endif

#if defined vsnprintf
// This definition of vsnprintf will generate "warning C4005: 'vsnprintf': macro
// redefinition" with a subsequent line indicating where the previous definition
// of vsnprintf was.  This makes it easier to find where vsnprintf was defined.
#pragma warning(push, 1)
#pragma warning(1: 4005) // macro redefinition
#define vsnprintf Do not define vsnprintf as a macro
#pragma warning(pop)
#error Macro definition of vsnprintf conflicts with Standard Library function declaration
#endif

_Success_(return >= 0)
_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL vsnprintf(
    _Out_writes_opt_(_BufferCount) _Always_(_Post_z_) char* const _Buffer,
    _In_                                              size_t      const _BufferCount,
    _In_z_ _Printf_format_string_                     char const* const _Format,
    va_list           _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    int const _Result = __stdio_common_vsprintf(
        _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
        _Buffer, _BufferCount, _Format, NULL, _ArgList);

    return _Result < 0 ? -1 : _Result;
}
#endif

_Success_(return >= 0)
_Check_return_opt_ _CRT_INSECURE_DEPRECATE(_vsprintf_s_l)
_CRT_STDIO_INLINE int __CRTDECL _vsprintf_l(
    _Pre_notnull_ _Always_(_Post_z_) char* const _Buffer,
    _In_z_                           char const* const _Format,
    _In_opt_                         _locale_t   const _Locale,
    va_list           _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
}
#endif

_Success_(return >= 0)
_Check_return_opt_ _CRT_INSECURE_DEPRECATE(vsprintf_s)
_CRT_STDIO_INLINE int __CRTDECL vsprintf(
    _Pre_notnull_ _Always_(_Post_z_) char* const _Buffer,
    _In_z_ _Printf_format_string_    char const* const _Format,
    va_list           _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return _vsnprintf_l(_Buffer, (size_t)-1, _Format, NULL, _ArgList);
}
#endif

_Success_(return >= 0)
_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _vsprintf_s_l(
    _Out_writes_(_BufferCount) _Always_(_Post_z_) char* const _Buffer,
    _In_                                          size_t      const _BufferCount,
    _In_z_ _Printf_format_string_params_(2)       char const* const _Format,
    _In_opt_                                      _locale_t   const _Locale,
    va_list           _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    int const _Result = __stdio_common_vsprintf_s(
        _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
        _Buffer, _BufferCount, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}
#endif

#if __STDC_WANT_SECURE_LIB__

_Success_(return >= 0)
_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL vsprintf_s(
    _Out_writes_(_BufferCount) _Always_(_Post_z_) char* const _Buffer,
    _In_                                          size_t      const _BufferCount,
    _In_z_ _Printf_format_string_                 char const* const _Format,
    va_list           _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return _vsprintf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
}
#endif

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(
    _Success_(return >= 0)
    int, vsprintf_s,
    _Always_(_Post_z_)            char, _Buffer,
    _In_z_ _Printf_format_string_ char const*, _Format,
    va_list, _ArgList
)

#endif

_Success_(return >= 0)
_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _vsprintf_p_l(
    _Out_writes_(_BufferCount) _Always_(_Post_z_) char* const _Buffer,
    _In_                                          size_t      const _BufferCount,
    _In_z_ _Printf_format_string_params_(2)       char const* const _Format,
    _In_opt_                                      _locale_t   const _Locale,
    va_list           _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    int const _Result = __stdio_common_vsprintf_p(
        _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
        _Buffer, _BufferCount, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}
#endif

_Success_(return >= 0)
_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _vsprintf_p(
    _Out_writes_(_BufferCount) _Always_(_Post_z_) char* const _Buffer,
    _In_                                          size_t      const _BufferCount,
    _In_z_ _Printf_format_string_                 char const* const _Format,
    va_list           _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return _vsprintf_p_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
}
#endif

_Success_(return >= 0)
_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _vsnprintf_s_l(
    _Out_writes_opt_(_BufferCount) _Always_(_Post_z_) char* const _Buffer,
    _In_                                              size_t      const _BufferCount,
    _In_                                              size_t      const _MaxCount,
    _In_z_ _Printf_format_string_params_(2)           char const* const _Format,
    _In_opt_                                          _locale_t   const _Locale,
    va_list          _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    int const _Result = __stdio_common_vsnprintf_s(
        _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
        _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}
#endif

_Success_(return >= 0)
_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _vsnprintf_s(
    _Out_writes_opt_(_BufferCount) _Always_(_Post_z_) char* const _Buffer,
    _In_                                              size_t      const _BufferCount,
    _In_                                              size_t      const _MaxCount,
    _In_z_ _Printf_format_string_                     char const* const _Format,
    va_list           _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);
}
#endif

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(
    _Success_(return >= 0)
    int, _vsnprintf_s,
    _Always_(_Post_z_)            char, _Buffer,
    _In_                          size_t, _BufferCount,
    _In_z_ _Printf_format_string_ char const*, _Format,
    va_list, _ArgList
)

#if __STDC_WANT_SECURE_LIB__

_Success_(return >= 0)
_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL vsnprintf_s(
    _Out_writes_opt_(_BufferCount) _Always_(_Post_z_) char* const _Buffer,
    _In_                                              size_t      const _BufferCount,
    _In_                                              size_t      const _MaxCount,
    _In_z_ _Printf_format_string_                     char const* const _Format,
    va_list           _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);
}
#endif

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(
    _Success_(return >= 0)
    int, vsnprintf_s,
    _Always_(_Post_z_)            char, _Buffer,
    _In_                          size_t, _BufferCount,
    _In_z_ _Printf_format_string_ char const*, _Format,
    va_list, _ArgList
)

#endif

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _vscprintf_l(
    _In_z_ _Printf_format_string_params_(2) char const* const _Format,
    _In_opt_                                _locale_t   const _Locale,
    va_list           _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    int const _Result = __stdio_common_vsprintf(
        _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
        NULL, 0, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}
#endif

_Check_return_
_CRT_STDIO_INLINE int __CRTDECL _vscprintf(
    _In_z_ _Printf_format_string_ char const* const _Format,
    va_list           _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return _vscprintf_l(_Format, NULL, _ArgList);
}
#endif

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _vscprintf_p_l(
    _In_z_ _Printf_format_string_params_(2) char const* const _Format,
    _In_opt_                                _locale_t   const _Locale,
    va_list           _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    int const _Result = __stdio_common_vsprintf_p(
        _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
        NULL, 0, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}
#endif

_Check_return_
_CRT_STDIO_INLINE int __CRTDECL _vscprintf_p(
    _In_z_ _Printf_format_string_ char const* const _Format,
    va_list           _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return _vscprintf_p_l(_Format, NULL, _ArgList);
}
#endif

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _vsnprintf_c_l(
    _Out_writes_opt_(_BufferCount)          char* const _Buffer,
    _In_                                    size_t      const _BufferCount,
    _In_z_ _Printf_format_string_params_(2) char const* const _Format,
    _In_opt_                                _locale_t   const _Locale,
    va_list           _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    int const _Result = __stdio_common_vsprintf(
        _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
        _Buffer, _BufferCount, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}
#endif

_Success_(return >= 0)
_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _vsnprintf_c(
    _Out_writes_opt_(_BufferCount) char* const _Buffer,
    _In_                           size_t      const _BufferCount,
    _In_z_ _Printf_format_string_  char const* const _Format,
    va_list           _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return _vsnprintf_c_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
}
#endif

_Success_(return >= 0)
_Check_return_opt_ _CRT_INSECURE_DEPRECATE(_sprintf_s_l)
_CRT_STDIO_INLINE int __CRTDECL _sprintf_l(
    _Pre_notnull_ _Always_(_Post_z_)        char* const _Buffer,
    _In_z_ _Printf_format_string_params_(0) char const* const _Format,
    _In_opt_                                _locale_t   const _Locale,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Locale);

    _Result = _vsprintf_l(_Buffer, _Format, _Locale, _ArgList);

    __crt_va_end(_ArgList);
    return _Result;
}
#endif

_Success_(return >= 0)
_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL sprintf(
    _Pre_notnull_ _Always_(_Post_z_) char* const _Buffer,
    _In_z_ _Printf_format_string_    char const* const _Format,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Format);

    _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

    __crt_va_end(_ArgList);
    return _Result;
}
#endif

__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_ARGLIST(
    _Success_(return >= 0)
    int, __RETURN_POLICY_SAME, __EMPTY_DECLSPEC, __CRTDECL, sprintf, vsprintf,
    _Pre_notnull_ _Always_(_Post_z_), char, _Buffer,
    _In_z_ _Printf_format_string_     char const*, _Format
)

_Success_(return >= 0)
_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _sprintf_s_l(
    _Out_writes_(_BufferCount) _Always_(_Post_z_) char* const _Buffer,
    _In_                                          size_t      const _BufferCount,
    _In_z_ _Printf_format_string_params_(0)       char const* const _Format,
    _In_opt_                                      _locale_t   const _Locale,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Locale);
    _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

#if __STDC_WANT_SECURE_LIB__

_Success_(return >= 0)
_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL sprintf_s(
    _Out_writes_(_BufferCount) _Always_(_Post_z_) char* const _Buffer,
    _In_                                          size_t      const _BufferCount,
    _In_z_ _Printf_format_string_                 char const* const _Format,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Format);
    _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

#endif

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1_ARGLIST(
    _Success_(return >= 0)
    int, sprintf_s, vsprintf_s,
    _Always_(_Post_z_)            char, _Buffer,
    _In_z_ _Printf_format_string_ char const*, _Format
)

_Success_(return >= 0)
_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _sprintf_p_l(
    _Out_writes_(_BufferCount) _Always_(_Post_z_) char* const _Buffer,
    _In_                                          size_t      const _BufferCount,
    _In_z_ _Printf_format_string_params_(0)       char const* const _Format,
    _In_opt_                                      _locale_t   const _Locale,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Locale);
    _Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

_Success_(return >= 0)
_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _sprintf_p(
    _Out_writes_(_BufferCount) _Always_(_Post_z_) char* const _Buffer,
    _In_                                          size_t      const _BufferCount,
    _In_z_ _Printf_format_string_                 char const* const _Format,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Format);
    _Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

_Success_(return >= 0)
_Check_return_opt_ _CRT_INSECURE_DEPRECATE(_snprintf_s_l)
_CRT_STDIO_INLINE int __CRTDECL _snprintf_l(
    _Out_writes_opt_(_BufferCount) _Post_maybez_ char* const _Buffer,
    _In_                                         size_t      const _BufferCount,
    _In_z_ _Printf_format_string_params_(0)      char const* const _Format,
    _In_opt_                                     _locale_t   const _Locale,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Locale);

    _Result = _vsnprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);

    __crt_va_end(_ArgList);
    return _Result;
}
#endif

#if defined snprintf
// This definition of snprintf will generate "warning C4005: 'snprintf': macro
// redefinition" with a subsequent line indicating where the previous definition
// of snprintf was.  This makes it easier to find where snprintf was defined.
#pragma warning(push, 1)
#pragma warning(1: 4005) // macro redefinition
#define snprintf Do not define snprintf as a macro
#pragma warning(pop)
#error Macro definition of snprintf conflicts with Standard Library function declaration
#endif

_Success_(return >= 0)
_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL snprintf(
    _Out_writes_opt_(_BufferCount) _Always_(_Post_z_) char* const _Buffer,
    _In_                                              size_t      const _BufferCount,
    _In_z_ _Printf_format_string_                     char const* const _Format,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Format);
    _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

_Success_(return >= 0)
_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _snprintf(
    _Out_writes_opt_(_BufferCount) _Post_maybez_ char* const _Buffer,
    _In_                                         size_t      const _BufferCount,
    _In_z_ _Printf_format_string_                char const* const _Format,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Format);
    _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_ARGLIST_EX(
    _Success_(return >= 0)
    int, __RETURN_POLICY_SAME, __EMPTY_DECLSPEC, __CRTDECL, _snprintf, _vsnprintf,
    _Pre_notnull_ _Post_maybez_                   char,
    _Out_writes_opt_(_BufferCount) _Post_maybez_, char, _Buffer,
    _In_                                          size_t, _BufferCount,
    _In_z_ _Printf_format_string_                 char const*, _Format
)

_Success_(return >= 0)
_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _snprintf_c_l(
    _Out_writes_opt_(_BufferCount)          char* const _Buffer,
    _In_                                    size_t      const _BufferCount,
    _In_z_ _Printf_format_string_params_(0) char const* const _Format,
    _In_opt_                                _locale_t   const _Locale,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Locale);
    _Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

_Success_(return >= 0)
_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _snprintf_c(
    _Out_writes_opt_(_BufferCount) char* const _Buffer,
    _In_                           size_t      const _BufferCount,
    _In_z_ _Printf_format_string_  char const* const _Format,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Format);
    _Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

_Success_(return >= 0)
_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _snprintf_s_l(
    _Out_writes_opt_(_BufferCount) _Always_(_Post_z_) char* const _Buffer,
    _In_                                              size_t      const _BufferCount,
    _In_                                              size_t      const _MaxCount,
    _In_z_ _Printf_format_string_params_(0)           char const* const _Format,
    _In_opt_                                          _locale_t   const _Locale,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Locale);
    _Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

_Success_(return >= 0)
_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _snprintf_s(
    _Out_writes_opt_(_BufferCount) _Always_(_Post_z_) char* const _Buffer,
    _In_                                              size_t      const _BufferCount,
    _In_                                              size_t      const _MaxCount,
    _In_z_ _Printf_format_string_                     char const* const _Format,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Format);
    _Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2_ARGLIST(
    _Success_(return >= 0)
    int, _snprintf_s, _vsnprintf_s,
    _Always_(_Post_z_)            char, _Buffer,
    _In_                          size_t, _BufferCount,
    _In_z_ _Printf_format_string_ char const*, _Format
)

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _scprintf_l(
    _In_z_ _Printf_format_string_params_(0) char const* const _Format,
    _In_opt_                                _locale_t   const _Locale,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Locale);
    _Result = _vscprintf_l(_Format, _Locale, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

_Check_return_
_CRT_STDIO_INLINE int __CRTDECL _scprintf(
    _In_z_ _Printf_format_string_ char const* const _Format,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Format);
    _Result = _vscprintf_l(_Format, NULL, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _scprintf_p_l(
    _In_z_ _Printf_format_string_params_(0) char const* const _Format,
    _In_opt_                                _locale_t   const _Locale,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Locale);
    _Result = _vscprintf_p_l(_Format, _Locale, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

_Check_return_
_CRT_STDIO_INLINE int __CRTDECL _scprintf_p(
    _In_z_ _Printf_format_string_ char const* const _Format,
    ...)
#if defined _NO_CRT_STDIO_INLINE
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Format);
    _Result = _vscprintf_p(_Format, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Narrow Character Formatted Input Functions (String)
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
_ACRTIMP int __cdecl __stdio_common_vsscanf(
    _In_                                   unsigned __int64 _Options,
    _In_reads_(_BufferCount) _Pre_z_       char const* _Buffer,
    _In_                                   size_t           _BufferCount,
    _In_z_ _Scanf_format_string_params_(2) char const* _Format,
    _In_opt_                               _locale_t        _Locale,
    va_list          _ArgList
);

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _vsscanf_l(
    _In_z_                        char const* const _Buffer,
    _In_z_ _Printf_format_string_ char const* const _Format,
    _In_opt_                      _locale_t   const _Locale,
    va_list           _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return __stdio_common_vsscanf(
        _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
        _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
}
#endif

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL vsscanf(
    _In_z_                        char const* const _Buffer,
    _In_z_ _Printf_format_string_ char const* const _Format,
    va_list           _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return _vsscanf_l(_Buffer, _Format, NULL, _ArgList);
}
#endif

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _vsscanf_s_l(
    _In_z_                        char const* const _Buffer,
    _In_z_ _Printf_format_string_ char const* const _Format,
    _In_opt_                      _locale_t   const _Locale,
    va_list           _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return __stdio_common_vsscanf(
        _CRT_INTERNAL_LOCAL_SCANF_OPTIONS | _CRT_INTERNAL_SCANF_SECURECRT,
        _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
}
#endif

#if __STDC_WANT_SECURE_LIB__

#pragma warning(push)
#pragma warning(disable: 6530) // Unrecognized SAL format string

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL vsscanf_s(
    _In_z_                        char const* const _Buffer,
    _In_z_ _Printf_format_string_ char const* const _Format,
    va_list           _ArgList
)
#if defined _NO_CRT_STDIO_INLINE
;
#else
{
    return _vsscanf_s_l(_Buffer, _Format, NULL, _ArgList);
}
#endif

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(
    int, vsscanf_s,
    _In_z_                        char const, _Buffer,
    _In_z_ _Printf_format_string_ char const*, _Format,
    va_list, _ArgList
)

#pragma warning(pop)

#endif

_Check_return_opt_ _CRT_INSECURE_DEPRECATE(_sscanf_s_l)
_CRT_STDIO_INLINE int __CRTDECL _sscanf_l(
    _In_z_                                 char const* const _Buffer,
    _In_z_ _Scanf_format_string_params_(0) char const* const _Format,
    _In_opt_                               _locale_t   const _Locale,
    ...)
#if defined _NO_CRT_STDIO_INLINE // SCANF
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Locale);
    _Result = _vsscanf_l(_Buffer, _Format, _Locale, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

_Check_return_ _CRT_INSECURE_DEPRECATE(sscanf_s)
_CRT_STDIO_INLINE int __CRTDECL sscanf(
    _In_z_                       char const* const _Buffer,
    _In_z_ _Scanf_format_string_ char const* const _Format,
    ...)
#if defined _NO_CRT_STDIO_INLINE // SCANF
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Format);
    _Result = _vsscanf_l(_Buffer, _Format, NULL, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _sscanf_s_l(
    _In_z_                                   char const* const _Buffer,
    _In_z_ _Scanf_s_format_string_params_(0) char const* const _Format,
    _In_opt_                                 _locale_t   const _Locale,
    ...)
#if defined _NO_CRT_STDIO_INLINE // SCANF
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Locale);
    _Result = _vsscanf_s_l(_Buffer, _Format, _Locale, _ArgList);
    __crt_va_end(_ArgList);
    return _Result;
}
#endif

#if __STDC_WANT_SECURE_LIB__

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL sscanf_s(
    _In_z_                         char const* const _Buffer,
    _In_z_ _Scanf_s_format_string_ char const* const _Format,
    ...)
#if defined _NO_CRT_STDIO_INLINE // SCANF
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Format);

    _Result = vsscanf_s(_Buffer, _Format, _ArgList);

    __crt_va_end(_ArgList);
    return _Result;
}
#endif

#endif

#pragma warning(push)
#pragma warning(disable: 6530) // Unrecognized SAL format string

_Check_return_opt_ _CRT_INSECURE_DEPRECATE(_snscanf_s_l)
_CRT_STDIO_INLINE int __CRTDECL _snscanf_l(
    _In_reads_bytes_(_BufferCount) _Pre_z_ char const* const _Buffer,
    _In_                                   size_t      const _BufferCount,
    _In_z_ _Scanf_format_string_params_(0) char const* const _Format,
    _In_opt_                               _locale_t   const _Locale,
    ...)
#if defined _NO_CRT_STDIO_INLINE // SCANF
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Locale);

    _Result = __stdio_common_vsscanf(
        _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
        _Buffer, _BufferCount, _Format, _Locale, _ArgList);

    __crt_va_end(_ArgList);
    return _Result;
}
#endif

_Check_return_opt_ _CRT_INSECURE_DEPRECATE(_snscanf_s)
_CRT_STDIO_INLINE int __CRTDECL _snscanf(
    _In_reads_bytes_(_BufferCount) _Pre_z_ char const* const _Buffer,
    _In_                                   size_t      const _BufferCount,
    _In_z_ _Scanf_format_string_           char const* const _Format,
    ...)
#if defined _NO_CRT_STDIO_INLINE // SCANF
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Format);

    _Result = __stdio_common_vsscanf(
        _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
        _Buffer, _BufferCount, _Format, NULL, _ArgList);

    __crt_va_end(_ArgList);
    return _Result;
}
#endif


_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _snscanf_s_l(
    _In_reads_bytes_(_BufferCount) _Pre_z_   char const* const _Buffer,
    _In_                                     size_t      const _BufferCount,
    _In_z_ _Scanf_s_format_string_params_(0) char const* const _Format,
    _In_opt_                                 _locale_t   const _Locale,
    ...)
#if defined _NO_CRT_STDIO_INLINE // SCANF
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Locale);

    _Result = __stdio_common_vsscanf(
        _CRT_INTERNAL_LOCAL_SCANF_OPTIONS | _CRT_INTERNAL_SCANF_SECURECRT,
        _Buffer, _BufferCount, _Format, _Locale, _ArgList);

    __crt_va_end(_ArgList);
    return _Result;
}
#endif

_Check_return_opt_
_CRT_STDIO_INLINE int __CRTDECL _snscanf_s(
    _In_reads_bytes_(_BufferCount) _Pre_z_ char const* const _Buffer,
    _In_                                   size_t      const _BufferCount,
    _In_z_ _Scanf_s_format_string_         char const* const _Format,
    ...)
#if defined _NO_CRT_STDIO_INLINE // SCANF
    ;
#else
{
    int _Result;
    va_list _ArgList;
    __crt_va_start(_ArgList, _Format);

    _Result = __stdio_common_vsscanf(
        _CRT_INTERNAL_LOCAL_SCANF_OPTIONS | _CRT_INTERNAL_SCANF_SECURECRT,
        _Buffer, _BufferCount, _Format, NULL, _ArgList);

    __crt_va_end(_ArgList);
    return _Result;
}
#endif

#pragma warning(pop)

#if defined _M_CEE_MIXED
#pragma managed(pop)
#endif



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Non-ANSI Names for Compatibility
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#if defined(_CRT_INTERNAL_NONSTDC_NAMES) && _CRT_INTERNAL_NONSTDC_NAMES

#define SYS_OPEN  _SYS_OPEN

#if defined _DEBUG && defined _CRTDBG_MAP_ALLOC
#pragma push_macro("tempnam")
#undef tempnam
#endif

_CRT_NONSTDC_DEPRECATE(_tempnam)
_ACRTIMP char* __cdecl tempnam(
    _In_opt_z_ char const* _Directory,
    _In_opt_z_ char const* _FilePrefix
);

#if defined _DEBUG && defined _CRTDBG_MAP_ALLOC
#pragma pop_macro("tempnam")
#endif

_Check_return_opt_ _CRT_NONSTDC_DEPRECATE(_fcloseall) _ACRTIMP int   __cdecl fcloseall(void);
_Check_return_     _CRT_NONSTDC_DEPRECATE(_fdopen)    _ACRTIMP FILE* __cdecl fdopen(_In_ int _FileHandle, _In_z_ char const* _Format);
_Check_return_opt_ _CRT_NONSTDC_DEPRECATE(_fgetchar)  _ACRTIMP int   __cdecl fgetchar(void);
_Check_return_     _CRT_NONSTDC_DEPRECATE(_fileno)    _ACRTIMP int   __cdecl fileno(_In_ FILE * _Stream);
_Check_return_opt_ _CRT_NONSTDC_DEPRECATE(_flushall)  _ACRTIMP int   __cdecl flushall(void);
_Check_return_opt_ _CRT_NONSTDC_DEPRECATE(_fputchar)  _ACRTIMP int   __cdecl fputchar(_In_ int _Ch);
_Check_return_     _CRT_NONSTDC_DEPRECATE(_getw)      _ACRTIMP int   __cdecl getw(_Inout_ FILE * _Stream);
_Check_return_opt_ _CRT_NONSTDC_DEPRECATE(_putw)      _ACRTIMP int   __cdecl putw(_In_ int _Ch, _Inout_ FILE * _Stream);
_Check_return_     _CRT_NONSTDC_DEPRECATE(_rmtmp)     _ACRTIMP int   __cdecl rmtmp(void);

#endif // _CRT_INTERNAL_NONSTDC_NAMES
#endif // _CRT_FUNCTIONS_REQUIRED



_CRT_END_C_HEADER
_UCRT_RESTORE_CLANG_WARNINGS
#pragma warning(pop) // _UCRT_DISABLED_WARNINGS
#endif // _INC_STDIO


#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

// undef common macro overrides
#undef clearerr
#undef feof
#undef ferror
#undef getc
#undef getchar
#undef putc
#undef putchar

// TRANSITION: Boost nonconformingly uses this macro
#define _FPOSOFF(fp) (static_cast<long long>(fp))

_STD_BEGIN
#pragma warning(push)
#pragma warning(disable : 4995) // name was marked as #pragma deprecated

using _CSTD _Mbstatet;

_EXPORT_STD using _CSTD size_t;
_EXPORT_STD using _CSTD fpos_t;
_EXPORT_STD using _CSTD FILE;
_EXPORT_STD using _CSTD clearerr;
_EXPORT_STD using _CSTD fclose;
_EXPORT_STD using _CSTD feof;
_EXPORT_STD using _CSTD ferror;
_EXPORT_STD using _CSTD fflush;
_EXPORT_STD using _CSTD fgetc;
_EXPORT_STD using _CSTD fgetpos;
_EXPORT_STD using _CSTD fgets;
_EXPORT_STD using _CSTD fopen;
_EXPORT_STD using _CSTD fprintf;
_EXPORT_STD using _CSTD fputc;
_EXPORT_STD using _CSTD fputs;
_EXPORT_STD using _CSTD fread;
_EXPORT_STD using _CSTD freopen;
_EXPORT_STD using _CSTD fscanf;
_EXPORT_STD using _CSTD fseek;
_EXPORT_STD using _CSTD fsetpos;
_EXPORT_STD using _CSTD ftell;
_EXPORT_STD using _CSTD fwrite;
_EXPORT_STD using _CSTD getc;
_EXPORT_STD using _CSTD getchar;
_EXPORT_STD using _CSTD perror;
_EXPORT_STD using _CSTD putc;
_EXPORT_STD using _CSTD putchar;
_EXPORT_STD using _CSTD printf;
_EXPORT_STD using _CSTD puts;
_EXPORT_STD using _CSTD remove;
_EXPORT_STD using _CSTD rename;
_EXPORT_STD using _CSTD rewind;
_EXPORT_STD using _CSTD scanf;
_EXPORT_STD using _CSTD setbuf;
_EXPORT_STD using _CSTD setvbuf;
_EXPORT_STD using _CSTD sprintf;
_EXPORT_STD using _CSTD sscanf;
_EXPORT_STD using _CSTD tmpfile;
_EXPORT_STD using _CSTD tmpnam;
_EXPORT_STD using _CSTD ungetc;
_EXPORT_STD using _CSTD vfprintf;
_EXPORT_STD using _CSTD vprintf;
_EXPORT_STD using _CSTD vsprintf;

_EXPORT_STD using _CSTD snprintf;
_EXPORT_STD using _CSTD vsnprintf;
_EXPORT_STD using _CSTD vfscanf;
_EXPORT_STD using _CSTD vscanf;
_EXPORT_STD using _CSTD vsscanf;

#pragma warning(pop)
_STD_END

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)

#endif // _STL_COMPILER_PREPROCESSOR
#endif // _CSTDIO_

// cstring standard header (core)

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#ifndef _CSTRING_
#define _CSTRING_
#if _STL_COMPILER_PREPROCESSOR
//
// string.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The C Standard Library <string.h> header.
//
#pragma once
#ifndef _INC_STRING // include guard for 3rd party interop
#define _INC_STRING

//
// corecrt_memory.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The buffer (memory) manipulation library.  These declarations are split out
// so that they may be included by both <string.h> and <memory.h>.  <string.h>
// does not include <memory.h> to avoid introducing conflicts with other user
// headers named <memory.h>.
//
#pragma once
//
// vcruntime_string.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// <string.h> functionality that is implemented in the VCRuntime.
//
#pragma once

#pragma warning(push)
#pragma warning(disable: _VCRUNTIME_DISABLED_WARNINGS)

#ifndef __midl

_CRT_BEGIN_C_HEADER



_NODISCARD _Check_return_
_VCRTIMP void _CONST_RETURN* __cdecl memchr(
    _In_reads_bytes_opt_(_MaxCount) void const* _Buf,
    _In_                            int         _Val,
    _In_                            size_t      _MaxCount
);

_NODISCARD _Check_return_
int __cdecl memcmp(
    _In_reads_bytes_(_Size) void const* _Buf1,
    _In_reads_bytes_(_Size) void const* _Buf2,
    _In_                    size_t      _Size
);

_CRT_INSECURE_DEPRECATE_MEMORY(memcpy_s)
_Post_equal_to_(_Dst)
_At_buffer_(
    (unsigned char*)_Dst,
    _Iter_,
    _Size,
    _Post_satisfies_(((unsigned char*)_Dst)[_Iter_] == ((unsigned char*)_Src)[_Iter_])
)
void* __cdecl memcpy(
    _Out_writes_bytes_all_(_Size) void* _Dst,
    _In_reads_bytes_(_Size)       void const* _Src,
    _In_                          size_t      _Size
);

_CRT_INSECURE_DEPRECATE_MEMORY(memmove_s)
_VCRTIMP void* __cdecl memmove(
    _Out_writes_bytes_all_opt_(_Size) void* _Dst,
    _In_reads_bytes_opt_(_Size)       void const* _Src,
    _In_                              size_t      _Size
);

_Post_equal_to_(_Dst)
_At_buffer_(
    (unsigned char*)_Dst,
    _Iter_,
    _Size,
    _Post_satisfies_(((unsigned char*)_Dst)[_Iter_] == _Val)
)
void* __cdecl memset(
    _Out_writes_bytes_all_(_Size) void* _Dst,
    _In_                          int    _Val,
    _In_                          size_t _Size
);

_NODISCARD _Check_return_
_VCRTIMP char _CONST_RETURN* __cdecl strchr(
    _In_z_ char const* _Str,
    _In_   int         _Val
);

_NODISCARD _Check_return_
_VCRTIMP char _CONST_RETURN* __cdecl strrchr(
    _In_z_ char const* _Str,
    _In_   int         _Ch
);

_NODISCARD _Check_return_ _Ret_maybenull_
_VCRTIMP char _CONST_RETURN* __cdecl strstr(
    _In_z_ char const* _Str,
    _In_z_ char const* _SubStr
);

_NODISCARD _Check_return_
_When_(return != NULL, _Ret_range_(_Str, _Str + _String_length_(_Str) - 1))
_VCRTIMP wchar_t _CONST_RETURN* __cdecl wcschr(
    _In_z_ wchar_t const* _Str,
    _In_   wchar_t        _Ch
);

_NODISCARD _Check_return_
_VCRTIMP wchar_t _CONST_RETURN* __cdecl wcsrchr(
    _In_z_ wchar_t const* _Str,
    _In_   wchar_t        _Ch
);

_NODISCARD _Check_return_ _Ret_maybenull_
_When_(return != NULL, _Ret_range_(_Str, _Str + _String_length_(_Str) - 1))
_VCRTIMP wchar_t _CONST_RETURN* __cdecl wcsstr(
    _In_z_ wchar_t const* _Str,
    _In_z_ wchar_t const* _SubStr
);



_CRT_END_C_HEADER

#endif // __midl

#pragma warning(pop) // _VCRUNTIME_DISABLED_WARNINGS


#pragma warning(push)
#pragma warning(disable: _UCRT_DISABLED_WARNINGS)
_UCRT_DISABLE_CLANG_WARNINGS

#ifndef __midl

_CRT_BEGIN_C_HEADER



_Check_return_
_ACRTIMP int __cdecl _memicmp(
    _In_reads_bytes_opt_(_Size) void const* _Buf1,
    _In_reads_bytes_opt_(_Size) void const* _Buf2,
    _In_                        size_t      _Size
);

_Check_return_
_ACRTIMP int __cdecl _memicmp_l(
    _In_reads_bytes_opt_(_Size) void const* _Buf1,
    _In_reads_bytes_opt_(_Size) void const* _Buf2,
    _In_                        size_t      _Size,
    _In_opt_                    _locale_t   _Locale
);



#if !defined RC_INVOKED && __STDC_WANT_SECURE_LIB__

#if defined __cplusplus && _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY
extern "C++"
{
    template <size_t _Size, typename _DstType>
    inline typename _CrtEnableIf<(_Size > 1), void*>::_Type __cdecl memcpy(
        _DstType(&_Dst)[_Size],
        _In_reads_bytes_opt_(_SrcSize) void const* _Src,
        _In_                           size_t      _SrcSize
    ) _CRT_SECURE_CPP_NOTHROW
    {
        return memcpy_s(_Dst, _Size * sizeof(_DstType), _Src, _SrcSize) == 0 ? _Dst : 0;
    }
}
#endif

#if defined __cplusplus && _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY
extern "C++"
{
    template <size_t _Size, typename _DstType>
    inline errno_t __CRTDECL memcpy_s(
        _DstType(&_Dst)[_Size],
        _In_reads_bytes_opt_(_SrcSize) void const* _Src,
        _In_                           rsize_t     _SrcSize
    ) _CRT_SECURE_CPP_NOTHROW
    {
        return memcpy_s(_Dst, _Size * sizeof(_DstType), _Src, _SrcSize);
    }
}
#endif

#endif // !defined RC_INVOKED && __STDC_WANT_SECURE_LIB__



#if defined(_CRT_INTERNAL_NONSTDC_NAMES) && _CRT_INTERNAL_NONSTDC_NAMES

_CRT_NONSTDC_DEPRECATE(_memccpy)
_ACRTIMP void* __cdecl memccpy(
    _Out_writes_bytes_opt_(_Size) void* _Dst,
    _In_reads_bytes_opt_(_Size)   void const* _Src,
    _In_                          int         _Val,
    _In_                          size_t      _Size
);

_Check_return_ _CRT_NONSTDC_DEPRECATE(_memicmp)
_ACRTIMP int __cdecl memicmp(
    _In_reads_bytes_opt_(_Size) void const* _Buf1,
    _In_reads_bytes_opt_(_Size) void const* _Buf2,
    _In_                        size_t      _Size
);

#endif // _CRT_INTERNAL_NONSTDC_NAMES



#if defined __cplusplus

extern "C++" _Check_return_
inline void* __CRTDECL memchr(
    _In_reads_bytes_opt_(_N) void* _Pv,
    _In_                     int    _C,
    _In_                     size_t _N
)
{
    void const* const _Pvc = _Pv;
    return const_cast<void*>(memchr(_Pvc, _C, _N));
}

#endif



_CRT_END_C_HEADER

#endif // !__midl
_UCRT_RESTORE_CLANG_WARNINGS
#pragma warning(pop) // _UCRT_DISABLED_WARNINGS

//
// corecrt_wstring.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// This file declares the wide character (wchar_t) string functionality, shared
// by <string.h> and <wchar.h>.
//
#pragma once

#pragma warning(push)
#pragma warning(disable: _UCRT_DISABLED_WARNINGS)
_UCRT_DISABLE_CLANG_WARNINGS

#ifndef __midl

_CRT_BEGIN_C_HEADER



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Secure Alternatives
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#if __STDC_WANT_SECURE_LIB__

_Check_return_wat_
_ACRTIMP errno_t __cdecl wcscat_s(
    _Inout_updates_z_(_SizeInWords) wchar_t* _Destination,
    _In_ rsize_t _SizeInWords,
    _In_z_ wchar_t const* _Source
);

_Check_return_wat_
_ACRTIMP errno_t __cdecl wcscpy_s(
    _Out_writes_z_(_SizeInWords) wchar_t* _Destination,
    _In_ rsize_t _SizeInWords,
    _In_z_ wchar_t const* _Source
);

_Check_return_wat_
_ACRTIMP errno_t __cdecl wcsncat_s(
    _Inout_updates_z_(_SizeInWords) wchar_t* _Destination,
    _In_                            rsize_t        _SizeInWords,
    _In_reads_or_z_(_MaxCount)      wchar_t const* _Source,
    _In_                            rsize_t        _MaxCount
);

_Check_return_wat_
_ACRTIMP errno_t __cdecl wcsncpy_s(
    _Out_writes_z_(_SizeInWords) wchar_t* _Destination,
    _In_                         rsize_t        _SizeInWords,
    _In_reads_or_z_(_MaxCount)   wchar_t const* _Source,
    _In_                         rsize_t        _MaxCount
);

_Check_return_
_ACRTIMP wchar_t* __cdecl wcstok_s(
    _Inout_opt_z_                 wchar_t* _String,
    _In_z_                        wchar_t const* _Delimiter,
    _Inout_ _Deref_prepost_opt_z_ wchar_t** _Context
);

#endif // __STDC_WANT_SECURE_LIB__



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Wide-Character <string.h> Functions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#if defined _DEBUG && defined _CRTDBG_MAP_ALLOC
#pragma push_macro("_wcsdup")
#undef _wcsdup
#endif

_Check_return_
_ACRTIMP _CRTALLOCATOR wchar_t* __cdecl _wcsdup(
    _In_z_ wchar_t const* _String
);

#if defined _DEBUG && defined _CRTDBG_MAP_ALLOC
#pragma pop_macro("_wcsdup")
#endif



__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(
    errno_t, wcscat_s,
    wchar_t, _Destination,
    _In_z_ wchar_t const*, _Source
)

#ifndef RC_INVOKED
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1(
    wchar_t*, __RETURN_POLICY_DST, _ACRTIMP, wcscat,
    _Inout_updates_z_(_String_length_(_Destination) + _String_length_(_Source) + 1), wchar_t, _Destination,
    _In_z_                                                                           wchar_t const*, _Source
)
#endif

_Check_return_
_ACRTIMP int __cdecl wcscmp(
    _In_z_ wchar_t const* _String1,
    _In_z_ wchar_t const* _String2
);

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(
    errno_t, wcscpy_s,
    wchar_t, _Destination,
    _In_z_ wchar_t const*, _Source
)

__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1(
    wchar_t*, __RETURN_POLICY_DST, _ACRTIMP, wcscpy,
    _Out_writes_z_(_String_length_(_Source) + 1), wchar_t, _Destination,
    _In_z_                                        wchar_t const*, _Source
)

_Check_return_
_ACRTIMP size_t __cdecl wcscspn(
    _In_z_ wchar_t const* _String,
    _In_z_ wchar_t const* _Control
);

_Check_return_
_ACRTIMP size_t __cdecl wcslen(
    _In_z_ wchar_t const* _String
);

_Check_return_
_When_(
    _MaxCount > _String_length_(_Source),
    _Post_satisfies_(return == _String_length_(_Source))
)
_When_(
    _MaxCount <= _String_length_(_Source),
    _Post_satisfies_(return == _MaxCount)
)
_ACRTIMP size_t __cdecl wcsnlen(
    _In_reads_or_z_(_MaxCount) wchar_t const* _Source,
    _In_                       size_t         _MaxCount
);

#if __STDC_WANT_SECURE_LIB__ && !defined(__midl)

_Check_return_
_When_(
    _MaxCount > _String_length_(_Source),
    _Post_satisfies_(return == _String_length_(_Source))
)
_When_(
    _MaxCount <= _String_length_(_Source),
    _Post_satisfies_(return == _MaxCount)
)
static __inline size_t __CRTDECL wcsnlen_s(
    _In_reads_or_z_(_MaxCount) wchar_t const* _Source,
    _In_                       size_t         _MaxCount
)
{
    return (_Source == 0) ? 0 : wcsnlen(_Source, _MaxCount);
}

#endif // __STDC_WANT_SECURE_LIB__ && !defined(__midl)

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(
    errno_t, wcsncat_s,
    _Prepost_z_             wchar_t, _Destination,
    _In_reads_or_z_(_Count) wchar_t const*, _Source,
    _In_                    size_t, _Count
)

__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_EX(
    wchar_t*, __RETURN_POLICY_DST, _ACRTIMP, wcsncat, wcsncat_s,
    _Inout_updates_z_(_Size)   wchar_t,
    _Inout_updates_z_(_Count), wchar_t, _Destination,
    _In_reads_or_z_(_Count)    wchar_t const*, _Source,
    _In_                       size_t, _Count
)

_Check_return_
_ACRTIMP int __cdecl wcsncmp(
    _In_reads_or_z_(_MaxCount) wchar_t const* _String1,
    _In_reads_or_z_(_MaxCount) wchar_t const* _String2,
    _In_                       size_t         _MaxCount
);

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(
    errno_t, wcsncpy_s,
    wchar_t, _Destination,
    _In_reads_or_z_(_Count) wchar_t const*, _Source,
    _In_                    size_t, _Count
)

__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_EX(
    wchar_t*, __RETURN_POLICY_DST, _ACRTIMP, wcsncpy, wcsncpy_s,
    _Pre_notnull_ _Post_maybez_         wchar_t,
    _Out_writes_(_Count) _Post_maybez_, wchar_t, _Destination,
    _In_reads_or_z_(_Count)             wchar_t const*, _Source,
    _In_                                size_t, _Count
)

_Check_return_
_ACRTIMP wchar_t _CONST_RETURN* __cdecl wcspbrk(
    _In_z_ wchar_t const* _String,
    _In_z_ wchar_t const* _Control
);

_Check_return_
_ACRTIMP size_t __cdecl wcsspn(
    _In_z_ wchar_t const* _String,
    _In_z_ wchar_t const* _Control
);

_Check_return_ _CRT_INSECURE_DEPRECATE(wcstok_s)
_ACRTIMP wchar_t* __cdecl wcstok(
    _Inout_opt_z_                     wchar_t* _String,
    _In_z_                            wchar_t const* _Delimiter,
    _Inout_opt_ _Deref_prepost_opt_z_ wchar_t** _Context
);

#if !defined RC_INVOKED && !defined __midl

#if defined _CRT_NON_CONFORMING_WCSTOK
#define _WCSTOK_DEPRECATED _CRT_INSECURE_DEPRECATE(wcstok_s)
#else
#define _WCSTOK_DEPRECATED _CRT_DEPRECATE_TEXT(                           \
                "wcstok has been changed to conform with the ISO C standard, "    \
                "adding an extra context parameter. To use the legacy Microsoft " \
                "wcstok, define _CRT_NON_CONFORMING_WCSTOK.")
#endif

_Check_return_ _CRT_INSECURE_DEPRECATE(wcstok_s)
static __inline wchar_t* __CRTDECL _wcstok(
    _Inout_opt_z_ wchar_t* const _String,
    _In_z_        wchar_t const* const _Delimiter
)
{
    return wcstok(_String, _Delimiter, 0);
}

#if defined _CRT_NON_CONFORMING_WCSTOK && !defined __cplusplus
#define wcstok _wcstok
#endif

#if defined __cplusplus && !defined _CRT_NO_INLINE_DEPRECATED_WCSTOK
extern "C++" _Check_return_ _WCSTOK_DEPRECATED
inline wchar_t* __CRTDECL wcstok(
    _Inout_opt_z_ wchar_t* _String,
    _In_z_        wchar_t const* _Delimiter
) throw()
{
    return wcstok(_String, _Delimiter, 0);
}
#endif

#endif // !defined RC_INVOKED && !defined __midl



_Ret_z_
_Check_return_ _CRT_INSECURE_DEPRECATE(_wcserror_s)
_ACRTIMP wchar_t* __cdecl _wcserror(
    _In_ int _ErrorNumber
);

_Check_return_wat_
_ACRTIMP errno_t __cdecl _wcserror_s(
    _Out_writes_opt_z_(_SizeInWords) wchar_t* _Buffer,
    _In_                             size_t   _SizeInWords,
    _In_                             int      _ErrorNumber
);

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(
    errno_t, _wcserror_s,
    wchar_t, _Buffer,
    _In_ int, _Error
)

_Ret_z_
_Success_(return != 0)
_Check_return_ _CRT_INSECURE_DEPRECATE(__wcserror_s)
_ACRTIMP wchar_t* __cdecl __wcserror(
    _In_opt_z_ wchar_t const* _String
);

_Check_return_wat_ _ACRTIMP_ALT errno_t __cdecl __wcserror_s(
    _Out_writes_opt_z_(_SizeInWords) wchar_t* _Buffer,
    _In_                             size_t         _SizeInWords,
    _In_z_                           wchar_t const* _ErrorMessage
);

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(
    errno_t, __wcserror_s,
    wchar_t, _Buffer,
    _In_z_ wchar_t const*, _ErrorMessage
)

_Check_return_ _ACRTIMP int __cdecl _wcsicmp(
    _In_z_ wchar_t const* _String1,
    _In_z_ wchar_t const* _String2
);

_Check_return_ _ACRTIMP int __cdecl _wcsicmp_l(
    _In_z_   wchar_t const* _String1,
    _In_z_   wchar_t const* _String2,
    _In_opt_ _locale_t      _Locale
);

_Check_return_ _ACRTIMP int __cdecl _wcsnicmp(
    _In_reads_or_z_(_MaxCount) wchar_t const* _String1,
    _In_reads_or_z_(_MaxCount) wchar_t const* _String2,
    _In_                       size_t         _MaxCount
);

_Check_return_ _ACRTIMP int __cdecl _wcsnicmp_l(
    _In_reads_or_z_(_MaxCount) wchar_t const* _String1,
    _In_reads_or_z_(_MaxCount) wchar_t const* _String2,
    _In_                       size_t         _MaxCount,
    _In_opt_                   _locale_t      _Locale
);

_Check_return_wat_ _ACRTIMP errno_t __cdecl _wcsnset_s(
    _Inout_updates_z_(_SizeInWords) wchar_t* _Destination,
    _In_                            size_t   _SizeInWords,
    _In_                            wchar_t  _Value,
    _In_                            size_t   _MaxCount
);

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(
    errno_t, _wcsnset_s,
    _Prepost_z_ wchar_t, _Destination,
    _In_        wchar_t, _Value,
    _In_         size_t, _MaxCount
)

__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_EX(
    wchar_t*, __RETURN_POLICY_DST, _ACRTIMP, _wcsnset, _wcsnset_s,
    _Inout_updates_z_(_Size)      wchar_t,
    _Inout_updates_z_(_MaxCount), wchar_t, _String,
    _In_                          wchar_t, _Value,
    _In_                          size_t, _MaxCount
)

_ACRTIMP wchar_t* __cdecl _wcsrev(
    _Inout_z_ wchar_t* _String
);

_Check_return_wat_ _ACRTIMP errno_t __cdecl _wcsset_s(
    _Inout_updates_z_(_SizeInWords) wchar_t* _Destination,
    _In_                            size_t   _SizeInWords,
    _In_                            wchar_t  _Value
);

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(
    errno_t, _wcsset_s,
    _Prepost_z_ wchar_t, _String,
    _In_        wchar_t, _Value
)

__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_EX(
    wchar_t*, __RETURN_POLICY_DST, _ACRTIMP, _wcsset, _wcsset_s,
    _Inout_updates_z_(_Size) wchar_t,
    _Inout_z_, wchar_t, _String,
    _In_                     wchar_t, _Value
)

_Check_return_wat_ _ACRTIMP errno_t __cdecl _wcslwr_s(
    _Inout_updates_z_(_SizeInWords) wchar_t* _String,
    _In_                            size_t   _SizeInWords
);

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(
    errno_t, _wcslwr_s,
    _Prepost_z_ wchar_t, _String
)

__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0(
    wchar_t*, __RETURN_POLICY_DST, _ACRTIMP, _wcslwr,
    _Inout_z_, wchar_t, _String
)

_Check_return_wat_
_ACRTIMP errno_t __cdecl _wcslwr_s_l(
    _Inout_updates_z_(_SizeInWords) wchar_t* _String,
    _In_                            size_t    _SizeInWords,
    _In_opt_                        _locale_t _Locale
);

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(
    errno_t, _wcslwr_s_l,
    _Prepost_z_ wchar_t, _String,
    _In_opt_    _locale_t, _Locale
)

__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_EX(
    wchar_t*, __RETURN_POLICY_DST, _ACRTIMP, _wcslwr_l, _wcslwr_s_l,
    _Inout_updates_z_(_Size) wchar_t,
    _Inout_z_, wchar_t, _String,
    _In_opt_                 _locale_t, _Locale
)

_Check_return_wat_
_ACRTIMP errno_t __cdecl _wcsupr_s(
    _Inout_updates_z_(_Size) wchar_t* _String,
    _In_                     size_t   _Size
);

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(
    errno_t, _wcsupr_s,
    _Prepost_z_ wchar_t, _String
)

__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0(
    wchar_t*, __RETURN_POLICY_DST, _ACRTIMP, _wcsupr,
    _Inout_z_, wchar_t, _String
)

_Check_return_wat_
_ACRTIMP errno_t __cdecl _wcsupr_s_l(
    _Inout_updates_z_(_Size) wchar_t* _String,
    _In_                     size_t    _Size,
    _In_opt_                 _locale_t _Locale
);

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(
    errno_t, _wcsupr_s_l,
    _Prepost_z_ wchar_t, _String,
    _In_opt_    _locale_t, _Locale
)

__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_EX(
    wchar_t*, __RETURN_POLICY_DST, _ACRTIMP, _wcsupr_l, _wcsupr_s_l,
    _Inout_updates_z_(_Size) wchar_t,
    _Inout_z_, wchar_t, _String,
    _In_opt_                 _locale_t, _Locale
)

_Success_(return < _MaxCount)
    _Check_return_opt_
    _ACRTIMP size_t __cdecl wcsxfrm(
        _Out_writes_opt_(_MaxCount) _Post_maybez_ wchar_t* _Destination,
        _In_z_                                    wchar_t const* _Source,
        _In_ _In_range_(<= , _CRT_INT_MAX)         size_t         _MaxCount
    );

_Success_(return < _MaxCount)
    _Check_return_opt_
    _ACRTIMP size_t __cdecl _wcsxfrm_l(
        _Out_writes_opt_(_MaxCount) _Post_maybez_ wchar_t* _Destination,
        _In_z_                                    wchar_t const* _Source,
        _In_ _In_range_(<= , _CRT_INT_MAX)         size_t         _MaxCount,
        _In_opt_                                  _locale_t      _Locale
    );

_Check_return_
_ACRTIMP int __cdecl wcscoll(
    _In_z_ wchar_t const* _String1,
    _In_z_ wchar_t const* _String2
);

_Check_return_
_ACRTIMP int __cdecl _wcscoll_l(
    _In_z_   wchar_t const* _String1,
    _In_z_   wchar_t const* _String2,
    _In_opt_ _locale_t      _Locale
);

_Check_return_
_ACRTIMP int __cdecl _wcsicoll(
    _In_z_ wchar_t const* _String1,
    _In_z_ wchar_t const* _String2
);

_Check_return_
_ACRTIMP int __cdecl _wcsicoll_l(
    _In_z_   wchar_t const* _String1,
    _In_z_   wchar_t const* _String2,
    _In_opt_ _locale_t      _Locale
);

_Check_return_
_ACRTIMP int __cdecl _wcsncoll(
    _In_reads_or_z_(_MaxCount) wchar_t const* _String1,
    _In_reads_or_z_(_MaxCount) wchar_t const* _String2,
    _In_                       size_t         _MaxCount
);

_Check_return_
_ACRTIMP int __cdecl _wcsncoll_l(
    _In_reads_or_z_(_MaxCount) wchar_t const* _String1,
    _In_reads_or_z_(_MaxCount) wchar_t const* _String2,
    _In_                       size_t         _MaxCount,
    _In_opt_                   _locale_t      _Locale
);

_Check_return_
_ACRTIMP int __cdecl _wcsnicoll(
    _In_reads_or_z_(_MaxCount) wchar_t const* _String1,
    _In_reads_or_z_(_MaxCount) wchar_t const* _String2,
    _In_                       size_t         _MaxCount
);

_Check_return_
_ACRTIMP int __cdecl _wcsnicoll_l(
    _In_reads_or_z_(_MaxCount) wchar_t const* _String1,
    _In_reads_or_z_(_MaxCount) wchar_t const* _String2,
    _In_                       size_t         _MaxCount,
    _In_opt_                   _locale_t      _Locale
);



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Inline C++ Overloads
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#ifdef __cplusplus
extern "C++" {

    _Check_return_
        _When_(return != NULL, _Ret_range_(_String, _String + _String_length_(_String) - 1))
        inline wchar_t* __CRTDECL wcschr(_In_z_ wchar_t* _String, wchar_t _C)
    {
        return const_cast<wchar_t*>(wcschr(static_cast<wchar_t const*>(_String), _C));
    }

    _Check_return_
        inline wchar_t* __CRTDECL wcspbrk(_In_z_ wchar_t* _String, _In_z_ wchar_t const* _Control)
    {
        return const_cast<wchar_t*>(wcspbrk(static_cast<wchar_t const*>(_String), _Control));
    }

    _Check_return_
        inline wchar_t* __CRTDECL wcsrchr(_In_z_ wchar_t* _String, _In_ wchar_t _C)
    {
        return const_cast<wchar_t*>(wcsrchr(static_cast<wchar_t const*>(_String), _C));
    }

    _Check_return_ _Ret_maybenull_
        _When_(return != NULL, _Ret_range_(_String, _String + _String_length_(_String) - 1))
        inline wchar_t* __CRTDECL wcsstr(_In_z_ wchar_t* _String, _In_z_ wchar_t const* _SubStr)
    {
        return const_cast<wchar_t*>(wcsstr(static_cast<wchar_t const*>(_String), _SubStr));
    }

}
#endif // __cplusplus



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Non-Standard Names
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#if defined(_CRT_INTERNAL_NONSTDC_NAMES) && _CRT_INTERNAL_NONSTDC_NAMES
#if defined _DEBUG && defined _CRTDBG_MAP_ALLOC
#pragma push_macro("wcsdup")
#undef wcsdup
#endif

_Check_return_ _CRT_NONSTDC_DEPRECATE(_wcsdup)
_ACRTIMP wchar_t* __cdecl wcsdup(
    _In_z_ wchar_t const* _String
);

#if defined _DEBUG && defined _CRTDBG_MAP_ALLOC
#pragma pop_macro("wcsdup")
#endif

// Declarations of functions defined in oldnames.lib:
#define wcswcs wcsstr

_Check_return_ _CRT_NONSTDC_DEPRECATE(_wcsicmp)
_ACRTIMP int __cdecl wcsicmp(
    _In_z_ wchar_t const* _String1,
    _In_z_ wchar_t const* _String2
);

_Check_return_ _CRT_NONSTDC_DEPRECATE(_wcsnicmp)
_ACRTIMP int __cdecl wcsnicmp(
    _In_reads_or_z_(_MaxCount) wchar_t const* _String1,
    _In_reads_or_z_(_MaxCount) wchar_t const* _String2,
    _In_                       size_t         _MaxCount
);

_CRT_NONSTDC_DEPRECATE(_wcsnset)
_Ret_z_
_ACRTIMP wchar_t* __cdecl wcsnset(
    _Inout_updates_z_(_MaxCount) wchar_t* _String,
    _In_                         wchar_t  _Value,
    _In_                         size_t   _MaxCount
);

_CRT_NONSTDC_DEPRECATE(_wcsrev)
_Ret_z_
_ACRTIMP wchar_t* __cdecl wcsrev(
    _Inout_z_ wchar_t* _String
);

_CRT_NONSTDC_DEPRECATE(_wcsset)
_Ret_z_
_ACRTIMP wchar_t* __cdecl wcsset(
    _Inout_z_ wchar_t* _String,
    _In_      wchar_t  _Value
);

_CRT_NONSTDC_DEPRECATE(_wcslwr)
_Ret_z_
_ACRTIMP wchar_t* __cdecl wcslwr(
    _Inout_z_ wchar_t* _String
);

_CRT_NONSTDC_DEPRECATE(_wcsupr)
_Ret_z_
_ACRTIMP wchar_t* __cdecl wcsupr(
    _Inout_z_ wchar_t* _String
);

_Check_return_ _CRT_NONSTDC_DEPRECATE(_wcsicoll)
_ACRTIMP int __cdecl wcsicoll(
    _In_z_ wchar_t const* _String1,
    _In_z_ wchar_t const* _String2
);

#endif // _CRT_INTERNAL_NONSTDC_NAMES

_CRT_END_C_HEADER

#endif // !__midl
_UCRT_RESTORE_CLANG_WARNINGS
#pragma warning(pop) // _UCRT_DISABLED_WARNINGS


#ifndef __midl

#pragma warning(push)
#pragma warning(disable: _UCRT_DISABLED_WARNINGS)
_UCRT_DISABLE_CLANG_WARNINGS

_CRT_BEGIN_C_HEADER



#define _NLSCMPERROR _CRT_INT_MAX // currently == INT_MAX

#if __STDC_WANT_SECURE_LIB__

_Check_return_wat_
_ACRTIMP errno_t __cdecl strcpy_s(
    _Out_writes_z_(_SizeInBytes) char* _Destination,
    _In_                         rsize_t     _SizeInBytes,
    _In_z_                       char const* _Source
);

_Check_return_wat_
_ACRTIMP errno_t __cdecl strcat_s(
    _Inout_updates_z_(_SizeInBytes) char* _Destination,
    _In_                            rsize_t     _SizeInBytes,
    _In_z_                          char const* _Source
);

_Check_return_wat_
_ACRTIMP errno_t __cdecl strerror_s(
    _Out_writes_z_(_SizeInBytes) char* _Buffer,
    _In_                         size_t _SizeInBytes,
    _In_                         int    _ErrorNumber);

_Check_return_wat_
_ACRTIMP errno_t __cdecl strncat_s(
    _Inout_updates_z_(_SizeInBytes) char* _Destination,
    _In_                            rsize_t     _SizeInBytes,
    _In_reads_or_z_(_MaxCount)      char const* _Source,
    _In_                            rsize_t     _MaxCount
);

_Check_return_wat_
_ACRTIMP errno_t __cdecl strncpy_s(
    _Out_writes_z_(_SizeInBytes) char* _Destination,
    _In_                         rsize_t     _SizeInBytes,
    _In_reads_or_z_(_MaxCount)   char const* _Source,
    _In_                         rsize_t     _MaxCount
);

_Check_return_
_ACRTIMP char* __cdecl strtok_s(
    _Inout_opt_z_                 char* _String,
    _In_z_                        char const* _Delimiter,
    _Inout_ _Deref_prepost_opt_z_ char** _Context
);

#endif // __STDC_WANT_SECURE_LIB__

_ACRTIMP void* __cdecl _memccpy(
    _Out_writes_bytes_opt_(_MaxCount) void* _Dst,
    _In_                              void const* _Src,
    _In_                              int         _Val,
    _In_                              size_t      _MaxCount
);

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(
    errno_t, strcat_s,
    char, _Destination,
    _In_z_ char const*, _Source
)

#ifndef RC_INVOKED

__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1(
    char*, __RETURN_POLICY_DST, __EMPTY_DECLSPEC, strcat,
    _Inout_updates_z_(_String_length_(_Destination) + _String_length_(_Source) + 1), char, _Destination,
    _In_z_                                                                           char const*, _Source
)

#endif // RC_INVOKED

_Check_return_
int __cdecl strcmp(
    _In_z_ char const* _Str1,
    _In_z_ char const* _Str2
);

_Check_return_
_ACRTIMP int __cdecl _strcmpi(
    _In_z_ char const* _String1,
    _In_z_ char const* _String2
);

_Check_return_
_ACRTIMP int __cdecl strcoll(
    _In_z_ char const* _String1,
    _In_z_ char const* _String2
);

_Check_return_
_ACRTIMP int __cdecl _strcoll_l(
    _In_z_   char const* _String1,
    _In_z_   char const* _String2,
    _In_opt_ _locale_t   _Locale
);

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(
    errno_t, strcpy_s,
    _Post_z_ char, _Destination,
    _In_z_   char const*, _Source
)

__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1(
    char*, __RETURN_POLICY_DST, __EMPTY_DECLSPEC, strcpy,
    _Out_writes_z_(_String_length_(_Source) + 1), char, _Destination,
    _In_z_                                        char const*, _Source
)

_Check_return_
_ACRTIMP size_t __cdecl strcspn(
    _In_z_ char const* _Str,
    _In_z_ char const* _Control
);

#if defined _DEBUG && defined _CRTDBG_MAP_ALLOC
#pragma push_macro("_strdup")
#undef _strdup
#endif

_Check_return_
_ACRTIMP _CRTALLOCATOR char* __cdecl _strdup(
    _In_opt_z_ char const* _Source
);

#if defined _DEBUG && defined _CRTDBG_MAP_ALLOC
#pragma pop_macro("_strdup")
#endif

_Ret_z_
_Success_(return != 0)
_Check_return_ _CRT_INSECURE_DEPRECATE(_strerror_s)
_ACRTIMP char* __cdecl _strerror(
    _In_opt_z_ char const* _ErrorMessage
);

_Check_return_wat_
_ACRTIMP errno_t __cdecl _strerror_s(
    _Out_writes_z_(_SizeInBytes) char* _Buffer,
    _In_                         size_t      _SizeInBytes,
    _In_opt_z_                   char const* _ErrorMessage
);

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(
    errno_t, _strerror_s,
    char, _Buffer,
    _In_opt_z_ char const*, _ErrorMessage
)

_Ret_z_
_Check_return_ _CRT_INSECURE_DEPRECATE(strerror_s)
_ACRTIMP char* __cdecl strerror(
    _In_ int _ErrorMessage
);

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(
    errno_t, strerror_s,
    char, _Buffer,
    _In_ int, _ErrorMessage
)

_Check_return_
_ACRTIMP int __cdecl _stricmp(
    _In_z_ char const* _String1,
    _In_z_ char const* _String2
);

_Check_return_
_ACRTIMP int __cdecl _stricoll(
    _In_z_ char const* _String1,
    _In_z_ char const* _String2
);

_Check_return_
_ACRTIMP int __cdecl _stricoll_l(
    _In_z_   char const* _String1,
    _In_z_   char const* _String2,
    _In_opt_ _locale_t   _Locale
);

_Check_return_
_ACRTIMP int __cdecl _stricmp_l(
    _In_z_   char const* _String1,
    _In_z_   char const* _String2,
    _In_opt_ _locale_t   _Locale
);

_Check_return_
size_t __cdecl strlen(
    _In_z_ char const* _Str
);

_Check_return_wat_
_ACRTIMP errno_t __cdecl _strlwr_s(
    _Inout_updates_z_(_Size) char* _String,
    _In_                     size_t _Size
);

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(
    errno_t, _strlwr_s,
    _Prepost_z_ char, _String
)

__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0(
    char*, __RETURN_POLICY_DST, _ACRTIMP, _strlwr,
    _Inout_z_, char, _String
)

_Check_return_wat_
_ACRTIMP errno_t __cdecl _strlwr_s_l(
    _Inout_updates_z_(_Size) char* _String,
    _In_                     size_t    _Size,
    _In_opt_                 _locale_t _Locale
);

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(
    errno_t, _strlwr_s_l,
    _Prepost_z_ char, _String,
    _In_opt_    _locale_t, _Locale
)

__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_EX(
    char*, __RETURN_POLICY_DST, _ACRTIMP, _strlwr_l, _strlwr_s_l,
    _Inout_updates_z_(_Size) char,
    _Inout_z_, char, _String,
    _In_opt_                 _locale_t, _Locale
)

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(
    errno_t, strncat_s,
    _Prepost_z_             char, _Destination,
    _In_reads_or_z_(_Count) char const*, _Source,
    _In_                    size_t, _Count
)

__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_EX(
    char*, __RETURN_POLICY_DST, _ACRTIMP, strncat, strncat_s,
    _Inout_updates_z_(_Size)   char,
    _Inout_updates_z_(_Count), char, _Destination,
    _In_reads_or_z_(_Count)    char const*, _Source,
    _In_                       size_t, _Count
)

_Check_return_
_ACRTIMP int __cdecl strncmp(
    _In_reads_or_z_(_MaxCount) char const* _Str1,
    _In_reads_or_z_(_MaxCount) char const* _Str2,
    _In_                       size_t      _MaxCount
);

_Check_return_
_ACRTIMP int __cdecl _strnicmp(
    _In_reads_or_z_(_MaxCount) char const* _String1,
    _In_reads_or_z_(_MaxCount) char const* _String2,
    _In_                       size_t      _MaxCount
);

_Check_return_
_ACRTIMP int __cdecl _strnicmp_l(
    _In_reads_or_z_(_MaxCount) char const* _String1,
    _In_reads_or_z_(_MaxCount) char const* _String2,
    _In_                       size_t      _MaxCount,
    _In_opt_                   _locale_t   _Locale
);

_Check_return_
_ACRTIMP int __cdecl _strnicoll(
    _In_reads_or_z_(_MaxCount) char const* _String1,
    _In_reads_or_z_(_MaxCount) char const* _String2,
    _In_                       size_t      _MaxCount
);

_Check_return_
_ACRTIMP int __cdecl _strnicoll_l(
    _In_reads_or_z_(_MaxCount) char const* _String1,
    _In_reads_or_z_(_MaxCount) char const* _String2,
    _In_                       size_t      _MaxCount,
    _In_opt_                   _locale_t   _Locale
);

_Check_return_
_ACRTIMP int __cdecl _strncoll(
    _In_reads_or_z_(_MaxCount) char const* _String1,
    _In_reads_or_z_(_MaxCount) char const* _String2,
    _In_                       size_t      _MaxCount
);

_Check_return_
_ACRTIMP int __cdecl _strncoll_l(
    _In_reads_or_z_(_MaxCount) char const* _String1,
    _In_reads_or_z_(_MaxCount) char const* _String2,
    _In_                       size_t      _MaxCount,
    _In_opt_                   _locale_t   _Locale
);

_ACRTIMP size_t __cdecl __strncnt(
    _In_reads_or_z_(_Count) char const* _String,
    _In_                    size_t      _Count
);

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(
    errno_t, strncpy_s,
    char, _Destination,
    _In_reads_or_z_(_Count) char const*, _Source,
    _In_                    size_t, _Count
)

__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_EX(
    char*, __RETURN_POLICY_DST, _ACRTIMP, strncpy, strncpy_s,
    _Out_writes_z_(_Size)               char,
    _Out_writes_(_Count) _Post_maybez_, char, _Destination,
    _In_reads_or_z_(_Count)             char const*, _Source,
    _In_                                size_t, _Count
)

_Check_return_
_When_(
    _MaxCount > _String_length_(_String),
    _Post_satisfies_(return == _String_length_(_String))
)
_When_(
    _MaxCount <= _String_length_(_String),
    _Post_satisfies_(return == _MaxCount)
)
_ACRTIMP size_t __cdecl strnlen(
    _In_reads_or_z_(_MaxCount) char const* _String,
    _In_                       size_t      _MaxCount
);

#if __STDC_WANT_SECURE_LIB__ && !defined __midl

_Check_return_
_When_(
    _MaxCount > _String_length_(_String),
    _Post_satisfies_(return == _String_length_(_String))
)
_When_(
    _MaxCount <= _String_length_(_String),
    _Post_satisfies_(return == _MaxCount)
)
static __inline size_t __CRTDECL strnlen_s(
    _In_reads_or_z_(_MaxCount) char const* _String,
    _In_                       size_t      _MaxCount
)
{
    return _String == 0 ? 0 : strnlen(_String, _MaxCount);
}

#endif

_Check_return_wat_
_ACRTIMP errno_t __cdecl _strnset_s(
    _Inout_updates_z_(_SizeInBytes) char* _String,
    _In_                            size_t _SizeInBytes,
    _In_                            int    _Value,
    _In_                            size_t _MaxCount
);

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(
    errno_t, _strnset_s,
    _Prepost_z_ char, _Destination,
    _In_        int, _Value,
    _In_        size_t, _Count
)

__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_EX(
    char*, __RETURN_POLICY_DST, _ACRTIMP, _strnset, _strnset_s,
    _Inout_updates_z_(_Size)   char,
    _Inout_updates_z_(_Count), char, _Destination,
    _In_                       int, _Value,
    _In_                       size_t, _Count
)

_Check_return_
_ACRTIMP char _CONST_RETURN* __cdecl strpbrk(
    _In_z_ char const* _Str,
    _In_z_ char const* _Control
);

_ACRTIMP char* __cdecl _strrev(
    _Inout_z_ char* _Str
);

_Check_return_wat_
_ACRTIMP errno_t __cdecl _strset_s(
    _Inout_updates_z_(_DestinationSize) char* _Destination,
    _In_                                size_t _DestinationSize,
    _In_                                int    _Value
);

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(
    errno_t, _strset_s,
    _Prepost_z_ char, _Destination,
    _In_        int, _Value
)

__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1(
    char*, __RETURN_POLICY_DST, __EMPTY_DECLSPEC, _strset,
    _Inout_z_, char, _Destination,
    _In_       int, _Value
)

_Check_return_
_ACRTIMP size_t __cdecl strspn(
    _In_z_ char const* _Str,
    _In_z_ char const* _Control
);

_Check_return_ _CRT_INSECURE_DEPRECATE(strtok_s)
_ACRTIMP char* __cdecl strtok(
    _Inout_opt_z_ char* _String,
    _In_z_        char const* _Delimiter
);

_Check_return_wat_
_ACRTIMP errno_t __cdecl _strupr_s(
    _Inout_updates_z_(_Size) char* _String,
    _In_                     size_t _Size
);

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(
    errno_t, _strupr_s,
    _Prepost_z_ char, _String
)

__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0(
    char*, __RETURN_POLICY_DST, _ACRTIMP, _strupr,
    _Inout_z_, char, _String
)

_Check_return_wat_
_ACRTIMP errno_t __cdecl _strupr_s_l(
    _Inout_updates_z_(_Size) char* _String,
    _In_                     size_t    _Size,
    _In_opt_                 _locale_t _Locale
);

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(
    errno_t, _strupr_s_l,
    _Prepost_z_ char, _String,
    _In_opt_    _locale_t, _Locale
)

__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_EX(
    char*, __RETURN_POLICY_DST, _ACRTIMP, _strupr_l, _strupr_s_l,
    _Inout_updates_z_(_Size) char,
    _Inout_z_, char, _String,
    _In_opt_                 _locale_t, _Locale
)

_Success_(return < _MaxCount)
    _Check_return_opt_
    _ACRTIMP size_t __cdecl strxfrm(
        _Out_writes_opt_(_MaxCount) _Post_maybez_ char* _Destination,
        _In_z_                                    char const* _Source,
        _In_ _In_range_(<= , _CRT_INT_MAX)          size_t      _MaxCount
    );

_Success_(return < _MaxCount)
    _Check_return_opt_
    _ACRTIMP size_t __cdecl _strxfrm_l(
        _Out_writes_opt_(_MaxCount) _Post_maybez_ char* _Destination,
        _In_z_                                    char const* _Source,
        _In_ _In_range_(<= , _CRT_INT_MAX)          size_t      _MaxCount,
        _In_opt_                                  _locale_t   _Locale
    );



#ifdef __cplusplus
extern "C++"
{
    _Check_return_
        inline char* __CRTDECL strchr(_In_z_ char* const _String, _In_ int const _Ch)
    {
        return const_cast<char*>(strchr(static_cast<char const*>(_String), _Ch));
    }

    _Check_return_
        inline char* __CRTDECL strpbrk(_In_z_ char* const _String, _In_z_ char const* const _Control)
    {
        return const_cast<char*>(strpbrk(static_cast<char const*>(_String), _Control));
    }

    _Check_return_
        inline char* __CRTDECL strrchr(_In_z_ char* const _String, _In_ int const _Ch)
    {
        return const_cast<char*>(strrchr(static_cast<char const*>(_String), _Ch));
    }

    _Check_return_ _Ret_maybenull_
        inline char* __CRTDECL strstr(_In_z_ char* const _String, _In_z_ char const* const _SubString)
    {
        return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));
    }
}
#endif // __cplusplus



#if defined(_CRT_INTERNAL_NONSTDC_NAMES) && _CRT_INTERNAL_NONSTDC_NAMES

#pragma push_macro("strdup")
#undef strdup
_Check_return_ _CRT_NONSTDC_DEPRECATE(_strdup)
_ACRTIMP char* __cdecl strdup(
    _In_opt_z_ char const* _String
);
#pragma pop_macro("strdup")

// Declarations of functions defined in oldnames.lib:
_Check_return_ _CRT_NONSTDC_DEPRECATE(_strcmpi)
_ACRTIMP int __cdecl strcmpi(
    _In_z_ char const* _String1,
    _In_z_ char const* _String2
);

_Check_return_ _CRT_NONSTDC_DEPRECATE(_stricmp)
_ACRTIMP int __cdecl stricmp(
    _In_z_ char const* _String1,
    _In_z_ char const* _String2
);

_CRT_NONSTDC_DEPRECATE(_strlwr)
_ACRTIMP char* __cdecl strlwr(
    _Inout_z_ char* _String
);

_Check_return_ _CRT_NONSTDC_DEPRECATE(_strnicmp)
_ACRTIMP int __cdecl strnicmp(
    _In_reads_or_z_(_MaxCount) char const* _String1,
    _In_reads_or_z_(_MaxCount) char const* _String2,
    _In_                       size_t      _MaxCount
);

_CRT_NONSTDC_DEPRECATE(_strnset)
_ACRTIMP char* __cdecl strnset(
    _Inout_updates_z_(_MaxCount) char* _String,
    _In_                         int    _Value,
    _In_                         size_t _MaxCount
);

_CRT_NONSTDC_DEPRECATE(_strrev)
_ACRTIMP char* __cdecl strrev(
    _Inout_z_ char* _String
);

_CRT_NONSTDC_DEPRECATE(_strset)
char* __cdecl strset(
    _Inout_z_ char* _String,
    _In_      int   _Value);

_CRT_NONSTDC_DEPRECATE(_strupr)
_ACRTIMP char* __cdecl strupr(
    _Inout_z_ char* _String
);

#endif // _CRT_INTERNAL_NONSTDC_NAMES

_CRT_END_C_HEADER
_UCRT_RESTORE_CLANG_WARNINGS
#pragma warning(pop) // _UCRT_DISABLED_WARNINGS
#endif // !__midl
#endif // _INC_STRING

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_STD_BEGIN
#pragma warning(push)
#pragma warning(disable : 4995) // name was marked as #pragma deprecated

_EXPORT_STD using _CSTD size_t;
_EXPORT_STD using _CSTD memchr;
_EXPORT_STD using _CSTD memcmp;
_EXPORT_STD using _CSTD memcpy;
_EXPORT_STD using _CSTD memmove;
_EXPORT_STD using _CSTD memset;
_EXPORT_STD using _CSTD strcat;
_EXPORT_STD using _CSTD strchr;
_EXPORT_STD using _CSTD strcmp;
_EXPORT_STD using _CSTD strcoll;
_EXPORT_STD using _CSTD strcpy;
_EXPORT_STD using _CSTD strcspn;
_EXPORT_STD using _CSTD strerror;
_EXPORT_STD using _CSTD strlen;
_EXPORT_STD using _CSTD strncat;
_EXPORT_STD using _CSTD strncmp;
_EXPORT_STD using _CSTD strncpy;
_EXPORT_STD using _CSTD strpbrk;
_EXPORT_STD using _CSTD strrchr;
_EXPORT_STD using _CSTD strspn;
_EXPORT_STD using _CSTD strstr;
_EXPORT_STD using _CSTD strtok;
_EXPORT_STD using _CSTD strxfrm;

#pragma warning(pop)
_STD_END

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)

#endif // _STL_COMPILER_PREPROCESSOR
#endif // _CSTRING_

// cwchar standard header (core)

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#ifndef _CWCHAR_
#define _CWCHAR_
#if _STL_COMPILER_PREPROCESSOR


//
// wchar.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// All of the types, macros, and function declarations for all wide-character
// related functionality.  Most of the functionality is in the #included
// <corecrt_wxxxx.h> headers, which are also #included by other public headers.
//
#pragma once
#ifndef _INC_WCHAR // include guard for 3rd party interop
#define _INC_WCHAR

//
// corecrt_wio.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// This file declares the wide character (wchar_t) I/O functionality, shared by
// <io.h> and <wchar.h>.
//
#pragma once

#pragma once
#pragma warning(push)
#pragma warning(disable: _UCRT_DISABLED_WARNINGS)
_UCRT_DISABLE_CLANG_WARNINGS

#define _SH_DENYRW      0x10    // deny read/write mode
#define _SH_DENYWR      0x20    // deny write mode
#define _SH_DENYRD      0x30    // deny read mode
#define _SH_DENYNO      0x40    // deny none mode
#define _SH_SECURE      0x80    // secure mode



#if (defined _CRT_DECLARE_NONSTDC_NAMES && _CRT_DECLARE_NONSTDC_NAMES) || (!defined _CRT_DECLARE_NONSTDC_NAMES && !__STDC__)
#define SH_DENYRW _SH_DENYRW
#define SH_DENYWR _SH_DENYWR
#define SH_DENYRD _SH_DENYRD
#define SH_DENYNO _SH_DENYNO
#endif

_UCRT_RESTORE_CLANG_WARNINGS
#pragma warning(pop) // _UCRT_DISABLED_WARNINGS


#pragma warning(push)
#pragma warning(disable: _UCRT_DISABLED_WARNINGS)
_UCRT_DISABLE_CLANG_WARNINGS

_CRT_BEGIN_C_HEADER

//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Types
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#ifdef _USE_32BIT_TIME_T
#define _wfinddata_t    _wfinddata32_t
#define _wfinddatai64_t _wfinddata32i64_t
#else
#define _wfinddata_t    _wfinddata64i32_t
#define _wfinddatai64_t _wfinddata64_t
#endif

typedef unsigned long _fsize_t;

struct _wfinddata32_t
{
    unsigned   attrib;
    __time32_t time_create;    // -1 for FAT file systems
    __time32_t time_access;    // -1 for FAT file systems
    __time32_t time_write;
    _fsize_t   size;
    wchar_t    name[260];
};

struct _wfinddata32i64_t
{
    unsigned   attrib;
    __time32_t time_create;    // -1 for FAT file systems
    __time32_t time_access;    // -1 for FAT file systems
    __time32_t time_write;
    __int64    size;
    wchar_t    name[260];
};

struct _wfinddata64i32_t
{
    unsigned   attrib;
    __time64_t time_create;    // -1 for FAT file systems
    __time64_t time_access;    // -1 for FAT file systems
    __time64_t time_write;
    _fsize_t   size;
    wchar_t    name[260];
};

struct _wfinddata64_t
{
    unsigned   attrib;
    __time64_t time_create;    // -1 for FAT file systems
    __time64_t time_access;    // -1 for FAT file systems
    __time64_t time_write;
    __int64    size;
    wchar_t    name[260];
};



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Functions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#ifdef _USE_32BIT_TIME_T
#define _wfindfirst     _wfindfirst32
#define _wfindnext      _wfindnext32
#define _wfindfirsti64  _wfindfirst32i64
#define _wfindnexti64   _wfindnext32i64
#else
#define _wfindfirst     _wfindfirst64i32
#define _wfindnext      _wfindnext64i32
#define _wfindfirsti64  _wfindfirst64
#define _wfindnexti64   _wfindnext64
#endif

_Check_return_
_ACRTIMP int __cdecl _waccess(
    _In_z_ wchar_t const* _FileName,
    _In_   int            _AccessMode
);

_Check_return_wat_
_ACRTIMP errno_t __cdecl _waccess_s(
    _In_z_ wchar_t const* _FileName,
    _In_   int            _AccessMode
);

_Check_return_
_ACRTIMP int __cdecl _wchmod(
    _In_z_ wchar_t const* _FileName,
    _In_   int            _Mode
);

_Check_return_ _CRT_INSECURE_DEPRECATE(_wsopen_s)
_ACRTIMP int __cdecl _wcreat(
    _In_z_ wchar_t const* _FileName,
    _In_   int            _PermissionMode
);

_Success_(return != -1)
_Check_return_
_ACRTIMP intptr_t __cdecl _wfindfirst32(
    _In_z_ wchar_t const* _FileName,
    _Out_  struct _wfinddata32_t* _FindData
);

_Success_(return != -1)
_Check_return_
_ACRTIMP int __cdecl _wfindnext32(
    _In_  intptr_t               _FindHandle,
    _Out_ struct _wfinddata32_t* _FindData
);

_ACRTIMP int __cdecl _wunlink(
    _In_z_ wchar_t const* _FileName
);

_Check_return_
_ACRTIMP int __cdecl _wrename(
    _In_z_ wchar_t const* _OldFileName,
    _In_z_ wchar_t const* _NewFileName
);

_ACRTIMP errno_t __cdecl _wmktemp_s(
    _Inout_updates_z_(_SizeInWords) wchar_t* _TemplateName,
    _In_                            size_t   _SizeInWords
);

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(
    errno_t, _wmktemp_s,
    wchar_t, _TemplateName
)

_Success_(return != 0)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0(
    wchar_t*, __RETURN_POLICY_DST, _ACRTIMP, _wmktemp,
    _Inout_z_, wchar_t, _TemplateName
)

_Success_(return != -1)
_Check_return_
_ACRTIMP intptr_t __cdecl _wfindfirst32i64(
    _In_z_ wchar_t const* _FileName,
    _Out_  struct _wfinddata32i64_t* _FindData
);

_Success_(return != -1)
_Check_return_
_ACRTIMP intptr_t __cdecl _wfindfirst64i32(
    _In_z_ wchar_t const* _FileName,
    _Out_  struct _wfinddata64i32_t* _FindData
);

_Success_(return != -1)
_Check_return_
_ACRTIMP intptr_t __cdecl _wfindfirst64(
    _In_z_ wchar_t const* _FileName,
    _Out_  struct _wfinddata64_t* _FindData
);

_Success_(return != -1)
_Check_return_
_ACRTIMP int __cdecl _wfindnext32i64(
    _In_  intptr_t                  _FindHandle,
    _Out_ struct _wfinddata32i64_t* _FindData
);

_Success_(return != -1)
_Check_return_
_ACRTIMP int __cdecl _wfindnext64i32(
    _In_  intptr_t                  _FindHandle,
    _Out_ struct _wfinddata64i32_t* _FindData
);

_Success_(return != -1)
_Check_return_
_ACRTIMP int __cdecl _wfindnext64(
    _In_  intptr_t               _FindHandle,
    _Out_ struct _wfinddata64_t* _FindData
);

_Check_return_wat_
_ACRTIMP errno_t __cdecl _wsopen_s(
    _Out_  int* _FileHandle,
    _In_z_ wchar_t const* _FileName,
    _In_   int            _OpenFlag,
    _In_   int            _ShareFlag,
    _In_   int            _PermissionFlag
);

_ACRTIMP errno_t __cdecl _wsopen_dispatch(
    _In_z_ wchar_t const* _FileName,
    _In_   int            _OFlag,
    _In_   int            _ShFlag,
    _In_   int            _PMode,
    _Out_  int* _PFileHandle,
    _In_   int            _BSecure
);



#if defined __cplusplus

// These functions do not validate pmode; use _wsopen_s instead.
extern "C++" _Check_return_ _CRT_INSECURE_DEPRECATE(_wsopen_s)
inline int __CRTDECL _wopen(
    _In_z_ wchar_t const* _FileName,
    _In_   int            _OFlag,
    _In_   int            _PMode = 0
)
{
    int _FileHandle;
    // Last parameter passed as 0 because we don't want to validate pmode from _open
    errno_t const _Result = _wsopen_dispatch(_FileName, _OFlag, _SH_DENYNO, _PMode, &_FileHandle, 0);
    return _Result ? -1 : _FileHandle;
}

extern "C++" _Check_return_ _CRT_INSECURE_DEPRECATE(_wsopen_s)
inline int __CRTDECL _wsopen(
    _In_z_ wchar_t const* _FileName,
    _In_   int            _OFlag,
    _In_   int            _ShFlag,
    _In_   int            _PMode = 0
)
{
    int _FileHandle;
    // Last parameter passed as 0 because we don't want to validate pmode from _sopen
    errno_t const _Result = _wsopen_dispatch(_FileName, _OFlag, _ShFlag, _PMode, &_FileHandle, 0);
    return _Result ? -1 : _FileHandle;
}


#else

_Check_return_ _CRT_INSECURE_DEPRECATE(_wsopen_s)
_ACRTIMP int __cdecl _wopen(
    _In_z_ wchar_t const* _FileName,
    _In_   int            _OpenFlag,
    ...);

_Check_return_ _CRT_INSECURE_DEPRECATE(_wsopen_s)
_ACRTIMP int __cdecl _wsopen(
    _In_z_ wchar_t const* _FileName,
    _In_   int            _OpenFlag,
    _In_   int            _ShareFlag,
    ...);

#endif

_CRT_END_C_HEADER
_UCRT_RESTORE_CLANG_WARNINGS
#pragma warning(pop) // _UCRT_DISABLED_WARNINGS


//
// corecrt_wtime.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// This file declares the wide character (wchar_t) time functionality, shared
// by <time.h> and <wchar.h>.
//
#pragma once
#pragma warning(push)
#pragma warning(disable: _UCRT_DISABLED_WARNINGS)
_UCRT_DISABLE_CLANG_WARNINGS

_CRT_BEGIN_C_HEADER



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Types
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
struct tm
{
    int tm_sec;   // seconds after the minute - [0, 60] including leap second
    int tm_min;   // minutes after the hour - [0, 59]
    int tm_hour;  // hours since midnight - [0, 23]
    int tm_mday;  // day of the month - [1, 31]
    int tm_mon;   // months since January - [0, 11]
    int tm_year;  // years since 1900
    int tm_wday;  // days since Sunday - [0, 6]
    int tm_yday;  // days since January 1 - [0, 365]
    int tm_isdst; // daylight savings time flag
};


//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Wide String Time Functions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
_Check_return_ _CRT_INSECURE_DEPRECATE(_wasctime_s)
_Success_(return != 0)
_Ret_writes_z_(26)
_ACRTIMP wchar_t* __cdecl _wasctime(
    _In_ struct tm const* _Tm
);

_Success_(return == 0)
_Check_return_wat_
_ACRTIMP errno_t __cdecl _wasctime_s(
    _Out_writes_z_(_SizeInWords) _Post_readable_size_(26) wchar_t* _Buffer,
    _In_range_(>= , 26)                                     size_t           _SizeInWords,
    _In_                                                  struct tm const* _Tm
);

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(
    _Success_(return == 0)
    errno_t, _wasctime_s,
    _Post_readable_size_(26) wchar_t, _Buffer,
    _In_                     struct tm const*, _Time
)

_Success_(return > 0)
_Check_return_wat_
_ACRTIMP size_t __cdecl wcsftime(
    _Out_writes_z_(_SizeInWords)  wchar_t* _Buffer,
    _In_                          size_t           _SizeInWords,
    _In_z_                        wchar_t const* _Format,
    _In_                          struct tm const* _Tm
);

_Success_(return > 0)
_Check_return_wat_
_ACRTIMP size_t __cdecl _wcsftime_l(
    _Out_writes_z_(_SizeInWords)  wchar_t* _Buffer,
    _In_                          size_t           _SizeInWords,
    _In_z_                        wchar_t const* _Format,
    _In_                          struct tm const* _Tm,
    _In_opt_                      _locale_t        _Locale
);

_Success_(return != 0)
_Check_return_ _CRT_INSECURE_DEPRECATE(_wctime32_s)
_ACRTIMP wchar_t* __cdecl _wctime32(
    _In_ __time32_t const* _Time
);

_Check_return_wat_
_ACRTIMP errno_t __cdecl _wctime32_s(
    _Out_writes_z_(_SizeInWords) _Post_readable_size_(26) wchar_t* _Buffer,
    _In_  _In_range_(>= , 26)                              size_t            _SizeInWords,
    _In_                                                  __time32_t const* _Time
);

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(
    errno_t, _wctime32_s,
    _Post_readable_size_(26) wchar_t, _Buffer,
    _In_                     __time32_t const*, _Time
)

_Success_(return != 0)
_Ret_writes_z_(26)
_Check_return_ _CRT_INSECURE_DEPRECATE(_wctime64_s)
_ACRTIMP wchar_t* __cdecl _wctime64(
    _In_ __time64_t const* _Time
);

_Check_return_wat_
_ACRTIMP errno_t __cdecl _wctime64_s(
    _Out_writes_z_(_SizeInWords) _Post_readable_size_(26) wchar_t* _Buffer,
    _In_  _In_range_(>= , 26)                              size_t            _SizeInWords,
    _In_                                                  __time64_t const* _Time);

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(
    errno_t, _wctime64_s,
    _Post_readable_size_(26) wchar_t, _Buffer,
    _In_                     __time64_t const*, _Time
)

_Check_return_wat_
_ACRTIMP errno_t __cdecl _wstrdate_s(
    _Out_writes_z_(_SizeInWords) _When_(_SizeInWords >= 9, _Post_readable_size_(9)) wchar_t* _Buffer,
    _In_                                                                           size_t   _SizeInWords
);

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(
    errno_t, _wstrdate_s,
    _Post_readable_size_(9) wchar_t, _Buffer
)

__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0(
    _Success_(return != 0) _Ret_writes_z_(9) wchar_t*, __RETURN_POLICY_DST, _ACRTIMP, _wstrdate,
    _Out_writes_z_(9), wchar_t, _Buffer
)

_Check_return_wat_
_ACRTIMP errno_t __cdecl _wstrtime_s(
    _Out_writes_z_(_SizeInWords) _When_(_SizeInWords >= 9, _Post_readable_size_(9)) wchar_t* _Buffer,
    _In_                                                                           size_t   _SizeInWords
);

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(
    errno_t, _wstrtime_s,
    _Post_readable_size_(9) wchar_t, _Buffer
)

__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0(
    _Success_(return != 0) _Ret_writes_z_(9) wchar_t*, __RETURN_POLICY_DST, _ACRTIMP, _wstrtime,
    _Out_writes_z_(9), wchar_t, _Buffer
)



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Inline Definitions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#if !defined RC_INVOKED && !defined __midl && !defined _INC_WTIME_INL && !defined _CRT_NO_TIME_T
#ifdef _USE_32BIT_TIME_T

_Check_return_
static __inline wchar_t* __CRTDECL _wctime(
    _In_ time_t const* const _Time
)
{
    return _wctime32(_Time);
}

_Check_return_wat_
static __inline errno_t __CRTDECL _wctime_s(
    _Pre_notnull_ _Post_z_ _Out_writes_z_(_SizeInWords) wchar_t* const _Buffer,
    _In_                                                size_t        const _SizeInWords,
    _In_                                                time_t const* const _Time)
{
    return _wctime32_s(_Buffer, _SizeInWords, _Time);
}

#else // ^^^ _USE_32BIT_TIME_T ^^^ // vvv !_USE_32BIT_TIME_T vvv //

_Check_return_
static __inline wchar_t* __CRTDECL _wctime(
    _In_ time_t const* const _Time)
{
    return _wctime64(_Time);
}

_Check_return_wat_
static __inline errno_t __CRTDECL _wctime_s(
    _Pre_notnull_ _Post_z_ _Out_writes_z_(_SizeInWords) wchar_t* const _Buffer,
    _In_                                                size_t        const _SizeInWords,
    _In_                                                time_t const* const _Time
)
{
    return _wctime64_s(_Buffer, _SizeInWords, _Time);
}

#endif // !_USE_32BIT_TIME_T
#endif

_CRT_END_C_HEADER
_UCRT_RESTORE_CLANG_WARNINGS
#pragma warning(pop) // _UCRT_DISABLED_WARNINGS



#pragma warning(push)
#pragma warning(disable: _UCRT_DISABLED_WARNINGS)
_UCRT_DISABLE_CLANG_WARNINGS

_CRT_BEGIN_C_HEADER



#define WCHAR_MIN 0x0000
#define WCHAR_MAX 0xffff



typedef wchar_t _Wint_t;



#if _CRT_FUNCTIONS_REQUIRED

_Check_return_opt_ _Success_(return != 0) _Ret_z_
_ACRTIMP wchar_t* __cdecl _wsetlocale(
    _In_       int            _Category,
    _In_opt_z_ wchar_t const* _Locale
);

_Check_return_opt_
_ACRTIMP _locale_t __cdecl _wcreate_locale(
    _In_   int            _Category,
    _In_z_ wchar_t const* _Locale
);



_ACRTIMP wint_t __cdecl btowc(
    _In_ int _Ch
);

_ACRTIMP size_t __cdecl mbrlen(
    _In_reads_bytes_opt_(_SizeInBytes) _Pre_opt_z_ char const* _Ch,
    _In_                                           size_t      _SizeInBytes,
    _Inout_                                        mbstate_t * _State
);

_ACRTIMP size_t __cdecl mbrtowc(
    _Pre_maybenull_ _Post_z_                       wchar_t* _DstCh,
    _In_reads_bytes_opt_(_SizeInBytes) _Pre_opt_z_ char const* _SrcCh,
    _In_                                           size_t      _SizeInBytes,
    _Inout_                                        mbstate_t * _State
);

_Success_(return == 0)
_ACRTIMP errno_t __cdecl mbsrtowcs_s(
    _Out_opt_                         size_t * _Retval,
    _Out_writes_opt_z_(_Size)         wchar_t* _Dst,
    _In_                              size_t       _Size,
    _Deref_pre_opt_z_                 char const** _PSrc,
    _In_                              size_t       _N,
    _Inout_                           mbstate_t * _State
);

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_3(
    _Success_(return == 0)
    errno_t, mbsrtowcs_s,
    _Out_opt_                         size_t*, _Retval,
    _Post_z_                          wchar_t, _Dest,
    _Inout_ _Deref_prepost_opt_valid_ char const**, _PSource,
    _In_                              size_t, _Count,
    _Inout_                           mbstate_t*, _State
)

__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_SIZE(
    _Success_(return == 0) _ACRTIMP, mbsrtowcs,
    _Out_writes_opt_z_(_Count), wchar_t, _Dest,
    _Deref_pre_opt_z_                 char const**, _PSrc,
    _In_                              size_t, _Count,
    _Inout_                           mbstate_t*, _State
)

_Success_(return == 0)
_ACRTIMP errno_t __cdecl wcrtomb_s(
    _Out_opt_                        size_t * _Retval,
    _Out_writes_opt_z_(_SizeInBytes) char* _Dst,
    _In_                             size_t     _SizeInBytes,
    _In_                             wchar_t    _Ch,
    _Inout_opt_                      mbstate_t * _State
);

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_2(
    _Success_(return == 0)
    errno_t, wcrtomb_s,
    _Out_opt_                 size_t*, _Retval,
    _Out_writes_opt_z_(_Size) char, _Dest,
    _In_                      wchar_t, _Source,
    _Inout_opt_               mbstate_t*, _State
)

__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_SIZE(
    _ACRTIMP, wcrtomb,
    _Pre_maybenull_ _Post_z_, char, _Dest,
    _In_                      wchar_t, _Source,
    _Inout_opt_              mbstate_t*, _State
)

_Success_(return == 0)
_ACRTIMP errno_t __cdecl wcsrtombs_s(
    _Out_opt_                                         size_t * _Retval,
    _Out_writes_bytes_to_opt_(_SizeInBytes, *_Retval) char* _Dst,
    _In_                                              size_t          _SizeInBytes,
    _Inout_ _Deref_prepost_z_                         wchar_t const** _Src,
    _In_                                              size_t          _Size,
    _Inout_opt_                                       mbstate_t * _State
);

__DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_3(
    _Success_(return == 0)
    errno_t, wcsrtombs_s,
    _Out_opt_                 size_t*, _Retval,
    _Out_writes_opt_z_(_Size) char, _Dest,
    _Inout_ _Deref_prepost_z_ wchar_t const**, _PSrc,
    _In_                      size_t, _Count,
    _Inout_opt_               mbstate_t*, _State
)

__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_SIZE(
    _ACRTIMP, wcsrtombs,
    _Pre_maybenull_ _Post_z_, char, _Dest,
    _Inout_ _Deref_prepost_z_ wchar_t const**, _PSource,
    _In_                      size_t, _Count,
    _Inout_opt_               mbstate_t*, _State
)

_ACRTIMP int __cdecl wctob(
    _In_ wint_t _WCh
);

#if __STDC_WANT_SECURE_LIB__

_Success_(return == 0)
errno_t __CRTDECL wmemcpy_s(
    _Out_writes_to_opt_(_N1, _N) wchar_t* _S1,
    _In_                         rsize_t        _N1,
    _In_reads_opt_(_N)           wchar_t const* _S2,
    _In_                         rsize_t        _N
);

_Success_(return == 0)
errno_t __CRTDECL wmemmove_s(
    _Out_writes_to_opt_(_N1, _N) wchar_t* _S1,
    _In_                         rsize_t        _N1,
    _In_reads_opt_(_N)           wchar_t const* _S2,
    _In_                         rsize_t        _N
);

#endif // __STDC_WANT_SECURE_LIB__

__inline int __CRTDECL fwide(
    _In_opt_ FILE * _F,
    _In_     int   _M
)
{
    _CRT_UNUSED(_F);
    return (_M);
}

__inline int __CRTDECL mbsinit(
    _In_opt_ mbstate_t const* _P
)
{
    return _P == NULL || _P->_Wchar == 0;
}

__inline wchar_t _CONST_RETURN* __CRTDECL wmemchr(
    _In_reads_(_N) wchar_t const* _S,
    _In_           wchar_t        _C,
    _In_           size_t         _N
)
{
    for (; 0 < _N; ++_S, --_N)
        if (*_S == _C)
            return (wchar_t _CONST_RETURN*)_S;

    return 0;
}

__inline int __CRTDECL wmemcmp(
    _In_reads_(_N) wchar_t const* _S1,
    _In_reads_(_N) wchar_t const* _S2,
    _In_           size_t         _N
)
{
    for (; 0 < _N; ++_S1, ++_S2, --_N)
        if (*_S1 != *_S2)
            return *_S1 < *_S2 ? -1 : 1;

    return 0;
}

_Post_equal_to_(_S1)
_At_buffer_(_S1, _Iter_, _N, _Post_satisfies_(_S1[_Iter_] == _S2[_Iter_]))
__inline _CRT_INSECURE_DEPRECATE_MEMORY(wmemcpy_s)
wchar_t* __CRTDECL wmemcpy(
    _Out_writes_all_(_N) wchar_t* _S1,
    _In_reads_(_N)       wchar_t const* _S2,
    _In_                 size_t         _N
)
{
#pragma warning(suppress: 6386) // Buffer overrun
    return (wchar_t*)memcpy(_S1, _S2, _N * sizeof(wchar_t));
}

__inline _CRT_INSECURE_DEPRECATE_MEMORY(wmemmove_s)
wchar_t* __CRTDECL wmemmove(
    _Out_writes_all_opt_(_N) wchar_t* _S1,
    _In_reads_opt_(_N)       wchar_t const* _S2,
    _In_                     size_t         _N
)
{
#pragma warning(suppress: 6386) // Buffer overrun
    return (wchar_t*)memmove(_S1, _S2, _N * sizeof(wchar_t));
}

_Post_equal_to_(_S)
_At_buffer_(_S, _Iter_, _N, _Post_satisfies_(_S[_Iter_] == _C))
__inline wchar_t* __CRTDECL wmemset(
    _Out_writes_all_(_N) wchar_t* _S,
    _In_                 wchar_t  _C,
    _In_                 size_t   _N
)
{
    wchar_t* _Su = _S;
    for (; 0 < _N; ++_Su, --_N)
    {
        *_Su = _C;
    }
    return _S;
}

#ifdef __cplusplus

extern "C++" inline wchar_t* __CRTDECL wmemchr(
    _In_reads_(_N) wchar_t* _S,
    _In_           wchar_t  _C,
    _In_           size_t   _N
)
{
    wchar_t const* const _SC = _S;
    return const_cast<wchar_t*>(wmemchr(_SC, _C, _N));
}

#endif // __cplusplus

#endif // _CRT_FUNCTIONS_REQUIRED


_CRT_END_C_HEADER
_UCRT_RESTORE_CLANG_WARNINGS
#pragma warning(pop) // _UCRT_DISABLED_WARNINGS
#endif // _INC_WCHAR


#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_EXTERN_CXX_WORKAROUND
using _Mbstatet = mbstate_t;
_END_EXTERN_CXX_WORKAROUND

_STD_BEGIN
#pragma warning(push)
#pragma warning(disable : 4995) // name was marked as #pragma deprecated

using _CSTD _Mbstatet;

_EXPORT_STD using _CSTD mbstate_t;
_EXPORT_STD using _CSTD size_t;
_EXPORT_STD using _CSTD tm;
_EXPORT_STD using _CSTD wint_t;

_EXPORT_STD using _CSTD btowc;
_EXPORT_STD using _CSTD fgetwc;
_EXPORT_STD using _CSTD fgetws;
_EXPORT_STD using _CSTD fputwc;
_EXPORT_STD using _CSTD fputws;
_EXPORT_STD using _CSTD fwide;
_EXPORT_STD using _CSTD fwprintf;
_EXPORT_STD using _CSTD fwscanf;
_EXPORT_STD using _CSTD getwc;
_EXPORT_STD using _CSTD getwchar;
_EXPORT_STD using _CSTD mbrlen;
_EXPORT_STD using _CSTD mbrtowc;
_EXPORT_STD using _CSTD mbsrtowcs;
_EXPORT_STD using _CSTD mbsinit;
_EXPORT_STD using _CSTD putwc;
_EXPORT_STD using _CSTD putwchar;
_EXPORT_STD using _CSTD swprintf;
_EXPORT_STD using _CSTD swscanf;
_EXPORT_STD using _CSTD ungetwc;
_EXPORT_STD using _CSTD vfwprintf;
_EXPORT_STD using _CSTD vswprintf;
_EXPORT_STD using _CSTD vwprintf;
_EXPORT_STD using _CSTD wcrtomb;
_EXPORT_STD using _CSTD wprintf;
_EXPORT_STD using _CSTD wscanf;
_EXPORT_STD using _CSTD wcsrtombs;
_EXPORT_STD using _CSTD wcstol;
_EXPORT_STD using _CSTD wcscat;
_EXPORT_STD using _CSTD wcschr;
_EXPORT_STD using _CSTD wcscmp;
_EXPORT_STD using _CSTD wcscoll;
_EXPORT_STD using _CSTD wcscpy;
_EXPORT_STD using _CSTD wcscspn;
_EXPORT_STD using _CSTD wcslen;
_EXPORT_STD using _CSTD wcsncat;
_EXPORT_STD using _CSTD wcsncmp;
_EXPORT_STD using _CSTD wcsncpy;
_EXPORT_STD using _CSTD wcspbrk;
_EXPORT_STD using _CSTD wcsrchr;
_EXPORT_STD using _CSTD wcsspn;
_EXPORT_STD using _CSTD wcstod;
_EXPORT_STD using _CSTD wcstoul;
_EXPORT_STD using _CSTD wcsstr;
_EXPORT_STD using _CSTD wcstok;
_EXPORT_STD using _CSTD wcsxfrm;
_EXPORT_STD using _CSTD wctob;
_EXPORT_STD using _CSTD wmemchr;
_EXPORT_STD using _CSTD wmemcmp;
_EXPORT_STD using _CSTD wmemcpy;
_EXPORT_STD using _CSTD wmemmove;
_EXPORT_STD using _CSTD wmemset;
_EXPORT_STD using _CSTD wcsftime;

_EXPORT_STD using _CSTD vfwscanf;
_EXPORT_STD using _CSTD vswscanf;
_EXPORT_STD using _CSTD vwscanf;
_EXPORT_STD using _CSTD wcstof;
_EXPORT_STD using _CSTD wcstold;
_EXPORT_STD using _CSTD wcstoll;
_EXPORT_STD using _CSTD wcstoull;

#pragma warning(pop)
_STD_END

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)

#endif // _STL_COMPILER_PREPROCESSOR
#endif // _CWCHAR_



#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_STD_BEGIN

#if _HAS_EXCEPTIONS
#define _TRY_IO_BEGIN _TRY_BEGIN // begin try block

#define _CATCH_IO_END                                                          \
    _CATCH_ALL /* catch block for _Myios */                                    \
        _Myios::setstate(ios_base::badbit, true); /* set badbit and rethrow */ \
    _CATCH_END

#define _CATCH_IO_(xtype, x)                                             \
    _CATCH_ALL /* catch block for basic_ios x */                         \
        (x)                                                              \
            .setstate(xtype::badbit, true); /* set badbit and rethrow */ \
    _CATCH_END

#else // ^^^ _HAS_EXCEPTIONS / !_HAS_EXCEPTIONS vvv
#define _TRY_IO_BEGIN        { // begin try block
#define _CATCH_IO_END        } // catch block for _Myios
#define _CATCH_IO_(xtype, x) } // catch block for basic_ios x
#endif // ^^^ !_HAS_EXCEPTIONS ^^^

// from <streambuf>
_EXPORT_STD using streamoff = long long;
_EXPORT_STD using streamsize = long long;

_EXPORT_STD template <class _Statetype>
class fpos { // store arbitrary file position
public:
    /* implicit */ fpos(streamoff _Off = 0) : _Myoff(_Off), _Fpos(0), _Mystate() {}

    fpos(_Statetype _State, fpos_t _Fileposition) : _Myoff(_Fileposition), _Fpos(0), _Mystate(_State) {}

    _NODISCARD _Statetype state() const {
        return _Mystate;
    }

    void state(_Statetype _State) {
        _Mystate = _State;
    }

    operator streamoff() const noexcept /* strengthened */ {
        // TRANSITION, ABI: We currently always set _Fpos to 0 but older .objs containing old
        // basic_filebuf would set _Fpos.
        return _Myoff + _Fpos;
    }

#ifndef _REMOVE_FPOS_SEEKPOS
    _DEPRECATE_FPOS_SEEKPOS fpos_t seekpos() const noexcept {
        return {};
    }
#endif // !defined(_REMOVE_FPOS_SEEKPOS)

    _NODISCARD streamoff operator-(const fpos& _Right) const noexcept /* strengthened */ {
        return static_cast<streamoff>(*this) - static_cast<streamoff>(_Right);
    }

    fpos& operator+=(streamoff _Off) noexcept /* strengthened */ { // add offset
        _Myoff += _Off;
        return *this;
    }

    fpos& operator-=(streamoff _Off) noexcept /* strengthened */ { // subtract offset
        _Myoff -= _Off;
        return *this;
    }

    _NODISCARD fpos operator+(streamoff _Off) const {
        fpos _Tmp = *this;
        _Tmp += _Off;
        return _Tmp;
    }

    _NODISCARD fpos operator-(streamoff _Off) const {
        fpos _Tmp = *this;
        _Tmp -= _Off;
        return _Tmp;
    }

    _NODISCARD bool operator==(const fpos& _Right) const noexcept /* strengthened */ {
        return static_cast<streamoff>(*this) == static_cast<streamoff>(_Right);
    }

    template <class _Int, enable_if_t<is_integral_v<_Int>, int> = 0>
    _NODISCARD_FRIEND bool operator==(const fpos& _Left, const _Int _Right) noexcept /* strengthened */ {
        return static_cast<streamoff>(_Left) == _Right;
    }

#if !_HAS_CXX20
    template <class _Int, enable_if_t<is_integral_v<_Int>, int> = 0>
    _NODISCARD_FRIEND bool operator==(const _Int _Left, const fpos& _Right) noexcept /* strengthened */ {
        return _Left == static_cast<streamoff>(_Right);
    }

    _NODISCARD bool operator!=(const fpos& _Right) const noexcept /* strengthened */ {
        return static_cast<streamoff>(*this) != static_cast<streamoff>(_Right);
    }

    template <class _Int, enable_if_t<is_integral_v<_Int>, int> = 0>
    _NODISCARD_FRIEND bool operator!=(const fpos& _Left, const _Int _Right) noexcept /* strengthened */ {
        return static_cast<streamoff>(_Left) != _Right;
    }

    template <class _Int, enable_if_t<is_integral_v<_Int>, int> = 0>
    _NODISCARD_FRIEND bool operator!=(const _Int _Left, const fpos& _Right) noexcept /* strengthened */ {
        return _Left != static_cast<streamoff>(_Right);
    }
#endif // !_HAS_CXX20

private:
    streamoff _Myoff; // stream offset
    fpos_t _Fpos; // TRANSITION, ABI. C file position, not currently used
    _Statetype _Mystate; // current conversion state
};

_EXPORT_STD using streampos = fpos<_Mbstatet>;
_EXPORT_STD using wstreampos = streampos;
#ifdef __cpp_lib_char8_t
_EXPORT_STD using u8streampos = streampos;
#endif // defined(__cpp_lib_char8_t)
_EXPORT_STD using u16streampos = streampos;
_EXPORT_STD using u32streampos = streampos;

_EXPORT_STD extern "C++" class locale;
_EXPORT_STD template <class _Facet>
const _Facet& __CRTDECL use_facet(const locale&);

_EXPORT_STD template <class _Elem>
struct char_traits;
template <>
struct char_traits<char>;
#ifdef __cpp_char8_t
template <>
struct char_traits<char8_t>;
#endif // defined(__cpp_char8_t)
template <>
struct char_traits<char16_t>;
template <>
struct char_traits<char32_t>;
template <>
struct char_traits<wchar_t>;
#ifdef _CRTBLD
template <>
struct char_traits<unsigned short>;
#endif // defined(_CRTBLD)

_EXPORT_STD template <class _Ty>
class allocator;
_EXPORT_STD extern "C++" class ios_base;
_EXPORT_STD extern "C++" template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_ios;
_EXPORT_STD template <class _Elem, class _Traits = char_traits<_Elem>>
class istreambuf_iterator;
_EXPORT_STD template <class _Elem, class _Traits = char_traits<_Elem>>
class ostreambuf_iterator;
_EXPORT_STD extern "C++" template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_streambuf;

#pragma vtordisp(push, 2) // compiler bug workaround
_EXPORT_STD extern "C++" template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_istream;
_EXPORT_STD extern "C++" template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_ostream;
#pragma vtordisp(pop) // compiler bug workaround

_EXPORT_STD extern "C++" template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_iostream;
_EXPORT_STD template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
class basic_stringbuf;
_EXPORT_STD template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
class basic_istringstream;
_EXPORT_STD template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
class basic_ostringstream;
_EXPORT_STD template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
class basic_stringstream;
#if _HAS_CXX23
_EXPORT_STD template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_spanbuf;
_EXPORT_STD template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_ispanstream;
_EXPORT_STD template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_ospanstream;
_EXPORT_STD template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_spanstream;
#endif // _HAS_CXX23
_EXPORT_STD template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_filebuf;
_EXPORT_STD template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_ifstream;
_EXPORT_STD template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_ofstream;
_EXPORT_STD template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_fstream;
#if _HAS_CXX20
template <class _Elem, class _Traits = char_traits<_Elem>>
class _Basic_syncbuf_impl;
_EXPORT_STD template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
class basic_syncbuf;
_EXPORT_STD template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
class basic_osyncstream;
#endif // _HAS_CXX20

#if defined(_DLL_CPPLIB)
_EXPORT_STD extern "C++" template <class _Elem, class _InIt>
class num_get;
_EXPORT_STD extern "C++" template <class _Elem, class _OutIt>
class num_put;
_EXPORT_STD template <class _Elem>
class collate;
#endif // defined(_DLL_CPPLIB)

_EXPORT_STD using ios = basic_ios<char, char_traits<char>>;
_EXPORT_STD using streambuf = basic_streambuf<char, char_traits<char>>;
_EXPORT_STD using istream = basic_istream<char, char_traits<char>>;
_EXPORT_STD using ostream = basic_ostream<char, char_traits<char>>;
_EXPORT_STD using iostream = basic_iostream<char, char_traits<char>>;
_EXPORT_STD using stringbuf = basic_stringbuf<char, char_traits<char>, allocator<char>>;
_EXPORT_STD using istringstream = basic_istringstream<char, char_traits<char>, allocator<char>>;
_EXPORT_STD using ostringstream = basic_ostringstream<char, char_traits<char>, allocator<char>>;
_EXPORT_STD using stringstream = basic_stringstream<char, char_traits<char>, allocator<char>>;
_EXPORT_STD using filebuf = basic_filebuf<char, char_traits<char>>;
_EXPORT_STD using ifstream = basic_ifstream<char, char_traits<char>>;
_EXPORT_STD using ofstream = basic_ofstream<char, char_traits<char>>;
_EXPORT_STD using fstream = basic_fstream<char, char_traits<char>>;
#if _HAS_CXX20
_EXPORT_STD using syncbuf = basic_syncbuf<char>;
_EXPORT_STD using osyncstream = basic_osyncstream<char>;
#endif // _HAS_CXX20
#if _HAS_CXX23
_EXPORT_STD using spanbuf = basic_spanbuf<char>;
_EXPORT_STD using ispanstream = basic_ispanstream<char>;
_EXPORT_STD using ospanstream = basic_ospanstream<char>;
_EXPORT_STD using spanstream = basic_spanstream<char>;
#endif // _HAS_CXX23

_EXPORT_STD using wios = basic_ios<wchar_t, char_traits<wchar_t>>;
_EXPORT_STD using wstreambuf = basic_streambuf<wchar_t, char_traits<wchar_t>>;
_EXPORT_STD using wistream = basic_istream<wchar_t, char_traits<wchar_t>>;
_EXPORT_STD using wostream = basic_ostream<wchar_t, char_traits<wchar_t>>;
_EXPORT_STD using wiostream = basic_iostream<wchar_t, char_traits<wchar_t>>;
_EXPORT_STD using wstringbuf = basic_stringbuf<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>;
_EXPORT_STD using wistringstream = basic_istringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>;
_EXPORT_STD using wostringstream = basic_ostringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>;
_EXPORT_STD using wstringstream = basic_stringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>;
_EXPORT_STD using wfilebuf = basic_filebuf<wchar_t, char_traits<wchar_t>>;
_EXPORT_STD using wifstream = basic_ifstream<wchar_t, char_traits<wchar_t>>;
_EXPORT_STD using wofstream = basic_ofstream<wchar_t, char_traits<wchar_t>>;
_EXPORT_STD using wfstream = basic_fstream<wchar_t, char_traits<wchar_t>>;
#if _HAS_CXX20
_EXPORT_STD using wsyncbuf = basic_syncbuf<wchar_t>;
_EXPORT_STD using wosyncstream = basic_osyncstream<wchar_t>;
#endif // _HAS_CXX20
#if _HAS_CXX23
_EXPORT_STD using wspanbuf = basic_spanbuf<wchar_t>;
_EXPORT_STD using wispanstream = basic_ispanstream<wchar_t>;
_EXPORT_STD using wospanstream = basic_ospanstream<wchar_t>;
_EXPORT_STD using wspanstream = basic_spanstream<wchar_t>;
#endif // _HAS_CXX23

_STD_END

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _IOSFWD_

#define _XUTILITY_
#if _STL_COMPILER_PREPROCESSOR
#ifndef __MSVC_ITER_CORE_HPP
#define __MSVC_ITER_CORE_HPP
#if _STL_COMPILER_PREPROCESSOR
// utility standard header (core)

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#ifndef _UTILITY_
#define _UTILITY_
#if _STL_COMPILER_PREPROCESSOR
// initializer_list standard header (core)

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#ifndef _INITIALIZER_LIST_
#define _INITIALIZER_LIST_
#if _STL_COMPILER_PREPROCESSOR
// cstddef standard header (core)

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#ifndef _CSTDDEF_
#define _CSTDDEF_
#if _STL_COMPILER_PREPROCESSOR



#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

// TRANSITION, non-_Ugly attribute tokens
#pragma push_macro("msvc")
#pragma push_macro("intrinsic")
#undef msvc
#undef intrinsic

_STD_BEGIN
_EXPORT_STD using _CSTD ptrdiff_t;
_EXPORT_STD using _CSTD size_t;
_EXPORT_STD using max_align_t = double; // most aligned type
_EXPORT_STD using nullptr_t = decltype(nullptr);

#ifdef __cpp_lib_byte
_EXPORT_STD enum class byte : unsigned char {};

_EXPORT_STD template <class _IntType, enable_if_t<is_integral_v<_IntType>, int> = 0>
_NODISCARD constexpr byte operator<<(const byte _Arg, const _IntType _Shift) noexcept {
    // every static_cast is intentional
    return static_cast<byte>(static_cast<unsigned char>(static_cast<unsigned int>(_Arg) << _Shift));
}

_EXPORT_STD template <class _IntType, enable_if_t<is_integral_v<_IntType>, int> = 0>
_NODISCARD constexpr byte operator>>(const byte _Arg, const _IntType _Shift) noexcept {
    // every static_cast is intentional
    return static_cast<byte>(static_cast<unsigned char>(static_cast<unsigned int>(_Arg) >> _Shift));
}

_EXPORT_STD _NODISCARD constexpr byte operator|(const byte _Left, const byte _Right) noexcept {
    // every static_cast is intentional
    return static_cast<byte>(
        static_cast<unsigned char>(static_cast<unsigned int>(_Left) | static_cast<unsigned int>(_Right)));
}

_EXPORT_STD _NODISCARD constexpr byte operator&(const byte _Left, const byte _Right) noexcept {
    // every static_cast is intentional
    return static_cast<byte>(
        static_cast<unsigned char>(static_cast<unsigned int>(_Left) & static_cast<unsigned int>(_Right)));
}

_EXPORT_STD _NODISCARD constexpr byte operator^(const byte _Left, const byte _Right) noexcept {
    // every static_cast is intentional
    return static_cast<byte>(
        static_cast<unsigned char>(static_cast<unsigned int>(_Left) ^ static_cast<unsigned int>(_Right)));
}

_EXPORT_STD _NODISCARD constexpr byte operator~(const byte _Arg) noexcept {
    // every static_cast is intentional
    return static_cast<byte>(static_cast<unsigned char>(~static_cast<unsigned int>(_Arg)));
}

_EXPORT_STD template <class _IntType, enable_if_t<is_integral_v<_IntType>, int> = 0>
constexpr byte& operator<<=(byte& _Arg, const _IntType _Shift) noexcept {
    return _Arg = _Arg << _Shift;
}

_EXPORT_STD template <class _IntType, enable_if_t<is_integral_v<_IntType>, int> = 0>
constexpr byte& operator>>=(byte& _Arg, const _IntType _Shift) noexcept {
    return _Arg = _Arg >> _Shift;
}

_EXPORT_STD constexpr byte& operator|=(byte& _Left, const byte _Right) noexcept {
    return _Left = _Left | _Right;
}

_EXPORT_STD constexpr byte& operator&=(byte& _Left, const byte _Right) noexcept {
    return _Left = _Left & _Right;
}

_EXPORT_STD constexpr byte& operator^=(byte& _Left, const byte _Right) noexcept {
    return _Left = _Left ^ _Right;
}

_EXPORT_STD template <class _IntType, enable_if_t<is_integral_v<_IntType>, int> = 0>
_NODISCARD _MSVC_INTRINSIC constexpr _IntType to_integer(const byte _Arg) noexcept {
    return static_cast<_IntType>(_Arg);
}
#endif // defined(__cpp_lib_byte)

_STD_END

_EXTERN_CXX_WORKAROUND
using _STD max_align_t; // intentional, for historical reasons
_END_EXTERN_CXX_WORKAROUND

// TRANSITION, non-_Ugly attribute tokens
#pragma pop_macro("intrinsic")
#pragma pop_macro("msvc")

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)

#endif // _STL_COMPILER_PREPROCESSOR
#endif // _CSTDDEF_


#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_STD_BEGIN
_EXPORT_STD template <class _Elem>
class initializer_list {
public:
    using value_type = _Elem;
    using reference = const _Elem&;
    using const_reference = const _Elem&;
    using size_type = size_t;

    using iterator = const _Elem*;
    using const_iterator = const _Elem*;

    constexpr initializer_list() noexcept : _First(nullptr), _Last(nullptr) {}

    constexpr initializer_list(const _Elem* _First_arg, const _Elem* _Last_arg) noexcept
        : _First(_First_arg), _Last(_Last_arg) {}

    _NODISCARD constexpr const _Elem* begin() const noexcept {
        return _First;
    }

    _NODISCARD constexpr const _Elem* end() const noexcept {
        return _Last;
    }

    _NODISCARD constexpr size_t size() const noexcept {
        return static_cast<size_t>(_Last - _First);
    }

private:
    const _Elem* _First;
    const _Elem* _Last;
};

_EXPORT_STD template <class _Elem>
_NODISCARD constexpr const _Elem* begin(initializer_list<_Elem> _Ilist) noexcept {
    return _Ilist.begin();
}

_EXPORT_STD template <class _Elem>
_NODISCARD constexpr const _Elem* end(initializer_list<_Elem> _Ilist) noexcept {
    return _Ilist.end();
}
_STD_END
#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _INITIALIZER_LIST_

// type_traits standard header (core)

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#ifndef _TYPE_TRAITS_
#define _TYPE_TRAITS_
#if _STL_COMPILER_PREPROCESSOR

// cstdint standard header (core)

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#ifndef _CSTDINT_
#define _CSTDINT_
#if _STL_COMPILER_PREPROCESSOR

//
// stdint.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The C Standard Library <stdint.h> header.
//
#pragma once
#define _STDINT

#if _VCRT_COMPILER_PREPROCESSOR

#pragma warning(push)
#pragma warning(disable: _VCRUNTIME_DISABLED_WARNINGS)

typedef signed char        int8_t;
typedef short              int16_t;
typedef int                int32_t;
typedef long long          int64_t;
typedef unsigned char      uint8_t;
typedef unsigned short     uint16_t;
typedef unsigned int       uint32_t;
typedef unsigned long long uint64_t;

typedef signed char        int_least8_t;
typedef short              int_least16_t;
typedef int                int_least32_t;
typedef long long          int_least64_t;
typedef unsigned char      uint_least8_t;
typedef unsigned short     uint_least16_t;
typedef unsigned int       uint_least32_t;
typedef unsigned long long uint_least64_t;

typedef signed char        int_fast8_t;
typedef int                int_fast16_t;
typedef int                int_fast32_t;
typedef long long          int_fast64_t;
typedef unsigned char      uint_fast8_t;
typedef unsigned int       uint_fast16_t;
typedef unsigned int       uint_fast32_t;
typedef unsigned long long uint_fast64_t;

typedef long long          intmax_t;
typedef unsigned long long uintmax_t;

// These macros must exactly match those in the Windows SDK's intsafe.h.
#define INT8_MIN         (-127i8 - 1)
#define INT16_MIN        (-32767i16 - 1)
#define INT32_MIN        (-2147483647i32 - 1)
#define INT64_MIN        (-9223372036854775807i64 - 1)
#define INT8_MAX         127i8
#define INT16_MAX        32767i16
#define INT32_MAX        2147483647i32
#define INT64_MAX        9223372036854775807i64
#define UINT8_MAX        0xffui8
#define UINT16_MAX       0xffffui16
#define UINT32_MAX       0xffffffffui32
#define UINT64_MAX       0xffffffffffffffffui64

#define INT_LEAST8_MIN   INT8_MIN
#define INT_LEAST16_MIN  INT16_MIN
#define INT_LEAST32_MIN  INT32_MIN
#define INT_LEAST64_MIN  INT64_MIN
#define INT_LEAST8_MAX   INT8_MAX
#define INT_LEAST16_MAX  INT16_MAX
#define INT_LEAST32_MAX  INT32_MAX
#define INT_LEAST64_MAX  INT64_MAX
#define UINT_LEAST8_MAX  UINT8_MAX
#define UINT_LEAST16_MAX UINT16_MAX
#define UINT_LEAST32_MAX UINT32_MAX
#define UINT_LEAST64_MAX UINT64_MAX

#define INT_FAST8_MIN    INT8_MIN
#define INT_FAST16_MIN   INT32_MIN
#define INT_FAST32_MIN   INT32_MIN
#define INT_FAST64_MIN   INT64_MIN
#define INT_FAST8_MAX    INT8_MAX
#define INT_FAST16_MAX   INT32_MAX
#define INT_FAST32_MAX   INT32_MAX
#define INT_FAST64_MAX   INT64_MAX
#define UINT_FAST8_MAX   UINT8_MAX
#define UINT_FAST16_MAX  UINT32_MAX
#define UINT_FAST32_MAX  UINT32_MAX
#define UINT_FAST64_MAX  UINT64_MAX

#ifdef _WIN64
#define INTPTR_MIN   INT64_MIN
#define INTPTR_MAX   INT64_MAX
#define UINTPTR_MAX  UINT64_MAX
#else
#define INTPTR_MIN   INT32_MIN
#define INTPTR_MAX   INT32_MAX
#define UINTPTR_MAX  UINT32_MAX
#endif

#define INTMAX_MIN       INT64_MIN
#define INTMAX_MAX       INT64_MAX
#define UINTMAX_MAX      UINT64_MAX

#define PTRDIFF_MIN      INTPTR_MIN
#define PTRDIFF_MAX      INTPTR_MAX

#ifndef SIZE_MAX
    // SIZE_MAX definition must match exactly with limits.h for modules support.
#ifdef _WIN64
#define SIZE_MAX 0xffffffffffffffffui64
#else
#define SIZE_MAX 0xffffffffui32
#endif
#endif

#define SIG_ATOMIC_MIN   INT32_MIN
#define SIG_ATOMIC_MAX   INT32_MAX

#define WCHAR_MIN        0x0000
#define WCHAR_MAX        0xffff

#define WINT_MIN         0x0000
#define WINT_MAX         0xffff

#define INT8_C(x)    (x)
#define INT16_C(x)   (x)
#define INT32_C(x)   (x)
#define INT64_C(x)   (x ## LL)

#define UINT8_C(x)   (x)
#define UINT16_C(x)  (x)
#define UINT32_C(x)  (x ## U)
#define UINT64_C(x)  (x ## ULL)

#define INTMAX_C(x)  INT64_C(x)
#define UINTMAX_C(x) UINT64_C(x)

#pragma warning(pop) // _VCRUNTIME_DISABLED_WARNINGS

#endif // _VCRT_COMPILER_PREPROCESSOR


#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_STD_BEGIN
_EXPORT_STD using _CSTD int8_t;
_EXPORT_STD using _CSTD int16_t;
_EXPORT_STD using _CSTD int32_t;
_EXPORT_STD using _CSTD int64_t;
_EXPORT_STD using _CSTD uint8_t;
_EXPORT_STD using _CSTD uint16_t;
_EXPORT_STD using _CSTD uint32_t;
_EXPORT_STD using _CSTD uint64_t;

_EXPORT_STD using _CSTD int_least8_t;
_EXPORT_STD using _CSTD int_least16_t;
_EXPORT_STD using _CSTD int_least32_t;
_EXPORT_STD using _CSTD int_least64_t;
_EXPORT_STD using _CSTD uint_least8_t;
_EXPORT_STD using _CSTD uint_least16_t;
_EXPORT_STD using _CSTD uint_least32_t;
_EXPORT_STD using _CSTD uint_least64_t;

_EXPORT_STD using _CSTD int_fast8_t;
_EXPORT_STD using _CSTD int_fast16_t;
_EXPORT_STD using _CSTD int_fast32_t;
_EXPORT_STD using _CSTD int_fast64_t;
_EXPORT_STD using _CSTD uint_fast8_t;
_EXPORT_STD using _CSTD uint_fast16_t;
_EXPORT_STD using _CSTD uint_fast32_t;
_EXPORT_STD using _CSTD uint_fast64_t;

_EXPORT_STD using _CSTD intmax_t;
_EXPORT_STD using _CSTD intptr_t;
_EXPORT_STD using _CSTD uintmax_t;
_EXPORT_STD using _CSTD uintptr_t;

_STD_END

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)

#endif // _STL_COMPILER_PREPROCESSOR
#endif // _CSTDINT_



#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

// TRANSITION, non-_Ugly attribute tokens
#pragma push_macro("msvc")
#pragma push_macro("intrinsic")
#pragma push_macro("known_semantics")
#undef msvc
#undef intrinsic
#undef known_semantics

_STD_BEGIN
template <class>
// TRANSITION, CWG-2518: false value attached to a dependent name (for static_assert)
_INLINE_VAR constexpr bool _Always_false = false;

template <bool _First_value, class _First, class... _Rest>
struct _Conjunction { // handle false trait or last trait
    using type = _First;
};

template <class _True, class _Next, class... _Rest>
struct _Conjunction<true, _True, _Next, _Rest...> { // the first trait is true, try the next one
    using type = typename _Conjunction<_Next::value, _Next, _Rest...>::type;
};

_EXPORT_STD template <class... _Traits>
struct conjunction : true_type {}; // If _Traits is empty, true_type

template <class _First, class... _Rest>
struct conjunction<_First, _Rest...> : _Conjunction<_First::value, _First, _Rest...>::type {
    // the first false trait in _Traits, or the last trait if none are false
};

_EXPORT_STD template <class... _Traits>
_INLINE_VAR constexpr bool conjunction_v = conjunction<_Traits...>::value;

_EXPORT_STD template <class _Trait>
struct negation : bool_constant<!static_cast<bool>(_Trait::value)> {}; // The negated result of _Trait

_EXPORT_STD template <class _Trait>
_INLINE_VAR constexpr bool negation_v = negation<_Trait>::value;

_EXPORT_STD template <class _Ty>
_INLINE_VAR constexpr bool is_void_v = is_same_v<remove_cv_t<_Ty>, void>;

_EXPORT_STD template <class _Ty>
struct is_void : bool_constant<is_void_v<_Ty>> {};

_EXPORT_STD template <class... _Types>
using void_t = void;

template <class _Ty>
struct _Identity {
    using type = _Ty;
};
template <class _Ty>
using _Identity_t _MSVC_KNOWN_SEMANTICS = typename _Identity<_Ty>::type;

// Type modifiers
_EXPORT_STD template <class _Ty>
struct add_const { // add top-level const qualifier
    using type = const _Ty;
};

_EXPORT_STD template <class _Ty>
using add_const_t = typename add_const<_Ty>::type;

_EXPORT_STD template <class _Ty>
struct add_volatile { // add top-level volatile qualifier
    using type = volatile _Ty;
};

_EXPORT_STD template <class _Ty>
using add_volatile_t = typename add_volatile<_Ty>::type;

_EXPORT_STD template <class _Ty>
struct add_cv { // add top-level const and volatile qualifiers
    using type = const volatile _Ty;
};

_EXPORT_STD template <class _Ty>
using add_cv_t = typename add_cv<_Ty>::type;

template <class _Ty, class = void>
struct _Add_reference { // add reference (non-referenceable type)
    using _Lvalue = _Ty;
    using _Rvalue = _Ty;
};

template <class _Ty>
struct _Add_reference<_Ty, void_t<_Ty&>> { // (referenceable type)
    using _Lvalue = _Ty&;
    using _Rvalue = _Ty&&;
};

_EXPORT_STD template <class _Ty>
struct add_lvalue_reference {
    using type = typename _Add_reference<_Ty>::_Lvalue;
};

_EXPORT_STD template <class _Ty>
using add_lvalue_reference_t = typename _Add_reference<_Ty>::_Lvalue;

_EXPORT_STD template <class _Ty>
struct add_rvalue_reference {
    using type = typename _Add_reference<_Ty>::_Rvalue;
};

_EXPORT_STD template <class _Ty>
using add_rvalue_reference_t = typename _Add_reference<_Ty>::_Rvalue;

_EXPORT_STD template <class _Ty>
add_rvalue_reference_t<_Ty> declval() noexcept {
    static_assert(_Always_false<_Ty>, "Calling declval is ill-formed, see N4950 [declval]/2.");
}

_EXPORT_STD template <class _Ty>
struct remove_extent { // remove array extent
    using type = _Ty;
};

template <class _Ty, size_t _Ix>
struct remove_extent<_Ty[_Ix]> {
    using type = _Ty;
};

template <class _Ty>
struct remove_extent<_Ty[]> {
    using type = _Ty;
};

_EXPORT_STD template <class _Ty>
using remove_extent_t = typename remove_extent<_Ty>::type;

_EXPORT_STD template <class _Ty>
struct remove_all_extents { // remove all array extents
    using type = _Ty;
};

template <class _Ty, size_t _Ix>
struct remove_all_extents<_Ty[_Ix]> {
    using type = typename remove_all_extents<_Ty>::type;
};

template <class _Ty>
struct remove_all_extents<_Ty[]> {
    using type = typename remove_all_extents<_Ty>::type;
};

_EXPORT_STD template <class _Ty>
using remove_all_extents_t = typename remove_all_extents<_Ty>::type;

_EXPORT_STD template <class _Ty>
struct remove_pointer {
    using type = _Ty;
};

template <class _Ty>
struct remove_pointer<_Ty*> {
    using type = _Ty;
};

template <class _Ty>
struct remove_pointer<_Ty* const> {
    using type = _Ty;
};

template <class _Ty>
struct remove_pointer<_Ty* volatile> {
    using type = _Ty;
};

template <class _Ty>
struct remove_pointer<_Ty* const volatile> {
    using type = _Ty;
};

_EXPORT_STD template <class _Ty>
using remove_pointer_t = typename remove_pointer<_Ty>::type;

template <class _Ty, class = void>
struct _Add_pointer { // add pointer (pointer type cannot be formed)
    using type = _Ty;
};

template <class _Ty>
struct _Add_pointer<_Ty, void_t<remove_reference_t<_Ty>*>> { // (pointer type can be formed)
    using type = remove_reference_t<_Ty>*;
};

_EXPORT_STD template <class _Ty>
struct add_pointer {
    using type = typename _Add_pointer<_Ty>::type;
};

_EXPORT_STD template <class _Ty>
using add_pointer_t = typename _Add_pointer<_Ty>::type;

_EXPORT_STD template <class>
_INLINE_VAR constexpr bool is_array_v = false; // determine whether type argument is an array

template <class _Ty, size_t _Nx>
_INLINE_VAR constexpr bool is_array_v<_Ty[_Nx]> = true;

template <class _Ty>
_INLINE_VAR constexpr bool is_array_v<_Ty[]> = true;

_EXPORT_STD template <class _Ty>
struct is_array : bool_constant<is_array_v<_Ty>> {};

#if _HAS_CXX20
_EXPORT_STD template <class>
inline constexpr bool is_bounded_array_v = false;

template <class _Ty, size_t _Nx>
inline constexpr bool is_bounded_array_v<_Ty[_Nx]> = true;

_EXPORT_STD template <class _Ty>
struct is_bounded_array : bool_constant<is_bounded_array_v<_Ty>> {};

_EXPORT_STD template <class>
inline constexpr bool is_unbounded_array_v = false;

template <class _Ty>
inline constexpr bool is_unbounded_array_v<_Ty[]> = true;

_EXPORT_STD template <class _Ty>
struct is_unbounded_array : bool_constant<is_unbounded_array_v<_Ty>> {};
#endif // _HAS_CXX20

_EXPORT_STD template <class>
_INLINE_VAR constexpr bool is_lvalue_reference_v = false; // determine whether type argument is an lvalue reference

template <class _Ty>
_INLINE_VAR constexpr bool is_lvalue_reference_v<_Ty&> = true;

_EXPORT_STD template <class _Ty>
struct is_lvalue_reference : bool_constant<is_lvalue_reference_v<_Ty>> {};

_EXPORT_STD template <class>
_INLINE_VAR constexpr bool is_rvalue_reference_v = false; // determine whether type argument is an rvalue reference

template <class _Ty>
_INLINE_VAR constexpr bool is_rvalue_reference_v<_Ty&&> = true;

_EXPORT_STD template <class _Ty>
struct is_rvalue_reference : bool_constant<is_rvalue_reference_v<_Ty>> {};

_EXPORT_STD template <class>
_INLINE_VAR constexpr bool is_reference_v = false; // determine whether type argument is a reference

template <class _Ty>
_INLINE_VAR constexpr bool is_reference_v<_Ty&> = true;

template <class _Ty>
_INLINE_VAR constexpr bool is_reference_v<_Ty&&> = true;

_EXPORT_STD template <class _Ty>
struct is_reference : bool_constant<is_reference_v<_Ty>> {};

_EXPORT_STD template <class>
_INLINE_VAR constexpr bool is_pointer_v = false; // determine whether _Ty is a pointer

template <class _Ty>
_INLINE_VAR constexpr bool is_pointer_v<_Ty*> = true;

template <class _Ty>
_INLINE_VAR constexpr bool is_pointer_v<_Ty* const> = true;

template <class _Ty>
_INLINE_VAR constexpr bool is_pointer_v<_Ty* volatile> = true;

template <class _Ty>
_INLINE_VAR constexpr bool is_pointer_v<_Ty* const volatile> = true;

_EXPORT_STD template <class _Ty>
struct is_pointer : bool_constant<is_pointer_v<_Ty>> {};

_EXPORT_STD template <class _Ty>
_INLINE_VAR constexpr bool is_null_pointer_v =
is_same_v<remove_cv_t<_Ty>, nullptr_t>; // determine whether _Ty is cv-qualified nullptr_t

_EXPORT_STD template <class _Ty>
struct is_null_pointer : bool_constant<is_null_pointer_v<_Ty>> {};

_EXPORT_STD template <class _Ty>
struct is_union : bool_constant<__is_union(_Ty)> {}; // determine whether _Ty is a union

_EXPORT_STD template <class _Ty>
_INLINE_VAR constexpr bool is_union_v = __is_union(_Ty);

_EXPORT_STD template <class _Ty>
struct is_class : bool_constant<__is_class(_Ty)> {}; // determine whether _Ty is a class

_EXPORT_STD template <class _Ty>
_INLINE_VAR constexpr bool is_class_v = __is_class(_Ty);

_EXPORT_STD template <class _Ty>
_INLINE_VAR constexpr bool is_fundamental_v = is_arithmetic_v<_Ty> || is_void_v<_Ty> || is_null_pointer_v<_Ty>;

_EXPORT_STD template <class _Ty>
struct is_fundamental : bool_constant<is_fundamental_v<_Ty>> {}; // determine whether _Ty is a fundamental type

_EXPORT_STD template <class _From, class _To>
struct is_convertible : bool_constant<__is_convertible_to(_From, _To)> {
    // determine whether _From is convertible to _To
};

_EXPORT_STD template <class _From, class _To>
_INLINE_VAR constexpr bool is_convertible_v = __is_convertible_to(_From, _To);

#if !defined(__clang__) && !defined(__EDG__) // TRANSITION, DevCom-1627396
template <class _Ty>
struct is_convertible<_Ty&, volatile _Ty&> : true_type {};

template <class _Ty>
struct is_convertible<volatile _Ty&, volatile _Ty&> : true_type {};

template <class _Ty>
struct is_convertible<_Ty&, const volatile _Ty&> : true_type {};

template <class _Ty>
struct is_convertible<volatile _Ty&, const volatile _Ty&> : true_type {};

template <class _Ty>
_INLINE_VAR constexpr bool is_convertible_v<_Ty&, volatile _Ty&> = true;

template <class _Ty>
_INLINE_VAR constexpr bool is_convertible_v<volatile _Ty&, volatile _Ty&> = true;

template <class _Ty>
_INLINE_VAR constexpr bool is_convertible_v<_Ty&, const volatile _Ty&> = true;

template <class _Ty>
_INLINE_VAR constexpr bool is_convertible_v<volatile _Ty&, const volatile _Ty&> = true;
#endif // ^^^ workaround ^^^

_EXPORT_STD template <class _Ty>
struct is_enum : bool_constant<__is_enum(_Ty)> {}; // determine whether _Ty is an enumerated type

_EXPORT_STD template <class _Ty>
_INLINE_VAR constexpr bool is_enum_v = __is_enum(_Ty);

#if _HAS_CXX23
_EXPORT_STD template <class _Ty>
inline constexpr bool is_scoped_enum_v = conjunction_v<is_enum<_Ty>, negation<is_convertible<_Ty, int>>>;

_EXPORT_STD template <class _Ty>
struct is_scoped_enum : bool_constant<is_scoped_enum_v<_Ty>> {};
#endif // _HAS_CXX23

_EXPORT_STD template <class _Ty>
struct is_compound : bool_constant<!is_fundamental_v<_Ty>> {}; // determine whether _Ty is a compound type

_EXPORT_STD template <class _Ty>
_INLINE_VAR constexpr bool is_compound_v = !is_fundamental_v<_Ty>;

#define _EMIT_CDECL(FUNC, OPT1, OPT2, OPT3) FUNC(__cdecl, OPT1, OPT2, OPT3)

#ifdef _M_CEE
#define _EMIT_CLRCALL(FUNC, OPT1, OPT2, OPT3) FUNC(__clrcall, OPT1, OPT2, OPT3)
#else // ^^^ __clrcall supported / __clrcall not supported vvv
#define _EMIT_CLRCALL(FUNC, OPT1, OPT2, OPT3)
#endif // ^^^ __clrcall not supported ^^^

#if defined(_M_IX86) && !defined(_M_CEE)
#define _EMIT_FASTCALL(FUNC, OPT1, OPT2, OPT3) FUNC(__fastcall, OPT1, OPT2, OPT3)
#else // ^^^ __fastcall supported / __fastcall not supported vvv
#define _EMIT_FASTCALL(FUNC, OPT1, OPT2, OPT3)
#endif // ^^^ __fastcall not supported ^^^

#ifdef _M_IX86
#define _EMIT_STDCALL(FUNC, OPT1, OPT2, OPT3)  FUNC(__stdcall, OPT1, OPT2, OPT3)
#define _EMIT_THISCALL(FUNC, OPT1, OPT2, OPT3) FUNC(__thiscall, OPT1, OPT2, OPT3)
#else // ^^^ __stdcall and __thiscall supported / __stdcall and __thiscall not supported vvv
#define _EMIT_STDCALL(FUNC, OPT1, OPT2, OPT3)
#define _EMIT_THISCALL(FUNC, OPT1, OPT2, OPT3)
#endif // ^^^ __stdcall and __thiscall not supported ^^^

#if ((defined(_M_IX86) && _M_IX86_FP >= 2) || defined(_M_X64)) && !defined(_M_CEE)
#define _EMIT_VECTORCALL(FUNC, OPT1, OPT2, OPT3) FUNC(__vectorcall, OPT1, OPT2, OPT3)
#else // ^^^ __vectorcall supported / __vectorcall not supported vvv
#define _EMIT_VECTORCALL(FUNC, OPT1, OPT2, OPT3)
#endif // ^^^ __vectorcall not supported ^^^

#define _NON_MEMBER_CALL(FUNC, CV_OPT, REF_OPT, NOEXCEPT_OPT) \
    _EMIT_CDECL(FUNC, CV_OPT, REF_OPT, NOEXCEPT_OPT)          \
    _EMIT_CLRCALL(FUNC, CV_OPT, REF_OPT, NOEXCEPT_OPT)        \
    _EMIT_FASTCALL(FUNC, CV_OPT, REF_OPT, NOEXCEPT_OPT)       \
    _EMIT_STDCALL(FUNC, CV_OPT, REF_OPT, NOEXCEPT_OPT)        \
    _EMIT_VECTORCALL(FUNC, CV_OPT, REF_OPT, NOEXCEPT_OPT)

#define _NON_MEMBER_CALL_CV(FUNC, REF_OPT, NOEXCEPT_OPT)    \
    _NON_MEMBER_CALL(FUNC, , REF_OPT, NOEXCEPT_OPT)         \
    _NON_MEMBER_CALL(FUNC, const, REF_OPT, NOEXCEPT_OPT)    \
    _NON_MEMBER_CALL(FUNC, volatile, REF_OPT, NOEXCEPT_OPT) \
    _NON_MEMBER_CALL(FUNC, const volatile, REF_OPT, NOEXCEPT_OPT)

#define _NON_MEMBER_CALL_CV_REF(FUNC, NOEXCEPT_OPT) \
    _NON_MEMBER_CALL_CV(FUNC, , NOEXCEPT_OPT)       \
    _NON_MEMBER_CALL_CV(FUNC, &, NOEXCEPT_OPT)      \
    _NON_MEMBER_CALL_CV(FUNC, &&, NOEXCEPT_OPT)

#ifdef __cpp_noexcept_function_type
#define _NON_MEMBER_CALL_CV_REF_NOEXCEPT(FUNC) \
    _NON_MEMBER_CALL_CV_REF(FUNC, )            \
    _NON_MEMBER_CALL_CV_REF(FUNC, noexcept)
#else // ^^^ defined(__cpp_noexcept_function_type) / !defined(__cpp_noexcept_function_type) vvv
#define _NON_MEMBER_CALL_CV_REF_NOEXCEPT(FUNC) _NON_MEMBER_CALL_CV_REF(FUNC, )
#endif // ^^^ !defined(__cpp_noexcept_function_type) ^^^

#define _MEMBER_CALL(FUNC, CV_OPT, REF_OPT, NOEXCEPT_OPT) \
    _EMIT_CDECL(FUNC, CV_OPT, REF_OPT, NOEXCEPT_OPT)      \
    _EMIT_CLRCALL(FUNC, CV_OPT, REF_OPT, NOEXCEPT_OPT)    \
    _EMIT_FASTCALL(FUNC, CV_OPT, REF_OPT, NOEXCEPT_OPT)   \
    _EMIT_STDCALL(FUNC, CV_OPT, REF_OPT, NOEXCEPT_OPT)    \
    _EMIT_THISCALL(FUNC, CV_OPT, REF_OPT, NOEXCEPT_OPT)   \
    _EMIT_VECTORCALL(FUNC, CV_OPT, REF_OPT, NOEXCEPT_OPT)

#define _MEMBER_CALL_CV(FUNC, REF_OPT, NOEXCEPT_OPT)    \
    _MEMBER_CALL(FUNC, , REF_OPT, NOEXCEPT_OPT)         \
    _MEMBER_CALL(FUNC, const, REF_OPT, NOEXCEPT_OPT)    \
    _MEMBER_CALL(FUNC, volatile, REF_OPT, NOEXCEPT_OPT) \
    _MEMBER_CALL(FUNC, const volatile, REF_OPT, NOEXCEPT_OPT)

#define _MEMBER_CALL_CV_REF(FUNC, NOEXCEPT_OPT) \
    _MEMBER_CALL_CV(FUNC, , NOEXCEPT_OPT)       \
    _MEMBER_CALL_CV(FUNC, &, NOEXCEPT_OPT)      \
    _MEMBER_CALL_CV(FUNC, &&, NOEXCEPT_OPT)

#ifdef __cpp_noexcept_function_type
#define _MEMBER_CALL_CV_REF_NOEXCEPT(FUNC) \
    _MEMBER_CALL_CV_REF(FUNC, )            \
    _MEMBER_CALL_CV_REF(FUNC, noexcept)
#else // ^^^ defined(__cpp_noexcept_function_type) / !defined(__cpp_noexcept_function_type) vvv
#define _MEMBER_CALL_CV_REF_NOEXCEPT(FUNC) _MEMBER_CALL_CV_REF(FUNC, )
#endif // ^^^ !defined(__cpp_noexcept_function_type) ^^^

#ifdef __cpp_noexcept_function_type
#define _CLASS_DEFINE_CV_REF_NOEXCEPT(CLASS) \
    CLASS(_EMPTY_ARGUMENT)                   \
    CLASS(const)                             \
    CLASS(volatile)                          \
    CLASS(const volatile)                    \
    CLASS(&)                                 \
    CLASS(const&)                            \
    CLASS(volatile&)                         \
    CLASS(const volatile&)                   \
    CLASS(&&)                                \
    CLASS(const&&)                           \
    CLASS(volatile&&)                        \
    CLASS(const volatile&&)                  \
    CLASS(noexcept)                          \
    CLASS(const noexcept)                    \
    CLASS(volatile noexcept)                 \
    CLASS(const volatile noexcept)           \
    CLASS(& noexcept)                        \
    CLASS(const& noexcept)                   \
    CLASS(volatile& noexcept)                \
    CLASS(const volatile& noexcept)          \
    CLASS(&& noexcept)                       \
    CLASS(const&& noexcept)                  \
    CLASS(volatile&& noexcept)               \
    CLASS(const volatile&& noexcept)
#else // ^^^ defined(__cpp_noexcept_function_type) / !defined(__cpp_noexcept_function_type) vvv
#define _CLASS_DEFINE_CV_REF_NOEXCEPT(CLASS) \
    CLASS(_EMPTY_ARGUMENT)                   \
    CLASS(const)                             \
    CLASS(volatile)                          \
    CLASS(const volatile)                    \
    CLASS(&)                                 \
    CLASS(const&)                            \
    CLASS(volatile&)                         \
    CLASS(const volatile&)                   \
    CLASS(&&)                                \
    CLASS(const&&)                           \
    CLASS(volatile&&)                        \
    CLASS(const volatile&&)
#endif // ^^^ !defined(__cpp_noexcept_function_type) ^^^

template <class... _Types>
struct _Arg_types {}; // provide argument_type, etc. when sizeof...(_Types) is 1 or 2

template <class _Ty1>
struct _Arg_types<_Ty1> {
    using _ARGUMENT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = _Ty1;
};

template <class _Ty1, class _Ty2>
struct _Arg_types<_Ty1, _Ty2> {
    using _FIRST_ARGUMENT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = _Ty1;
    using _SECOND_ARGUMENT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = _Ty2;
};

template <class _Ty>
struct _Is_memfunptr { // base class for member function pointer predicates
    using _Bool_type = false_type; // NB: members are user-visible via _Weak_types
};

#define _IS_MEMFUNPTR(CALL_OPT, CV_OPT, REF_OPT, NOEXCEPT_OPT)                            \
    template <class _Ret, class _Arg0, class... _Types>                                   \
    struct _Is_memfunptr<_Ret (CALL_OPT _Arg0::*)(_Types...) CV_OPT REF_OPT NOEXCEPT_OPT> \
        : _Arg_types<CV_OPT _Arg0*, _Types...> {                                          \
        using _Bool_type                                          = true_type;            \
        using _RESULT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = _Ret;                 \
        using _Class_type                                         = _Arg0;                \
        using _Guide_type = enable_if<!is_same_v<int REF_OPT, int&&>, _Ret(_Types...)>;   \
    };

_MEMBER_CALL_CV_REF_NOEXCEPT(_IS_MEMFUNPTR)
#undef _IS_MEMFUNPTR

#define _IS_MEMFUNPTR_ELLIPSIS(CV_REF_NOEXCEPT_OPT)                                   \
    template <class _Ret, class _Arg0, class... _Types>                               \
    struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...)                              \
            CV_REF_NOEXCEPT_OPT> { /* no calling conventions for ellipsis */          \
        using _Bool_type                                          = true_type;        \
        using _RESULT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = _Ret;             \
        using _Class_type                                         = _Arg0;            \
        using _Guide_type                                         = enable_if<false>; \
    };

_CLASS_DEFINE_CV_REF_NOEXCEPT(_IS_MEMFUNPTR_ELLIPSIS)
#undef _IS_MEMFUNPTR_ELLIPSIS

#if _HAS_CXX23 && !defined(__clang__) // TRANSITION, DevCom-10107077, Clang has not implemented Deducing this
#define _IS_MEMFUNPTR_EXPLICIT_THIS_GUIDES(CALL_OPT, CV_OPT, REF_OPT, NOEXCEPT_OPT) \
    template <class _Ret, class _Self, class... _Args>                              \
    struct _Is_memfunptr<_Ret(CALL_OPT*)(_Self, _Args...) NOEXCEPT_OPT> {           \
        using _Bool_type  = false_type;                                             \
        using _Guide_type = _Identity<_Ret(_Args...)>;                              \
    };

_NON_MEMBER_CALL(_IS_MEMFUNPTR_EXPLICIT_THIS_GUIDES, , , )
#ifdef __cpp_noexcept_function_type
_NON_MEMBER_CALL(_IS_MEMFUNPTR_EXPLICIT_THIS_GUIDES, , , noexcept)
#endif // defined(__cpp_noexcept_function_type)

#undef _IS_MEMFUNPTR_EXPLICIT_THIS_GUIDES
#endif // _HAS_CXX23 && !defined(__clang__)

#ifdef __clang__
_EXPORT_STD template <class _Ty>
_INLINE_VAR constexpr bool is_member_function_pointer_v = __is_member_function_pointer(_Ty);
#else // ^^^ Clang / Other vvv
_EXPORT_STD template <class _Ty>
_INLINE_VAR constexpr bool is_member_function_pointer_v = _Is_memfunptr<remove_cv_t<_Ty>>::_Bool_type::value;
#endif // ^^^ Other ^^^

_EXPORT_STD template <class _Ty>
struct is_member_function_pointer : bool_constant<is_member_function_pointer_v<_Ty>> {};

_EXPORT_STD template <class>
_INLINE_VAR constexpr bool is_const_v = false; // determine whether type argument is const qualified

template <class _Ty>
_INLINE_VAR constexpr bool is_const_v<const _Ty> = true;

_EXPORT_STD template <class _Ty>
struct is_const : bool_constant<is_const_v<_Ty>> {};

_EXPORT_STD template <class>
_INLINE_VAR constexpr bool is_volatile_v = false; // determine whether type argument is volatile qualified

template <class _Ty>
_INLINE_VAR constexpr bool is_volatile_v<volatile _Ty> = true;

_EXPORT_STD template <class _Ty>
struct is_volatile : bool_constant<is_volatile_v<_Ty>> {};

_EXPORT_STD template <class _Ty>
_INLINE_VAR constexpr bool is_function_v = // only function types and reference types can't be const qualified
!is_const_v<const _Ty> && !is_reference_v<_Ty>;

_EXPORT_STD template <class _Ty>
struct is_function : bool_constant<is_function_v<_Ty>> {};

_EXPORT_STD template <class _Ty>
_INLINE_VAR constexpr bool is_object_v = // only function types and reference types can't be const qualified
is_const_v<const _Ty> && !is_void_v<_Ty>;

_EXPORT_STD template <class _Ty>
struct is_object : bool_constant<is_object_v<_Ty>> {};

template <class>
struct _Is_member_object_pointer {
    static constexpr bool value = false;
};

template <class _Ty1, class _Ty2>
struct _Is_member_object_pointer<_Ty1 _Ty2::*> {
    static constexpr bool value = !is_function_v<_Ty1>;
    using _Class_type = _Ty2;
};

#ifdef __clang__
_EXPORT_STD template <class _Ty>
_INLINE_VAR constexpr bool is_member_object_pointer_v = __is_member_object_pointer(_Ty);
#else // ^^^ Clang / Other vvv
_EXPORT_STD template <class _Ty>
_INLINE_VAR constexpr bool is_member_object_pointer_v = _Is_member_object_pointer<remove_cv_t<_Ty>>::value;
#endif // ^^^ Other ^^^

_EXPORT_STD template <class _Ty>
struct is_member_object_pointer : bool_constant<is_member_object_pointer_v<_Ty>> {};

#ifdef __clang__
_EXPORT_STD template <class _Ty>
_INLINE_VAR constexpr bool is_member_pointer_v = __is_member_pointer(_Ty);
#else // ^^^ Clang / Other vvv
_EXPORT_STD template <class _Ty>
_INLINE_VAR constexpr bool is_member_pointer_v = is_member_object_pointer_v<_Ty> || is_member_function_pointer_v<_Ty>;
#endif // ^^^ Other ^^^

_EXPORT_STD template <class _Ty>
struct is_member_pointer : bool_constant<is_member_pointer_v<_Ty>> {}; // determine whether _Ty is a pointer to member

_EXPORT_STD template <class _Ty>
_INLINE_VAR constexpr bool is_scalar_v = // determine whether _Ty is a scalar type
is_arithmetic_v<_Ty> || is_enum_v<_Ty> || is_pointer_v<_Ty> || is_member_pointer_v<_Ty> || is_null_pointer_v<_Ty>;

_EXPORT_STD template <class _Ty>
struct is_scalar : bool_constant<is_scalar_v<_Ty>> {};

_EXPORT_STD template <class _Ty>
struct _CXX20_DEPRECATE_IS_POD is_pod : bool_constant<__is_pod(_Ty)> {}; // determine whether _Ty is a POD type

_EXPORT_STD template <class _Ty>
_CXX20_DEPRECATE_IS_POD _INLINE_VAR constexpr bool is_pod_v = __is_pod(_Ty);

_EXPORT_STD template <class _Ty>
struct is_empty : bool_constant<__is_empty(_Ty)> {}; // determine whether _Ty is an empty class

_EXPORT_STD template <class _Ty>
_INLINE_VAR constexpr bool is_empty_v = __is_empty(_Ty);

_EXPORT_STD template <class _Ty>
struct is_polymorphic : bool_constant<__is_polymorphic(_Ty)> {}; // determine whether _Ty is a polymorphic type

_EXPORT_STD template <class _Ty>
_INLINE_VAR constexpr bool is_polymorphic_v = __is_polymorphic(_Ty);

_EXPORT_STD template <class _Ty>
struct is_abstract : bool_constant<__is_abstract(_Ty)> {}; // determine whether _Ty is an abstract class

_EXPORT_STD template <class _Ty>
_INLINE_VAR constexpr bool is_abstract_v = __is_abstract(_Ty);

_EXPORT_STD template <class _Ty>
struct is_final : bool_constant<__is_final(_Ty)> {}; // determine whether _Ty is a final class

_EXPORT_STD template <class _Ty>
_INLINE_VAR constexpr bool is_final_v = __is_final(_Ty);

_EXPORT_STD template <class _Ty>
struct is_standard_layout : bool_constant<__is_standard_layout(_Ty)> {}; // determine whether _Ty is standard layout

_EXPORT_STD template <class _Ty>
_INLINE_VAR constexpr bool is_standard_layout_v = __is_standard_layout(_Ty);

#if _HAS_DEPRECATED_IS_LITERAL_TYPE
_EXPORT_STD template <class _Ty>
struct _CXX17_DEPRECATE_IS_LITERAL_TYPE is_literal_type : bool_constant<__is_literal_type(_Ty)> {
    // determine whether _Ty is a literal type
};

_EXPORT_STD template <class _Ty>
_CXX17_DEPRECATE_IS_LITERAL_TYPE _INLINE_VAR constexpr bool is_literal_type_v = __is_literal_type(_Ty);
#endif // _HAS_DEPRECATED_IS_LITERAL_TYPE

#if 1 // TRANSITION, VSO-119526 and LLVM-41915
_EXPORT_STD template <class _Ty>
struct is_trivial : bool_constant<__is_trivially_constructible(_Ty) && __is_trivially_copyable(_Ty)> {
    // determine whether _Ty is a trivial type
};

_EXPORT_STD template <class _Ty>
_INLINE_VAR constexpr bool is_trivial_v = __is_trivially_constructible(_Ty) && __is_trivially_copyable(_Ty);
#else // ^^^ workaround / no workaround vvv
_EXPORT_STD template <class _Ty>
struct is_trivial : bool_constant<__is_trivial(_Ty)> {}; // determine whether _Ty is a trivial type

_EXPORT_STD template <class _Ty>
_INLINE_VAR constexpr bool is_trivial_v = __is_trivial(_Ty);
#endif // ^^^ no workaround ^^^

_EXPORT_STD template <class _Ty>
struct is_trivially_copyable : bool_constant<__is_trivially_copyable(_Ty)> {
    // determine whether _Ty is a trivially copyable type
};

_EXPORT_STD template <class _Ty>
_INLINE_VAR constexpr bool is_trivially_copyable_v = __is_trivially_copyable(_Ty);

_EXPORT_STD template <class _Ty>
struct has_virtual_destructor : bool_constant<__has_virtual_destructor(_Ty)> {
    // determine whether _Ty has a virtual destructor
};

_EXPORT_STD template <class _Ty>
_INLINE_VAR constexpr bool has_virtual_destructor_v = __has_virtual_destructor(_Ty);

#if _HAS_CXX17
_EXPORT_STD template <class _Ty>
struct has_unique_object_representations : bool_constant<__has_unique_object_representations(_Ty)> {
    // determine whether _Ty has unique object representations
};

_EXPORT_STD template <class _Ty>
_INLINE_VAR constexpr bool has_unique_object_representations_v = __has_unique_object_representations(_Ty);

#ifdef __EDG__ // TRANSITION, VSO-1690654
template <class _Ty>
struct _Is_aggregate_impl : bool_constant<__is_aggregate(_Ty)> {};

_EXPORT_STD template <class _Ty>
_INLINE_VAR constexpr bool is_aggregate_v = disjunction_v<is_array<_Ty>, _Is_aggregate_impl<_Ty>>;

_EXPORT_STD template <class _Ty>
struct is_aggregate : bool_constant<is_aggregate_v<_Ty>> {};
#else // ^^^ workaround / no workaround vvv
_EXPORT_STD template <class _Ty>
struct is_aggregate : bool_constant<__is_aggregate(_Ty)> {};

_EXPORT_STD template <class _Ty>
_INLINE_VAR constexpr bool is_aggregate_v = __is_aggregate(_Ty);
#endif // ^^^ no workaround ^^^
#endif // _HAS_CXX17

_EXPORT_STD template <class _Ty, class... _Args>
struct is_constructible : bool_constant<__is_constructible(_Ty, _Args...)> {
    // determine whether _Ty can be direct-initialized with _Args...
};

_EXPORT_STD template <class _Ty, class... _Args>
_INLINE_VAR constexpr bool is_constructible_v = __is_constructible(_Ty, _Args...);

_EXPORT_STD template <class _Ty>
struct is_copy_constructible : bool_constant<__is_constructible(_Ty, add_lvalue_reference_t<const _Ty>)> {
    // determine whether _Ty can be direct-initialized with an lvalue const _Ty
};

_EXPORT_STD template <class _Ty>
_INLINE_VAR constexpr bool is_copy_constructible_v = __is_constructible(_Ty, add_lvalue_reference_t<const _Ty>);

_EXPORT_STD template <class _Ty>
struct is_default_constructible : bool_constant<__is_constructible(_Ty)> {
    // determine whether _Ty can be value-initialized
};

_EXPORT_STD template <class _Ty>
_INLINE_VAR constexpr bool is_default_constructible_v = __is_constructible(_Ty);

template <class _Ty, class = void>
struct _Is_implicitly_default_constructible : false_type {
    // determine whether _Ty can be copy-initialized with {}
};

template <class _Ty>
void _Implicitly_default_construct(const _Ty&);

template <class _Ty>
struct _Is_implicitly_default_constructible < _Ty, void_t<decltype(_Implicitly_default_construct<_Ty>({})) >> : true_type {
};

_EXPORT_STD template <class _Ty>
struct is_move_constructible : bool_constant<__is_constructible(_Ty, _Ty)> {
    // determine whether _Ty can be direct-initialized from an rvalue _Ty
};

_EXPORT_STD template <class _Ty>
_INLINE_VAR constexpr bool is_move_constructible_v = __is_constructible(_Ty, _Ty);

_EXPORT_STD template <class _To, class _From>
struct is_assignable : bool_constant<__is_assignable(_To, _From)> {}; // determine whether _From can be assigned to _To

_EXPORT_STD template <class _To, class _From>
_INLINE_VAR constexpr bool is_assignable_v = __is_assignable(_To, _From);

#if defined(_IS_ASSIGNABLE_NOCHECK_SUPPORTED) && !defined(__CUDACC__)
template <class _To, class _From>
struct _Is_assignable_no_precondition_check : bool_constant<__is_assignable_no_precondition_check(_To, _From)> {};
#else // ^^^ Use intrinsic / intrinsic not supported vvv
template <class _To, class _From>
using _Is_assignable_no_precondition_check = is_assignable<_To, _From>;
#endif // ^^^ intrinsic not supported ^^^

_EXPORT_STD template <class _Ty>
struct is_copy_assignable
    : bool_constant<__is_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>)> {
    // determine whether an lvalue const _Ty can be assigned to an lvalue _Ty
};

_EXPORT_STD template <class _Ty>
_INLINE_VAR constexpr bool is_copy_assignable_v =
__is_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>);

#if defined(_IS_ASSIGNABLE_NOCHECK_SUPPORTED) && !defined(__CUDACC__)
template <class _Ty>
struct _Is_copy_assignable_no_precondition_check
    : bool_constant<__is_assignable_no_precondition_check(
        add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>)> {};

template <class _Ty>
_INLINE_VAR constexpr bool _Is_copy_assignable_unchecked_v =
__is_assignable_no_precondition_check(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>);
#else // ^^^ Use intrinsic / intrinsic not supported vvv
template <class _Ty>
using _Is_copy_assignable_no_precondition_check = is_copy_assignable<_Ty>;

template <class _Ty>
_INLINE_VAR constexpr bool _Is_copy_assignable_unchecked_v = is_copy_assignable_v<_Ty>;
#endif // ^^^ intrinsic not supported ^^^

_EXPORT_STD template <class _Ty>
struct is_move_assignable : bool_constant<__is_assignable(add_lvalue_reference_t<_Ty>, _Ty)> {
    // determine whether an rvalue _Ty can be assigned to an lvalue _Ty
};

_EXPORT_STD template <class _Ty>
_INLINE_VAR constexpr bool is_move_assignable_v = __is_assignable(add_lvalue_reference_t<_Ty>, _Ty);

#if defined(_IS_ASSIGNABLE_NOCHECK_SUPPORTED) && !defined(__CUDACC__)
template <class _Ty>
struct _Is_move_assignable_no_precondition_check
    : bool_constant<__is_assignable_no_precondition_check(add_lvalue_reference_t<_Ty>, _Ty)> {};

template <class _Ty>
_INLINE_VAR constexpr bool _Is_move_assignable_unchecked_v =
__is_assignable_no_precondition_check(add_lvalue_reference_t<_Ty>, _Ty);
#else // ^^^ Use intrinsic / intrinsic not supported vvv
template <class _Ty>
using _Is_move_assignable_no_precondition_check = is_move_assignable<_Ty>;

template <class _Ty>
_INLINE_VAR constexpr bool _Is_move_assignable_unchecked_v = is_move_assignable_v<_Ty>;
#endif // ^^^ intrinsic not supported ^^^

_EXPORT_STD template <class _Ty>
struct is_destructible : bool_constant<__is_destructible(_Ty)> {
    // true iff remove_all_extents_t<_Ty> is a reference type, or can be explicitly destroyed
};

_EXPORT_STD template <class _Ty>
_INLINE_VAR constexpr bool is_destructible_v = __is_destructible(_Ty);

_EXPORT_STD template <class _Ty, class... _Args>
struct is_trivially_constructible : bool_constant<__is_trivially_constructible(_Ty, _Args...)> {
    // determine whether direct-initialization of _Ty with _Args... is trivial
};

_EXPORT_STD template <class _Ty, class... _Args>
_INLINE_VAR constexpr bool is_trivially_constructible_v = __is_trivially_constructible(_Ty, _Args...);

_EXPORT_STD template <class _Ty>
struct is_trivially_copy_constructible
    : bool_constant<__is_trivially_constructible(_Ty, add_lvalue_reference_t<const _Ty>)> {
    // determine whether direct-initialization of _Ty with an lvalue const _Ty is trivial
};

_EXPORT_STD template <class _Ty>
_INLINE_VAR constexpr bool is_trivially_copy_constructible_v =
__is_trivially_constructible(_Ty, add_lvalue_reference_t<const _Ty>);

_EXPORT_STD template <class _Ty>
struct is_trivially_default_constructible : bool_constant<__is_trivially_constructible(_Ty)> {
    // determine whether value-initialization of _Ty is trivial
};

_EXPORT_STD template <class _Ty>
_INLINE_VAR constexpr bool is_trivially_default_constructible_v = __is_trivially_constructible(_Ty);

_EXPORT_STD template <class _Ty>
struct is_trivially_move_constructible : bool_constant<__is_trivially_constructible(_Ty, _Ty)> {
    // determine whether direct-initialization of _Ty with an rvalue _Ty is trivial
};

_EXPORT_STD template <class _Ty>
_INLINE_VAR constexpr bool is_trivially_move_constructible_v = __is_trivially_constructible(_Ty, _Ty);

_EXPORT_STD template <class _To, class _From>
struct is_trivially_assignable : bool_constant<__is_trivially_assignable(_To, _From)> {
    // determine whether _From can be trivially assigned to _To
};

_EXPORT_STD template <class _To, class _From>
_INLINE_VAR constexpr bool is_trivially_assignable_v = __is_trivially_assignable(_To, _From);

_EXPORT_STD template <class _Ty>
struct is_trivially_copy_assignable
    : bool_constant<__is_trivially_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>)> {
    // determine whether an lvalue const _Ty can be trivially assigned to an lvalue _Ty
};

_EXPORT_STD template <class _Ty>
_INLINE_VAR constexpr bool is_trivially_copy_assignable_v =
__is_trivially_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>);

_EXPORT_STD template <class _Ty>
struct is_trivially_move_assignable : bool_constant<__is_trivially_assignable(add_lvalue_reference_t<_Ty>, _Ty)> {
    // determine whether an rvalue _Ty can be trivially assigned to an lvalue _Ty
};

_EXPORT_STD template <class _Ty>
_INLINE_VAR constexpr bool is_trivially_move_assignable_v = __is_trivially_assignable(add_lvalue_reference_t<_Ty>, _Ty);

_EXPORT_STD template <class _Ty>
struct is_trivially_destructible : bool_constant<__is_trivially_destructible(_Ty)> {
    // determine whether remove_all_extents_t<_Ty> is a reference type or can trivially be explicitly destroyed
};

_EXPORT_STD template <class _Ty>
_INLINE_VAR constexpr bool is_trivially_destructible_v = __is_trivially_destructible(_Ty);

_EXPORT_STD template <class _Ty, class... _Args>
struct is_nothrow_constructible : bool_constant<__is_nothrow_constructible(_Ty, _Args...)> {
    // determine whether direct-initialization of _Ty from _Args... is both valid and not potentially-throwing
};

_EXPORT_STD template <class _Ty, class... _Args>
_INLINE_VAR constexpr bool is_nothrow_constructible_v = __is_nothrow_constructible(_Ty, _Args...);

_EXPORT_STD template <class _Ty>
struct is_nothrow_copy_constructible
    : bool_constant<__is_nothrow_constructible(_Ty, add_lvalue_reference_t<const _Ty>)> {
    // determine whether direct-initialization of _Ty from an lvalue const _Ty is both valid
    // and not potentially-throwing
};

_EXPORT_STD template <class _Ty>
_INLINE_VAR constexpr bool is_nothrow_copy_constructible_v =
__is_nothrow_constructible(_Ty, add_lvalue_reference_t<const _Ty>);

_EXPORT_STD template <class _Ty>
struct is_nothrow_default_constructible : bool_constant<__is_nothrow_constructible(_Ty)> {
    // determine whether value-initialization of _Ty is both valid and not potentially-throwing
};

_EXPORT_STD template <class _Ty>
_INLINE_VAR constexpr bool is_nothrow_default_constructible_v = __is_nothrow_constructible(_Ty);

_EXPORT_STD template <class _Ty>
struct is_nothrow_move_constructible : bool_constant<__is_nothrow_constructible(_Ty, _Ty)> {
    // determine whether direct-initialization of _Ty from an rvalue _Ty is both valid and not potentially-throwing
};

_EXPORT_STD template <class _Ty>
_INLINE_VAR constexpr bool is_nothrow_move_constructible_v = __is_nothrow_constructible(_Ty, _Ty);

_EXPORT_STD template <class _To, class _From>
struct is_nothrow_assignable : bool_constant<__is_nothrow_assignable(_To, _From)> {
    // determine whether assignment of _From to _To is both valid and not potentially-throwing
};

_EXPORT_STD template <class _To, class _From>
_INLINE_VAR constexpr bool is_nothrow_assignable_v = __is_nothrow_assignable(_To, _From);

_EXPORT_STD template <class _Ty>
struct is_nothrow_copy_assignable
    : bool_constant<__is_nothrow_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>)> {
    // determine whether assignment of an lvalue const _Ty to an lvalue _Ty is both valid and not potentially-throwing
};

_EXPORT_STD template <class _Ty>
_INLINE_VAR constexpr bool is_nothrow_copy_assignable_v =
__is_nothrow_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>);

_EXPORT_STD template <class _Ty>
struct is_nothrow_move_assignable : bool_constant<__is_nothrow_assignable(add_lvalue_reference_t<_Ty>, _Ty)> {
    // determine whether assignment of an rvalue _Ty to an lvalue _Ty is both valid and not potentially-throwing
};

_EXPORT_STD template <class _Ty>
_INLINE_VAR constexpr bool is_nothrow_move_assignable_v = __is_nothrow_assignable(add_lvalue_reference_t<_Ty>, _Ty);

_EXPORT_STD template <class _Ty>
struct is_nothrow_destructible : bool_constant<__is_nothrow_destructible(_Ty)> {
    // determine whether remove_all_extents_t<_Ty> is a reference type or has
    // non-potentially-throwing explicit destruction
};

_EXPORT_STD template <class _Ty>
_INLINE_VAR constexpr bool is_nothrow_destructible_v = __is_nothrow_destructible(_Ty);

template <class _Ty, bool = is_integral_v<_Ty>>
struct _Sign_base { // determine whether integral type _Ty is signed or unsigned
    using _Uty = remove_cv_t<_Ty>;

    static constexpr bool _Signed = static_cast<_Uty>(-1) < static_cast<_Uty>(0);
    static constexpr bool _Unsigned = !_Signed;
};

template <class _Ty>
struct _Sign_base<_Ty, false> { // floating-point _Ty is signed
    // non-arithmetic _Ty is neither signed nor unsigned
    static constexpr bool _Signed = is_floating_point_v<_Ty>;
    static constexpr bool _Unsigned = false;
};

_EXPORT_STD template <class _Ty>
struct is_signed : bool_constant<_Sign_base<_Ty>::_Signed> {}; // determine whether _Ty is a signed type

_EXPORT_STD template <class _Ty>
_INLINE_VAR constexpr bool is_signed_v = _Sign_base<_Ty>::_Signed;

_EXPORT_STD template <class _Ty>
struct is_unsigned : bool_constant<_Sign_base<_Ty>::_Unsigned> {}; // determine whether _Ty is an unsigned type

_EXPORT_STD template <class _Ty>
_INLINE_VAR constexpr bool is_unsigned_v = _Sign_base<_Ty>::_Unsigned;

template <class _Ty>
_INLINE_VAR constexpr bool _Is_nonbool_integral = is_integral_v<_Ty> && !is_same_v<remove_cv_t<_Ty>, bool>;

template <bool>
struct _Select { // Select between aliases that extract either their first or second parameter
    template <class _Ty1, class>
    using _Apply = _Ty1;
};

template <>
struct _Select<false> {
    template <class, class _Ty2>
    using _Apply = _Ty2;
};

template <size_t>
struct _Make_signed2; // Choose make_signed strategy by type size

template <>
struct _Make_signed2<1> {
    template <class>
    using _Apply = signed char;
};

template <>
struct _Make_signed2<2> {
    template <class>
    using _Apply = short;
};

template <>
struct _Make_signed2<4> {
    template <class _Ty>
    using _Apply = // assumes LLP64
        typename _Select<is_same_v<_Ty, long> || is_same_v<_Ty, unsigned long>>::template _Apply<long, int>;
};

template <>
struct _Make_signed2<8> {
    template <class>
    using _Apply = long long;
};

template <class _Ty>
using _Make_signed1 = // signed partner to cv-unqualified _Ty
typename _Make_signed2<sizeof(_Ty)>::template _Apply<_Ty>;

_EXPORT_STD template <class _Ty>
struct make_signed { // signed partner to _Ty
    static_assert(_Is_nonbool_integral<_Ty> || is_enum_v<_Ty>,
        "make_signed<T> requires that T shall be a (possibly cv-qualified) "
        "integral type or enumeration but not a bool type.");

    using type = typename remove_cv<_Ty>::template _Apply<_Make_signed1>;
};

_EXPORT_STD template <class _Ty>
using make_signed_t = typename make_signed<_Ty>::type;

template <size_t>
struct _Make_unsigned2; // Choose make_unsigned strategy by type size

template <>
struct _Make_unsigned2<1> {
    template <class>
    using _Apply = unsigned char;
};

template <>
struct _Make_unsigned2<2> {
    template <class>
    using _Apply = unsigned short;
};

template <>
struct _Make_unsigned2<4> {
    template <class _Ty>
    using _Apply = // assumes LLP64
        typename _Select<is_same_v<_Ty, long> || is_same_v<_Ty, unsigned long>>::template _Apply<unsigned long,
        unsigned int>;
};

template <>
struct _Make_unsigned2<8> {
    template <class>
    using _Apply = unsigned long long;
};

template <class _Ty>
using _Make_unsigned1 = // unsigned partner to cv-unqualified _Ty
typename _Make_unsigned2<sizeof(_Ty)>::template _Apply<_Ty>;

_EXPORT_STD template <class _Ty>
struct make_unsigned { // unsigned partner to _Ty
    static_assert(_Is_nonbool_integral<_Ty> || is_enum_v<_Ty>,
        "make_unsigned<T> requires that T shall be a (possibly cv-qualified) "
        "integral type or enumeration but not a bool type.");

    using type = typename remove_cv<_Ty>::template _Apply<_Make_unsigned1>;
};

_EXPORT_STD template <class _Ty>
using make_unsigned_t = typename make_unsigned<_Ty>::type;

template <class _Rep>
constexpr make_unsigned_t<_Rep> _Unsigned_value(_Rep _Val) { // makes _Val unsigned
    return static_cast<make_unsigned_t<_Rep>>(_Val);
}

_EXPORT_STD template <class _Ty>
struct alignment_of : integral_constant<size_t, alignof(_Ty)> {}; // determine alignment of _Ty

_EXPORT_STD template <class _Ty>
_INLINE_VAR constexpr size_t alignment_of_v = alignof(_Ty);

template <class _Ty, size_t _Len>
union _Align_type { // union with size _Len bytes and alignment of _Ty
    _Ty _Val;
    char _Pad[_Len];
};

template <size_t _Len, size_t _Align, class _Ty, bool _Ok>
struct _Aligned; // define type with size _Len and alignment _Ty

template <size_t _Len, size_t _Align, class _Ty>
struct _Aligned<_Len, _Align, _Ty, true> {
    using type = _Align_type<_Ty, _Len>;
};

template <size_t _Len, size_t _Align>
struct _Aligned<_Len, _Align, double, false> {
#ifdef _ENABLE_EXTENDED_ALIGNED_STORAGE
    struct type {
        alignas(_Align) char _Space[_Len];
    };
#else // ^^^ defined(_ENABLE_EXTENDED_ALIGNED_STORAGE) / !defined(_ENABLE_EXTENDED_ALIGNED_STORAGE) vvv
#ifndef _DISABLE_EXTENDED_ALIGNED_STORAGE
    static_assert(_Always_false<_Aligned>,
        "You've instantiated std::aligned_storage<Len, Align> with an extended alignment (in other "
        "words, Align > alignof(max_align_t)). Before VS 2017 15.8, the member \"type\" would "
        "non-conformingly have an alignment of only alignof(max_align_t). VS 2017 15.8 was fixed to "
        "handle this correctly, but the fix inherently changes layout and breaks binary compatibility "
        "(*only* for uses of aligned_storage with extended alignments). "
        "To suppress this error, please define either "
        "(1) _ENABLE_EXTENDED_ALIGNED_STORAGE to confirm that you want a type with an extended alignment, or "
        "(2) _DISABLE_EXTENDED_ALIGNED_STORAGE to get the old non-conforming behavior.");
#endif // ^^^ !defined(_DISABLE_EXTENDED_ALIGNED_STORAGE) ^^^
    using type = _Align_type<max_align_t, _Len>;
#endif // ^^^ !defined(_ENABLE_EXTENDED_ALIGNED_STORAGE) ^^^
};

template <size_t _Len, size_t _Align>
struct _Aligned<_Len, _Align, int, false> {
    using _Next = double;
    static constexpr bool _Fits = _Align <= alignof(_Next);
    using type = typename _Aligned<_Len, _Align, _Next, _Fits>::type;
};

template <size_t _Len, size_t _Align>
struct _Aligned<_Len, _Align, short, false> {
    using _Next = int;
    static constexpr bool _Fits = _Align <= alignof(_Next);
    using type = typename _Aligned<_Len, _Align, _Next, _Fits>::type;
};

template <size_t _Len, size_t _Align>
struct _Aligned<_Len, _Align, char, false> {
    using _Next = short;
    static constexpr bool _Fits = _Align <= alignof(_Next);
    using type = typename _Aligned<_Len, _Align, _Next, _Fits>::type;
};

// TRANSITION, ABI: Internal non-deprecated version to avoid ABI changes due to deprecation
template <size_t _Len, size_t _Align = alignof(max_align_t)>
struct _Aligned_storage { // define type with size _Len and alignment _Align
    using _Next = char;
    static constexpr bool _Fits = _Align <= alignof(_Next);
    using type = typename _Aligned<_Len, _Align, _Next, _Fits>::type;
};

template <size_t _Len, size_t _Align = alignof(max_align_t)>
using _Aligned_storage_t = typename _Aligned_storage<_Len, _Align>::type;

_EXPORT_STD template <size_t _Len, size_t _Align = alignof(max_align_t)>
struct _CXX23_DEPRECATE_ALIGNED_STORAGE aligned_storage { // define type with size _Len and alignment _Align
    using type = _Aligned_storage_t<_Len, _Align>;
};

_EXPORT_STD template <size_t _Len, size_t _Align = alignof(max_align_t)>
using aligned_storage_t _CXX23_DEPRECATE_ALIGNED_STORAGE = _Aligned_storage_t<_Len, _Align>;

template <size_t... _Vals>
struct _Maximum;

template <>
struct _Maximum<> : integral_constant<size_t, 0> {}; // maximum of nothing is 0

template <size_t _Val>
struct _Maximum<_Val> : integral_constant<size_t, _Val> {}; // maximum of _Val is _Val

template <size_t _First, size_t _Second, size_t... _Rest>
struct _Maximum<_First, _Second, _Rest...> : _Maximum<(_First < _Second ? _Second : _First), _Rest...>::type{
    // find maximum value in _First, _Second, _Rest...
};

_EXPORT_STD template <size_t _Len, class... _Types>
struct _CXX23_DEPRECATE_ALIGNED_UNION aligned_union {
    // define type with size at least _Len, for storing anything in _Types
    static constexpr size_t _Max_len = _Maximum<_Len, sizeof(_Types)...>::value; // NOT sizeof...(_Types)
    static constexpr size_t alignment_value = _Maximum<alignof(_Types)...>::value;

    using type = _Aligned_storage_t<_Max_len, alignment_value>;
};

_STL_DISABLE_DEPRECATED_WARNING
_EXPORT_STD template <size_t _Len, class... _Types>
using aligned_union_t _CXX23_DEPRECATE_ALIGNED_UNION = typename aligned_union<_Len, _Types...>::type;
_STL_RESTORE_DEPRECATED_WARNING

template <class _Ty, bool = is_enum_v<_Ty>>
struct _Underlying_type {
    using type = __underlying_type(_Ty);
};

template <class _Ty>
struct _Underlying_type<_Ty, false> {};

_EXPORT_STD template <class _Ty>
struct underlying_type : _Underlying_type<_Ty> {}; // determine underlying type for enum

_EXPORT_STD template <class _Ty>
using underlying_type_t = typename _Underlying_type<_Ty>::type;

_EXPORT_STD template <class _Ty>
_INLINE_VAR constexpr size_t rank_v = 0; // determine number of dimensions of array _Ty

template <class _Ty, size_t _Nx>
_INLINE_VAR constexpr size_t rank_v<_Ty[_Nx]> = rank_v<_Ty> +1;

template <class _Ty>
_INLINE_VAR constexpr size_t rank_v<_Ty[]> = rank_v<_Ty> +1;

_EXPORT_STD template <class _Ty>
struct rank : integral_constant<size_t, rank_v<_Ty>> {};

_EXPORT_STD template <class _Ty, unsigned int _Ix = 0>
_INLINE_VAR constexpr size_t extent_v = 0; // determine extent of dimension _Ix of array _Ty

template <class _Ty, size_t _Nx>
_INLINE_VAR constexpr size_t extent_v<_Ty[_Nx], 0> = _Nx;

template <class _Ty, unsigned int _Ix, size_t _Nx>
_INLINE_VAR constexpr size_t extent_v<_Ty[_Nx], _Ix> = extent_v<_Ty, _Ix - 1>;

template <class _Ty, unsigned int _Ix>
_INLINE_VAR constexpr size_t extent_v<_Ty[], _Ix> = extent_v<_Ty, _Ix - 1>;

_EXPORT_STD template <class _Ty, unsigned int _Ix = 0>
struct extent : integral_constant<size_t, extent_v<_Ty, _Ix>> {};

_EXPORT_STD template <class _Base, class _Derived>
struct is_base_of : bool_constant<__is_base_of(_Base, _Derived)> {
    // determine whether _Base is a base of or the same as _Derived
};

_EXPORT_STD template <class _Base, class _Derived>
_INLINE_VAR constexpr bool is_base_of_v = __is_base_of(_Base, _Derived);

_EXPORT_STD template <class _Ty>
struct decay { // determines decayed version of _Ty
    using _Ty1 = remove_reference_t<_Ty>;
    using _Ty2 = typename _Select<is_function_v<_Ty1>>::template _Apply<add_pointer<_Ty1>, remove_cv<_Ty1>>;
    using type = typename _Select<is_array_v<_Ty1>>::template _Apply<add_pointer<remove_extent_t<_Ty1>>, _Ty2>::type;
};

_EXPORT_STD template <class _Ty>
using decay_t = typename decay<_Ty>::type;

template <class _Ty1, class _Ty2>
using _Conditional_type = decltype(false ? _STD declval<_Ty1>() : _STD declval<_Ty2>());

template <class _Ty1, class _Ty2, class = void>
struct _Decayed_cond_oper {};

template <class _Ty1, class _Ty2>
struct _Decayed_cond_oper<_Ty1, _Ty2, void_t<_Conditional_type<_Ty1, _Ty2>>> {
    using type = decay_t<_Conditional_type<_Ty1, _Ty2>>;
};

_EXPORT_STD template <class... _Ty>
struct common_type;

_EXPORT_STD template <class... _Ty>
using common_type_t = typename common_type<_Ty...>::type;

template <>
struct common_type<> {};

template <class _Ty1>
struct common_type<_Ty1> : common_type<_Ty1, _Ty1> {};

template <class _Ty1, class _Ty2, class _Decayed1 = decay_t<_Ty1>, class _Decayed2 = decay_t<_Ty2>>
struct _Common_type2 : common_type<_Decayed1, _Decayed2> {};

template <class _Ty1, class _Ty2>
struct _Common_type2<_Ty1, _Ty2, _Ty1, _Ty2> : _Decayed_cond_oper<_Ty1, _Ty2> {};

template <class _Ty1, class _Ty2>
struct common_type<_Ty1, _Ty2> : _Common_type2<_Ty1, _Ty2> {};

template <class _Void, class _Ty1, class _Ty2, class... _Rest>
struct _Common_type3 {};

template <class _Ty1, class _Ty2, class... _Rest>
struct _Common_type3<void_t<common_type_t<_Ty1, _Ty2>>, _Ty1, _Ty2, _Rest...>
    : common_type<common_type_t<_Ty1, _Ty2>, _Rest...> {};

template <class _Ty1, class _Ty2, class... _Rest>
struct common_type<_Ty1, _Ty2, _Rest...> : _Common_type3<void, _Ty1, _Ty2, _Rest...> {};

template <class _Ty>
_Ty _Returns_exactly() noexcept; // not defined


template <class _Type, template <class...> class _Template>
_INLINE_VAR constexpr bool _Is_specialization_v = false; // true if and only if _Type is a specialization of _Template
template <template <class...> class _Template, class... _Types>
_INLINE_VAR constexpr bool _Is_specialization_v<_Template<_Types...>, _Template> = true;

template <class _Type, template <class...> class _Template>
struct _Is_specialization : bool_constant<_Is_specialization_v<_Type, _Template>> {};

_EXPORT_STD template <class _Ty>
_NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {
    return static_cast<_Ty&&>(_Arg);
}

_EXPORT_STD template <class _Ty>
_NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>&& _Arg) noexcept {
    static_assert(!is_lvalue_reference_v<_Ty>, "bad forward call");
    return static_cast<_Ty&&>(_Arg);
}

_EXPORT_STD template <class _Ty>
_NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {
    return static_cast<remove_reference_t<_Ty>&&>(_Arg);
}

_EXPORT_STD template <class _Ty>
_NODISCARD _MSVC_INTRINSIC constexpr //
conditional_t<!is_nothrow_move_constructible_v<_Ty>&& is_copy_constructible_v<_Ty>, const _Ty&, _Ty&&>
move_if_noexcept(_Ty& _Arg) noexcept {
    return _STD move(_Arg);
}

_EXPORT_STD template <class _Ty>
_NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {
    return __builtin_addressof(_Val);
}

_EXPORT_STD template <class _Ty>
const _Ty* addressof(const _Ty&&) = delete;

#pragma warning(push)
#pragma warning(disable : 5215) // '%s' a function parameter with a volatile qualified type is deprecated in C++20
#pragma warning(disable : 5216) // '%s' a volatile qualified return type is deprecated in C++20

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-volatile"
#endif // defined(__clang__)

template <class _Ty>
_NODISCARD _Ty _Fake_copy_init(_Ty) noexcept;
// _Fake_copy_init<T>(E):
// (1) has type T [decay_t<decltype((E))> if T is deduced],
// (2) is well-formed if and only if E is implicitly convertible to T and T is destructible, and
// (3) is non-throwing if and only if both conversion from decltype((E)) to T and destruction of T are non-throwing.

#ifdef __clang__
#pragma clang diagnostic pop
#endif // defined(__clang__)

#pragma warning(pop)

_EXPORT_STD template <class _Ty>
class reference_wrapper;

// std::invoke isn't constexpr in C++17, and normally implementers are forbidden from "strengthening" constexpr
// (N4950 [constexpr.functions]/1), yet both std::apply and std::visit are required to be constexpr and have
// invoke-like behavior. As a result, we've chosen to apply the part of P1065R2 resolving LWG-2894 as a defect report.

enum class _Invoker_strategy {
    _Functor,
    _Pmf_object,
    _Pmf_refwrap,
    _Pmf_pointer,
    _Pmd_object,
    _Pmd_refwrap,
    _Pmd_pointer
};

struct _Invoker_functor {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Functor;

    template <class _Callable, class... _Types>
    static constexpr auto _Call(_Callable&& _Obj, _Types&&... _Args) noexcept(
        noexcept(static_cast<_Callable&&>(_Obj)(static_cast<_Types&&>(_Args)...)))
        -> decltype(static_cast<_Callable&&>(_Obj)(static_cast<_Types&&>(_Args)...)) {
        return static_cast<_Callable&&>(_Obj)(static_cast<_Types&&>(_Args)...);
    }
};

struct _Invoker_pmf_object {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmf_object;

    template <class _Decayed, class _Ty1, class... _Types2>
    static constexpr auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2) noexcept(
        noexcept((static_cast<_Ty1&&>(_Arg1).*_Pmf)(static_cast<_Types2&&>(_Args2)...)))
        -> decltype((static_cast<_Ty1&&>(_Arg1).*_Pmf)(static_cast<_Types2&&>(_Args2)...)) {
        return (static_cast<_Ty1&&>(_Arg1).*_Pmf)(static_cast<_Types2&&>(_Args2)...);
    }
};

struct _Invoker_pmf_refwrap {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmf_refwrap;

    template <class _Decayed, class _Refwrap, class... _Types2>
    static constexpr auto _Call(_Decayed _Pmf, _Refwrap _Rw, _Types2&&... _Args2) noexcept(
        noexcept((_Rw.get().*_Pmf)(static_cast<_Types2&&>(_Args2)...)))
        -> decltype((_Rw.get().*_Pmf)(static_cast<_Types2&&>(_Args2)...)) {
        return (_Rw.get().*_Pmf)(static_cast<_Types2&&>(_Args2)...);
    }
};

struct _Invoker_pmf_pointer {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmf_pointer;

    template <class _Decayed, class _Ty1, class... _Types2>
    static constexpr auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2) noexcept(
        noexcept(((*static_cast<_Ty1&&>(_Arg1)).*_Pmf)(static_cast<_Types2&&>(_Args2)...)))
        -> decltype(((*static_cast<_Ty1&&>(_Arg1)).*_Pmf)(static_cast<_Types2&&>(_Args2)...)) {
        return ((*static_cast<_Ty1&&>(_Arg1)).*_Pmf)(static_cast<_Types2&&>(_Args2)...);
    }
};

struct _Invoker_pmd_object {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmd_object;

    template <class _Decayed, class _Ty1>
    static constexpr auto _Call(_Decayed _Pmd, _Ty1&& _Arg1) noexcept -> decltype(static_cast<_Ty1&&>(_Arg1).*_Pmd) {
        return static_cast<_Ty1&&>(_Arg1).*_Pmd;
    }
};

struct _Invoker_pmd_refwrap {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmd_refwrap;

    template <class _Decayed, class _Refwrap>
    static constexpr auto _Call(_Decayed _Pmd, _Refwrap _Rw) noexcept -> decltype(_Rw.get().*_Pmd) {
        return _Rw.get().*_Pmd;
    }
};

struct _Invoker_pmd_pointer {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmd_pointer;

    template <class _Decayed, class _Ty1>
    static constexpr auto _Call(_Decayed _Pmd, _Ty1&& _Arg1) noexcept(noexcept((*static_cast<_Ty1&&>(_Arg1)).*_Pmd))
        -> decltype((*static_cast<_Ty1&&>(_Arg1)).*_Pmd) {
        return (*static_cast<_Ty1&&>(_Arg1)).*_Pmd;
    }
};

template <class _Callable, class _Ty1, class _Removed_cvref = _Remove_cvref_t<_Callable>,
    bool _Is_pmf = is_member_function_pointer_v<_Removed_cvref>,
    bool _Is_pmd = is_member_object_pointer_v<_Removed_cvref>>
    struct _Invoker1;

template <class _Callable, class _Ty1, class _Removed_cvref>
struct _Invoker1<_Callable, _Ty1, _Removed_cvref, true, false>
    : conditional_t<is_same_v<typename _Is_memfunptr<_Removed_cvref>::_Class_type, _Remove_cvref_t<_Ty1>>
    || is_base_of_v<typename _Is_memfunptr<_Removed_cvref>::_Class_type, _Remove_cvref_t<_Ty1>>,
    _Invoker_pmf_object,
    conditional_t<_Is_specialization_v<_Remove_cvref_t<_Ty1>, reference_wrapper>, _Invoker_pmf_refwrap,
    _Invoker_pmf_pointer>> {}; // pointer to member function

template <class _Callable, class _Ty1, class _Removed_cvref>
struct _Invoker1<_Callable, _Ty1, _Removed_cvref, false, true>
    : conditional_t<
    is_same_v<typename _Is_member_object_pointer<_Removed_cvref>::_Class_type, _Remove_cvref_t<_Ty1>>
    || is_base_of_v<typename _Is_member_object_pointer<_Removed_cvref>::_Class_type, _Remove_cvref_t<_Ty1>>,
    _Invoker_pmd_object,
    conditional_t<_Is_specialization_v<_Remove_cvref_t<_Ty1>, reference_wrapper>, _Invoker_pmd_refwrap,
    _Invoker_pmd_pointer>> {}; // pointer to member data

template <class _Callable, class _Ty1, class _Removed_cvref>
struct _Invoker1<_Callable, _Ty1, _Removed_cvref, false, false> : _Invoker_functor {};

_EXPORT_STD template <class _Callable>
constexpr auto invoke(_Callable&& _Obj) noexcept(noexcept(static_cast<_Callable&&>(_Obj)()))
-> decltype(static_cast<_Callable&&>(_Obj)()) {
    return static_cast<_Callable&&>(_Obj)();
}

_EXPORT_STD template <class _Callable, class _Ty1, class... _Types2>
constexpr auto invoke(_Callable&& _Obj, _Ty1&& _Arg1, _Types2&&... _Args2) noexcept(
    noexcept(_Invoker1<_Callable, _Ty1>::_Call(
        static_cast<_Callable&&>(_Obj), static_cast<_Ty1&&>(_Arg1), static_cast<_Types2&&>(_Args2)...)))
    -> decltype(_Invoker1<_Callable, _Ty1>::_Call(
        static_cast<_Callable&&>(_Obj), static_cast<_Ty1&&>(_Arg1), static_cast<_Types2&&>(_Args2)...)) {
    if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Functor) {
        return static_cast<_Callable&&>(_Obj)(static_cast<_Ty1&&>(_Arg1), static_cast<_Types2&&>(_Args2)...);
    }
    else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmf_object) {
        return (static_cast<_Ty1&&>(_Arg1).*_Obj)(static_cast<_Types2&&>(_Args2)...);
    }
    else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmf_refwrap) {
        return (_Arg1.get().*_Obj)(static_cast<_Types2&&>(_Args2)...);
    }
    else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmf_pointer) {
        return ((*static_cast<_Ty1&&>(_Arg1)).*_Obj)(static_cast<_Types2&&>(_Args2)...);
    }
    else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmd_object) {
        return static_cast<_Ty1&&>(_Arg1).*_Obj;
    }
    else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmd_refwrap) {
#if defined(__clang__) || defined(__EDG__) // TRANSITION, VSO-1956799
        return _Arg1.get().*_Obj;
#else // ^^^ no workaround / workaround vvv
        auto& _Ref = _Arg1.get();
        return _Ref.*_Obj;
#endif // ^^^ workaround ^^^
    }
    else {
        _STL_INTERNAL_STATIC_ASSERT(_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmd_pointer);
        return (*static_cast<_Ty1&&>(_Arg1)).*_Obj;
    }
}

#pragma warning(push)
#pragma warning(disable : 4242) // '%s': conversion from '%s' to '%s', possible loss of data (/Wall)
#pragma warning(disable : 4244) // '%s': conversion from '%s' to '%s', possible loss of data (Yes, duplicated message.)
#pragma warning(disable : 4365) // '%s': conversion from '%s' to '%s', signed/unsigned mismatch (/Wall)

template <class _From, class _To, bool = is_convertible_v<_From, _To>, bool = is_void_v<_To>>
_INLINE_VAR constexpr bool _Is_nothrow_convertible_v = noexcept(_STD _Fake_copy_init<_To>(_STD declval<_From>()));

#pragma warning(pop)

template <class _From, class _To, bool _IsVoid>
_INLINE_VAR constexpr bool _Is_nothrow_convertible_v<_From, _To, false, _IsVoid> = false;

template <class _From, class _To>
_INLINE_VAR constexpr bool _Is_nothrow_convertible_v<_From, _To, true, true> = true;

template <class _From, class _To>
struct _Is_nothrow_convertible : bool_constant<_Is_nothrow_convertible_v<_From, _To>> {
    // determine whether _From is nothrow-convertible to _To
};

#if _HAS_CXX20
_EXPORT_STD template <class _From, class _To>
inline constexpr bool is_nothrow_convertible_v = _Is_nothrow_convertible_v<_From, _To>;

_EXPORT_STD template <class _From, class _To>
struct is_nothrow_convertible : bool_constant<_Is_nothrow_convertible_v<_From, _To>> {};
#endif // _HAS_CXX20

template <class _From, class _To, class = void>
struct _Invoke_convertible : false_type {};

template <class _From, class _To>
struct _Invoke_convertible<_From, _To, void_t<decltype(_STD _Fake_copy_init<_To>(_STD _Returns_exactly<_From>()))>>
    : true_type {};

template <class _From, class _To>
struct _Invoke_nothrow_convertible
    : bool_constant<noexcept(_STD _Fake_copy_init<_To>(_STD _Returns_exactly<_From>()))> {};

template <class _Result, bool _Nothrow>
struct _Invoke_traits_common {
    using type = _Result;
    using _Is_invocable = true_type;
    using _Is_nothrow_invocable = bool_constant<_Nothrow>;
    template <class _Rx>
    using _Is_invocable_r = bool_constant<disjunction_v<is_void<_Rx>, _Invoke_convertible<type, _Rx>>>;
    template <class _Rx>
    using _Is_nothrow_invocable_r = bool_constant<conjunction_v<_Is_nothrow_invocable,
        disjunction<is_void<_Rx>,
        conjunction<_Invoke_convertible<type, _Rx>, _Invoke_nothrow_convertible<type, _Rx>>>>>;
};

template <class _Void, class _Callable>
struct _Invoke_traits_zero {
    // selected when _Callable isn't callable with zero _Args
    using _Is_invocable = false_type;
    using _Is_nothrow_invocable = false_type;
    template <class _Rx>
    using _Is_invocable_r = false_type;
    template <class _Rx>
    using _Is_nothrow_invocable_r = false_type;
};

template <class _Callable>
using _Decltype_invoke_zero = decltype(_STD declval<_Callable>()());

template <class _Callable>
struct _Invoke_traits_zero<void_t<_Decltype_invoke_zero<_Callable>>, _Callable>
    : _Invoke_traits_common<_Decltype_invoke_zero<_Callable>, noexcept(_STD declval<_Callable>()())> {};

template <class _Void, class... _Types>
struct _Invoke_traits_nonzero {
    // selected when _Callable isn't callable with nonzero _Args
    using _Is_invocable = false_type;
    using _Is_nothrow_invocable = false_type;
    template <class _Rx>
    using _Is_invocable_r = false_type;
    template <class _Rx>
    using _Is_nothrow_invocable_r = false_type;
};

template <class _Callable, class _Ty1, class... _Types2>
using _Decltype_invoke_nonzero = decltype(_Invoker1<_Callable, _Ty1>::_Call(
    _STD declval<_Callable>(), _STD declval<_Ty1>(), _STD declval<_Types2>()...));

template <class _Callable, class _Ty1, class... _Types2>
struct _Invoke_traits_nonzero<void_t<_Decltype_invoke_nonzero<_Callable, _Ty1, _Types2...>>, _Callable, _Ty1,
    _Types2...> : _Invoke_traits_common<_Decltype_invoke_nonzero<_Callable, _Ty1, _Types2...>,
    noexcept(_Invoker1<_Callable, _Ty1>::_Call(
        _STD declval<_Callable>(), _STD declval<_Ty1>(), _STD declval<_Types2>()...))> {};

template <class _Callable, class... _Args>
using _Select_invoke_traits = conditional_t<sizeof...(_Args) == 0, _Invoke_traits_zero<void, _Callable>,
    _Invoke_traits_nonzero<void, _Callable, _Args...>>;

#if _HAS_DEPRECATED_RESULT_OF
_EXPORT_STD template <class _Fty>
struct _CXX17_DEPRECATE_RESULT_OF result_of { // explain usage
    static_assert(_Always_false<_Fty>, "result_of<CallableType> is invalid; use "
        "result_of<CallableType(zero or more argument types)> instead.");
};

#define _RESULT_OF(CALL_OPT, X1, X2, X3)                                                                    \
    template <class _Callable, class... _Args>                                                              \
    struct _CXX17_DEPRECATE_RESULT_OF result_of<_Callable CALL_OPT(_Args...)>                               \
        : _Select_invoke_traits<_Callable, _Args...> { /* template to determine result of call operation */ \
    };

_NON_MEMBER_CALL(_RESULT_OF, X1, X2, X3)
#undef _RESULT_OF

_STL_DISABLE_DEPRECATED_WARNING
_EXPORT_STD template <class _Ty>
using result_of_t _CXX17_DEPRECATE_RESULT_OF = typename result_of<_Ty>::type;
_STL_RESTORE_DEPRECATED_WARNING
#endif // _HAS_DEPRECATED_RESULT_OF

template <class _Callable, class... _Args>
using _Invoke_result_t = typename _Select_invoke_traits<_Callable, _Args...>::type;

template <class _Rx, class _Callable, class... _Args>
using _Is_invocable_r_ = typename _Select_invoke_traits<_Callable, _Args...>::template _Is_invocable_r<_Rx>;

template <class _Rx, class _Callable, class... _Args>
struct _Is_invocable_r : _Is_invocable_r_<_Rx, _Callable, _Args...> {
    // determines whether _Callable is callable with _Args and return type _Rx
};

#if _HAS_CXX17
_EXPORT_STD template <class _Callable, class... _Args>
struct invoke_result : _Select_invoke_traits<_Callable, _Args...> {
    // determine the result type of invoking _Callable with _Args
};

_EXPORT_STD template <class _Callable, class... _Args>
using invoke_result_t = typename _Select_invoke_traits<_Callable, _Args...>::type;

_EXPORT_STD template <class _Callable, class... _Args>
struct is_invocable : _Select_invoke_traits<_Callable, _Args...>::_Is_invocable {
    // determines whether _Callable is callable with _Args
};

_EXPORT_STD template <class _Callable, class... _Args>
inline constexpr bool is_invocable_v = _Select_invoke_traits<_Callable, _Args...>::_Is_invocable::value;

_EXPORT_STD template <class _Callable, class... _Args>
struct is_nothrow_invocable : _Select_invoke_traits<_Callable, _Args...>::_Is_nothrow_invocable {
    // determines whether _Callable is nothrow-callable with _Args
};

_EXPORT_STD template <class _Callable, class... _Args>
inline constexpr bool is_nothrow_invocable_v = _Select_invoke_traits<_Callable, _Args...>::_Is_nothrow_invocable::value;

_EXPORT_STD template <class _Rx, class _Callable, class... _Args>
struct is_invocable_r : _Is_invocable_r_<_Rx, _Callable, _Args...> {
    // determines whether _Callable is callable with _Args and return type _Rx
};

_EXPORT_STD template <class _Rx, class _Callable, class... _Args>
inline constexpr bool is_invocable_r_v = _Is_invocable_r_<_Rx, _Callable, _Args...>::value;

_EXPORT_STD template <class _Rx, class _Callable, class... _Args>
struct is_nothrow_invocable_r : _Select_invoke_traits<_Callable, _Args...>::template _Is_nothrow_invocable_r<_Rx> {
    // determines whether _Callable is nothrow-callable with _Args and return type _Rx
};

_EXPORT_STD template <class _Rx, class _Callable, class... _Args>
inline constexpr bool is_nothrow_invocable_r_v =
_Select_invoke_traits<_Callable, _Args...>::template _Is_nothrow_invocable_r<_Rx>::value;
#endif // _HAS_CXX17

#if _HAS_CXX20
#ifndef __clang__ // TRANSITION, LLVM-48860
_EXPORT_STD template <class _Ty1, class _Ty2>
struct is_layout_compatible : bool_constant<__is_layout_compatible(_Ty1, _Ty2)> {};

_EXPORT_STD template <class _Ty1, class _Ty2>
inline constexpr bool is_layout_compatible_v = __is_layout_compatible(_Ty1, _Ty2);

_EXPORT_STD template <class _Base, class _Derived>
struct is_pointer_interconvertible_base_of : bool_constant<__is_pointer_interconvertible_base_of(_Base, _Derived)> {};

_EXPORT_STD template <class _Base, class _Derived>
inline constexpr bool is_pointer_interconvertible_base_of_v = __is_pointer_interconvertible_base_of(_Base, _Derived);

_EXPORT_STD template <class _ClassTy, class _MemberTy>
_NODISCARD constexpr bool is_pointer_interconvertible_with_class(_MemberTy _ClassTy::* _Pm) noexcept {
    return __is_pointer_interconvertible_with_class(_ClassTy, _Pm);
}

_EXPORT_STD template <class _ClassTy1, class _ClassTy2, class _MemberTy1, class _MemberTy2>
_NODISCARD constexpr bool is_corresponding_member(_MemberTy1 _ClassTy1::* _Pm1, _MemberTy2 _ClassTy2::* _Pm2) noexcept {
    return __is_corresponding_member(_ClassTy1, _ClassTy2, _Pm1, _Pm2);
}
#endif // ^^^ no workaround ^^^
#endif // _HAS_CXX20

template <class _Ty>
struct _Function_args {}; // determine whether _Ty is a function

#define _FUNCTION_ARGS(CALL_OPT, CV_OPT, REF_OPT, NOEXCEPT_OPT)                                           \
    template <class _Ret, class... _Types>                                                                \
    struct _Function_args<_Ret CALL_OPT(_Types...) CV_OPT REF_OPT NOEXCEPT_OPT> : _Arg_types<_Types...> { \
        using _RESULT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = _Ret;                                 \
    };

_NON_MEMBER_CALL_CV_REF_NOEXCEPT(_FUNCTION_ARGS)
#undef _FUNCTION_ARGS

#define _FUNCTION_ARGS_ELLIPSIS(CV_REF_NOEXCEPT_OPT)                                                            \
    template <class _Ret, class... _Types>                                                                      \
    struct _Function_args<_Ret(_Types..., ...) CV_REF_NOEXCEPT_OPT> { /* no calling conventions for ellipsis */ \
        using _RESULT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = _Ret;                                       \
    };

_CLASS_DEFINE_CV_REF_NOEXCEPT(_FUNCTION_ARGS_ELLIPSIS)
#undef _FUNCTION_ARGS_ELLIPSIS

template <class _Ty, class = void>
struct _Weak_result_type {}; // default definition

_STL_DISABLE_DEPRECATED_WARNING
template <class _Ty>
struct _Weak_result_type<_Ty, void_t<typename _Ty::result_type>> { // defined if _Ty::result_type exists
    using _RESULT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = typename _Ty::result_type;
};
_STL_RESTORE_DEPRECATED_WARNING

template <class _Ty, class = void>
struct _Weak_argument_type : _Weak_result_type<_Ty> {}; // default definition

_STL_DISABLE_DEPRECATED_WARNING
template <class _Ty>
struct _Weak_argument_type<_Ty, void_t<typename _Ty::argument_type>> : _Weak_result_type<_Ty> {
    // defined if _Ty::argument_type exists
    using _ARGUMENT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = typename _Ty::argument_type;
};
_STL_RESTORE_DEPRECATED_WARNING

template <class _Ty, class = void>
struct _Weak_binary_args : _Weak_argument_type<_Ty> {}; // default definition

_STL_DISABLE_DEPRECATED_WARNING
template <class _Ty>
struct _Weak_binary_args<_Ty, void_t<typename _Ty::first_argument_type,
    typename _Ty::second_argument_type>>
    : _Weak_argument_type<_Ty> { // defined if both types exist
    using _FIRST_ARGUMENT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = typename _Ty::first_argument_type;
    using _SECOND_ARGUMENT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = typename _Ty::second_argument_type;
};
_STL_RESTORE_DEPRECATED_WARNING

template <class _Ty>
using _Weak_types = conditional_t<is_function_v<remove_pointer_t<_Ty>>, _Function_args<remove_pointer_t<_Ty>>,
    conditional_t<is_member_function_pointer_v<_Ty>, _Is_memfunptr<remove_cv_t<_Ty>>, _Weak_binary_args<_Ty>>>;

template <class _Ty>
void _Refwrap_ctor_fun(_Identity_t<_Ty&>) noexcept; // not defined
template <class _Ty>
void _Refwrap_ctor_fun(_Identity_t<_Ty&&>) = delete;

template <class _Ty, class _Uty, class = void>
struct _Refwrap_has_ctor_from : false_type {};

template <class _Ty, class _Uty>
struct _Refwrap_has_ctor_from<_Ty, _Uty, void_t<decltype(_STD _Refwrap_ctor_fun<_Ty>(_STD declval<_Uty>()))>>
    : true_type {}; // _STD _Refwrap_ctor_fun is qualified: avoid ADL, handle incomplete types

_EXPORT_STD template <class _Ty>
class reference_wrapper
#if !_HAS_CXX20
    : public _Weak_types<_Ty>
#endif // !_HAS_CXX20
{
public:
    static_assert(is_object_v<_Ty> || is_function_v<_Ty>,
        "reference_wrapper<T> requires T to be an object type or a function type.");

    using type = _Ty;

    template <class _Uty, enable_if_t<conjunction_v<negation<is_same<_Remove_cvref_t<_Uty>, reference_wrapper>>,
        _Refwrap_has_ctor_from<_Ty, _Uty>>,
        int> = 0>
    _CONSTEXPR20 reference_wrapper(_Uty&& _Val) noexcept(
        noexcept(_STD _Refwrap_ctor_fun<_Ty>(_STD declval<_Uty>()))) { // qualified: avoid ADL, handle incomplete types
        _Ty& _Ref = static_cast<_Uty&&>(_Val);
        _Ptr = _STD addressof(_Ref);
    }

    _CONSTEXPR20 operator _Ty& () const noexcept {
        return *_Ptr;
    }

    _NODISCARD _CONSTEXPR20 _Ty& get() const noexcept {
        return *_Ptr;
    }

private:
    _Ty* _Ptr{};

public:
    template <class... _Types>
    _CONSTEXPR20 auto operator()(_Types&&... _Args) const
        noexcept(noexcept(_STD invoke(*_Ptr, static_cast<_Types&&>(_Args)...)))
        -> decltype(_STD invoke(*_Ptr, static_cast<_Types&&>(_Args)...)) {
        return _STD invoke(*_Ptr, static_cast<_Types&&>(_Args)...);
    }
};

#if _HAS_CXX17
template <class _Ty>
reference_wrapper(_Ty&) -> reference_wrapper<_Ty>;
#endif // _HAS_CXX17

_EXPORT_STD template <class _Ty>
_NODISCARD _CONSTEXPR20 reference_wrapper<_Ty> ref(_Ty& _Val) noexcept {
    return reference_wrapper<_Ty>(_Val);
}

_EXPORT_STD template <class _Ty>
void ref(const _Ty&&) = delete;

_EXPORT_STD template <class _Ty>
_NODISCARD _CONSTEXPR20 reference_wrapper<_Ty> ref(reference_wrapper<_Ty> _Val) noexcept {
    return _Val;
}

_EXPORT_STD template <class _Ty>
_NODISCARD _CONSTEXPR20 reference_wrapper<const _Ty> cref(const _Ty& _Val) noexcept {
    return reference_wrapper<const _Ty>(_Val);
}

_EXPORT_STD template <class _Ty>
void cref(const _Ty&&) = delete;

_EXPORT_STD template <class _Ty>
_NODISCARD _CONSTEXPR20 reference_wrapper<const _Ty> cref(reference_wrapper<_Ty> _Val) noexcept {
    return _Val;
}

#if _HAS_CXX20
_EXPORT_STD template <class _Ty>
struct unwrap_reference {
    using type = _Ty;
};
template <class _Ty>
struct unwrap_reference<reference_wrapper<_Ty>> {
    using type = _Ty&;
};
_EXPORT_STD template <class _Ty>
using unwrap_reference_t = unwrap_reference<_Ty>::type;

_EXPORT_STD template <class _Ty>
using unwrap_ref_decay_t = unwrap_reference_t<decay_t<_Ty>>;
_EXPORT_STD template <class _Ty>
struct unwrap_ref_decay {
    using type = unwrap_ref_decay_t<_Ty>;
};
#endif // _HAS_CXX20

template <class _Ty>
struct _Is_swappable;

template <class _Ty>
struct _Is_nothrow_swappable;

#if _HAS_CXX17
_EXPORT_STD template <class _Ty, enable_if_t<is_move_constructible_v<_Ty>&& is_move_assignable_v<_Ty>, int> = 0>
#else // ^^^ _HAS_CXX17 / !_HAS_CXX17 vvv
template <class _Ty, int _Enabled = 0>
#endif // ^^^ !_HAS_CXX17 ^^^
_CONSTEXPR20 void swap(_Ty&, _Ty&) noexcept(is_nothrow_move_constructible_v<_Ty>&& is_nothrow_move_assignable_v<_Ty>);

_EXPORT_STD template <class _Ty, size_t _Size, enable_if_t<_Is_swappable<_Ty>::value, int> = 0>
_CONSTEXPR20 void swap(_Ty(&)[_Size], _Ty(&)[_Size]) noexcept(_Is_nothrow_swappable<_Ty>::value);

template <class _Ty1, class _Ty2, class = void>
struct _Swappable_with_helper : false_type {}; // swap(declval<_Ty1>(), declval<_Ty2>()) is not valid

template <class _Ty1, class _Ty2>
struct _Swappable_with_helper<_Ty1, _Ty2, void_t<decltype(swap(_STD declval<_Ty1>(), _STD declval<_Ty2>()))>>
    : true_type {}; // swap(declval<_Ty1>(), declval<_Ty2>()) is valid

template <class _Ty1, class _Ty2>
struct _Is_swappable_with
    : bool_constant<conjunction_v<_Swappable_with_helper<_Ty1, _Ty2>, _Swappable_with_helper<_Ty2, _Ty1>>> {
    // Determine if expressions with type and value category _Ty1 and _Ty2 can be swapped (and vice versa)
};

template <class _Ty>
struct _Is_swappable : _Is_swappable_with<add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<_Ty>>::type {
    // Determine if _Ty lvalues satisfy is_swappable_with
};

template <class _Ty1, class _Ty2>
struct _Swap_cannot_throw : bool_constant<noexcept(swap(_STD declval<_Ty1>(), _STD declval<_Ty2>()))
    && noexcept(swap(_STD declval<_Ty2>(), _STD declval<_Ty1>()))> {
    // Determine if expressions with type and value category _Ty1 and _Ty2
    // (presumed to satisfy is_swappable_with) can be swapped without emitting exceptions
};

template <class _Ty1, class _Ty2>
struct _Is_nothrow_swappable_with
    : bool_constant<conjunction_v<_Is_swappable_with<_Ty1, _Ty2>, _Swap_cannot_throw<_Ty1, _Ty2>>> {
    // Determine if expressions with type and value category _Ty1 and _Ty2
    // satisfy is_swappable_with, and can be swapped without emitting exceptions
};

template <class _Ty>
struct _Is_nothrow_swappable
    : _Is_nothrow_swappable_with<add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<_Ty>>::type {
    // Determine if _Ty lvalues satisfy is_nothrow_swappable_with
};

#if _HAS_CXX17
_EXPORT_STD template <class _Ty1, class _Ty2>
struct is_swappable_with : _Is_swappable_with<_Ty1, _Ty2>::type {
    // Determine if expressions with type and value category _Ty1 and _Ty2
    // can be swapped (and vice versa)
};

_EXPORT_STD template <class _Ty1, class _Ty2>
inline constexpr bool is_swappable_with_v =
conjunction_v<_Swappable_with_helper<_Ty1, _Ty2>, _Swappable_with_helper<_Ty2, _Ty1>>;

_EXPORT_STD template <class _Ty>
struct is_swappable : _Is_swappable<_Ty>::type {}; // Determine if _Ty lvalues satisfy is_swappable_with

_EXPORT_STD template <class _Ty>
inline constexpr bool is_swappable_v = _Is_swappable<_Ty>::value;

_EXPORT_STD template <class _Ty1, class _Ty2>
struct is_nothrow_swappable_with : _Is_nothrow_swappable_with<_Ty1, _Ty2>::type {
    // Determine if expressions with type and value category _Ty1 and _Ty2
    // satisfy is_swappable_with, and can be swapped without emitting exceptions
};

_EXPORT_STD template <class _Ty1, class _Ty2>
inline constexpr bool is_nothrow_swappable_with_v = _Is_nothrow_swappable_with<_Ty1, _Ty2>::value;

_EXPORT_STD template <class _Ty>
struct is_nothrow_swappable : _Is_nothrow_swappable<_Ty>::type {
    // Determine if _Ty lvalues satisfy is_nothrow_swappable_with
};

_EXPORT_STD template <class _Ty>
inline constexpr bool is_nothrow_swappable_v = _Is_nothrow_swappable<_Ty>::value;
#endif // _HAS_CXX17

namespace _Has_ADL_swap_detail {
#if defined(__clang__) || defined(__EDG__) // TRANSITION, VSO-1681199
    void swap() = delete; // Block unqualified name lookup
#else // ^^^ no workaround / workaround vvv
    void swap();
#endif // ^^^ workaround ^^^

    template <class, class = void>
    struct _Has_ADL_swap : false_type {};
    template <class _Ty>
    struct _Has_ADL_swap<_Ty, void_t<decltype(swap(_STD declval<_Ty&>(), _STD declval<_Ty&>()))>> : true_type {};
} // namespace _Has_ADL_swap_detail
using _Has_ADL_swap_detail::_Has_ADL_swap;

template <class _Ty>
_INLINE_VAR constexpr bool _Is_trivially_swappable_v = conjunction_v<is_trivially_destructible<_Ty>,
    is_trivially_move_constructible<_Ty>, is_trivially_move_assignable<_Ty>, negation<_Has_ADL_swap<_Ty>>>;

#ifdef __cpp_lib_byte
template <>
inline constexpr bool _Is_trivially_swappable_v<byte> = true;
#endif // defined(__cpp_lib_byte)

template <class _Ty>
struct _Is_trivially_swappable : bool_constant<_Is_trivially_swappable_v<_Ty>> {
    // true_type if and only if it is valid to swap two _Ty lvalues by exchanging object representations.
};

#if _HAS_CXX20
_EXPORT_STD template <class _From, class _To>
concept convertible_to =
#if !defined(__clang__) && !defined(__EDG__) // TRANSITION, DevCom-1627396
is_convertible_v<_From, _To>
#else // ^^^ workaround / no workaround vvv
__is_convertible_to(_From, _To)
#endif // ^^^ no workaround ^^^
&& requires { static_cast<_To>(_STD declval<_From>()); };

template <class _RefWrap, class _Ty, class _RefWrapQ, class _TyQ>
concept _Ref_wrap_common_reference_exists_with = _Is_specialization_v<_RefWrap, reference_wrapper>&& requires {
    typename common_reference_t<typename _RefWrap::type&, _TyQ>;
}&& convertible_to<_RefWrapQ, common_reference_t<typename _RefWrap::type&, _TyQ>>;

template <class _RefWrap, class _Ty, template <class> class _RefWrapQual, template <class> class _TyQual>
    requires (_Ref_wrap_common_reference_exists_with<_RefWrap, _Ty, _RefWrapQual<_RefWrap>, _TyQual<_Ty>>
&& !_Ref_wrap_common_reference_exists_with<_Ty, _RefWrap, _TyQual<_Ty>, _RefWrapQual<_RefWrap>>)
struct basic_common_reference<_RefWrap, _Ty, _RefWrapQual, _TyQual> {
    using type = common_reference_t<typename _RefWrap::type&, _TyQual<_Ty>>;
};

template <class _Ty, class _RefWrap, template <class> class _TyQual, template <class> class _RefWrapQual>
    requires (_Ref_wrap_common_reference_exists_with<_RefWrap, _Ty, _RefWrapQual<_RefWrap>, _TyQual<_Ty>>
&& !_Ref_wrap_common_reference_exists_with<_Ty, _RefWrap, _TyQual<_Ty>, _RefWrapQual<_RefWrap>>)
struct basic_common_reference<_Ty, _RefWrap, _TyQual, _RefWrapQual> {
    using type = common_reference_t<typename _RefWrap::type&, _TyQual<_Ty>>;
};
#endif // _HAS_CXX20

#define _BITMASK_OPS(_MAYBE_EXPORT, _BITMASK)                                                         \
    _MAYBE_EXPORT _NODISCARD constexpr _BITMASK operator&(_BITMASK _Left, _BITMASK _Right) noexcept { \
        using _IntTy = _STD underlying_type_t<_BITMASK>;                                              \
        return static_cast<_BITMASK>(static_cast<_IntTy>(_Left) & static_cast<_IntTy>(_Right));       \
    }                                                                                                 \
                                                                                                      \
    _MAYBE_EXPORT _NODISCARD constexpr _BITMASK operator|(_BITMASK _Left, _BITMASK _Right) noexcept { \
        using _IntTy = _STD underlying_type_t<_BITMASK>;                                              \
        return static_cast<_BITMASK>(static_cast<_IntTy>(_Left) | static_cast<_IntTy>(_Right));       \
    }                                                                                                 \
                                                                                                      \
    _MAYBE_EXPORT _NODISCARD constexpr _BITMASK operator^(_BITMASK _Left, _BITMASK _Right) noexcept { \
        using _IntTy = _STD underlying_type_t<_BITMASK>;                                              \
        return static_cast<_BITMASK>(static_cast<_IntTy>(_Left) ^ static_cast<_IntTy>(_Right));       \
    }                                                                                                 \
                                                                                                      \
    _MAYBE_EXPORT constexpr _BITMASK& operator&=(_BITMASK& _Left, _BITMASK _Right) noexcept {         \
        return _Left = _Left & _Right;                                                                \
    }                                                                                                 \
                                                                                                      \
    _MAYBE_EXPORT constexpr _BITMASK& operator|=(_BITMASK& _Left, _BITMASK _Right) noexcept {         \
        return _Left = _Left | _Right;                                                                \
    }                                                                                                 \
                                                                                                      \
    _MAYBE_EXPORT constexpr _BITMASK& operator^=(_BITMASK& _Left, _BITMASK _Right) noexcept {         \
        return _Left = _Left ^ _Right;                                                                \
    }                                                                                                 \
                                                                                                      \
    _MAYBE_EXPORT _NODISCARD constexpr _BITMASK operator~(_BITMASK _Left) noexcept {                  \
        using _IntTy = _STD underlying_type_t<_BITMASK>;                                              \
        return static_cast<_BITMASK>(~static_cast<_IntTy>(_Left));                                    \
    }

template <class _Bitmask>
_NODISCARD constexpr bool _Bitmask_includes_any(_Bitmask _Left, _Bitmask _Elements) noexcept {
    return (_Left & _Elements) != _Bitmask{};
}

template <class _Bitmask>
_NODISCARD constexpr bool _Bitmask_includes_all(_Bitmask _Left, _Bitmask _Elements) noexcept {
    return (_Left & _Elements) == _Elements;
}

// These FNV-1a utility functions are extremely performance sensitive,
// check examples like that in VSO-653642 before making changes.
#if defined(_WIN64)
_INLINE_VAR constexpr size_t _FNV_offset_basis = 14695981039346656037ULL;
_INLINE_VAR constexpr size_t _FNV_prime = 1099511628211ULL;
#else // ^^^ defined(_WIN64) / !defined(_WIN64) vvv
_INLINE_VAR constexpr size_t _FNV_offset_basis = 2166136261U;
_INLINE_VAR constexpr size_t _FNV_prime = 16777619U;
#endif // ^^^ !defined(_WIN64) ^^^

_NODISCARD inline size_t _Fnv1a_append_bytes(size_t _Val, const unsigned char* const _First,
    const size_t _Count) noexcept { // accumulate range [_First, _First + _Count) into partial FNV-1a hash _Val
    for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {
        _Val ^= static_cast<size_t>(_First[_Idx]);
        _Val *= _FNV_prime;
    }

    return _Val;
}

template <class _Ty>
_NODISCARD size_t _Fnv1a_append_range(const size_t _Val, const _Ty* const _First,
    const _Ty* const _Last) noexcept { // accumulate range [_First, _Last) into partial FNV-1a hash _Val
    static_assert(is_trivial_v<_Ty>, "Only trivial types can be directly hashed.");
    const auto _Firstb = reinterpret_cast<const unsigned char*>(_First);
    const auto _Lastb = reinterpret_cast<const unsigned char*>(_Last);
    return _Fnv1a_append_bytes(_Val, _Firstb, static_cast<size_t>(_Lastb - _Firstb));
}

template <class _Kty>
_NODISCARD size_t _Fnv1a_append_value(
    const size_t _Val, const _Kty& _Keyval) noexcept { // accumulate _Keyval into partial FNV-1a hash _Val
    static_assert(is_trivial_v<_Kty>, "Only trivial types can be directly hashed.");
    return _Fnv1a_append_bytes(_Val, &reinterpret_cast<const unsigned char&>(_Keyval), sizeof(_Kty));
}

template <class _Kty>
_NODISCARD size_t _Hash_representation(const _Kty& _Keyval) noexcept { // bitwise hashes the representation of a key
    return _Fnv1a_append_value(_FNV_offset_basis, _Keyval);
}

template <class _Kty>
_NODISCARD size_t _Hash_array_representation(
    const _Kty* const _First, const size_t _Count) noexcept { // bitwise hashes the representation of an array
    static_assert(is_trivial_v<_Kty>, "Only trivial types can be directly hashed.");
    return _Fnv1a_append_bytes(
        _FNV_offset_basis, reinterpret_cast<const unsigned char*>(_First), _Count * sizeof(_Kty));
}

_EXPORT_STD template <class _Kty>
struct hash;

template <class _Kty, bool _Enabled>
struct _Conditionally_enabled_hash { // conditionally enabled hash base
    using _ARGUMENT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = _Kty;
    using _RESULT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = size_t;

    _NODISCARD _STATIC_CALL_OPERATOR size_t operator()(const _Kty& _Keyval) _CONST_CALL_OPERATOR
        noexcept(noexcept(hash<_Kty>::_Do_hash(_Keyval))) /* strengthened */ {
        return hash<_Kty>::_Do_hash(_Keyval);
    }
};

template <class _Kty>
struct _Conditionally_enabled_hash<_Kty, false> { // conditionally disabled hash base
    _Conditionally_enabled_hash() = delete;
    _Conditionally_enabled_hash(const _Conditionally_enabled_hash&) = delete;
    _Conditionally_enabled_hash(_Conditionally_enabled_hash&&) = delete;
    _Conditionally_enabled_hash& operator=(const _Conditionally_enabled_hash&) = delete;
    _Conditionally_enabled_hash& operator=(_Conditionally_enabled_hash&&) = delete;
};

_EXPORT_STD template <class _Kty>
struct hash : _Conditionally_enabled_hash<_Kty, !is_const_v<_Kty> && !is_volatile_v<_Kty>
    && (is_enum_v<_Kty> || is_integral_v<_Kty> || is_pointer_v<_Kty>)> {
    // hash functor primary template (handles enums, integrals, and pointers)
    static size_t _Do_hash(const _Kty& _Keyval) noexcept {
        return _Hash_representation(_Keyval);
    }
};

template <>
struct hash<float> {
    using _ARGUMENT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = float;
    using _RESULT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = size_t;
    _NODISCARD _STATIC_CALL_OPERATOR size_t operator()(const float _Keyval) _CONST_CALL_OPERATOR noexcept {
        return _Hash_representation(_Keyval == 0.0F ? 0.0F : _Keyval); // map -0 to 0
    }
};

template <>
struct hash<double> {
    using _ARGUMENT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = double;
    using _RESULT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = size_t;
    _NODISCARD _STATIC_CALL_OPERATOR size_t operator()(const double _Keyval) _CONST_CALL_OPERATOR noexcept {
        return _Hash_representation(_Keyval == 0.0 ? 0.0 : _Keyval); // map -0 to 0
    }
};

template <>
struct hash<long double> {
    using _ARGUMENT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = long double;
    using _RESULT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = size_t;
    _NODISCARD _STATIC_CALL_OPERATOR size_t operator()(const long double _Keyval) _CONST_CALL_OPERATOR noexcept {
        return _Hash_representation(_Keyval == 0.0L ? 0.0L : _Keyval); // map -0 to 0
    }
};

template <>
struct hash<nullptr_t> {
    using _ARGUMENT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = nullptr_t;
    using _RESULT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = size_t;
    _NODISCARD _STATIC_CALL_OPERATOR size_t operator()(nullptr_t) _CONST_CALL_OPERATOR noexcept {
        void* _Null{};
        return _Hash_representation(_Null);
    }
};

template <class _Kty, class = void>
struct _Is_nothrow_hashable : false_type {}; // tests if std::hash can hash _Kty with noexcept

template <class _Kty>
struct _Is_nothrow_hashable < _Kty, void_t<decltype(hash<_Kty>{}(_STD declval<const _Kty&>())) >>
    : bool_constant < noexcept(hash<_Kty>{}(_STD declval<const _Kty&>())) > {};

_EXPORT_STD template <class _Ty = void>
struct less {
    using _FIRST_ARGUMENT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = _Ty;
    using _SECOND_ARGUMENT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = _Ty;
    using _RESULT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = bool;

    _NODISCARD constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
        noexcept(noexcept(_STD _Fake_copy_init<bool>(_Left < _Right))) /* strengthened */ {
        return _Left < _Right;
    }
};

template <>
struct less<void> {
    template <class _Ty1, class _Ty2>
    _NODISCARD constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right))) // strengthened
        -> decltype(static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

// vvvvvvvvvv DERIVED FROM corecrt_internal_fltintrn.h vvvvvvvvvv

template <class _FloatingType>
struct _Floating_type_traits;

template <>
struct _Floating_type_traits<float> {
    static constexpr int32_t _Mantissa_bits = 24; // FLT_MANT_DIG
    static constexpr int32_t _Exponent_bits = 8; // sizeof(float) * CHAR_BIT - FLT_MANT_DIG
    static constexpr int32_t _Maximum_binary_exponent = 127; // FLT_MAX_EXP - 1
    static constexpr int32_t _Minimum_binary_exponent = -126; // FLT_MIN_EXP - 1
    static constexpr int32_t _Exponent_bias = 127;
    static constexpr int32_t _Sign_shift = 31; // _Exponent_bits + _Mantissa_bits - 1
    static constexpr int32_t _Exponent_shift = 23; // _Mantissa_bits - 1

    using _Uint_type = uint32_t;

    static constexpr uint32_t _Exponent_mask = 0x000000FFu; // (1u << _Exponent_bits) - 1
    static constexpr uint32_t _Normal_mantissa_mask = 0x00FFFFFFu; // (1u << _Mantissa_bits) - 1
    static constexpr uint32_t _Denormal_mantissa_mask = 0x007FFFFFu; // (1u << (_Mantissa_bits - 1)) - 1
    static constexpr uint32_t _Special_nan_mantissa_mask = 0x00400000u; // 1u << (_Mantissa_bits - 2)
    static constexpr uint32_t _Shifted_sign_mask = 0x80000000u; // 1u << _Sign_shift
    static constexpr uint32_t _Shifted_exponent_mask = 0x7F800000u; // _Exponent_mask << _Exponent_shift
};

template <>
struct _Floating_type_traits<double> {
    static constexpr int32_t _Mantissa_bits = 53; // DBL_MANT_DIG
    static constexpr int32_t _Exponent_bits = 11; // sizeof(double) * CHAR_BIT - DBL_MANT_DIG
    static constexpr int32_t _Maximum_binary_exponent = 1023; // DBL_MAX_EXP - 1
    static constexpr int32_t _Minimum_binary_exponent = -1022; // DBL_MIN_EXP - 1
    static constexpr int32_t _Exponent_bias = 1023;
    static constexpr int32_t _Sign_shift = 63; // _Exponent_bits + _Mantissa_bits - 1
    static constexpr int32_t _Exponent_shift = 52; // _Mantissa_bits - 1

    using _Uint_type = uint64_t;

    static constexpr uint64_t _Exponent_mask = 0x00000000000007FFu; // (1ULL << _Exponent_bits) - 1
    static constexpr uint64_t _Normal_mantissa_mask = 0x001FFFFFFFFFFFFFu; // (1ULL << _Mantissa_bits) - 1
    static constexpr uint64_t _Denormal_mantissa_mask = 0x000FFFFFFFFFFFFFu; // (1ULL << (_Mantissa_bits - 1)) - 1
    static constexpr uint64_t _Special_nan_mantissa_mask = 0x0008000000000000u; // 1ULL << (_Mantissa_bits - 2)
    static constexpr uint64_t _Shifted_sign_mask = 0x8000000000000000u; // 1ULL << _Sign_shift
    static constexpr uint64_t _Shifted_exponent_mask = 0x7FF0000000000000u; // _Exponent_mask << _Exponent_shift
};

template <>
struct _Floating_type_traits<long double> : _Floating_type_traits<double> {};

// ^^^^^^^^^^ DERIVED FROM corecrt_internal_fltintrn.h ^^^^^^^^^^

template <class _To, class _From,
    enable_if_t<conjunction_v<bool_constant<sizeof(_To) == sizeof(_From)>, is_trivially_copyable<_To>,
    is_trivially_copyable<_From>>,
    int> = 0>
    _NODISCARD constexpr _To _Bit_cast(const _From& _Val) noexcept {
    return __builtin_bit_cast(_To, _Val);
}

template <bool _IsConst, class _Ty>
using _Maybe_const = conditional_t<_IsConst, const _Ty, _Ty>;

#if _HAS_TR1_NAMESPACE
_STL_DISABLE_DEPRECATED_WARNING
namespace _DEPRECATE_TR1_NAMESPACE tr1 {
    using _STD add_const;
    using _STD add_cv;
    using _STD add_pointer;
    using _STD add_volatile;
    using _STD aligned_storage;
    using _STD alignment_of;
    using _STD conditional;
    using _STD decay;
    using _STD enable_if;
    using _STD extent;
    using _STD false_type;
    using _STD has_virtual_destructor;
    using _STD integral_constant;
    using _STD is_abstract;
    using _STD is_arithmetic;
    using _STD is_array;
    using _STD is_base_of;
    using _STD is_class;
    using _STD is_compound;
    using _STD is_const;
    using _STD is_convertible;
    using _STD is_empty;
    using _STD is_enum;
    using _STD is_floating_point;
    using _STD is_function;
    using _STD is_fundamental;
    using _STD is_integral;
    using _STD is_member_function_pointer;
    using _STD is_member_object_pointer;
    using _STD is_member_pointer;
    using _STD is_object;
    using _STD is_pod;
    using _STD is_pointer;
    using _STD is_polymorphic;
    using _STD is_reference;
    using _STD is_same;
    using _STD is_scalar;
    using _STD is_signed;
    using _STD is_union;
    using _STD is_unsigned;
    using _STD is_void;
    using _STD is_volatile;
    using _STD make_signed;
    using _STD make_unsigned;
    using _STD rank;
    using _STD remove_all_extents;
    using _STD remove_const;
    using _STD remove_cv;
    using _STD remove_extent;
    using _STD remove_pointer;
    using _STD remove_reference;
    using _STD remove_volatile;
    using _STD true_type;
    using _STD cref;
    using _STD ref;
    using _STD reference_wrapper;
#if _HAS_DEPRECATED_RESULT_OF
    using _STD result_of;
#endif // _HAS_DEPRECATED_RESULT_OF
    using _STD hash;
} // namespace _DEPRECATE_TR1_NAMESPACE tr1
_STL_RESTORE_DEPRECATED_WARNING
#endif // _HAS_TR1_NAMESPACE

_STD_END

// TRANSITION, non-_Ugly attribute tokens
#pragma pop_macro("known_semantics")
#pragma pop_macro("intrinsic")
#pragma pop_macro("msvc")

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)

#endif // _STL_COMPILER_PREPROCESSOR
#endif // _TYPE_TRAITS_

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

// TRANSITION, non-_Ugly attribute tokens
#pragma push_macro("msvc")
#pragma push_macro("intrinsic")
#pragma push_macro("known_semantics")
#undef msvc
#undef intrinsic
#undef known_semantics

_STD_BEGIN
_EXPORT_STD template <class _Ty, _Ty... _Vals>
struct integer_sequence { // sequence of integer parameters
    static_assert(is_integral_v<_Ty>, "integer_sequence<T, I...> requires T to be an integral type.");

    using value_type = _Ty;

    _NODISCARD static constexpr size_t size() noexcept {
        return sizeof...(_Vals);
    }
};

_EXPORT_STD template <class _Ty, _Ty _Size>
using make_integer_sequence = __make_integer_seq<integer_sequence, _Ty, _Size>;

_EXPORT_STD template <size_t... _Vals>
using index_sequence = integer_sequence<size_t, _Vals...>;

_EXPORT_STD template <size_t _Size>
using make_index_sequence = make_integer_sequence<size_t, _Size>;

_EXPORT_STD template <class... _Types>
using index_sequence_for = make_index_sequence<sizeof...(_Types)>;

_EXPORT_STD template <class _Ty, class _Pr>
_NODISCARD constexpr const _Ty& (max)(const _Ty& _Left, const _Ty& _Right, _Pr _Pred) noexcept(
    noexcept(_Pred(_Left, _Right))) /* strengthened */ {
    // return larger of _Left and _Right
    return _Pred(_Left, _Right) ? _Right : _Left;
}

#pragma warning(push)
#pragma warning(disable : 28285) // (syntax error in SAL annotation, occurs when _Ty is not an integral type)
_EXPORT_STD template <class _Ty>
_NODISCARD _Post_equal_to_(_Left < _Right ? _Right : _Left) constexpr const _Ty& //
    (max)(const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Left < _Right)) /* strengthened */ {
    // return larger of _Left and _Right
    return _Left < _Right ? _Right : _Left;
}
#pragma warning(pop)

_EXPORT_STD template <class _Ty, class _Pr>
_NODISCARD constexpr _Ty(max)(initializer_list<_Ty>, _Pr); // implemented in <algorithm>

_EXPORT_STD template <class _Ty>
_NODISCARD constexpr _Ty(max)(initializer_list<_Ty>); // implemented in <algorithm>

_EXPORT_STD template <class _Ty, class _Pr>
_NODISCARD constexpr const _Ty& (min)(const _Ty& _Left, const _Ty& _Right, _Pr _Pred) noexcept(
    noexcept(_Pred(_Right, _Left))) /* strengthened */ {
    // return smaller of _Left and _Right
    return _Pred(_Right, _Left) ? _Right : _Left;
}

#pragma warning(push)
#pragma warning(disable : 28285) // (syntax error in SAL annotation, occurs when _Ty is not an integral type)
_EXPORT_STD template <class _Ty>
_NODISCARD _Post_equal_to_(_Right < _Left ? _Right : _Left) constexpr const _Ty& //
    (min)(const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Right < _Left)) /* strengthened */ {
    // return smaller of _Left and _Right
    return _Right < _Left ? _Right : _Left;
}
#pragma warning(pop)

_EXPORT_STD template <class _Ty, class _Pr>
_NODISCARD constexpr _Ty(min)(initializer_list<_Ty>, _Pr); // implemented in <algorithm>

_EXPORT_STD template <class _Ty>
_NODISCARD constexpr _Ty(min)(initializer_list<_Ty>); // implemented in <algorithm>

_EXPORT_STD template <class _Ty, size_t _Size, enable_if_t<_Is_swappable<_Ty>::value, int> /* = 0 */>
_CONSTEXPR20 void swap(_Ty(&_Left)[_Size], _Ty(&_Right)[_Size]) noexcept(_Is_nothrow_swappable<_Ty>::value) {
    if (&_Left != &_Right) {
        _Ty* _First1 = _Left;
        _Ty* _Last1 = _First1 + _Size;
        _Ty* _First2 = _Right;
        for (; _First1 != _Last1; ++_First1, ++_First2) {
            swap(*_First1, *_First2); // intentional ADL
        }
    }
}

#if _HAS_CXX17
_EXPORT_STD template <class _Ty, enable_if_t<is_move_constructible_v<_Ty>&& is_move_assignable_v<_Ty>, int> /* = 0 */>
#else // ^^^ _HAS_CXX17 / !_HAS_CXX17 vvv
template <class _Ty, int _Enabled /* = 0 */>
#endif // ^^^ !_HAS_CXX17 ^^^
_CONSTEXPR20 void swap(_Ty& _Left, _Ty& _Right) noexcept(
    is_nothrow_move_constructible_v<_Ty>&& is_nothrow_move_assignable_v<_Ty>) {
    _Ty _Tmp = _STD move(_Left);
    _Left = _STD move(_Right);
    _Right = _STD move(_Tmp);
}

_EXPORT_STD struct piecewise_construct_t { // tag type for pair tuple arguments
    explicit piecewise_construct_t() = default;
};

_EXPORT_STD _INLINE_VAR constexpr piecewise_construct_t piecewise_construct{};

_EXPORT_STD template <class... _Types>
class tuple;

_EXPORT_STD template <class _Ty1, class _Ty2>
struct pair;

_EXPORT_STD template <class _Ty, size_t _Size>
class array;

_EXPORT_STD template <class _Tuple>
struct tuple_size;

_EXPORT_STD template <class _Ty>
_INLINE_VAR constexpr size_t tuple_size_v = tuple_size<_Ty>::value;

_EXPORT_STD template <size_t _Index, class _Tuple>
struct tuple_element;

_EXPORT_STD template <size_t _Index, class _Tuple>
using tuple_element_t = typename tuple_element<_Index, _Tuple>::type;

_EXPORT_STD /* TRANSITION, VSO-1538698 */ template <size_t _Index, class... _Types>
_NODISCARD constexpr auto&& _Tuple_get(tuple<_Types...>&& _Tuple) noexcept;

_EXPORT_STD template <size_t _Index, class... _Types>
_NODISCARD constexpr tuple_element_t<_Index, tuple<_Types...>>& get(tuple<_Types...>& _Tuple) noexcept;

_EXPORT_STD template <size_t _Index, class... _Types>
_NODISCARD constexpr const tuple_element_t<_Index, tuple<_Types...>>& get(const tuple<_Types...>& _Tuple) noexcept;

_EXPORT_STD template <size_t _Index, class... _Types>
_NODISCARD constexpr tuple_element_t<_Index, tuple<_Types...>>&& get(tuple<_Types...>&& _Tuple) noexcept;

_EXPORT_STD template <size_t _Index, class... _Types>
_NODISCARD constexpr const tuple_element_t<_Index, tuple<_Types...>>&& get(const tuple<_Types...>&& _Tuple) noexcept;

_EXPORT_STD template <size_t _Idx, class _Ty, size_t _Size>
_NODISCARD constexpr _Ty& get(array<_Ty, _Size>& _Arr) noexcept;

_EXPORT_STD template <size_t _Idx, class _Ty, size_t _Size>
_NODISCARD constexpr const _Ty& get(const array<_Ty, _Size>& _Arr) noexcept;

_EXPORT_STD template <size_t _Idx, class _Ty, size_t _Size>
_NODISCARD constexpr _Ty&& get(array<_Ty, _Size>&& _Arr) noexcept;

_EXPORT_STD template <size_t _Idx, class _Ty, size_t _Size>
_NODISCARD constexpr const _Ty&& get(const array<_Ty, _Size>&& _Arr) noexcept;

#if _HAS_CXX20
template <class _Ty1, class _Ty2>
concept _Different_from = !same_as<remove_cvref_t<_Ty1>, remove_cvref_t<_Ty2>>;

template <class>
inline constexpr bool _Is_std_array_v = false;

template <class _Ty, size_t _Size>
inline constexpr bool _Is_std_array_v<array<_Ty, _Size>> = true;

template <class>
inline constexpr bool _Is_subrange_v = false;

#if _HAS_CXX23
template <class _Ty>
inline constexpr bool _Tuple_like_impl =
_Is_specialization_v<_Ty, tuple> || _Is_specialization_v<_Ty, pair> || _Is_std_array_v<_Ty> || _Is_subrange_v<_Ty>;

template <class _Ty>
concept _Tuple_like = _Tuple_like_impl<remove_cvref_t<_Ty>>;

template <class _Ty>
concept _Pair_like = _Tuple_like<_Ty> && tuple_size_v<remove_cvref_t<_Ty>> == 2;

#if defined(__clang__) || defined(__EDG__) // TRANSITION, LLVM-59827 and VSO-1900279
template <class _PairLike, class _Ty1, class _Ty2>
concept _Can_construct_from_pair_like = _Pair_like<_PairLike> && !_Is_subrange_v<remove_cvref_t<_PairLike>>
&& is_constructible_v<_Ty1, decltype(_STD get<0>(_STD declval<_PairLike>()))>
&& is_constructible_v<_Ty2, decltype(_STD get<1>(_STD declval<_PairLike>()))>;
#endif // ^^^ workaround ^^^
#endif // _HAS_CXX23
#endif // _HAS_CXX20

_EXPORT_STD template <class _Ty1, class _Ty2>
struct pair { // store a pair of values
    using first_type = _Ty1;
    using second_type = _Ty2;

    template <class _Uty1 = _Ty1, class _Uty2 = _Ty2,
        enable_if_t<conjunction_v<is_default_constructible<_Uty1>, is_default_constructible<_Uty2>>, int> = 0>
    constexpr explicit(
        !conjunction_v<_Is_implicitly_default_constructible<_Uty1>, _Is_implicitly_default_constructible<_Uty2>>)
        pair() noexcept(
            is_nothrow_default_constructible_v<_Uty1>&& is_nothrow_default_constructible_v<_Uty2>) // strengthened
        : first(), second() {}

    template <class _Uty1 = _Ty1, class _Uty2 = _Ty2,
        enable_if_t<conjunction_v<is_copy_constructible<_Uty1>, is_copy_constructible<_Uty2>>, int> = 0>
    constexpr explicit(!conjunction_v<is_convertible<const _Uty1&, _Uty1>, is_convertible<const _Uty2&, _Uty2>>)
        pair(const _Ty1& _Val1, const _Ty2& _Val2) noexcept(
            is_nothrow_copy_constructible_v<_Uty1>&& is_nothrow_copy_constructible_v<_Uty2>) // strengthened
        : first(_Val1), second(_Val2) {}

#if _HAS_CXX23
    template <class _Other1 = _Ty1, class _Other2 = _Ty2,
#else // ^^^ _HAS_CXX23 / !_HAS_CXX23 vvv
    template <class _Other1, class _Other2,
#endif // ^^^ !_HAS_CXX23 ^^^
        enable_if_t<conjunction_v<is_constructible<_Ty1, _Other1>, is_constructible<_Ty2, _Other2>>, int> = 0>
    constexpr explicit(!conjunction_v<is_convertible<_Other1, _Ty1>, is_convertible<_Other2, _Ty2>>)
        pair(_Other1&& _Val1, _Other2&& _Val2) noexcept(
            is_nothrow_constructible_v<_Ty1, _Other1>&& is_nothrow_constructible_v<_Ty2, _Other2>) // strengthened
        : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {
    }

    pair(const pair&) = default;
    pair(pair&&) = default;

#if _HAS_CXX23
    template <class _Other1, class _Other2,
        enable_if_t<conjunction_v<is_constructible<_Ty1, _Other1&>, is_constructible<_Ty2, _Other2&>>, int> = 0>
    constexpr explicit(!conjunction_v<is_convertible<_Other1&, _Ty1>, is_convertible<_Other2&, _Ty2>>)
        pair(pair<_Other1, _Other2>& _Right) noexcept(
            is_nothrow_constructible_v<_Ty1, _Other1&>&& is_nothrow_constructible_v<_Ty2, _Other2&>) // strengthened
        : first(_Right.first), second(_Right.second) {}
#endif // _HAS_CXX23

    template <class _Other1, class _Other2,
        enable_if_t<conjunction_v<is_constructible<_Ty1, const _Other1&>, is_constructible<_Ty2, const _Other2&>>,
        int> = 0>
    constexpr explicit(!conjunction_v<is_convertible<const _Other1&, _Ty1>, is_convertible<const _Other2&, _Ty2>>)
        pair(const pair<_Other1, _Other2>& _Right) noexcept(
            is_nothrow_constructible_v<_Ty1, const _Other1&>
            && is_nothrow_constructible_v<_Ty2, const _Other2&>) // strengthened
        : first(_Right.first), second(_Right.second) {}

    template <class _Other1, class _Other2,
        enable_if_t<conjunction_v<is_constructible<_Ty1, _Other1>, is_constructible<_Ty2, _Other2>>, int> = 0>
    constexpr explicit(!conjunction_v<is_convertible<_Other1, _Ty1>, is_convertible<_Other2, _Ty2>>)
        pair(pair<_Other1, _Other2>&& _Right) noexcept(
            is_nothrow_constructible_v<_Ty1, _Other1>&& is_nothrow_constructible_v<_Ty2, _Other2>) // strengthened
        : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

#if _HAS_CXX23
    template <class _Other1, class _Other2,
        enable_if_t<conjunction_v<is_constructible<_Ty1, const _Other1>, is_constructible<_Ty2, const _Other2>>, int> =
        0>
    constexpr explicit(!conjunction_v<is_convertible<const _Other1, _Ty1>, is_convertible<const _Other2, _Ty2>>)
        pair(const pair<_Other1, _Other2>&& _Right) noexcept(
            is_nothrow_constructible_v<_Ty1, const _Other1>
            && is_nothrow_constructible_v<_Ty2, const _Other2>) // strengthened
        : first(_STD forward<const _Other1>(_Right.first)), second(_STD forward<const _Other2>(_Right.second)) {}

#if defined(__clang__) || defined(__EDG__) // TRANSITION, LLVM-59827 (Clang), VSO-1900279 (EDG)
    template <class _Other, enable_if_t<_Can_construct_from_pair_like<_Other, _Ty1, _Ty2>, int> = 0>
#else // ^^^ workaround / no workaround vvv
    template <_Pair_like _Other>
        requires conjunction_v<bool_constant<!_Is_subrange_v<remove_cvref_t<_Other>>>,
    is_constructible<_Ty1, decltype(_STD get<0>(_STD declval<_Other>()))>,
        is_constructible<_Ty2, decltype(_STD get<1>(_STD declval<_Other>()))>>
#endif // ^^^ no workaround ^^^
        constexpr explicit(!conjunction_v<is_convertible<decltype(_STD get<0>(_STD declval<_Other>())), _Ty1>,
            is_convertible<decltype(_STD get<1>(_STD declval<_Other>())), _Ty2>>)
        pair(_Other&& _Right) noexcept(
            is_nothrow_constructible_v<_Ty1, decltype(_STD get<0>(_STD declval<_Other>()))>
            && is_nothrow_constructible_v<_Ty2, decltype(_STD get<1>(_STD declval<_Other>()))>) // strengthened
        : first(_STD get<0>(_STD forward<_Other>(_Right))), second(_STD get<1>(_STD forward<_Other>(_Right))) {
    }
#endif // _HAS_CXX23

    template <class _Tuple1, class _Tuple2, size_t... _Indices1, size_t... _Indices2>
    constexpr pair(_Tuple1& _Val1, _Tuple2& _Val2, index_sequence<_Indices1...>, index_sequence<_Indices2...>)
        : first(_Tuple_get<_Indices1>(_STD move(_Val1))...), second(_Tuple_get<_Indices2>(_STD move(_Val2))...) {}

    template <class... _Types1, class... _Types2>
    _CONSTEXPR20 pair(piecewise_construct_t, tuple<_Types1...> _Val1, tuple<_Types2...> _Val2)
        : pair(_Val1, _Val2, index_sequence_for<_Types1...>{}, index_sequence_for<_Types2...>{}) {}

    pair& operator=(const volatile pair&) = delete;

    template <class _Myself = pair,
        enable_if_t<conjunction_v<_Is_copy_assignable_no_precondition_check<typename _Myself::first_type>,
        _Is_copy_assignable_no_precondition_check<typename _Myself::second_type>>,
        int> = 0>
        _CONSTEXPR20 pair& operator=(_Identity_t<const _Myself&> _Right) noexcept(
            conjunction_v<is_nothrow_copy_assignable<_Ty1>, is_nothrow_copy_assignable<_Ty2>>) /* strengthened */ {
        first = _Right.first;
        second = _Right.second;
        return *this;
    }

#if _HAS_CXX23
    template <class _Myself = pair,
        enable_if_t<conjunction_v<_Is_copy_assignable_no_precondition_check<const typename _Myself::first_type>,
        _Is_copy_assignable_no_precondition_check<const typename _Myself::second_type>>,
        int> = 0>
        constexpr const pair& operator=(_Identity_t<const _Myself&> _Right) const
        noexcept(conjunction_v<is_nothrow_copy_assignable<const _Ty1>,
            is_nothrow_copy_assignable<const _Ty2>>) /* strengthened */ {
        first = _Right.first;
        second = _Right.second;
        return *this;
    }
#endif // _HAS_CXX23

    template <class _Myself = pair,
        enable_if_t<conjunction_v<_Is_move_assignable_no_precondition_check<typename _Myself::first_type>,
        _Is_move_assignable_no_precondition_check<typename _Myself::second_type>>,
        int> = 0>
        _CONSTEXPR20 pair& operator=(_Identity_t<_Myself&&> _Right) noexcept(
            conjunction_v<is_nothrow_move_assignable<_Ty1>, is_nothrow_move_assignable<_Ty2>>) /* strengthened */ {
        first = _STD forward<_Ty1>(_Right.first);
        second = _STD forward<_Ty2>(_Right.second);
        return *this;
    }

#if _HAS_CXX23
    template <class _Myself = pair,
        enable_if_t<conjunction_v<_Is_assignable_no_precondition_check<const typename _Myself::first_type&, _Ty1>,
        _Is_assignable_no_precondition_check<const typename _Myself::second_type&, _Ty2>>,
        int> = 0>
        constexpr const pair& operator=(_Identity_t<_Myself&&> _Right) const
        noexcept(conjunction_v<is_nothrow_assignable<const _Ty1&, _Ty1>,
            is_nothrow_assignable<const _Ty2&, _Ty2>>) /* strengthened */ {
        first = _STD forward<_Ty1>(_Right.first);
        second = _STD forward<_Ty2>(_Right.second);
        return *this;
    }
#endif // _HAS_CXX23

    template <class _Other1, class _Other2,
        enable_if_t<conjunction_v<negation<is_same<pair, pair<_Other1, _Other2>>>, is_assignable<_Ty1&, const _Other1&>,
        is_assignable<_Ty2&, const _Other2&>>,
        int> = 0>
        _CONSTEXPR20 pair& operator=(const pair<_Other1, _Other2>& _Right) noexcept(
            is_nothrow_assignable_v<_Ty1&, const _Other1&>
            && is_nothrow_assignable_v<_Ty2&, const _Other2&>) /* strengthened */ {
        first = _Right.first;
        second = _Right.second;
        return *this;
    }

#if _HAS_CXX23
    template <class _Other1, class _Other2,
        enable_if_t<conjunction_v<negation<is_same<pair, pair<_Other1, _Other2>>>,
        is_assignable<const _Ty1&, const _Other1&>, is_assignable<const _Ty2&, const _Other2&>>,
        int> = 0>
        constexpr const pair& operator=(const pair<_Other1, _Other2>& _Right) const
        noexcept(is_nothrow_assignable_v<const _Ty1&, const _Other1&>
            && is_nothrow_assignable_v<const _Ty2&, const _Other2&>) /* strengthened */ {
        first = _Right.first;
        second = _Right.second;
        return *this;
    }
#endif // _HAS_CXX23

    template <class _Other1, class _Other2,
        enable_if_t<conjunction_v<negation<is_same<pair, pair<_Other1, _Other2>>>, is_assignable<_Ty1&, _Other1>,
        is_assignable<_Ty2&, _Other2>>,
        int> = 0>
        _CONSTEXPR20 pair& operator=(pair<_Other1, _Other2>&& _Right) noexcept(
            is_nothrow_assignable_v<_Ty1&, _Other1>&& is_nothrow_assignable_v<_Ty2&, _Other2>) /* strengthened */ {
        first = _STD forward<_Other1>(_Right.first);
        second = _STD forward<_Other2>(_Right.second);
        return *this;
    }

#if _HAS_CXX23
    template <class _Other1, class _Other2,
        enable_if_t<conjunction_v<negation<is_same<pair, pair<_Other1, _Other2>>>, is_assignable<const _Ty1&, _Other1>,
        is_assignable<const _Ty2&, _Other2>>,
        int> = 0>
        constexpr const pair& operator=(pair<_Other1, _Other2>&& _Right) const
        noexcept(is_nothrow_assignable_v<const _Ty1&, _Other1>
            && is_nothrow_assignable_v<const _Ty2&, _Other2>) /* strengthened */ {
        first = _STD forward<_Other1>(_Right.first);
        second = _STD forward<_Other2>(_Right.second);
        return *this;
    }

    template <_Pair_like _Other>
        requires _Different_from<_Other, pair> && (!_Is_subrange_v<remove_cvref_t<_Other>>)
    && is_assignable_v<_Ty1&, decltype(_STD get<0>(_STD declval<_Other>()))>
        && is_assignable_v<_Ty2&, decltype(_STD get<1>(_STD declval<_Other>()))>
        constexpr pair& operator=(_Other&& _Right) noexcept(
            is_nothrow_assignable_v<_Ty1&, decltype(_STD get<0>(_STD declval<_Other>()))>
            && is_nothrow_assignable_v<_Ty2&, decltype(_STD get<1>(_STD declval<_Other>()))>) /* strengthened */ {
        first = _STD get<0>(_STD forward<_Other>(_Right));
        second = _STD get<1>(_STD forward<_Other>(_Right));
        return *this;
    }

    template <_Pair_like _Other>
        requires _Different_from<_Other, pair> && (!_Is_subrange_v<remove_cvref_t<_Other>>)
    && is_assignable_v<const _Ty1&, decltype(_STD get<0>(_STD declval<_Other>()))>
        && is_assignable_v<const _Ty2&, decltype(_STD get<1>(_STD declval<_Other>()))>
        constexpr const pair& operator=(_Other&& _Right) const noexcept(
            is_nothrow_assignable_v<const _Ty1&, decltype(_STD get<0>(_STD declval<_Other>()))>
            && is_nothrow_assignable_v<const _Ty2&, decltype(_STD get<1>(_STD declval<_Other>()))>) /* strengthened */ {
        first = _STD get<0>(_STD forward<_Other>(_Right));
        second = _STD get<1>(_STD forward<_Other>(_Right));
        return *this;
    }
#endif // _HAS_CXX23

    _CONSTEXPR20 void swap(pair& _Right) noexcept(
        _Is_nothrow_swappable<_Ty1>::value&& _Is_nothrow_swappable<_Ty2>::value) {
        using _STD swap;
        if (this != _STD addressof(_Right)) {
            swap(first, _Right.first); // intentional ADL
            swap(second, _Right.second); // intentional ADL
        }
    }

#if _HAS_CXX23
    template <int = 0> // see GH-3013
    constexpr void swap(const pair& _Right) const
        noexcept(is_nothrow_swappable_v<const _Ty1>&& is_nothrow_swappable_v<const _Ty2>) {
        using _STD swap;
        if (this != _STD addressof(_Right)) {
            swap(first, _Right.first); // intentional ADL
            swap(second, _Right.second); // intentional ADL
        }
    }
#endif // _HAS_CXX23

    _Ty1 first; // the first stored value
    _Ty2 second; // the second stored value
};

#if _HAS_CXX17
template <class _Ty1, class _Ty2>
pair(_Ty1, _Ty2) -> pair<_Ty1, _Ty2>;
#endif // _HAS_CXX17

_EXPORT_STD template <class _Ty1, class _Ty2,
    enable_if_t<_Is_swappable<_Ty1>::value&& _Is_swappable<_Ty2>::value, int> = 0>
    _CONSTEXPR20 void swap(pair<_Ty1, _Ty2>& _Left, pair<_Ty1, _Ty2>& _Right) noexcept(noexcept(_Left.swap(_Right))) {
    _Left.swap(_Right);
}

#if _HAS_CXX23
_EXPORT_STD template <class _Ty1, class _Ty2,
    enable_if_t<is_swappable_v<const _Ty1>&& is_swappable_v<const _Ty2>, int> = 0>
    constexpr void swap(const pair<_Ty1, _Ty2>& _Left, const pair<_Ty1, _Ty2>& _Right) noexcept(
        noexcept(_Left.swap(_Right))) {
    _Left.swap(_Right);
}
#endif // _HAS_CXX23

_EXPORT_STD template <class _Ty1, class _Ty2, class _Uty1, class _Uty2>
_NODISCARD constexpr bool operator==(const pair<_Ty1, _Ty2>& _Left, const pair<_Uty1, _Uty2>& _Right) {
    return _Left.first == _Right.first && _Left.second == _Right.second;
}

#if _HAS_CXX20
_EXPORT_STD template <class _Ty1, class _Ty2, class _Uty1, class _Uty2>
_NODISCARD constexpr common_comparison_category_t<_Synth_three_way_result<_Ty1, _Uty1>,
    _Synth_three_way_result<_Ty2, _Uty2>>
    operator<=>(const pair<_Ty1, _Ty2>& _Left, const pair<_Uty1, _Uty2>& _Right) {
    if (auto _Result = _Synth_three_way{}(_Left.first, _Right.first); _Result != 0) {
        return _Result;
    }
    return _Synth_three_way{}(_Left.second, _Right.second);
}
#else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
template <class _Ty1, class _Ty2, class _Uty1, class _Uty2>
_NODISCARD constexpr bool operator!=(const pair<_Ty1, _Ty2>& _Left, const pair<_Uty1, _Uty2>& _Right) {
    return !(_Left == _Right);
}

template <class _Ty1, class _Ty2, class _Uty1, class _Uty2>
_NODISCARD constexpr bool operator<(const pair<_Ty1, _Ty2>& _Left, const pair<_Uty1, _Uty2>& _Right) {
    return _Left.first < _Right.first || (!(_Right.first < _Left.first) && _Left.second < _Right.second);
}

template <class _Ty1, class _Ty2, class _Uty1, class _Uty2>
_NODISCARD constexpr bool operator>(const pair<_Ty1, _Ty2>& _Left, const pair<_Uty1, _Uty2>& _Right) {
    return _Right < _Left;
}

template <class _Ty1, class _Ty2, class _Uty1, class _Uty2>
_NODISCARD constexpr bool operator<=(const pair<_Ty1, _Ty2>& _Left, const pair<_Uty1, _Uty2>& _Right) {
    return !(_Right < _Left);
}

template <class _Ty1, class _Ty2, class _Uty1, class _Uty2>
_NODISCARD constexpr bool operator>=(const pair<_Ty1, _Ty2>& _Left, const pair<_Uty1, _Uty2>& _Right) {
    return !(_Left < _Right);
}
#endif // ^^^ !_HAS_CXX20 ^^^

#if _HAS_CXX23
template <class _Ty1, class _Ty2, class _Uty1, class _Uty2, template <class> class _TQual,
    template <class> class _UQual>
    requires requires {
    typename pair<common_reference_t<_TQual<_Ty1>, _UQual<_Uty1>>, common_reference_t<_TQual<_Ty2>, _UQual<_Uty2>>>;
}
struct basic_common_reference<pair<_Ty1, _Ty2>, pair<_Uty1, _Uty2>, _TQual, _UQual> {
    using type = pair<common_reference_t<_TQual<_Ty1>, _UQual<_Uty1>>, common_reference_t<_TQual<_Ty2>, _UQual<_Uty2>>>;
};

template <class _Ty1, class _Ty2, class _Uty1, class _Uty2>
    requires requires { typename pair<common_type_t<_Ty1, _Uty1>, common_type_t<_Ty2, _Uty2>>; }
struct common_type<pair<_Ty1, _Ty2>, pair<_Uty1, _Uty2>> {
    using type = pair<common_type_t<_Ty1, _Uty1>, common_type_t<_Ty2, _Uty2>>;
};
#endif // _HAS_CXX23

template <class _Ty>
struct _Unrefwrap_helper { // leave unchanged if not a reference_wrapper
    using type = _Ty;
};

template <class _Ty>
struct _Unrefwrap_helper<reference_wrapper<_Ty>> { // make a reference from a reference_wrapper
    using type = _Ty&;
};

// decay, then unwrap a reference_wrapper
template <class _Ty>
using _Unrefwrap_t = typename _Unrefwrap_helper<decay_t<_Ty>>::type;

_EXPORT_STD template <class _Ty1, class _Ty2>
_NODISCARD constexpr pair<_Unrefwrap_t<_Ty1>, _Unrefwrap_t<_Ty2>> make_pair(_Ty1&& _Val1, _Ty2&& _Val2) noexcept(
    is_nothrow_constructible_v<_Unrefwrap_t<_Ty1>, _Ty1>
    && is_nothrow_constructible_v<_Unrefwrap_t<_Ty2>, _Ty2>) /* strengthened */ {
    // return pair composed from arguments
    using _Mypair = pair<_Unrefwrap_t<_Ty1>, _Unrefwrap_t<_Ty2>>;
    return _Mypair(_STD forward<_Ty1>(_Val1), _STD forward<_Ty2>(_Val2));
}

namespace _CXX20_DEPRECATE_REL_OPS rel_ops {
    _EXPORT_STD template <class _Ty>
        _CXX20_DEPRECATE_REL_OPS _NODISCARD bool operator!=(const _Ty& _Left, const _Ty& _Right) {
        return !(_Left == _Right);
    }

    _EXPORT_STD template <class _Ty>
        _CXX20_DEPRECATE_REL_OPS _NODISCARD bool operator>(const _Ty& _Left, const _Ty& _Right) {
        return _Right < _Left;
    }

    _EXPORT_STD template <class _Ty>
        _CXX20_DEPRECATE_REL_OPS _NODISCARD bool operator<=(const _Ty& _Left, const _Ty& _Right) {
        return !(_Right < _Left);
    }

    _EXPORT_STD template <class _Ty>
        _CXX20_DEPRECATE_REL_OPS _NODISCARD bool operator>=(const _Ty& _Left, const _Ty& _Right) {
        return !(_Left < _Right);
    }
} // namespace _CXX20_DEPRECATE_REL_OPS rel_ops

template <class _Tuple, class = void>
struct _Tuple_size_sfinae {}; // selected when tuple_size<_Tuple>::value isn't well-formed

template <class _Tuple>
struct _Tuple_size_sfinae<_Tuple, void_t<decltype(tuple_size<_Tuple>::value)>>
    : integral_constant<size_t, tuple_size<_Tuple>::value> {}; // selected when tuple_size<_Tuple>::value is well-formed

template <class _Tuple>
struct tuple_size<const _Tuple> : _Tuple_size_sfinae<_Tuple> {}; // ignore cv

template <class _Tuple>
struct _CXX20_DEPRECATE_VOLATILE tuple_size<volatile _Tuple> : _Tuple_size_sfinae<_Tuple> {}; // ignore cv

template <class _Tuple>
struct _CXX20_DEPRECATE_VOLATILE tuple_size<const volatile _Tuple> : _Tuple_size_sfinae<_Tuple> {}; // ignore cv

template <size_t _Index, class _Tuple>
struct _MSVC_KNOWN_SEMANTICS tuple_element<_Index, const _Tuple> : tuple_element<_Index, _Tuple> {
    using _Mybase = tuple_element<_Index, _Tuple>;
    using type = add_const_t<typename _Mybase::type>;
};

template <size_t _Index, class _Tuple>
struct _CXX20_DEPRECATE_VOLATILE _MSVC_KNOWN_SEMANTICS tuple_element<_Index, volatile _Tuple>
    : tuple_element<_Index, _Tuple>{
    using _Mybase = tuple_element<_Index, _Tuple>;
    using type = add_volatile_t<typename _Mybase::type>;
};

template <size_t _Index, class _Tuple>
struct _CXX20_DEPRECATE_VOLATILE _MSVC_KNOWN_SEMANTICS tuple_element<_Index, const volatile _Tuple>
    : tuple_element<_Index, _Tuple>{
    using _Mybase = tuple_element<_Index, _Tuple>;
    using type = add_cv_t<typename _Mybase::type>;
};

template <class _Ty, size_t _Size>
struct tuple_size<array<_Ty, _Size>> : integral_constant<size_t, _Size> {}; // size of array

template <size_t _Idx, class _Ty, size_t _Size>
struct _MSVC_KNOWN_SEMANTICS tuple_element<_Idx, array<_Ty, _Size>> {
    static_assert(_Idx < _Size, "array index out of bounds");

    using type = _Ty;
};

template <class... _Types>
struct tuple_size<tuple<_Types...>> : integral_constant<size_t, sizeof...(_Types)> {}; // size of tuple

template <size_t _Index>
struct _MSVC_KNOWN_SEMANTICS tuple_element<_Index, tuple<>> { // enforce bounds checking
    static_assert(_Always_false<integral_constant<size_t, _Index>>, "tuple index out of bounds");
};

template <class _This, class... _Rest>
struct _MSVC_KNOWN_SEMANTICS tuple_element<0, tuple<_This, _Rest...>> { // select first element
    using type = _This;
    // MSVC assumes the meaning of _Ttype; remove or rename, but do not change semantics
    using _Ttype = tuple<_This, _Rest...>;
};

template <size_t _Index, class _This, class... _Rest>
struct _MSVC_KNOWN_SEMANTICS tuple_element<_Index, tuple<_This, _Rest...>>
    : tuple_element<_Index - 1, tuple<_Rest...>> {}; // recursive tuple_element definition

template <class _Ty1, class _Ty2>
struct tuple_size<pair<_Ty1, _Ty2>> : integral_constant<size_t, 2> {}; // size of pair

template <size_t _Idx, class _Ty1, class _Ty2>
struct _MSVC_KNOWN_SEMANTICS tuple_element<_Idx, pair<_Ty1, _Ty2>> {
    static_assert(_Idx < 2, "pair index out of bounds");

    using type = conditional_t<_Idx == 0, _Ty1, _Ty2>;
};

_EXPORT_STD template <size_t _Idx, class _Ty1, class _Ty2>
_NODISCARD constexpr tuple_element_t<_Idx, pair<_Ty1, _Ty2>>& get(pair<_Ty1, _Ty2>& _Pr) noexcept {
    // get reference to element at _Idx in pair _Pr
    if constexpr (_Idx == 0) {
        return _Pr.first;
    }
    else {
        return _Pr.second;
    }
}

_EXPORT_STD template <class _Ty1, class _Ty2>
_NODISCARD constexpr _Ty1& get(pair<_Ty1, _Ty2>& _Pr) noexcept {
    // get reference to element _Ty1 in pair _Pr
    return _Pr.first;
}

_EXPORT_STD template <class _Ty2, class _Ty1>
_NODISCARD constexpr _Ty2& get(pair<_Ty1, _Ty2>& _Pr) noexcept {
    // get reference to element _Ty2 in pair _Pr
    return _Pr.second;
}

_EXPORT_STD template <size_t _Idx, class _Ty1, class _Ty2>
_NODISCARD constexpr const tuple_element_t<_Idx, pair<_Ty1, _Ty2>>& get(const pair<_Ty1, _Ty2>& _Pr) noexcept {
    // get const reference to element at _Idx in pair _Pr
    if constexpr (_Idx == 0) {
        return _Pr.first;
    }
    else {
        return _Pr.second;
    }
}

_EXPORT_STD template <class _Ty1, class _Ty2>
_NODISCARD constexpr const _Ty1& get(const pair<_Ty1, _Ty2>& _Pr) noexcept {
    // get const reference to element _Ty1 in pair _Pr
    return _Pr.first;
}

_EXPORT_STD template <class _Ty2, class _Ty1>
_NODISCARD constexpr const _Ty2& get(const pair<_Ty1, _Ty2>& _Pr) noexcept {
    // get const reference to element _Ty2 in pair _Pr
    return _Pr.second;
}

_EXPORT_STD template <size_t _Idx, class _Ty1, class _Ty2>
_NODISCARD constexpr tuple_element_t<_Idx, pair<_Ty1, _Ty2>>&& get(pair<_Ty1, _Ty2>&& _Pr) noexcept {
    // get rvalue reference to element at _Idx in pair _Pr
    if constexpr (_Idx == 0) {
        return _STD forward<_Ty1>(_Pr.first);
    }
    else {
        return _STD forward<_Ty2>(_Pr.second);
    }
}

_EXPORT_STD template <class _Ty1, class _Ty2>
_NODISCARD constexpr _Ty1&& get(pair<_Ty1, _Ty2>&& _Pr) noexcept {
    // get rvalue reference to element _Ty1 in pair _Pr
    return _STD forward<_Ty1>(_Pr.first);
}

_EXPORT_STD template <class _Ty2, class _Ty1>
_NODISCARD constexpr _Ty2&& get(pair<_Ty1, _Ty2>&& _Pr) noexcept {
    // get rvalue reference to element _Ty2 in pair _Pr
    return _STD forward<_Ty2>(_Pr.second);
}

_EXPORT_STD template <size_t _Idx, class _Ty1, class _Ty2>
_NODISCARD constexpr const tuple_element_t<_Idx, pair<_Ty1, _Ty2>>&& get(const pair<_Ty1, _Ty2>&& _Pr) noexcept {
    // get const rvalue reference to element at _Idx in pair _Pr
    if constexpr (_Idx == 0) {
        return _STD forward<const _Ty1>(_Pr.first);
    }
    else {
        return _STD forward<const _Ty2>(_Pr.second);
    }
}

_EXPORT_STD template <class _Ty1, class _Ty2>
_NODISCARD constexpr const _Ty1&& get(const pair<_Ty1, _Ty2>&& _Pr) noexcept {
    // get const rvalue reference to element _Ty1 in pair _Pr
    return _STD forward<const _Ty1>(_Pr.first);
}

_EXPORT_STD template <class _Ty2, class _Ty1>
_NODISCARD constexpr const _Ty2&& get(const pair<_Ty1, _Ty2>&& _Pr) noexcept {
    // get const rvalue reference to element _Ty2 in pair _Pr
    return _STD forward<const _Ty2>(_Pr.second);
}

_EXPORT_STD template <class _Ty, class _Other = _Ty>
_CONSTEXPR20 _Ty exchange(_Ty& _Val, _Other&& _New_val) noexcept(
    conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {
    // assign _New_val to _Val, return previous _Val
    _Ty _Old_val = static_cast<_Ty&&>(_Val);
    _Val = static_cast<_Other&&>(_New_val);
    return _Old_val;
}

_EXPORT_STD template <class _Ty>
_NODISCARD _MSVC_INTRINSIC constexpr add_const_t<_Ty>& as_const(_Ty& _Val) noexcept { // view _Val through const lenses
    return _Val;
}

_EXPORT_STD template <class _Ty>
void as_const(const _Ty&&) = delete;

#if _HAS_CXX17
_EXPORT_STD struct in_place_t { // tag used to select a constructor which initializes a contained object in place
    explicit in_place_t() = default;
};
_EXPORT_STD inline constexpr in_place_t in_place{};

_EXPORT_STD template <class>
struct in_place_type_t { // tag that selects a type to construct in place
    explicit in_place_type_t() = default;
};
_EXPORT_STD template <class _Ty>
inline constexpr in_place_type_t<_Ty> in_place_type{};

_EXPORT_STD template <size_t>
struct in_place_index_t { // tag that selects the index of a type to construct in place
    explicit in_place_index_t() = default;
};
_EXPORT_STD template <size_t _Idx>
inline constexpr in_place_index_t<_Idx> in_place_index{};
#endif // _HAS_CXX17

#if _HAS_TR1_NAMESPACE
namespace _DEPRECATE_TR1_NAMESPACE tr1 {
    using _STD get;
    using _STD tuple_element;
    using _STD tuple_size;
} // namespace _DEPRECATE_TR1_NAMESPACE tr1
#endif // _HAS_TR1_NAMESPACE

_STD_END

// TRANSITION, non-_Ugly attribute tokens
#pragma pop_macro("known_semantics")
#pragma pop_macro("intrinsic")
#pragma pop_macro("msvc")

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _UTILITY_


#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_STD_BEGIN
template <class _Ty, class _Alloc, class = void>
struct _Has_allocator_type : false_type {}; // tests for suitable _Ty::allocator_type

template <class _Ty, class _Alloc>
struct _Has_allocator_type<_Ty, _Alloc, void_t<typename _Ty::allocator_type>>
    : is_convertible<_Alloc, typename _Ty::allocator_type>::type {};

_EXPORT_STD struct allocator_arg_t { // tag type for added allocator argument
    explicit allocator_arg_t() = default;
};

_EXPORT_STD _INLINE_VAR constexpr allocator_arg_t allocator_arg{};

_EXPORT_STD template <class _Ty, class _Alloc>
struct uses_allocator : _Has_allocator_type<_Ty, _Alloc>::type {};

_EXPORT_STD template <class _Ty, class _Alloc>
_INLINE_VAR constexpr bool uses_allocator_v = uses_allocator<_Ty, _Alloc>::value;

// from <iterator>
_EXPORT_STD struct input_iterator_tag {};

_EXPORT_STD struct output_iterator_tag {};

_EXPORT_STD struct forward_iterator_tag : input_iterator_tag {};

_EXPORT_STD struct bidirectional_iterator_tag : forward_iterator_tag {};

_EXPORT_STD struct random_access_iterator_tag : bidirectional_iterator_tag {};

#if _HAS_CXX20
_EXPORT_STD struct contiguous_iterator_tag : random_access_iterator_tag {};

template <class _Ty>
using _With_reference = _Ty&;

template <class _Ty>
concept _Can_reference = requires { typename _With_reference<_Ty>; };

template <class _Ty>
concept _Dereferenceable = requires(_Ty & __t) {
    { *__t } -> _Can_reference;
};

template <class _Ty>
concept _Has_member_iterator_concept = requires { typename _Ty::iterator_concept; };

template <class _Ty>
concept _Has_member_iterator_category = requires { typename _Ty::iterator_category; };

template <class _Ty>
concept _Has_member_value_type = requires { typename _Ty::value_type; };

template <class _Ty>
concept _Has_member_element_type = requires { typename _Ty::element_type; };

template <class _Ty>
concept _Has_member_difference_type = requires { typename _Ty::difference_type; };

template <class _Ty>
concept _Has_member_pointer = requires { typename _Ty::pointer; };

template <class _Ty>
concept _Has_member_reference = requires { typename _Ty::reference; };

_EXPORT_STD template <class>
struct incrementable_traits {};

template <class _Ty>
    requires is_object_v<_Ty>
struct incrementable_traits<_Ty*> {
    using difference_type = ptrdiff_t;
};

template <class _Ty>
struct incrementable_traits<const _Ty> : incrementable_traits<_Ty> {};

template <_Has_member_difference_type _Ty>
struct incrementable_traits<_Ty> {
    using difference_type = _Ty::difference_type;
};

template <class _Ty>
concept _Can_difference = requires(const _Ty & __a, const _Ty & __b) {
    { __a - __b } -> integral;
};

template <class _Ty>
    requires (!_Has_member_difference_type<_Ty>&& _Can_difference<_Ty>)
struct incrementable_traits<_Ty> {
    using difference_type = make_signed_t<decltype(_STD declval<_Ty>() - _STD declval<_Ty>())>;
};

template <class _Ty>
concept _Is_from_primary = _Same_impl<typename _Ty::_From_primary, _Ty>;

_EXPORT_STD template <class>
struct iterator_traits;

_EXPORT_STD template <class _Ty>
using iter_difference_t = conditional_t<_Is_from_primary<iterator_traits<remove_cvref_t<_Ty>>>,
    incrementable_traits<remove_cvref_t<_Ty>>, iterator_traits<remove_cvref_t<_Ty>>>::difference_type;

template <class>
struct _Cond_value_type {};

template <class _Ty>
    requires is_object_v<_Ty>
struct _Cond_value_type<_Ty> {
    using value_type = remove_cv_t<_Ty>;
};

_EXPORT_STD template <class>
struct indirectly_readable_traits {};

template <class _Ty>
struct indirectly_readable_traits<_Ty*> : _Cond_value_type<_Ty> {};

template <class _Ty>
    requires is_array_v<_Ty>
struct indirectly_readable_traits<_Ty> {
    using value_type = remove_cv_t<remove_extent_t<_Ty>>;
};

template <class _Ty>
struct indirectly_readable_traits<const _Ty> : indirectly_readable_traits<_Ty> {};

template <_Has_member_value_type _Ty>
struct indirectly_readable_traits<_Ty> : _Cond_value_type<typename _Ty::value_type> {};

template <_Has_member_element_type _Ty>
struct indirectly_readable_traits<_Ty> : _Cond_value_type<typename _Ty::element_type> {};

template <_Has_member_value_type _Ty>
    requires _Has_member_element_type<_Ty>
struct indirectly_readable_traits<_Ty> {};

template <_Has_member_value_type _Ty>
    requires _Has_member_element_type<_Ty>
&& same_as<remove_cv_t<typename _Ty::value_type>, remove_cv_t<typename _Ty::element_type>>
struct indirectly_readable_traits<_Ty> : _Cond_value_type<typename _Ty::value_type> {};

_EXPORT_STD template <class _Ty>
using iter_value_t = conditional_t<_Is_from_primary<iterator_traits<remove_cvref_t<_Ty>>>,
    indirectly_readable_traits<remove_cvref_t<_Ty>>, iterator_traits<remove_cvref_t<_Ty>>>::value_type;

_EXPORT_STD template <_Dereferenceable _Ty>
using iter_reference_t = decltype(*_STD declval<_Ty&>());

template <class>
struct _Iterator_traits_base {};

template <class _It>
concept _Has_iter_types = _Has_member_difference_type<_It> && _Has_member_value_type<_It> && _Has_member_reference<_It>
&& _Has_member_iterator_category<_It>;

template <bool _Has_member_typedef>
struct _Old_iter_traits_pointer {
    template <class _It>
    using _Apply = _It::pointer;
};

template <>
struct _Old_iter_traits_pointer<false> {
    template <class>
    using _Apply = void;
};

template <_Has_iter_types _It>
struct _Iterator_traits_base<_It> {
    using iterator_category = _It::iterator_category;
    using value_type = _It::value_type;
    using difference_type = _It::difference_type;
    using pointer = _Old_iter_traits_pointer<_Has_member_pointer<_It>>::template _Apply<_It>;
    using reference = _It::reference;
};

template <bool _Has_member_typedef>
struct _Iter_traits_difference {
    template <class _It>
    using _Apply = incrementable_traits<_It>::difference_type;
};

template <>
struct _Iter_traits_difference<false> {
    template <class>
    using _Apply = void;
};

// clang-format off
template <class _It>
concept _Cpp17_iterator =
    requires(_It __i) {
        { *__i } -> _Can_reference;
        { ++__i } -> same_as<_It&>;
        { *__i++ } -> _Can_reference;
}
&& copyable<_It>;

template <class _It>
concept _Cpp17_input_iterator = _Cpp17_iterator<_It>
&& equality_comparable<_It>
&& _Has_member_difference_type<incrementable_traits<_It>>
&& _Has_member_value_type<indirectly_readable_traits<_It>>
&& requires(_It __i) {
    typename common_reference_t<iter_reference_t<_It>&&, typename indirectly_readable_traits<_It>::value_type&>;
    typename common_reference_t<decltype(*__i++)&&, typename indirectly_readable_traits<_It>::value_type&>;
        requires signed_integral<typename incrementable_traits<_It>::difference_type>;
};

template <class _It>
    requires (!_Has_iter_types<_It>&& _Cpp17_iterator<_It> && !_Cpp17_input_iterator<_It>)
struct _Iterator_traits_base<_It> {
    using iterator_category = output_iterator_tag;
    using value_type = void;
    using difference_type =
        _Iter_traits_difference<_Has_member_difference_type<incrementable_traits<_It>>>::template _Apply<_It>;
    using pointer = void;
    using reference = void;
};
// clang-format on

enum class _Itraits_pointer_strategy { _Use_void, _Use_member, _Use_decltype };

template <_Itraits_pointer_strategy>
struct _Iter_traits_pointer;

template <>
struct _Iter_traits_pointer<_Itraits_pointer_strategy::_Use_void> {
    template <class>
    using _Apply = void;
};

template <>
struct _Iter_traits_pointer<_Itraits_pointer_strategy::_Use_member> {
    template <class _It>
    using _Apply = _It::pointer;
};

template <>
struct _Iter_traits_pointer<_Itraits_pointer_strategy::_Use_decltype> {
    template <class _It>
    using _Apply = decltype(_STD declval<_It&>().operator->());
};

template <class _Ty>
concept _Has_member_arrow = requires(_Ty && __t) { static_cast<_Ty&&>(__t).operator->(); };

template <bool _Has_member_typedef>
struct _Iter_traits_reference {
    template <class _It>
    using _Apply = _It::reference;
};

template <>
struct _Iter_traits_reference<false> {
    template <class _It>
    using _Apply = iter_reference_t<_It>;
};

template <bool _Is_random>
struct _Iter_traits_category4 {
    using type = random_access_iterator_tag;
};

template <>
struct _Iter_traits_category4<false> {
    using type = bidirectional_iterator_tag;
};

// clang-format off
template <class _It>
concept _Cpp17_random_delta = totally_ordered<_It>
&& requires(_It __i, incrementable_traits<_It>::difference_type __n) {
    { __i += __n } -> same_as<_It&>;
    { __i -= __n } -> same_as<_It&>;
    { __i + __n } -> same_as<_It>;
    { __n + __i } -> same_as<_It>;
    { __i - __n } -> same_as<_It>;
    { __i - __i } -> same_as<decltype(__n)>;
    { __i[__n] } -> convertible_to<iter_reference_t<_It>>;
};
// clang-format on

template <bool _Is_bidi>
struct _Iter_traits_category3 {
    template <class _It>
    using _Apply = _Iter_traits_category4<_Cpp17_random_delta<_It>>::type;
};

template <>
struct _Iter_traits_category3<false> {
    template <class>
    using _Apply = forward_iterator_tag;
};

template <class _It>
concept _Cpp17_bidi_delta = requires(_It __i) {
    { --__i } -> same_as<_It&>;
    { __i-- } -> convertible_to<const _It&>;
        requires same_as<decltype(*__i--), iter_reference_t<_It>>;
};

template <bool _Is_forward>
struct _Iter_traits_category2 {
    template <class _It>
    using _Apply = _Iter_traits_category3<_Cpp17_bidi_delta<_It>>::template _Apply<_It>;
};

template <>
struct _Iter_traits_category2<false> {
    template <class>
    using _Apply = input_iterator_tag;
};

// clang-format off
template <class _It>
concept _Cpp17_forward_delta = constructible_from<_It> && is_reference_v<iter_reference_t<_It>>
&& same_as<remove_cvref_t<iter_reference_t<_It>>, typename indirectly_readable_traits<_It>::value_type>
&& requires(_It __i) {
    { __i++ } -> convertible_to<const _It&>;
    requires same_as<decltype(*__i++), iter_reference_t<_It>>;
};
// clang-format on

template <bool _Has_member_typedef>
struct _Iter_traits_category {
    template <class _It>
    using _Apply = _It::iterator_category;
};

template <>
struct _Iter_traits_category<false> {
    template <class _It>
    using _Apply = _Iter_traits_category2<_Cpp17_forward_delta<_It>>::template _Apply<_It>;
};

// clang-format off
template <class _It>
    requires (!_Has_iter_types<_It>&& _Cpp17_input_iterator<_It>)
struct _Iterator_traits_base<_It> {
    using iterator_category = _Iter_traits_category<_Has_member_iterator_category<_It>>::template _Apply<_It>;
    using value_type = indirectly_readable_traits<_It>::value_type;
    using difference_type = incrementable_traits<_It>::difference_type;
    using pointer = _Iter_traits_pointer<(
        _Has_member_pointer<_It> ? _Itraits_pointer_strategy::_Use_member
        : _Has_member_arrow<_It&> ? _Itraits_pointer_strategy::_Use_decltype
        : _Itraits_pointer_strategy::_Use_void)>::template _Apply<_It>;
    using reference = _Iter_traits_reference<_Has_member_reference<_It>>::template _Apply<_It>;
};
// clang-format on

_EXPORT_STD template <class _Ty>
struct iterator_traits : _Iterator_traits_base<_Ty> {
    using _From_primary = iterator_traits;
};

template <class _Ty>
    requires is_object_v<_Ty>
struct iterator_traits<_Ty*> {
    using iterator_concept = contiguous_iterator_tag;
    using iterator_category = random_access_iterator_tag;
    using value_type = remove_cv_t<_Ty>;
    using difference_type = ptrdiff_t;
    using pointer = _Ty*;
    using reference = _Ty&;
};

template <class _Ty>
inline constexpr bool _Integer_class = requires {
    typename _Ty::_Signed_type;
    typename _Ty::_Unsigned_type;
};

template <class _Ty>
concept _Integer_like = _Is_nonbool_integral<remove_cv_t<_Ty>> || _Integer_class<_Ty>;

template <class _Ty>
concept _Signed_integer_like = _Integer_like<_Ty> && static_cast<_Ty>(-1) < static_cast<_Ty>(0);

// clang-format off
_EXPORT_STD template <class _Ty>
concept weakly_incrementable = movable<_Ty>
&& requires(_Ty __i) {
    typename iter_difference_t<_Ty>;
    requires _Signed_integer_like<iter_difference_t<_Ty>>;
    { ++__i } -> same_as<_Ty&>;
    __i++;
};

_EXPORT_STD template <class _It>
concept input_or_output_iterator = requires(_It __i) { { *__i } -> _Can_reference; }
&& weakly_incrementable<_It>;

_EXPORT_STD template <class _Se, class _It>
concept sentinel_for = semiregular<_Se>
&& input_or_output_iterator<_It>
&& _Weakly_equality_comparable_with<_Se, _It>;
// clang-format on

_EXPORT_STD template <class _Se, class _It>
inline constexpr bool disable_sized_sentinel_for = false;

// clang-format off
_EXPORT_STD template <class _Se, class _It>
concept sized_sentinel_for = sentinel_for<_Se, _It>
&& !disable_sized_sentinel_for<remove_cv_t<_Se>, remove_cv_t<_It>>
&& requires(const _It& __i, const _Se& __s) {
    { __s - __i } -> same_as<iter_difference_t<_It>>;
    { __i - __s } -> same_as<iter_difference_t<_It>>;
};
// clang-format on

_EXPORT_STD struct default_sentinel_t {};

_EXPORT_STD inline constexpr default_sentinel_t default_sentinel{};

namespace ranges {
    _EXPORT_STD enum class subrange_kind : bool { unsized, sized };

    _EXPORT_STD template <input_or_output_iterator _It, sentinel_for<_It> _Se = _It,
        subrange_kind _Ki = sized_sentinel_for<_Se, _It> ? subrange_kind::sized : subrange_kind::unsized>
        requires (_Ki == subrange_kind::sized || !sized_sentinel_for<_Se, _It>)
    class subrange;

    _EXPORT_STD template <size_t _Idx, class _It, class _Se, subrange_kind _Ki>
        requires ((_Idx == 0 && copyable<_It>) || _Idx == 1)
    _NODISCARD constexpr auto get(const subrange<_It, _Se, _Ki>& _Val);

    _EXPORT_STD template <size_t _Idx, class _It, class _Se, subrange_kind _Ki>
        requires (_Idx < 2)
    _NODISCARD constexpr auto get(subrange<_It, _Se, _Ki>&& _Val);
} // namespace ranges

_EXPORT_STD using ranges::get;

template <class _It, class _Se, ranges::subrange_kind _Ki>
inline constexpr bool _Is_subrange_v<ranges::subrange<_It, _Se, _Ki>> = true;

template <class _It, class _Se, ranges::subrange_kind _Ki>
struct tuple_size<ranges::subrange<_It, _Se, _Ki>> : integral_constant<size_t, 2> {};

template <class _It, class _Se, ranges::subrange_kind _Ki>
struct tuple_element<0, ranges::subrange<_It, _Se, _Ki>> {
    using type = _It;
};

template <class _It, class _Se, ranges::subrange_kind _Ki>
struct tuple_element<1, ranges::subrange<_It, _Se, _Ki>> {
    using type = _Se;
};

template <class _It, class _Se, ranges::subrange_kind _Ki>
struct tuple_element<0, const ranges::subrange<_It, _Se, _Ki>> {
    using type = _It;
};

template <class _It, class _Se, ranges::subrange_kind _Ki>
struct tuple_element<1, const ranges::subrange<_It, _Se, _Ki>> {
    using type = _Se;
};
#else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
template <class, class = void>
struct _Iterator_traits_base {}; // empty for non-iterators

template <class _Iter>
struct _Iterator_traits_base<_Iter,
    void_t<typename _Iter::iterator_category, typename _Iter::value_type, typename _Iter::difference_type,
    typename _Iter::pointer, typename _Iter::reference>> {
    // defined if _Iter::* types exist
    using iterator_category = typename _Iter::iterator_category;
    using value_type = typename _Iter::value_type;
    using difference_type = typename _Iter::difference_type;
    using pointer = typename _Iter::pointer;
    using reference = typename _Iter::reference;
};

template <class _Ty, bool = is_object_v<_Ty>>
struct _Iterator_traits_pointer_base { // iterator properties for pointers to object
    using iterator_category = random_access_iterator_tag;
    using value_type = remove_cv_t<_Ty>;
    using difference_type = ptrdiff_t;
    using pointer = _Ty*;
    using reference = _Ty&;
};

template <class _Ty>
struct _Iterator_traits_pointer_base<_Ty, false> {}; // iterator non-properties for pointers to non-object

template <class _Iter>
struct iterator_traits : _Iterator_traits_base<_Iter> {}; // get traits from iterator _Iter, if possible

template <class _Ty>
struct iterator_traits<_Ty*> : _Iterator_traits_pointer_base<_Ty> {}; // get traits from pointer, if possible
#endif // ^^^ !_HAS_CXX20 ^^^
_STD_END

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#endif // _STL_COMPILER_PREPROCESSOR
#endif // __MSVC_ITER_CORE_HPP


#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

// TRANSITION, non-_Ugly attribute tokens
#pragma push_macro("msvc")
#pragma push_macro("intrinsic")
#undef msvc
#undef intrinsic

#if defined(_CRTBLD) && defined(CRTDLL2)
// TRANSITION, ABI: The vector algorithms are compiled into the import lib, so we disable their usage when building
// the DLL. (We could additionally link them into the DLL - not as exports, just for internal usage - but we
// haven't chosen to do that yet.) When we can break ABI and export the vector algorithms from the DLL,
// this preprocessor case should be removed.
#ifndef _USE_STD_VECTOR_ALGORITHMS
#define _USE_STD_VECTOR_ALGORITHMS 0
#elif _USE_STD_VECTOR_ALGORITHMS
#error Vector algorithms are not supported when building msvcp140.dll, but _USE_STD_VECTOR_ALGORITHMS is set.
#endif // ^^^ _USE_STD_VECTOR_ALGORITHMS != 0 ^^^
#elif (defined(_M_IX86) || defined(_M_X64)) && !defined(_M_CEE_PURE) && !defined(_M_HYBRID) && !defined(_M_ARM64EC)
#ifndef _USE_STD_VECTOR_ALGORITHMS
#define _USE_STD_VECTOR_ALGORITHMS 1
#endif // !defined(_USE_STD_VECTOR_ALGORITHMS)
#else // ^^^ arch supports vector algorithms / no support for vector algorithms vvv
#ifndef _USE_STD_VECTOR_ALGORITHMS
#define _USE_STD_VECTOR_ALGORITHMS 0
#elif _USE_STD_VECTOR_ALGORITHMS
#error Vector algorithms are not supported on this architecture, but _USE_STD_VECTOR_ALGORITHMS is set.
#endif // ^^^ _USE_STD_VECTOR_ALGORITHMS != 0 ^^^
#endif // ^^^ no support for vector algorithms ^^^

#ifndef _USE_STD_VECTOR_FLOATING_ALGORITHMS
#if _USE_STD_VECTOR_ALGORITHMS && !defined(_M_FP_EXCEPT)
#define _USE_STD_VECTOR_FLOATING_ALGORITHMS 1
#else // ^^^ use vector algorithms and fast math / not use vector algorithms or not use fast math vvv
#define _USE_STD_VECTOR_FLOATING_ALGORITHMS 0
#endif // ^^^ not use vector algorithms or not use fast math ^^^
#else // ^^^ !defined(_USE_STD_VECTOR_FLOATING_ALGORITHMS) / defined(_USE_STD_VECTOR_FLOATING_ALGORITHMS) vvv
#if _USE_STD_VECTOR_FLOATING_ALGORITHMS && !_USE_STD_VECTOR_ALGORITHMS
#error _USE_STD_VECTOR_FLOATING_ALGORITHMS must imply _USE_STD_VECTOR_ALGORITHMS.
#endif // _USE_STD_VECTOR_FLOATING_ALGORITHMS && !_USE_STD_VECTOR_ALGORITHMS
#endif // ^^^ defined(_USE_STD_VECTOR_FLOATING_ALGORITHMS) ^^^

#if _USE_STD_VECTOR_ALGORITHMS
extern "C" {
    // The "noalias" attribute tells the compiler optimizer that pointers going into these hand-vectorized algorithms
    // won't be stored beyond the lifetime of the function, and that the function will only reference arrays denoted by
    // those pointers. The optimizer also assumes in that case that a pointer parameter is not returned to the caller via
    // the return value, so functions using "noalias" must usually return void. This attribute is valuable because these
    // functions are in native code objects that the compiler cannot analyze. In the absence of the noalias attribute, the
    // compiler has to assume that the denoted arrays are "globally address taken", and that any later calls to
    // unanalyzable routines may modify those arrays.
    __declspec(noalias) void __cdecl __std_reverse_trivially_swappable_1(void* _First, void* _Last) noexcept;
    __declspec(noalias) void __cdecl __std_reverse_trivially_swappable_2(void* _First, void* _Last) noexcept;
    __declspec(noalias) void __cdecl __std_reverse_trivially_swappable_4(void* _First, void* _Last) noexcept;
    __declspec(noalias) void __cdecl __std_reverse_trivially_swappable_8(void* _First, void* _Last) noexcept;
    __declspec(noalias) void __cdecl __std_swap_ranges_trivially_swappable_noalias(
        void* _First1, void* _Last1, void* _First2) noexcept;

    __declspec(noalias)size_t
        __stdcall __std_count_trivial_1(const void* _First, const void* _Last, uint8_t _Val) noexcept;
    __declspec(noalias)size_t
        __stdcall __std_count_trivial_2(const void* _First, const void* _Last, uint16_t _Val) noexcept;
    __declspec(noalias)size_t
        __stdcall __std_count_trivial_4(const void* _First, const void* _Last, uint32_t _Val) noexcept;
    __declspec(noalias)size_t
        __stdcall __std_count_trivial_8(const void* _First, const void* _Last, uint64_t _Val) noexcept;

    const void* __stdcall __std_find_trivial_1(const void* _First, const void* _Last, uint8_t _Val) noexcept;
    const void* __stdcall __std_find_trivial_2(const void* _First, const void* _Last, uint16_t _Val) noexcept;
    const void* __stdcall __std_find_trivial_4(const void* _First, const void* _Last, uint32_t _Val) noexcept;
    const void* __stdcall __std_find_trivial_8(const void* _First, const void* _Last, uint64_t _Val) noexcept;

    const void* __stdcall __std_find_trivial_unsized_1(const void* _First, uint8_t _Val) noexcept;
    const void* __stdcall __std_find_trivial_unsized_2(const void* _First, uint16_t _Val) noexcept;
    const void* __stdcall __std_find_trivial_unsized_4(const void* _First, uint32_t _Val) noexcept;
    const void* __stdcall __std_find_trivial_unsized_8(const void* _First, uint64_t _Val) noexcept;

    const void* __stdcall __std_min_element_1(const void* _First, const void* _Last, bool _Signed) noexcept;
    const void* __stdcall __std_min_element_2(const void* _First, const void* _Last, bool _Signed) noexcept;
    const void* __stdcall __std_min_element_4(const void* _First, const void* _Last, bool _Signed) noexcept;
    const void* __stdcall __std_min_element_8(const void* _First, const void* _Last, bool _Signed) noexcept;
    const void* __stdcall __std_min_element_f(const void* _First, const void* _Last, bool _Unused) noexcept;
    const void* __stdcall __std_min_element_d(const void* _First, const void* _Last, bool _Unused) noexcept;

    const void* __stdcall __std_max_element_1(const void* _First, const void* _Last, bool _Signed) noexcept;
    const void* __stdcall __std_max_element_2(const void* _First, const void* _Last, bool _Signed) noexcept;
    const void* __stdcall __std_max_element_4(const void* _First, const void* _Last, bool _Signed) noexcept;
    const void* __stdcall __std_max_element_8(const void* _First, const void* _Last, bool _Signed) noexcept;
    const void* __stdcall __std_max_element_f(const void* _First, const void* _Last, bool _Unused) noexcept;
    const void* __stdcall __std_max_element_d(const void* _First, const void* _Last, bool _Unused) noexcept;

    __declspec(noalias)int8_t __stdcall __std_min_1i(const void* _First, const void* _Last) noexcept;
    __declspec(noalias)uint8_t __stdcall __std_min_1u(const void* _First, const void* _Last) noexcept;
    __declspec(noalias)int16_t __stdcall __std_min_2i(const void* _First, const void* _Last) noexcept;
    __declspec(noalias)uint16_t __stdcall __std_min_2u(const void* _First, const void* _Last) noexcept;
    __declspec(noalias)int32_t __stdcall __std_min_4i(const void* _First, const void* _Last) noexcept;
    __declspec(noalias)uint32_t __stdcall __std_min_4u(const void* _First, const void* _Last) noexcept;
    __declspec(noalias)int64_t __stdcall __std_min_8i(const void* _First, const void* _Last) noexcept;
    __declspec(noalias)uint64_t __stdcall __std_min_8u(const void* _First, const void* _Last) noexcept;
    __declspec(noalias) float __stdcall __std_min_f(const void* _First, const void* _Last) noexcept;
    __declspec(noalias) double __stdcall __std_min_d(const void* _First, const void* _Last) noexcept;
    __declspec(noalias)int8_t __stdcall __std_max_1i(const void* _First, const void* _Last) noexcept;
    __declspec(noalias)uint8_t __stdcall __std_max_1u(const void* _First, const void* _Last) noexcept;
    __declspec(noalias)int16_t __stdcall __std_max_2i(const void* _First, const void* _Last) noexcept;
    __declspec(noalias)uint16_t __stdcall __std_max_2u(const void* _First, const void* _Last) noexcept;
    __declspec(noalias)int32_t __stdcall __std_max_4i(const void* _First, const void* _Last) noexcept;
    __declspec(noalias)uint32_t __stdcall __std_max_4u(const void* _First, const void* _Last) noexcept;
    __declspec(noalias)int64_t __stdcall __std_max_8i(const void* _First, const void* _Last) noexcept;
    __declspec(noalias)uint64_t __stdcall __std_max_8u(const void* _First, const void* _Last) noexcept;
    __declspec(noalias) float __stdcall __std_max_f(const void* _First, const void* _Last) noexcept;
    __declspec(noalias) double __stdcall __std_max_d(const void* _First, const void* _Last) noexcept;
} // extern "C"

_STD_BEGIN
template <class _Ty, class _TVal>
__declspec(noalias)size_t __std_count_trivial(_Ty* const _First, _Ty* const _Last, const _TVal _Val) noexcept {
    if constexpr (is_pointer_v<_TVal> || is_null_pointer_v<_TVal>) {
        return _STD __std_count_trivial(_First, _Last, reinterpret_cast<uintptr_t>(_Val));
    }
    else if constexpr (sizeof(_Ty) == 1) {
        return ::__std_count_trivial_1(_First, _Last, static_cast<uint8_t>(_Val));
    }
    else if constexpr (sizeof(_Ty) == 2) {
        return ::__std_count_trivial_2(_First, _Last, static_cast<uint16_t>(_Val));
    }
    else if constexpr (sizeof(_Ty) == 4) {
        return ::__std_count_trivial_4(_First, _Last, static_cast<uint32_t>(_Val));
    }
    else if constexpr (sizeof(_Ty) == 8) {
        return ::__std_count_trivial_8(_First, _Last, static_cast<uint64_t>(_Val));
    }
    else {
        static_assert(_Always_false<_Ty>, "Unexpected size");
    }
}

template <class _Ty, class _TVal>
_Ty* __std_find_trivial(_Ty* const _First, _Ty* const _Last, const _TVal _Val) noexcept {
    if constexpr (is_pointer_v<_TVal> || is_null_pointer_v<_TVal>) {
        return _STD __std_find_trivial(_First, _Last, reinterpret_cast<uintptr_t>(_Val));
    }
    else if constexpr (sizeof(_Ty) == 1) {
        return const_cast<_Ty*>(
            static_cast<const _Ty*>(::__std_find_trivial_1(_First, _Last, static_cast<uint8_t>(_Val))));
    }
    else if constexpr (sizeof(_Ty) == 2) {
        return const_cast<_Ty*>(
            static_cast<const _Ty*>(::__std_find_trivial_2(_First, _Last, static_cast<uint16_t>(_Val))));
    }
    else if constexpr (sizeof(_Ty) == 4) {
        return const_cast<_Ty*>(
            static_cast<const _Ty*>(::__std_find_trivial_4(_First, _Last, static_cast<uint32_t>(_Val))));
    }
    else if constexpr (sizeof(_Ty) == 8) {
        return const_cast<_Ty*>(
            static_cast<const _Ty*>(::__std_find_trivial_8(_First, _Last, static_cast<uint64_t>(_Val))));
    }
    else {
        static_assert(_Always_false<_Ty>, "Unexpected size");
    }
}

template <class _Ty, class _TVal>
_Ty* __std_find_trivial_unsized(_Ty* const _First, const _TVal _Val) noexcept {
    if constexpr (is_pointer_v<_TVal> || is_null_pointer_v<_TVal>) {
        return _STD __std_find_trivial_unsized(_First, reinterpret_cast<uintptr_t>(_Val));
    }
    else if constexpr (sizeof(_Ty) == 1) {
        return const_cast<_Ty*>(
            static_cast<const _Ty*>(::__std_find_trivial_unsized_1(_First, static_cast<uint8_t>(_Val))));
    }
    else if constexpr (sizeof(_Ty) == 2) {
        return const_cast<_Ty*>(
            static_cast<const _Ty*>(::__std_find_trivial_unsized_2(_First, static_cast<uint16_t>(_Val))));
    }
    else if constexpr (sizeof(_Ty) == 4) {
        return const_cast<_Ty*>(
            static_cast<const _Ty*>(::__std_find_trivial_unsized_4(_First, static_cast<uint32_t>(_Val))));
    }
    else if constexpr (sizeof(_Ty) == 8) {
        return const_cast<_Ty*>(
            static_cast<const _Ty*>(::__std_find_trivial_unsized_8(_First, static_cast<uint64_t>(_Val))));
    }
    else {
        static_assert(_Always_false<_Ty>, "Unexpected size");
    }
}

template <class _Ty>
_Ty* __std_min_element(_Ty* const _First, _Ty* const _Last) noexcept {
    constexpr bool _Signed = is_signed_v<_Ty>;

    if constexpr (is_same_v<remove_const_t<_Ty>, float>) {
        return const_cast<_Ty*>(static_cast<const _Ty*>(::__std_min_element_f(_First, _Last, false)));
    }
    else if constexpr (_Is_any_of_v<remove_const_t<_Ty>, double, long double>) {
        return const_cast<_Ty*>(static_cast<const _Ty*>(::__std_min_element_d(_First, _Last, false)));
    }
    else if constexpr (sizeof(_Ty) == 1) {
        return const_cast<_Ty*>(static_cast<const _Ty*>(::__std_min_element_1(_First, _Last, _Signed)));
    }
    else if constexpr (sizeof(_Ty) == 2) {
        return const_cast<_Ty*>(static_cast<const _Ty*>(::__std_min_element_2(_First, _Last, _Signed)));
    }
    else if constexpr (sizeof(_Ty) == 4) {
        return const_cast<_Ty*>(static_cast<const _Ty*>(::__std_min_element_4(_First, _Last, _Signed)));
    }
    else if constexpr (sizeof(_Ty) == 8) {
        return const_cast<_Ty*>(static_cast<const _Ty*>(::__std_min_element_8(_First, _Last, _Signed)));
    }
    else {
        static_assert(_Always_false<_Ty>, "Unexpected size");
    }
}

template <class _Ty>
_Ty* __std_max_element(_Ty* const _First, _Ty* const _Last) noexcept {
    constexpr bool _Signed = is_signed_v<_Ty>;

    if constexpr (is_same_v<remove_const_t<_Ty>, float>) {
        return const_cast<_Ty*>(static_cast<const _Ty*>(::__std_max_element_f(_First, _Last, false)));
    }
    else if constexpr (_Is_any_of_v<remove_const_t<_Ty>, double, long double>) {
        return const_cast<_Ty*>(static_cast<const _Ty*>(::__std_max_element_d(_First, _Last, false)));
    }
    else if constexpr (sizeof(_Ty) == 1) {
        return const_cast<_Ty*>(static_cast<const _Ty*>(::__std_max_element_1(_First, _Last, _Signed)));
    }
    else if constexpr (sizeof(_Ty) == 2) {
        return const_cast<_Ty*>(static_cast<const _Ty*>(::__std_max_element_2(_First, _Last, _Signed)));
    }
    else if constexpr (sizeof(_Ty) == 4) {
        return const_cast<_Ty*>(static_cast<const _Ty*>(::__std_max_element_4(_First, _Last, _Signed)));
    }
    else if constexpr (sizeof(_Ty) == 8) {
        return const_cast<_Ty*>(static_cast<const _Ty*>(::__std_max_element_8(_First, _Last, _Signed)));
    }
    else {
        static_assert(_Always_false<_Ty>, "Unexpected size");
    }
}

template <class _Ty>
auto __std_min(_Ty* const _First, _Ty* const _Last) noexcept {
    constexpr bool _Signed = is_signed_v<_Ty>;

    if constexpr (is_pointer_v<_Ty>) {
#ifdef _WIN64
        return reinterpret_cast<void*>(::__std_min_8u(_First, _Last));
#else
        return reinterpret_cast<void*>(::__std_min_4u(_First, _Last));
#endif
    }
    else if constexpr (is_same_v<remove_const_t<_Ty>, float>) {
        return ::__std_min_f(_First, _Last);
    }
    else if constexpr (_Is_any_of_v<remove_const_t<_Ty>, double, long double>) {
        return ::__std_min_d(_First, _Last);
    }
    else if constexpr (sizeof(_Ty) == 1) {
        if constexpr (_Signed) {
            return ::__std_min_1i(_First, _Last);
        }
        else {
            return ::__std_min_1u(_First, _Last);
        }
    }
    else if constexpr (sizeof(_Ty) == 2) {
        if constexpr (_Signed) {
            return ::__std_min_2i(_First, _Last);
        }
        else {
            return ::__std_min_2u(_First, _Last);
        }
    }
    else if constexpr (sizeof(_Ty) == 4) {
        if constexpr (_Signed) {
            return ::__std_min_4i(_First, _Last);
        }
        else {
            return ::__std_min_4u(_First, _Last);
        }
    }
    else if constexpr (sizeof(_Ty) == 8) {
        if constexpr (_Signed) {
            return ::__std_min_8i(_First, _Last);
        }
        else {
            return ::__std_min_8u(_First, _Last);
        }
    }
    else {
        static_assert(_Always_false<_Ty>, "Unexpected size");
    }
}

template <class _Ty>
auto __std_max(_Ty* const _First, _Ty* const _Last) noexcept {
    constexpr bool _Signed = is_signed_v<_Ty>;

    if constexpr (is_pointer_v<_Ty>) {
#ifdef _WIN64
        return reinterpret_cast<void*>(::__std_max_8u(_First, _Last));
#else
        return reinterpret_cast<void*>(::__std_max_4u(_First, _Last));
#endif
    }
    else if constexpr (is_same_v<remove_const_t<_Ty>, float>) {
        return ::__std_max_f(_First, _Last);
    }
    else if constexpr (_Is_any_of_v<remove_const_t<_Ty>, double, long double>) {
        return ::__std_max_d(_First, _Last);
    }
    else if constexpr (sizeof(_Ty) == 1) {
        if constexpr (_Signed) {
            return ::__std_max_1i(_First, _Last);
        }
        else {
            return ::__std_max_1u(_First, _Last);
        }
    }
    else if constexpr (sizeof(_Ty) == 2) {
        if constexpr (_Signed) {
            return ::__std_max_2i(_First, _Last);
        }
        else {
            return ::__std_max_2u(_First, _Last);
        }
    }
    else if constexpr (sizeof(_Ty) == 4) {
        if constexpr (_Signed) {
            return ::__std_max_4i(_First, _Last);
        }
        else {
            return ::__std_max_4u(_First, _Last);
        }
    }
    else if constexpr (sizeof(_Ty) == 8) {
        if constexpr (_Signed) {
            return ::__std_max_8i(_First, _Last);
        }
        else {
            return ::__std_max_8u(_First, _Last);
        }
    }
    else {
        static_assert(_Always_false<_Ty>, "Unexpected size");
    }
}
_STD_END

#endif // _USE_STD_VECTOR_ALGORITHMS

_STD_BEGIN

template <class _Ty>
struct _Get_first_parameter;

template <template <class, class...> class _Ty, class _First, class... _Rest>
struct _Get_first_parameter<_Ty<_First, _Rest...>> { // given _Ty<_First, _Rest...>, extract _First
    using type = _First;
};

template <class _Newfirst, class _Ty>
struct _Replace_first_parameter;

template <class _Newfirst, template <class, class...> class _Ty, class _First, class... _Rest>
struct _Replace_first_parameter<_Newfirst, _Ty<_First, _Rest...>> { // given _Ty<_First, _Rest...>, replace _First
    using type = _Ty<_Newfirst, _Rest...>;
};

template <class _Ty, class = void>
struct _Get_ptr_difference_type {
    using type = ptrdiff_t;
};

template <class _Ty>
struct _Get_ptr_difference_type<_Ty, void_t<typename _Ty::difference_type>> {
    using type = typename _Ty::difference_type;
};

template <class _Ty, class _Other, class = void>
struct _Get_rebind_alias {
    using type = typename _Replace_first_parameter<_Other, _Ty>::type;
};

template <class _Ty, class _Other>
struct _Get_rebind_alias<_Ty, _Other, void_t<typename _Ty::template rebind<_Other>>> {
    using type = typename _Ty::template rebind<_Other>;
};

#if _HAS_CXX20
#if defined(__clang__) || defined(__EDG__) // TRANSITION, DevCom-1691516
// per LWG-3888
_EXPORT_STD template <class _Ty, class... _Types,
    class = void_t<decltype(::new(static_cast<void*>(_STD declval<_Ty*>())) _Ty(_STD declval<_Types>()...))>>
#else // ^^^ no workaround / workaround vvv
// per LWG-3888
_EXPORT_STD template <class _Ty, class... _Types,
    void_t<decltype(::new(static_cast<void*>(_STD declval<_Ty*>())) _Ty(_STD declval<_Types>()...))>* = nullptr>
#endif // ^^^ workaround ^^^
    constexpr _Ty* construct_at(_Ty* const _Location, _Types&&... _Args) noexcept(
        noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {
    _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);
}
#endif // _HAS_CXX20

template <class _Ty, class... _Types>
_CONSTEXPR20 void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(
    is_nothrow_constructible_v<_Ty, _Types...>) {
#if _HAS_CXX20
    if (_STD is_constant_evaluated()) {
        _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
    }
    else
#endif // _HAS_CXX20
    {
        ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
    }
}

template <class _Ty>
void _Default_construct_in_place(_Ty& _Obj) noexcept(is_nothrow_default_constructible_v<_Ty>) {
    ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty;
}

template <class _Ty, class _Elem>
struct _Ptr_traits_base {
    using pointer = _Ty;
    using element_type = _Elem;
    using difference_type = typename _Get_ptr_difference_type<_Ty>::type;

    template <class _Other>
    using rebind = typename _Get_rebind_alias<_Ty, _Other>::type;

    using _Reftype = conditional_t<is_void_v<_Elem>, char, _Elem>&;

    _NODISCARD static _CONSTEXPR20 pointer pointer_to(_Reftype _Val) noexcept(
        noexcept(_Ty::pointer_to(_Val))) /* strengthened */ { // Per LWG-3454
        return _Ty::pointer_to(_Val);
    }
};

template <class, class = void, class = void>
struct _Ptr_traits_sfinae_layer {};

template <class _Ty, class _Uty>
struct _Ptr_traits_sfinae_layer<_Ty, _Uty, void_t<typename _Get_first_parameter<_Ty>::type>>
    : _Ptr_traits_base<_Ty, typename _Get_first_parameter<_Ty>::type> {};

template <class _Ty>
struct _Ptr_traits_sfinae_layer<_Ty, void_t<typename _Ty::element_type>, void>
    : _Ptr_traits_base<_Ty, typename _Ty::element_type> {};

_EXPORT_STD template <class _Ty>
struct pointer_traits : _Ptr_traits_sfinae_layer<_Ty> {};

template <class _Ty>
struct pointer_traits<_Ty*> {
    using pointer = _Ty*;
    using element_type = _Ty;
    using difference_type = ptrdiff_t;

    template <class _Other>
    using rebind = _Other*;

    using _Reftype = conditional_t<is_void_v<_Ty>, char, _Ty>&;

    _NODISCARD static _CONSTEXPR20 pointer pointer_to(_Reftype _Val) noexcept {
        return _STD addressof(_Val);
    }
};

#if _HAS_CXX20
template <class _Ty>
concept _Has_to_address = requires(const _Ty & _Val) {
    typename pointer_traits<_Ty>;
    pointer_traits<_Ty>::to_address(_Val);
};

_EXPORT_STD template <class _Ty>
_NODISCARD constexpr _Ty* to_address(_Ty* const _Val) noexcept {
    static_assert(!is_function_v<_Ty>, "N4950 [pointer.conversion]/1: Mandates: T is not a function type.");
    return _Val;
}

_EXPORT_STD template <class _Ptr>
_NODISCARD constexpr auto to_address(const _Ptr& _Val) noexcept {
    if constexpr (_Has_to_address<_Ptr>) {
        return pointer_traits<_Ptr>::to_address(_Val);
    }
    else {
        return _STD to_address(_Val.operator->()); // plain pointer overload must come first
    }
}

_EXPORT_STD struct identity {
    template <class _Ty>
    _NODISCARD constexpr _Ty&& operator()(_Ty&& _Left) const noexcept {
        return _STD forward<_Ty>(_Left);
    }

    using is_transparent = int;
};
#endif // _HAS_CXX20

_EXPORT_STD template <class _Ty = void>
struct plus {
    using _FIRST_ARGUMENT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = _Ty;
    using _SECOND_ARGUMENT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = _Ty;
    using _RESULT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = _Ty;

    _NODISCARD constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const {
        return _Left + _Right;
    }
};

_EXPORT_STD template <class _Ty = void>
struct minus {
    using _FIRST_ARGUMENT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = _Ty;
    using _SECOND_ARGUMENT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = _Ty;
    using _RESULT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = _Ty;

    _NODISCARD constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const {
        return _Left - _Right;
    }
};

_EXPORT_STD template <class _Ty = void>
struct multiplies {
    using _FIRST_ARGUMENT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = _Ty;
    using _SECOND_ARGUMENT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = _Ty;
    using _RESULT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = _Ty;

    _NODISCARD constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const {
        return _Left * _Right;
    }
};

_EXPORT_STD template <class _Ty = void>
struct equal_to {
    using _FIRST_ARGUMENT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = _Ty;
    using _SECOND_ARGUMENT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = _Ty;
    using _RESULT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = bool;

    _NODISCARD constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
        noexcept(noexcept(_STD _Fake_copy_init<bool>(_Left == _Right))) /* strengthened */ {
        return _Left == _Right;
    }
};

_EXPORT_STD template <class _Ty = void>
struct not_equal_to {
    using _FIRST_ARGUMENT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = _Ty;
    using _SECOND_ARGUMENT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = _Ty;
    using _RESULT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = bool;

    _NODISCARD constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
        noexcept(noexcept(_STD _Fake_copy_init<bool>(_Left != _Right))) /* strengthened */ {
        return _Left != _Right;
    }
};

_EXPORT_STD template <class _Ty = void>
struct greater {
    using _FIRST_ARGUMENT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = _Ty;
    using _SECOND_ARGUMENT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = _Ty;
    using _RESULT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = bool;

    _NODISCARD constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
        noexcept(noexcept(_STD _Fake_copy_init<bool>(_Left > _Right))) /* strengthened */ {
        return _Left > _Right;
    }
};

_EXPORT_STD template <class _Ty = void>
struct greater_equal {
    using _FIRST_ARGUMENT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = _Ty;
    using _SECOND_ARGUMENT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = _Ty;
    using _RESULT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = bool;

    _NODISCARD constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
        noexcept(noexcept(_STD _Fake_copy_init<bool>(_Left >= _Right))) /* strengthened */ {
        return _Left >= _Right;
    }
};

_EXPORT_STD template <class _Ty = void>
struct less_equal {
    using _FIRST_ARGUMENT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = _Ty;
    using _SECOND_ARGUMENT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = _Ty;
    using _RESULT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = bool;

    _NODISCARD constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
        noexcept(noexcept(_STD _Fake_copy_init<bool>(_Left <= _Right))) /* strengthened */ {
        return _Left <= _Right;
    }
};

template <>
struct plus<void> {
    template <class _Ty1, class _Ty2>
    _NODISCARD constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) + static_cast<_Ty2&&>(_Right))) // strengthened
        -> decltype(static_cast<_Ty1&&>(_Left) + static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) + static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

template <>
struct minus<void> {
    template <class _Ty1, class _Ty2>
    _NODISCARD constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) - static_cast<_Ty2&&>(_Right))) // strengthened
        -> decltype(static_cast<_Ty1&&>(_Left) - static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) - static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

template <>
struct multiplies<void> {
    template <class _Ty1, class _Ty2>
    _NODISCARD constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left)* static_cast<_Ty2&&>(_Right))) // strengthened
        -> decltype(static_cast<_Ty1&&>(_Left)* static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) * static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

template <>
struct equal_to<void> {
    template <class _Ty1, class _Ty2>
    _NODISCARD constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) == static_cast<_Ty2&&>(_Right))) // strengthened
        -> decltype(static_cast<_Ty1&&>(_Left) == static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) == static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

template <>
struct not_equal_to<void> {
    template <class _Ty1, class _Ty2>
    _NODISCARD constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) != static_cast<_Ty2&&>(_Right))) // strengthened
        -> decltype(static_cast<_Ty1&&>(_Left) != static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) != static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

template <>
struct greater<void> {
    template <class _Ty1, class _Ty2>
    _NODISCARD constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) > static_cast<_Ty2&&>(_Right))) // strengthened
        -> decltype(static_cast<_Ty1&&>(_Left) > static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) > static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

template <>
struct greater_equal<void> {
    template <class _Ty1, class _Ty2>
    _NODISCARD constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) >= static_cast<_Ty2&&>(_Right))) // strengthened
        -> decltype(static_cast<_Ty1&&>(_Left) >= static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) >= static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

template <>
struct less_equal<void> {
    template <class _Ty1, class _Ty2>
    _NODISCARD constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) <= static_cast<_Ty2&&>(_Right))) // strengthened
        -> decltype(static_cast<_Ty1&&>(_Left) <= static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) <= static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

template <class _Fx>
struct _Ref_fn { // pass function object by value as a reference
    // _Ref_fn is an aggregate so it can be enregistered, unlike reference_wrapper

    template <class... _Args>
    constexpr decltype(auto) operator()(_Args&&... _Vals) noexcept(
        _Select_invoke_traits<_Fx&, _Args...>::_Is_nothrow_invocable::value) { // forward function call operator
        if constexpr (is_member_pointer_v<_Fx>) {
            return _STD invoke(_Fn, _STD forward<_Args>(_Vals)...);
        }
        else {
            return _Fn(_STD forward<_Args>(_Vals)...);
        }
    }

    _Fx& _Fn;
};

template <class _Fn>
_NODISCARD constexpr auto _Pass_fn(_Fn& _Func) noexcept {
    constexpr bool _Pass_by_value = conjunction_v<bool_constant<sizeof(_Fn) <= sizeof(void*)>,
        is_trivially_copy_constructible<_Fn>, is_trivially_destructible<_Fn>>;
    if constexpr (_Pass_by_value) {
        return _Func;
    }
    else {
        return _Ref_fn<_Fn>{_Func}; // pass functor by "reference"
    }
}

#if _HAS_CXX23
_EXPORT_STD template <class _Result_type, class _Callable, class... _Types,
    enable_if_t<is_invocable_r_v<_Result_type, _Callable, _Types...>, int> = 0>
    _NODISCARD constexpr _Result_type invoke_r(_Callable&& _Obj, _Types&&... _Args) noexcept(
        is_nothrow_invocable_r_v<_Result_type, _Callable, _Types...>) {
    if constexpr (is_void_v<_Result_type>) {
        (void)_STD invoke(static_cast<_Callable&&>(_Obj), static_cast<_Types&&>(_Args)...);
    }
    else {
        return _STD invoke(static_cast<_Callable&&>(_Obj), static_cast<_Types&&>(_Args)...);
    }
}
#endif // _HAS_CXX23

struct _Unused_parameter { // generic unused parameter struct
    constexpr _Unused_parameter() noexcept = default;
    template <class _Ty>
    constexpr _Unused_parameter(_Ty&&) noexcept {}
};

template <class _Ty, class = void> // checks whether a container/view is a non-customized specialization
_INLINE_VAR constexpr bool _Has_unchecked_begin_end = false;

template <class _Ty>
_INLINE_VAR constexpr bool _Has_unchecked_begin_end<_Ty,
    void_t<decltype(_STD declval<_Ty&>()._Unchecked_begin()), decltype(_STD declval<_Ty&>()._Unchecked_end())>> = true;

template <class _Ty>
using _Algorithm_int_t = conditional_t<is_integral_v<_Ty>, _Ty, ptrdiff_t>;

#if _HAS_CXX20
template <class _Ty>
concept _Destructible_object = is_object_v<_Ty> && destructible<_Ty>;

template <template <class...> class _Template, class... _Args>
void _Derived_from_specialization_impl(const _Template<_Args...>&);

template <class _Ty, template <class...> class _Template>
concept _Derived_from_specialization_of = requires(const _Ty & _Obj) {
    _STD _Derived_from_specialization_impl<_Template>(_Obj); // qualified: avoid ADL, handle incomplete types
};

namespace ranges {
    namespace _Iter_move {
#if defined(__clang__) || defined(__EDG__) // TRANSITION, VSO-1681199
        void iter_move() = delete; // Block unqualified name lookup
#else // ^^^ no workaround / workaround vvv
        void iter_move();
#endif // ^^^ workaround ^^^

        template <class _Ty>
        concept _Has_ADL = _Has_class_or_enum_type<_Ty> && requires(_Ty && __t) {
            iter_move(static_cast<_Ty&&>(__t)); // intentional ADL
        };

        template <class _Ty>
        concept _Can_deref = requires(_Ty && __t) { *static_cast<_Ty&&>(__t); };

        class _Cpo {
        private:
            enum class _St { _None, _Custom, _Fallback };

            template <class _Ty>
            _NODISCARD static consteval _Choice_t<_St> _Choose() noexcept {
                if constexpr (_Has_ADL<_Ty>) {
                    return { _St::_Custom, noexcept(iter_move(_STD declval<_Ty>())) }; // intentional ADL
                }
                else if constexpr (_Can_deref<_Ty>) {
                    return { _St::_Fallback, noexcept(*_STD declval<_Ty>()) };
                }
                else {
                    return { _St::_None };
                }
            }

            template <class _Ty>
            static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();

        public:
            template <class _Ty>
                requires (_Choice<_Ty>._Strategy != _St::_None)
            _NODISCARD _STATIC_CALL_OPERATOR constexpr decltype(auto) operator()(_Ty&& _Val) _CONST_CALL_OPERATOR
                noexcept(_Choice<_Ty>._No_throw) {
                constexpr _St _Strat = _Choice<_Ty>._Strategy;

                if constexpr (_Strat == _St::_Custom) {
                    return iter_move(static_cast<_Ty&&>(_Val)); // intentional ADL
                }
                else if constexpr (_Strat == _St::_Fallback) {
                    using _Ref = decltype(*static_cast<_Ty&&>(_Val));
                    if constexpr (is_lvalue_reference_v<_Ref>) {
                        return _STD move(*static_cast<_Ty&&>(_Val));
                    }
                    else {
                        return *static_cast<_Ty&&>(_Val);
                    }
                }
                else {
                    static_assert(_Always_false<_Ty>, "should be unreachable");
                }
            }
        };
    } // namespace _Iter_move

    inline namespace _Cpos {
        _EXPORT_STD inline constexpr _Iter_move::_Cpo iter_move;
    }
} // namespace ranges

// iter_swap defined below since it depends on indirectly_movable_storable

_EXPORT_STD template <class _Ty>
    requires _Dereferenceable<_Ty>&& requires(_Ty& __t) {
        { _RANGES iter_move(__t) } -> _Can_reference;
}
using iter_rvalue_reference_t = decltype(_RANGES iter_move(_STD declval<_Ty&>()));

template <class _It>
concept _Indirectly_readable_impl =
    requires(const _It __i) {
    typename iter_value_t<_It>;
    typename iter_reference_t<_It>;
    typename iter_rvalue_reference_t<_It>;
    { *__i } -> same_as<iter_reference_t<_It>>;
    { _RANGES iter_move(__i) } -> same_as<iter_rvalue_reference_t<_It>>;
}&& common_reference_with<iter_reference_t<_It>&&, iter_value_t<_It>&>
&& common_reference_with<iter_reference_t<_It>&&, iter_rvalue_reference_t<_It>&&>
&& common_reference_with<iter_rvalue_reference_t<_It>&&, const iter_value_t<_It>&>;

_EXPORT_STD template <class _It>
concept indirectly_readable = _Indirectly_readable_impl<remove_cvref_t<_It>>;

template <class _Ty>
struct _Indirect_value_impl {
    using type = iter_value_t<_Ty>&;
};

template <indirectly_readable _It>
using _Indirect_value_t = _Indirect_value_impl<_It>::type;

_EXPORT_STD template <indirectly_readable _Ty>
using iter_common_reference_t = common_reference_t<iter_reference_t<_Ty>, _Indirect_value_t<_Ty>>;

_EXPORT_STD template <class _It, class _Ty>
concept indirectly_writable = requires(_It && __i, _Ty && __t) {
    *__i = static_cast<_Ty&&>(__t);
    *static_cast<_It&&>(__i) = static_cast<_Ty&&>(__t);
    const_cast<const iter_reference_t<_It>&&>(*__i) = static_cast<_Ty&&>(__t);
    const_cast<const iter_reference_t<_It>&&>(*static_cast<_It&&>(__i)) = static_cast<_Ty&&>(__t);
};

template <bool _Is_integer_class>
struct _Make_unsigned_like_impl {
    template <class _Ty>
    using _Apply = _Ty::_Unsigned_type;
};
template <>
struct _Make_unsigned_like_impl<false> {
    template <class _Ty>
    using _Apply = make_unsigned_t<_Ty>;
};

template <class _Ty>
using _Make_unsigned_like_t = _Make_unsigned_like_impl<_Integer_class<_Ty>>::template _Apply<_Ty>;

template <_Integer_like _Ty>
_NODISCARD constexpr auto _To_unsigned_like(const _Ty _Value) noexcept {
    return static_cast<_Make_unsigned_like_t<_Ty>>(_Value);
}

template <bool _Is_integer_class>
struct _Make_signed_like_impl {
    template <class _Ty>
    using _Apply = _Ty::_Signed_type;
};
template <>
struct _Make_signed_like_impl<false> {
    template <class _Ty>
    using _Apply = make_signed_t<_Ty>;
};

template <class _Ty>
using _Make_signed_like_t = _Make_signed_like_impl<_Integer_class<_Ty>>::template _Apply<_Ty>;

_EXPORT_STD template <class _Ty>
concept incrementable = regular<_Ty> && weakly_incrementable<_Ty> && requires(_Ty __t) {
    { __t++ } -> same_as<_Ty>;
};

template <bool _Iterator_category_present>
struct _Iter_concept_impl2 {
    template <class _It, class _Traits>
    using _Apply = _Traits::iterator_category;
};
template <>
struct _Iter_concept_impl2<false> {
    template <class _It, class _Traits>
        requires _Is_from_primary<iterator_traits<_It>>
    using _Apply = random_access_iterator_tag;
};

template <bool _Iterator_concept_present>
struct _Iter_concept_impl1 {
    template <class _It, class _Traits>
    using _Apply = _Traits::iterator_concept;
};
template <>
struct _Iter_concept_impl1<false> {
    template <class _It, class _Traits>
    using _Apply = _Iter_concept_impl2<_Has_member_iterator_category<_Traits>>::template _Apply<_It, _Traits>;
};

template <class _It, class _Traits = conditional_t<_Is_from_primary<iterator_traits<_It>>, _It, iterator_traits<_It>>>
using _Iter_concept = _Iter_concept_impl1<_Has_member_iterator_concept<_Traits>>::template _Apply<_It, _Traits>;

// clang-format off
_EXPORT_STD template <class _It>
concept input_iterator = input_or_output_iterator<_It> && indirectly_readable<_It>
&& requires { typename _Iter_concept<_It>; }
&& derived_from<_Iter_concept<_It>, input_iterator_tag>;

_EXPORT_STD template <class _It, class _Ty>
concept output_iterator = input_or_output_iterator<_It> && indirectly_writable<_It, _Ty>
&& requires(_It __i, _Ty&& __t) {
    *__i++ = static_cast<_Ty&&>(__t);
};

_EXPORT_STD template <class _It>
concept forward_iterator = input_iterator<_It> && derived_from<_Iter_concept<_It>, forward_iterator_tag>
&& incrementable<_It>&& sentinel_for<_It, _It>;

_EXPORT_STD template <class _It>
concept bidirectional_iterator = forward_iterator<_It> && derived_from<_Iter_concept<_It>, bidirectional_iterator_tag>
&& requires(_It __i) {
    { --__i } -> same_as<_It&>;
    { __i-- } -> same_as<_It>;
};

_EXPORT_STD template <class _It>
concept random_access_iterator = bidirectional_iterator<_It>
&& derived_from<_Iter_concept<_It>, random_access_iterator_tag>&& totally_ordered<_It>
&& sized_sentinel_for<_It, _It>&& requires(_It __i, const _It __j, const iter_difference_t<_It> __n) {
    { __i += __n } -> same_as<_It&>;
    { __j + __n } -> same_as<_It>;
    { __n + __j } -> same_as<_It>;
    { __i -= __n } -> same_as<_It&>;
    { __j - __n } -> same_as<_It>;
    { __j[__n] } -> same_as<iter_reference_t<_It>>;
};

_EXPORT_STD template <class _It>
concept contiguous_iterator = random_access_iterator<_It>
&& derived_from<_Iter_concept<_It>, contiguous_iterator_tag>
&& is_lvalue_reference_v<iter_reference_t<_It>>
&& same_as<iter_value_t<_It>, remove_cvref_t<iter_reference_t<_It>>>
&& requires(const _It& __i) {
    { _STD to_address(__i) } -> same_as<add_pointer_t<iter_reference_t<_It>>>;
};
// clang-format on

_EXPORT_STD template <class _Fn, class _It>
concept indirectly_unary_invocable =
indirectly_readable<_It> && copy_constructible<_Fn> && invocable<_Fn&, _Indirect_value_t<_It>>
&& invocable<_Fn&, iter_reference_t<_It>>&& invocable<_Fn&, iter_common_reference_t<_It>>
&& common_reference_with<invoke_result_t<_Fn&, _Indirect_value_t<_It>>,
    invoke_result_t<_Fn&, iter_reference_t<_It>>>;

_EXPORT_STD template <class _Fn, class _It>
concept indirectly_regular_unary_invocable =
indirectly_readable<_It> && copy_constructible<_Fn> && regular_invocable<_Fn&, _Indirect_value_t<_It>>
&& regular_invocable<_Fn&, iter_reference_t<_It>>&& regular_invocable<_Fn&, iter_common_reference_t<_It>>
&& common_reference_with<invoke_result_t<_Fn&, _Indirect_value_t<_It>>,
    invoke_result_t<_Fn&, iter_reference_t<_It>>>;

_EXPORT_STD template <class _Fn, class _It>
concept indirect_unary_predicate =
indirectly_readable<_It> && copy_constructible<_Fn> && predicate<_Fn&, _Indirect_value_t<_It>>
&& predicate<_Fn&, iter_reference_t<_It>>&& predicate<_Fn&, iter_common_reference_t<_It>>;

_EXPORT_STD template <class _Fn, class _It1, class _It2>
concept indirect_binary_predicate = indirectly_readable<_It1> && indirectly_readable<_It2> && copy_constructible<_Fn>
&& predicate<_Fn&, _Indirect_value_t<_It1>, _Indirect_value_t<_It2>>
&& predicate<_Fn&, _Indirect_value_t<_It1>, iter_reference_t<_It2>>
&& predicate<_Fn&, iter_reference_t<_It1>, _Indirect_value_t<_It2>>
&& predicate<_Fn&, iter_reference_t<_It1>, iter_reference_t<_It2>>
&& predicate<_Fn&, iter_common_reference_t<_It1>, iter_common_reference_t<_It2>>;

_EXPORT_STD template <class _Fn, class _It1, class _It2 = _It1>
concept indirect_equivalence_relation =
indirectly_readable<_It1> && indirectly_readable<_It2> && copy_constructible<_Fn>
&& equivalence_relation<_Fn&, _Indirect_value_t<_It1>, _Indirect_value_t<_It2>>
&& equivalence_relation<_Fn&, _Indirect_value_t<_It1>, iter_reference_t<_It2>>
&& equivalence_relation<_Fn&, iter_reference_t<_It1>, _Indirect_value_t<_It2>>
&& equivalence_relation<_Fn&, iter_reference_t<_It1>, iter_reference_t<_It2>>
&& equivalence_relation<_Fn&, iter_common_reference_t<_It1>, iter_common_reference_t<_It2>>;

_EXPORT_STD template <class _Fn, class _It1, class _It2 = _It1>
concept indirect_strict_weak_order =
indirectly_readable<_It1> && indirectly_readable<_It2> && copy_constructible<_Fn>
&& strict_weak_order<_Fn&, _Indirect_value_t<_It1>, _Indirect_value_t<_It2>>
&& strict_weak_order<_Fn&, _Indirect_value_t<_It1>, iter_reference_t<_It2>>
&& strict_weak_order<_Fn&, iter_reference_t<_It1>, _Indirect_value_t<_It2>>
&& strict_weak_order<_Fn&, iter_reference_t<_It1>, iter_reference_t<_It2>>
&& strict_weak_order<_Fn&, iter_common_reference_t<_It1>, iter_common_reference_t<_It2>>;

_EXPORT_STD template <class _Fn, class... _Its>
    requires (indirectly_readable<_Its> && ...) && invocable<_Fn, iter_reference_t<_Its>...>
using indirect_result_t = invoke_result_t<_Fn, iter_reference_t<_Its>...>;

template <class _It>
struct _Projected_difference_type_impl {
    struct _Base {};
};

template <weakly_incrementable _It>
struct _Projected_difference_type_impl<_It> {
    struct _Base {
        using difference_type = iter_difference_t<_It>;
    };
};

template <class _It, class _Proj>
struct _Projected_impl {
    struct _Type : _Projected_difference_type_impl<_It>::_Base {
        using _Iterator = _It;
        using _Projection = _Proj;

        using value_type = remove_cvref_t<indirect_result_t<_Proj&, _It>>;
        [[noreturn]] indirect_result_t<_Proj&, _It> operator*() const {
            _CSTD abort(); // shouldn't be called, see GH-3888
        }
    };
};

_EXPORT_STD template <indirectly_readable _It, indirectly_regular_unary_invocable<_It> _Proj>
using projected = _Projected_impl<_It, _Proj>::_Type;

template <class _Ty>
concept _Projected_specialization = same_as<_Ty, projected<typename _Ty::_Iterator, typename _Ty::_Projection>>;

template <_Projected_specialization _ProjTy>
struct _Indirect_value_impl<_ProjTy> {
    using type = invoke_result_t<typename _ProjTy::_Projection&, _Indirect_value_t<typename _ProjTy::_Iterator>>;
};

_EXPORT_STD template <class _In, class _Out>
concept indirectly_movable = indirectly_readable<_In> && indirectly_writable<_Out, iter_rvalue_reference_t<_In>>;

_EXPORT_STD template <class _In, class _Out>
concept indirectly_movable_storable =
indirectly_movable<_In, _Out>&& indirectly_writable<_Out, iter_value_t<_In>>&& movable<iter_value_t<_In>>
&& constructible_from<iter_value_t<_In>, iter_rvalue_reference_t<_In>>
&& assignable_from<iter_value_t<_In>&, iter_rvalue_reference_t<_In>>;

_EXPORT_STD template <class _In, class _Out>
concept indirectly_copyable = indirectly_readable<_In> && indirectly_writable<_Out, iter_reference_t<_In>>;

// clang-format off
_EXPORT_STD template <class _In, class _Out>
concept indirectly_copyable_storable = indirectly_copyable<_In, _Out>
&& indirectly_writable<_Out, iter_value_t<_In>&>
&& indirectly_writable<_Out, const iter_value_t<_In>&>
&& indirectly_writable<_Out, iter_value_t<_In>&&>
&& indirectly_writable<_Out, const iter_value_t<_In>&&>
&& copyable<iter_value_t<_In>>
&& constructible_from<iter_value_t<_In>, iter_reference_t<_In>>
&& assignable_from<iter_value_t<_In>&, iter_reference_t<_In>>;
// clang-format on

namespace ranges {
    namespace _Iter_swap {
        template <class _Ty1, class _Ty2>
        void iter_swap(_Ty1, _Ty2) = delete;

        // clang-format off
        template <class _Ty1, class _Ty2>
        concept _Has_ADL = (_Has_class_or_enum_type<_Ty1> || _Has_class_or_enum_type<_Ty2>)
            && requires(_Ty1 && __t1, _Ty2 && __t2) {
            iter_swap(static_cast<_Ty1&&>(__t1), static_cast<_Ty2&&>(__t2)); // intentional ADL
        };
        // clang-format on

        template <class _Ty1, class _Ty2>
        concept _Can_swap_references =
            indirectly_readable<remove_reference_t<_Ty1>> && indirectly_readable<remove_reference_t<_Ty2>>
            && swappable_with<iter_reference_t<_Ty1>, iter_reference_t<_Ty2>>;

        template <class _Ty1, class _Ty2>
        concept _Symmetric_indirectly_movable_storable =
            indirectly_movable_storable<remove_reference_t<_Ty1>, remove_reference_t<_Ty2>>
            && indirectly_movable_storable<remove_reference_t<_Ty2>, remove_reference_t<_Ty1>>;

        template <class _Xty, class _Yty>
        _NODISCARD constexpr iter_value_t<remove_reference_t<_Xty>> _Iter_exchange_move(_Xty&& _XVal,
            _Yty&& _YVal) noexcept(noexcept(iter_value_t<remove_reference_t<_Xty>>(_RANGES iter_move(_XVal)))) {
            iter_value_t<remove_reference_t<_Xty>> _Tmp(_RANGES iter_move(_XVal));
            *_XVal = _RANGES iter_move(_YVal);
            return _Tmp;
        }

        class _Cpo {
        private:
            enum class _St { _None, _Custom, _Swap, _Exchange };

            template <class _Ty1, class _Ty2>
            _NODISCARD static consteval _Choice_t<_St> _Choose() noexcept {
                if constexpr (_Has_ADL<_Ty1, _Ty2>) {
                    return { _St::_Custom,
                        noexcept(iter_swap(_STD declval<_Ty1>(), _STD declval<_Ty2>())) }; // intentional ADL
                }
                else if constexpr (_Can_swap_references<_Ty1, _Ty2>) {
                    return { _St::_Swap, noexcept(_RANGES swap(*_STD declval<_Ty1>(), *_STD declval<_Ty2>())) };
                }
                else if constexpr (_Symmetric_indirectly_movable_storable<_Ty1, _Ty2>) {
                    constexpr auto _Nothrow = noexcept(*_STD declval<_Ty1>() = _Iter_swap::_Iter_exchange_move(
                        _STD declval<_Ty2>(), _STD declval<_Ty1>()));
                    return { _St::_Exchange, _Nothrow };
                }
                else {
                    return { _St::_None };
                }
            }

            template <class _Ty1, class _Ty2>
            static constexpr _Choice_t<_St> _Choice = _Choose<_Ty1, _Ty2>();

        public:
            template <class _Ty1, class _Ty2>
                requires (_Choice<_Ty1, _Ty2>._Strategy != _St::_None)
            _STATIC_CALL_OPERATOR constexpr void operator()(_Ty1&& _Val1, _Ty2&& _Val2) _CONST_CALL_OPERATOR
                noexcept(_Choice<_Ty1, _Ty2>._No_throw) {
                constexpr _St _Strat = _Choice<_Ty1, _Ty2>._Strategy;

                if constexpr (_Strat == _St::_Custom) {
                    (void)iter_swap(static_cast<_Ty1&&>(_Val1), static_cast<_Ty2&&>(_Val2)); // intentional ADL
                }
                else if constexpr (_Strat == _St::_Swap) {
                    _RANGES swap(*static_cast<_Ty1&&>(_Val1), *static_cast<_Ty2&&>(_Val2));
                }
                else if constexpr (_Strat == _St::_Exchange) {
                    *static_cast<_Ty1&&>(_Val1) =
                        _Iter_swap::_Iter_exchange_move(static_cast<_Ty2&&>(_Val2), static_cast<_Ty1&&>(_Val1));
                }
                else {
                    static_assert(_Always_false<_Ty1>, "should be unreachable");
                }
            }
        };
    } // namespace _Iter_swap

    inline namespace _Cpos {
        _EXPORT_STD inline constexpr _Iter_swap::_Cpo iter_swap;
    }
} // namespace ranges

_EXPORT_STD template <class _It1, class _It2 = _It1>
concept indirectly_swappable =
indirectly_readable<_It1> && indirectly_readable<_It2> && requires(const _It1 __i1, const _It2 __i2) {
    _RANGES iter_swap(__i1, __i1);
    _RANGES iter_swap(__i2, __i2);
    _RANGES iter_swap(__i1, __i2);
    _RANGES iter_swap(__i2, __i1);
};

_EXPORT_STD template <class _It1, class _It2, class _Rel, class _Proj1 = identity, class _Proj2 = identity>
concept indirectly_comparable = indirect_binary_predicate<_Rel, projected<_It1, _Proj1>, projected<_It2, _Proj2>>;

_EXPORT_STD template <class _It>
concept permutable = forward_iterator<_It> && indirectly_movable_storable<_It, _It>&& indirectly_swappable<_It, _It>;

namespace ranges {
    _EXPORT_STD struct less;
} // namespace ranges

_EXPORT_STD template <class _It1, class _It2, class _Out, class _Pr = ranges::less, class _Pj1 = identity,
    class _Pj2 = identity>
    concept mergeable =
    input_iterator<_It1> && input_iterator<_It2> && weakly_incrementable<_Out> && indirectly_copyable<_It1, _Out>
    && indirectly_copyable<_It2, _Out>&& indirect_strict_weak_order<_Pr, projected<_It1, _Pj1>, projected<_It2, _Pj2>>;

_EXPORT_STD template <class _It, class _Pr = ranges::less, class _Proj = identity>
concept sortable = permutable<_It> && indirect_strict_weak_order<_Pr, projected<_It, _Proj>>;

template <class _Iter>
using _Iter_ref_t = iter_reference_t<_Iter>;

template <class _Iter>
using _Iter_value_t = iter_value_t<_Iter>;

template <class _Iter>
using _Iter_diff_t = iter_difference_t<_Iter>;

#else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
template <class _Iter>
using _Iter_ref_t = typename iterator_traits<_Iter>::reference;

template <class _Iter>
using _Iter_value_t = typename iterator_traits<_Iter>::value_type;

template <class _Iter>
using _Iter_diff_t = typename iterator_traits<_Iter>::difference_type;

template <class _Ty>
using _Make_unsigned_like_t = make_unsigned_t<_Ty>;
#endif // ^^^ !_HAS_CXX20 ^^^

template <class... _Iters>
using _Common_diff_t = common_type_t<_Iter_diff_t<_Iters>...>;

template <class _Iter>
using _Iter_cat_t = typename iterator_traits<_Iter>::iterator_category;

template <class _Ty, class = void>
_INLINE_VAR constexpr bool _Is_iterator_v = false;

template <class _Ty>
_INLINE_VAR constexpr bool _Is_iterator_v<_Ty, void_t<_Iter_cat_t<_Ty>>> = true;

template <class _Ty>
struct _Is_iterator : bool_constant<_Is_iterator_v<_Ty>> {};

template <class _Iter>
_INLINE_VAR constexpr bool _Is_cpp17_input_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, input_iterator_tag>;

template <class _Iter>
_INLINE_VAR constexpr bool _Is_ranges_input_iter_v =
#if _HAS_CXX20
(input_iterator<_Iter> && sentinel_for<_Iter, _Iter>) ||
#endif
_Is_cpp17_input_iter_v<_Iter>;

template <class _Iter>
_INLINE_VAR constexpr bool _Is_cpp17_fwd_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, forward_iterator_tag>;

template <class _Iter>
_INLINE_VAR constexpr bool _Is_ranges_fwd_iter_v =
#if _HAS_CXX20
forward_iterator<_Iter> ||
#endif
_Is_cpp17_fwd_iter_v<_Iter>;

template <class _Iter>
_INLINE_VAR constexpr bool _Is_cpp17_bidi_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, bidirectional_iterator_tag>;

template <class _Iter>
_INLINE_VAR constexpr bool _Is_ranges_bidi_iter_v =
#if _HAS_CXX20
bidirectional_iterator<_Iter> ||
#endif
_Is_cpp17_bidi_iter_v<_Iter>;

template <class _Iter>
_INLINE_VAR constexpr bool _Is_cpp17_random_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, random_access_iterator_tag>;

template <class _Iter>
_INLINE_VAR constexpr bool _Is_ranges_random_iter_v =
#if _HAS_CXX20
random_access_iterator<_Iter> ||
#endif
_Is_cpp17_random_iter_v<_Iter>;

#define _REQUIRE_CPP17_MUTABLE_ITERATOR(_Iter) \
    static_assert(_Is_cpp17_fwd_iter_v<_Iter>, \
        "Non-ranges algorithms require that mutable iterators be Cpp17ForwardIterators or stronger.")

#define _REQUIRE_CPP17_MUTABLE_BIDIRECTIONAL_ITERATOR(_Iter) \
    static_assert(_Is_cpp17_bidi_iter_v<_Iter>,              \
        "This algorithm requires that mutable iterators be Cpp17BidirectionalIterators or stronger.")

template <class, class = void>
struct _Is_checked_helper {}; // default definition, no longer used, retained due to pseudo-documentation

#if _ITERATOR_DEBUG_LEVEL != 0
template <class _Ty>
constexpr void _Verify_range(const _Ty* const _First, const _Ty* const _Last) noexcept {
    // special case range verification for pointers
    _STL_VERIFY(_First <= _Last, "transposed pointer range");
}
#endif // _ITERATOR_DEBUG_LEVEL != 0

template <class _Iter, class = void>
_INLINE_VAR constexpr bool _Allow_inheriting_unwrap_v = true;

template <class _Iter>
_INLINE_VAR constexpr bool _Allow_inheriting_unwrap_v<_Iter, void_t<typename _Iter::_Prevent_inheriting_unwrap>> =
is_same_v<_Iter, typename _Iter::_Prevent_inheriting_unwrap>;

template <class _Iter, class _Sentinel = _Iter, class = void>
_INLINE_VAR constexpr bool _Range_verifiable_v = false;

template <class _Iter, class _Sentinel>
_INLINE_VAR constexpr bool _Range_verifiable_v<_Iter, _Sentinel,
    void_t<decltype(_Verify_range(_STD declval<const _Iter&>(), _STD declval<const _Sentinel&>()))>> =
    _Allow_inheriting_unwrap_v<_Iter>;

template <class _Iter, class _Sentinel>
constexpr void _Adl_verify_range(const _Iter& _First, const _Sentinel& _Last) {
    // check that [_First, _Last) forms an iterator range
    if constexpr (is_pointer_v<_Iter> && is_pointer_v<_Sentinel>) {
#if _ITERATOR_DEBUG_LEVEL != 0
        _STL_VERIFY(_First <= _Last, "transposed pointer range");
#endif // _ITERATOR_DEBUG_LEVEL != 0
    }
    else if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
        _Verify_range(_First, _Last);
    }
}

template <class _Iter, class = void>
_INLINE_VAR constexpr bool _Unwrappable_v = false;

template <class _Iter>
_INLINE_VAR constexpr bool _Unwrappable_v<_Iter,
    void_t<decltype(_STD declval<_Remove_cvref_t<_Iter>&>()._Seek_to(_STD declval<_Iter>()._Unwrapped()))>> =
    _Allow_inheriting_unwrap_v<_Remove_cvref_t<_Iter>>;

template <class _Iter, class = void>
_INLINE_VAR constexpr bool _Has_nothrow_unwrapped = false;
template <class _Iter>
_INLINE_VAR constexpr bool _Has_nothrow_unwrapped<_Iter, void_t<decltype(_STD declval<_Iter>()._Unwrapped())>> =
noexcept(_STD declval<_Iter>()._Unwrapped());

template <class _Iter>
_NODISCARD constexpr decltype(auto) _Get_unwrapped(_Iter&& _It) noexcept(
    !_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {
    // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
    if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
        return _It + 0;
    }
    else if constexpr (_Unwrappable_v<_Iter>) {
        return static_cast<_Iter&&>(_It)._Unwrapped();
    }
    else {
        return static_cast<_Iter&&>(_It);
    }
}

template <class _Iter>
using _Unwrapped_t = _Remove_cvref_t<decltype(_STD _Get_unwrapped(_STD declval<_Iter>()))>;

template <class _Iter, class = bool>
_INLINE_VAR constexpr bool _Do_unwrap_when_unverified_v = false;

template <class _Iter>
_INLINE_VAR constexpr bool
_Do_unwrap_when_unverified_v<_Iter, decltype(static_cast<bool>(_Iter::_Unwrap_when_unverified))> =
static_cast<bool>(_Iter::_Unwrap_when_unverified);

template <class _Iter>
_INLINE_VAR constexpr bool _Unwrappable_for_unverified_v =
_Unwrappable_v<_Iter> && _Do_unwrap_when_unverified_v<_Remove_cvref_t<_Iter>>;

template <class _Iter>
_NODISCARD constexpr decltype(auto) _Get_unwrapped_unverified(_Iter&& _It) {
    // unwrap an iterator not previously subjected to _Adl_verify_range
    if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
        return _It + 0;
    }
    else if constexpr (_Unwrappable_for_unverified_v<_Iter>) {
        return static_cast<_Iter&&>(_It)._Unwrapped();
    }
    else {
        return static_cast<_Iter&&>(_It);
    }
}

template <class _Iter>
using _Unwrapped_unverified_t = _Remove_cvref_t<decltype(_Get_unwrapped_unverified(_STD declval<_Iter>()))>;

struct _Distance_unknown {
    constexpr _Distance_unknown operator-() const noexcept {
        return {};
    }
};

template <class _Diff>
_INLINE_VAR constexpr _Diff _Max_possible_v{ static_cast<_Make_unsigned_like_t<_Diff>>(-1) >> 1 };

template <class _Diff>
_INLINE_VAR constexpr _Diff _Min_possible_v{ -_Max_possible_v<_Diff> -1 };

template <class _Iter, class = void>
_INLINE_VAR constexpr bool _Offset_verifiable_v = false;

template <class _Iter>
_INLINE_VAR constexpr bool
_Offset_verifiable_v < _Iter, void_t<decltype(_STD declval<const _Iter&>()._Verify_offset(_Iter_diff_t<_Iter>{})) >> =
    true;

template <class _Iter>
_INLINE_VAR constexpr bool _Unwrappable_for_offset_v =
_Unwrappable_v<_Iter> && _Offset_verifiable_v<_Remove_cvref_t<_Iter>>;

template <class _Iter, class _Diff>
_NODISCARD constexpr decltype(auto) _Get_unwrapped_n(_Iter&& _It, const _Diff _Off) {
    if constexpr (is_pointer_v<decay_t<_Iter>>) {
        return _It + 0;
    }
    else if constexpr (_Unwrappable_for_offset_v<_Iter> && is_integral_v<_Diff>) {
        // ask an iterator to assert that the iterator moved _Off positions is valid, and unwrap
        using _IDiff = _Iter_diff_t<_Remove_cvref_t<_Iter>>;
        using _CDiff = common_type_t<_Diff, _IDiff>;
        const auto _COff = static_cast<_CDiff>(_Off);

        _STL_ASSERT(_COff <= static_cast<_CDiff>(_Max_possible_v<_IDiff>)
            && (is_unsigned_v<_Diff> || static_cast<_CDiff>(_Min_possible_v<_IDiff>) <= _COff),
            "integer overflow");
        (void)_COff;

        _It._Verify_offset(static_cast<_IDiff>(_Off));
        return static_cast<_Iter&&>(_It)._Unwrapped();
    }
    else if constexpr (_Unwrappable_for_unverified_v<_Iter>) {
        // iterator doesn't support offset-based asserts, or offset unknown; defer to unverified unwrap
        return static_cast<_Iter&&>(_It)._Unwrapped();
    }
    else {
        // pass through iterator that doesn't participate in checking
        return static_cast<_Iter&&>(_It);
    }
}

template <class _Iter, class _UIter, class = void>
_INLINE_VAR constexpr bool _Wrapped_seekable_v = false;

template <class _Iter, class _UIter>
_INLINE_VAR constexpr bool
_Wrapped_seekable_v<_Iter, _UIter, void_t<decltype(_STD declval<_Iter&>()._Seek_to(_STD declval<_UIter>()))>> =
true;

template <class _Iter, class _UIter>
constexpr void _Seek_wrapped(_Iter& _It, _UIter&& _UIt) {
    if constexpr (_Wrapped_seekable_v<_Iter, _UIter>) {
        _It._Seek_to(_STD forward<_UIter>(_UIt));
    }
    else {
        _It = _STD forward<_UIter>(_UIt);
    }
}

#if _HAS_CXX17
template <class _Ty, class = void>
struct _Is_allocator : false_type {}; // selected when _Ty can't possibly be an allocator

template <class _Ty>
struct _Is_allocator < _Ty, void_t<typename _Ty::value_type, decltype(_STD declval<_Ty&>().deallocate(
    _STD declval<_Ty&>().allocate(size_t{ 1 }), size_t{ 1 })) >>
    : true_type {}; // selected when _Ty resembles an allocator, N4950 [container.reqmts]/69

// deduction guide utilities (N4950 [associative.general]/2)
template <class _Iter>
using _Guide_key_t =
#if _HAS_CXX23
remove_const_t<tuple_element_t<0, typename iterator_traits<_Iter>::value_type>>;
#else // ^^^ _HAS_CXX23 / !_HAS_CXX23 vvv
remove_const_t<typename iterator_traits<_Iter>::value_type::first_type>;
#endif // ^^^ !_HAS_CXX23 ^^^

template <class _Iter>
using _Guide_val_t =
#if _HAS_CXX23
tuple_element_t<1, typename iterator_traits<_Iter>::value_type>;
#else // ^^^ _HAS_CXX23 / !_HAS_CXX23 vvv
typename iterator_traits<_Iter>::value_type::second_type;
#endif // ^^^ !_HAS_CXX23 ^^^

template <class _Iter>
using _Guide_pair_t =
#if _HAS_CXX23
pair<add_const_t<tuple_element_t<0, typename iterator_traits<_Iter>::value_type>>,
    tuple_element_t<1, typename iterator_traits<_Iter>::value_type>>;
#else // ^^^ _HAS_CXX23 / !_HAS_CXX23 vvv
    pair<add_const_t<typename iterator_traits<_Iter>::value_type::first_type>,
    typename iterator_traits<_Iter>::value_type::second_type>;
#endif // ^^^ !_HAS_CXX23 ^^^

_EXPORT_STD template <class _Ty>
struct is_execution_policy : false_type {};

_EXPORT_STD template <class _Ty>
inline constexpr bool is_execution_policy_v = is_execution_policy<_Ty>::value;

// Note: The noexcept specifiers on all parallel algorithm overloads enforce termination as per
// N4950 [execpol.seq]/2, [execpol.par]/2, [execpol.parunseq]/2, and [execpol.unseq]/2
template <class _ExPo>
using _Enable_if_execution_policy_t = typename remove_reference_t<_ExPo>::_Standard_execution_policy;

#define _REQUIRE_PARALLEL_ITERATOR(_Iter) \
    static_assert(_Is_ranges_fwd_iter_v<_Iter>, "Parallel algorithms require forward iterators or stronger.")

#endif // _HAS_CXX17

template <class _Checked, class _Iter>
_NODISCARD constexpr auto _Idl_distance(const _Iter& _First, const _Iter& _Last) {
    // tries to get the distance between _First and _Last if they are random-access iterators
    if constexpr (_Is_ranges_random_iter_v<_Iter>) {
        return static_cast<_Iter_diff_t<_Checked>>(_Last - _First);
    }
    else {
        return _Distance_unknown{};
    }
}

template <class _Elem, bool _Is_enum = is_enum_v<_Elem>>
struct _Unwrap_enum { // if _Elem is an enum, gets its underlying type; otherwise leaves _Elem unchanged
    using type = underlying_type_t<_Elem>;
};

template <class _Elem>
struct _Unwrap_enum<_Elem, false> { // passthrough non-enum type
    using type = _Elem;
};

template <class _Elem>
using _Unwrap_enum_t = typename _Unwrap_enum<_Elem>::type;

#if _ITERATOR_DEBUG_LEVEL < 2
#define _DEBUG_LT_PRED(pred, x, y) static_cast<bool>(pred(x, y))
#define _DEBUG_ORDER_UNWRAPPED(first, last, pred)
#define _DEBUG_ORDER_SET_UNWRAPPED(otherIter, first, last, pred)

#else // ^^^ _ITERATOR_DEBUG_LEVEL < 2 / _ITERATOR_DEBUG_LEVEL == 2 vvv
#define _DEBUG_LT_PRED(pred, x, y)                _STD _Debug_lt_pred(pred, x, y)
#define _DEBUG_ORDER_UNWRAPPED(first, last, pred) _STD _Debug_order_unchecked(first, last, pred)
#define _DEBUG_ORDER_SET_UNWRAPPED(otherIter, first, last, pred) \
    _STD _Debug_order_set_unchecked<otherIter>(first, last, pred)

template <class _Pr, class _Ty1, class _Ty2,
    enable_if_t<is_same_v<_Remove_cvref_t<_Ty1>, _Remove_cvref_t<_Ty2>>, int> = 0>
constexpr bool _Debug_lt_pred(_Pr&& _Pred, _Ty1&& _Left, _Ty2&& _Right) noexcept(
    noexcept(_Pred(_Left, _Right)) && noexcept(_Pred(_Right, _Left))) {
    // test if _Pred(_Left, _Right) and _Pred is strict weak ordering, when the arguments are the cv-same-type
    const auto _Result = static_cast<bool>(_Pred(_Left, _Right));
    if (_Result) {
        _STL_VERIFY(!_Pred(_Right, _Left), "invalid comparator");
    }

    return _Result;
}

template <class _Pr, class _Ty1, class _Ty2,
    enable_if_t<!is_same_v<_Remove_cvref_t<_Ty1>, _Remove_cvref_t<_Ty2>>, int> = 0>
constexpr bool _Debug_lt_pred(_Pr&& _Pred, _Ty1&& _Left, _Ty2&& _Right) noexcept(noexcept(_Pred(_Left, _Right))) {
    // test if _Pred(_Left, _Right); no debug checks as the types differ
    return static_cast<bool>(_Pred(_Left, _Right));
}

template <class _InIt, class _Sentinel, class _Pr>
constexpr void _Debug_order_unchecked(_InIt _First, _Sentinel _Last, _Pr&& _Pred) {
    // test if range is ordered by predicate
    if constexpr (_Is_ranges_fwd_iter_v<_InIt>) {
        if (_First != _Last) {
            for (auto _Next = _First; ++_Next != _Last; _First = _Next) {
                _STL_VERIFY(!static_cast<bool>(_Pred(*_Next, *_First)), "sequence not ordered");
            }
        }
    }
}

template <class _OtherIt, class _InIt, class _Pr>
constexpr void _Debug_order_set_unchecked(_InIt _First, _InIt _Last, _Pr&& _Pred) {
    // test if range is ordered by predicate
    if constexpr (is_same_v<_Iter_value_t<_OtherIt>, _Iter_value_t<_InIt>>) {
        _STD _Debug_order_unchecked(_First, _Last, _Pred);
    }
}
#endif // ^^^ _ITERATOR_DEBUG_LEVEL == 2 ^^^

// from <iterator>
_EXPORT_STD template <class _InIt, class _Diff>
_CONSTEXPR17 void advance(_InIt& _Where, _Diff _Off) { // increment iterator by offset
    if constexpr (_Is_ranges_random_iter_v<_InIt>) {
        _Where += _Off;
    }
    else {
        if constexpr (is_signed_v<_Diff> && !_Is_ranges_bidi_iter_v<_InIt>) {
            _STL_ASSERT(_Off >= 0, "negative advance of non-bidirectional iterator");
        }

        decltype(auto) _UWhere = _STD _Get_unwrapped_n(_STD move(_Where), _Off);
        constexpr bool _Need_rewrap = !is_reference_v<decltype(_STD _Get_unwrapped_n(_STD move(_Where), _Off))>;

        if constexpr (is_signed_v<_Diff> && _Is_ranges_bidi_iter_v<_InIt>) {
            for (; _Off < 0; ++_Off) {
                --_UWhere;
            }
        }

        for (; 0 < _Off; --_Off) {
            ++_UWhere;
        }

        if constexpr (_Need_rewrap) {
            _STD _Seek_wrapped(_Where, _STD move(_UWhere));
        }
    }
}

_EXPORT_STD template <class _InIt>
_NODISCARD _CONSTEXPR17 _Iter_diff_t<_InIt> distance(_InIt _First, _InIt _Last) {
    if constexpr (_Is_ranges_random_iter_v<_InIt>) {
        return _Last - _First; // assume the iterator will do debug checking
    }
    else {
        _STD _Adl_verify_range(_First, _Last);
        auto _UFirst = _STD _Get_unwrapped(_First);
        const auto _ULast = _STD _Get_unwrapped(_Last);
        _Iter_diff_t<_InIt> _Off = 0;
        for (; _UFirst != _ULast; ++_UFirst) {
            ++_Off;
        }

        return _Off;
    }
}

template <class _InIt>
constexpr _InIt _Next_iter(_InIt _First) { // increment iterator
    return ++_First;
}

_EXPORT_STD template <class _InIt>
_NODISCARD _CONSTEXPR17 _InIt next(
    _InIt _First, typename iterator_traits<_InIt>::difference_type _Off = 1) { // increment iterator
    static_assert(_Is_ranges_input_iter_v<_InIt>, "next requires input iterator");

    _STD advance(_First, _Off);
    return _First;
}

template <class _BidIt>
constexpr _BidIt _Prev_iter(_BidIt _First) { // decrement iterator
    return --_First;
}

_EXPORT_STD template <class _BidIt>
_NODISCARD _CONSTEXPR17 _BidIt prev(
    _BidIt _First, typename iterator_traits<_BidIt>::difference_type _Off = 1) { // decrement iterator
    static_assert(_Is_ranges_bidi_iter_v<_BidIt>, "prev requires bidirectional iterator");

    _STD advance(_First, -_Off);
    return _First;
}

template <class _Iter, class _Pointer, bool = is_pointer_v<_Remove_cvref_t<_Iter>>>
_INLINE_VAR constexpr bool _Has_nothrow_operator_arrow = _Is_nothrow_convertible_v<_Iter, _Pointer>;

template <class _Iter, class _Pointer>
_INLINE_VAR constexpr bool _Has_nothrow_operator_arrow<_Iter, _Pointer, false> =
noexcept(_STD _Fake_copy_init<_Pointer>(_STD declval<_Iter>().operator->()));

_EXPORT_STD template <class _BidIt>
class reverse_iterator {
public:
    using iterator_type = _BidIt;

#if _HAS_CXX20
    using iterator_concept =
        conditional_t<random_access_iterator<_BidIt>, random_access_iterator_tag, bidirectional_iterator_tag>;
    using iterator_category = conditional_t<derived_from<_Iter_cat_t<_BidIt>, random_access_iterator_tag>,
        random_access_iterator_tag, _Iter_cat_t<_BidIt>>;
#else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
    using iterator_category = _Iter_cat_t<_BidIt>;
#endif // ^^^ !_HAS_CXX20 ^^^
    using value_type = _Iter_value_t<_BidIt>;
    using difference_type = _Iter_diff_t<_BidIt>;
    using pointer = typename iterator_traits<_BidIt>::pointer;
    using reference = _Iter_ref_t<_BidIt>;

    template <class>
    friend class reverse_iterator;

    _CONSTEXPR17 reverse_iterator() = default;

    _CONSTEXPR17 explicit reverse_iterator(_BidIt _Right) noexcept(
        is_nothrow_move_constructible_v<_BidIt>) // strengthened
        : current(_STD move(_Right)) {}

    template <class _Other>
#if _HAS_CXX20
        requires (!is_same_v<_Other, _BidIt>) && convertible_to<const _Other&, _BidIt>
#endif // _HAS_CXX20
    _CONSTEXPR17 reverse_iterator(const reverse_iterator<_Other>& _Right) noexcept(
        is_nothrow_constructible_v<_BidIt, const _Other&>) // strengthened
        : current(_Right.current) {
    }

    template <class _Other>
#if _HAS_CXX20
        requires (!is_same_v<_Other, _BidIt>)
    && convertible_to<const _Other&, _BidIt>&& assignable_from<_BidIt&, const _Other&>
#endif // _HAS_CXX20
        _CONSTEXPR17 reverse_iterator& operator=(const reverse_iterator<_Other>& _Right) noexcept(
            is_nothrow_assignable_v<_BidIt&, const _Other&>) /* strengthened */ {
        current = _Right.current;
        return *this;
    }

    _NODISCARD _CONSTEXPR17 _BidIt base() const noexcept(is_nothrow_copy_constructible_v<_BidIt>) /* strengthened */ {
        return current;
    }

    _NODISCARD _CONSTEXPR17 reference operator*() const noexcept(is_nothrow_copy_constructible_v<_BidIt> //
        && noexcept(*--(_STD declval<_BidIt&>()))) /* strengthened */ {
        _BidIt _Tmp = current;
        return *--_Tmp;
    }

    _NODISCARD _CONSTEXPR17 pointer operator->() const
        noexcept(is_nothrow_copy_constructible_v<_BidIt> //
            && noexcept(--(_STD declval<_BidIt&>()))
            && _Has_nothrow_operator_arrow<_BidIt&, pointer>) /* strengthened */
#if _HAS_CXX20
        requires (is_pointer_v<_BidIt> || requires(const _BidIt __i) { __i.operator->(); })
#endif
    {
        _BidIt _Tmp = current;
        --_Tmp;
        if constexpr (is_pointer_v<_BidIt>) {
            return _Tmp;
        }
        else {
            return _Tmp.operator->();
        }
    }

    _CONSTEXPR17 reverse_iterator& operator++() noexcept(noexcept(--current)) /* strengthened */ {
        --current;
        return *this;
    }

    _CONSTEXPR17 reverse_iterator operator++(int) noexcept(is_nothrow_copy_constructible_v<_BidIt> //
        && noexcept(--current)) /* strengthened */ {
        reverse_iterator _Tmp = *this;
        --current;
        return _Tmp;
    }

    _CONSTEXPR17 reverse_iterator& operator--() noexcept(noexcept(++current)) /* strengthened */ {
        ++current;
        return *this;
    }

    _CONSTEXPR17 reverse_iterator operator--(int) noexcept(is_nothrow_copy_constructible_v<_BidIt> //
        && noexcept(++current)) /* strengthened */ {
        reverse_iterator _Tmp = *this;
        ++current;
        return _Tmp;
    }

    _NODISCARD _CONSTEXPR17 reverse_iterator operator+(const difference_type _Off) const
        noexcept(noexcept(reverse_iterator(current - _Off))) /* strengthened */ {
        return reverse_iterator(current - _Off);
    }

    _CONSTEXPR17 reverse_iterator& operator+=(const difference_type _Off) noexcept(
        noexcept(current -= _Off)) /* strengthened */ {
        current -= _Off;
        return *this;
    }

    _NODISCARD _CONSTEXPR17 reverse_iterator operator-(const difference_type _Off) const
        noexcept(noexcept(reverse_iterator(current + _Off))) /* strengthened */ {
        return reverse_iterator(current + _Off);
    }

    _CONSTEXPR17 reverse_iterator& operator-=(const difference_type _Off) noexcept(
        noexcept(current += _Off)) /* strengthened */ {
        current += _Off;
        return *this;
    }

    _NODISCARD _CONSTEXPR17 reference operator[](const difference_type _Off) const
        noexcept(noexcept(_STD _Fake_copy_init<reference>(current[_Off]))) /* strengthened */ {
        return current[static_cast<difference_type>(-_Off - 1)];
    }

#if _HAS_CXX20
    _NODISCARD_FRIEND constexpr iter_rvalue_reference_t<_BidIt> iter_move(const reverse_iterator& _It) noexcept(
        is_nothrow_copy_constructible_v<_BidIt> //
        && noexcept(_RANGES iter_move(--_STD declval<_BidIt&>()))) {
        auto _Tmp = _It.current;
        --_Tmp;
        return _RANGES iter_move(_Tmp);
    }

    template <indirectly_swappable<_BidIt> _BidIt2>
    friend constexpr void iter_swap(const reverse_iterator& _Left, const reverse_iterator<_BidIt2>& _Right) noexcept(
        is_nothrow_copy_constructible_v<_BidIt>
        && is_nothrow_copy_constructible_v<_BidIt2> //
        && noexcept(_RANGES iter_swap(--_STD declval<_BidIt&>(), --_STD declval<_BidIt2&>()))) {
        auto _LTmp = _Left.current;
        auto _RTmp = _Right.base();
        --_LTmp;
        --_RTmp;
        _RANGES iter_swap(_LTmp, _RTmp);
    }
#endif // _HAS_CXX20

    using _Prevent_inheriting_unwrap = reverse_iterator;

    template <class _BidIt2, enable_if_t<_Range_verifiable_v<_BidIt, _BidIt2>, int> = 0>
    friend constexpr void _Verify_range(
        const reverse_iterator& _First, const reverse_iterator<_BidIt2>& _Last) noexcept {
        _Verify_range(_Last._Get_current(), _First.current); // note reversed parameters
    }

    template <class _BidIt2 = _BidIt, enable_if_t<_Offset_verifiable_v<_BidIt2>, int> = 0>
    constexpr void _Verify_offset(const difference_type _Off) const noexcept {
        _STL_VERIFY(_Off != _Min_possible_v<difference_type>, "integer overflow");
        current._Verify_offset(-_Off);
    }

    template <class _BidIt2 = _BidIt, enable_if_t<_Unwrappable_v<const _BidIt2&>, int> = 0>
    _NODISCARD constexpr reverse_iterator<_Unwrapped_t<const _BidIt2&>> _Unwrapped() const& noexcept(
        noexcept(static_cast<reverse_iterator<_Unwrapped_t<const _BidIt2&>>>(current._Unwrapped()))) {
        return static_cast<reverse_iterator<_Unwrapped_t<const _BidIt2&>>>(current._Unwrapped());
    }
    template <class _BidIt2 = _BidIt, enable_if_t<_Unwrappable_v<_BidIt2>, int> = 0>
    _NODISCARD constexpr reverse_iterator<_Unwrapped_t<_BidIt2>> _Unwrapped() && noexcept(
        noexcept(static_cast<reverse_iterator<_Unwrapped_t<_BidIt2>>>(_STD move(current)._Unwrapped()))) {
        return static_cast<reverse_iterator<_Unwrapped_t<_BidIt2>>>(_STD move(current)._Unwrapped());
    }

    static constexpr bool _Unwrap_when_unverified = _Do_unwrap_when_unverified_v<_BidIt>;

    template <class _Src, enable_if_t<_Wrapped_seekable_v<_BidIt, const _Src&>, int> = 0>
    constexpr void _Seek_to(const reverse_iterator<_Src>& _It) noexcept(noexcept(current._Seek_to(_It.current))) {
        current._Seek_to(_It.current);
    }

    _NODISCARD constexpr const _BidIt& _Get_current() const noexcept {
        return current;
    }

protected:
    _BidIt current{};
};

_EXPORT_STD template <class _BidIt1, class _BidIt2>
_NODISCARD _CONSTEXPR17 bool
operator==(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right) noexcept(
    noexcept(_STD _Fake_copy_init<bool>(_Left._Get_current() == _Right._Get_current()))) /* strengthened */
#if _HAS_CXX20
    requires requires {
        { _Left._Get_current() == _Right._Get_current() } -> _Implicitly_convertible_to<bool>;
}
#endif // _HAS_CXX20
{
    return _Left._Get_current() == _Right._Get_current();
}

_EXPORT_STD template <class _BidIt1, class _BidIt2>
_NODISCARD _CONSTEXPR17 bool
operator!=(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right) noexcept(
    noexcept(_STD _Fake_copy_init<bool>(_Left._Get_current() != _Right._Get_current()))) /* strengthened */
#if _HAS_CXX20
    requires requires {
        { _Left._Get_current() != _Right._Get_current() } -> _Implicitly_convertible_to<bool>;
}
#endif // _HAS_CXX20
{
    return _Left._Get_current() != _Right._Get_current();
}

_EXPORT_STD template <class _BidIt1, class _BidIt2>
_NODISCARD _CONSTEXPR17 bool
operator<(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right) noexcept(
    noexcept(_STD _Fake_copy_init<bool>(_Left._Get_current() > _Right._Get_current()))) /* strengthened */
#if _HAS_CXX20
    requires requires {
        { _Left._Get_current() > _Right._Get_current() } -> _Implicitly_convertible_to<bool>;
}
#endif // _HAS_CXX20
{
    return _Left._Get_current() > _Right._Get_current();
}

_EXPORT_STD template <class _BidIt1, class _BidIt2>
_NODISCARD _CONSTEXPR17 bool
operator>(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right) noexcept(
    noexcept(_STD _Fake_copy_init<bool>(_Left._Get_current() < _Right._Get_current()))) /* strengthened */
#if _HAS_CXX20
    requires requires {
        { _Left._Get_current() < _Right._Get_current() } -> _Implicitly_convertible_to<bool>;
}
#endif // _HAS_CXX20
{
    return _Left._Get_current() < _Right._Get_current();
}

_EXPORT_STD template <class _BidIt1, class _BidIt2>
_NODISCARD _CONSTEXPR17 bool
operator<=(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right) noexcept(
    noexcept(_STD _Fake_copy_init<bool>(_Left._Get_current() >= _Right._Get_current()))) /* strengthened */
#if _HAS_CXX20
    requires requires {
        { _Left._Get_current() >= _Right._Get_current() } -> _Implicitly_convertible_to<bool>;
}
#endif // _HAS_CXX20
{
    return _Left._Get_current() >= _Right._Get_current();
}

_EXPORT_STD template <class _BidIt1, class _BidIt2>
_NODISCARD _CONSTEXPR17 bool
operator>=(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right) noexcept(
    noexcept(_STD _Fake_copy_init<bool>(_Left._Get_current() <= _Right._Get_current()))) /* strengthened */
#if _HAS_CXX20
    requires requires {
        { _Left._Get_current() <= _Right._Get_current() } -> _Implicitly_convertible_to<bool>;
}
#endif // _HAS_CXX20
{
    return _Left._Get_current() <= _Right._Get_current();
}

#if _HAS_CXX20
_EXPORT_STD template <class _BidIt1, three_way_comparable_with<_BidIt1> _BidIt2>
_NODISCARD constexpr compare_three_way_result_t<_BidIt1, _BidIt2>
operator<=>(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right) noexcept(
    noexcept(_Right._Get_current() <=> _Left._Get_current())) /* strengthened */ {
    return _Right._Get_current() <=> _Left._Get_current();
}
#endif // _HAS_CXX20

_EXPORT_STD template <class _BidIt1, class _BidIt2>
_NODISCARD _CONSTEXPR17 auto
operator-(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right) noexcept(
    noexcept(_Right._Get_current() - _Left._Get_current())) /* strengthened */
    -> decltype(_Right._Get_current() - _Left._Get_current()) {
    return _Right._Get_current() - _Left._Get_current();
}

_EXPORT_STD template <class _BidIt>
_NODISCARD _CONSTEXPR17 reverse_iterator<_BidIt> operator+(typename reverse_iterator<_BidIt>::difference_type _Off,
    const reverse_iterator<_BidIt>& _Right) noexcept(noexcept(_Right + _Off)) /* strengthened */ {
    return _Right + _Off;
}

_EXPORT_STD template <class _BidIt>
_NODISCARD _CONSTEXPR17 reverse_iterator<_BidIt> make_reverse_iterator(_BidIt _Iter) noexcept(
    is_nothrow_move_constructible_v<_BidIt>) /* strengthened */ {
    return reverse_iterator<_BidIt>(_STD move(_Iter));
}

#if _HAS_CXX20
template <class _BidIt1, class _BidIt2>
    requires (!sized_sentinel_for<_BidIt1, _BidIt2>)
inline constexpr bool disable_sized_sentinel_for<reverse_iterator<_BidIt1>, reverse_iterator<_BidIt2>> = true;
#endif // _HAS_CXX20

_EXPORT_STD template <class _Container>
_NODISCARD _CONSTEXPR17 auto begin(_Container& _Cont) noexcept(noexcept(_Cont.begin())) /* strengthened */
-> decltype(_Cont.begin()) {
    return _Cont.begin();
}

_EXPORT_STD template <class _Container>
_NODISCARD _CONSTEXPR17 auto begin(const _Container& _Cont) noexcept(noexcept(_Cont.begin())) /* strengthened */
-> decltype(_Cont.begin()) {
    return _Cont.begin();
}

_EXPORT_STD template <class _Container>
_NODISCARD _CONSTEXPR17 auto end(_Container& _Cont) noexcept(noexcept(_Cont.end())) /* strengthened */
-> decltype(_Cont.end()) {
    return _Cont.end();
}

_EXPORT_STD template <class _Container>
_NODISCARD _CONSTEXPR17 auto end(const _Container& _Cont) noexcept(noexcept(_Cont.end())) /* strengthened */
-> decltype(_Cont.end()) {
    return _Cont.end();
}

_EXPORT_STD template <class _Ty, size_t _Size>
_NODISCARD constexpr _Ty* begin(_Ty(&_Array)[_Size]) noexcept {
    return _Array;
}

_EXPORT_STD template <class _Ty, size_t _Size>
_NODISCARD constexpr _Ty* end(_Ty(&_Array)[_Size]) noexcept {
    return _Array + _Size;
}

_EXPORT_STD template <class _Container>
_NODISCARD constexpr auto cbegin(const _Container& _Cont) noexcept(noexcept(_STD begin(_Cont)))
-> decltype(_STD begin(_Cont)) {
    return _STD begin(_Cont);
}

_EXPORT_STD template <class _Container>
_NODISCARD constexpr auto cend(const _Container& _Cont) noexcept(noexcept(_STD end(_Cont)))
-> decltype(_STD end(_Cont)) {
    return _STD end(_Cont);
}

_EXPORT_STD template <class _Container>
_NODISCARD _CONSTEXPR17 auto rbegin(_Container& _Cont) noexcept(noexcept(_Cont.rbegin())) /* strengthened */
-> decltype(_Cont.rbegin()) {
    return _Cont.rbegin();
}

_EXPORT_STD template <class _Container>
_NODISCARD _CONSTEXPR17 auto rbegin(const _Container& _Cont) noexcept(noexcept(_Cont.rbegin())) /* strengthened */
-> decltype(_Cont.rbegin()) {
    return _Cont.rbegin();
}

_EXPORT_STD template <class _Container>
_NODISCARD _CONSTEXPR17 auto rend(_Container& _Cont) noexcept(noexcept(_Cont.rend())) /* strengthened */
-> decltype(_Cont.rend()) {
    return _Cont.rend();
}

_EXPORT_STD template <class _Container>
_NODISCARD _CONSTEXPR17 auto rend(const _Container& _Cont) noexcept(noexcept(_Cont.rend())) /* strengthened */
-> decltype(_Cont.rend()) {
    return _Cont.rend();
}

_EXPORT_STD template <class _Ty, size_t _Size>
_NODISCARD _CONSTEXPR17 reverse_iterator<_Ty*> rbegin(_Ty(&_Array)[_Size]) noexcept /* strengthened */ {
    return reverse_iterator<_Ty*>(_Array + _Size);
}

_EXPORT_STD template <class _Ty, size_t _Size>
_NODISCARD _CONSTEXPR17 reverse_iterator<_Ty*> rend(_Ty(&_Array)[_Size]) noexcept /* strengthened */ {
    return reverse_iterator<_Ty*>(_Array);
}

_EXPORT_STD template <class _Elem>
_NODISCARD _CONSTEXPR17 reverse_iterator<const _Elem*> rbegin(initializer_list<_Elem> _Ilist) noexcept
/* strengthened */ {
    return reverse_iterator<const _Elem*>(_Ilist.end());
}

_EXPORT_STD template <class _Elem>
_NODISCARD _CONSTEXPR17 reverse_iterator<const _Elem*> rend(initializer_list<_Elem> _Ilist) noexcept
/* strengthened */ {
    return reverse_iterator<const _Elem*>(_Ilist.begin());
}

_EXPORT_STD template <class _Container>
_NODISCARD _CONSTEXPR17 auto crbegin(const _Container& _Cont) noexcept(noexcept(_STD rbegin(_Cont))) /* strengthened */
-> decltype(_STD rbegin(_Cont)) {
    return _STD rbegin(_Cont);
}

_EXPORT_STD template <class _Container>
_NODISCARD _CONSTEXPR17 auto crend(const _Container& _Cont) noexcept(noexcept(_STD rend(_Cont))) /* strengthened */
-> decltype(_STD rend(_Cont)) {
    return _STD rend(_Cont);
}

_EXPORT_STD template <class _Container>
_NODISCARD constexpr auto size(const _Container& _Cont) noexcept(noexcept(_Cont.size())) /* strengthened */
-> decltype(_Cont.size()) {
    return _Cont.size();
}

_EXPORT_STD template <class _Ty, size_t _Size>
_NODISCARD constexpr size_t size(const _Ty(&)[_Size]) noexcept {
    return _Size;
}

#if _HAS_CXX20
_EXPORT_STD template <class _Container>
_NODISCARD constexpr auto ssize(const _Container& _Cont) noexcept(noexcept(
    static_cast<common_type_t<ptrdiff_t, make_signed_t<decltype(_Cont.size())>>>(_Cont.size()))) /* strengthened */
    -> common_type_t<ptrdiff_t, make_signed_t<decltype(_Cont.size())>> {
    using _Common = common_type_t<ptrdiff_t, make_signed_t<decltype(_Cont.size())>>;
    return static_cast<_Common>(_Cont.size());
}

_EXPORT_STD template <class _Ty, ptrdiff_t _Size>
_NODISCARD constexpr ptrdiff_t ssize(const _Ty(&)[_Size]) noexcept {
    return _Size;
}
#endif // _HAS_CXX20

_EXPORT_STD template <class _Container>
_NODISCARD_EMPTY_NON_MEMBER constexpr auto empty(const _Container& _Cont) noexcept(
    noexcept(_Cont.empty())) /* strengthened */
    -> decltype(_Cont.empty()) {
    return _Cont.empty();
}

_EXPORT_STD template <class _Ty, size_t _Size>
_NODISCARD_EMPTY_NON_MEMBER constexpr bool empty(const _Ty(&)[_Size]) noexcept {
    return false;
}

_EXPORT_STD template <class _Elem>
_NODISCARD_EMPTY_NON_MEMBER constexpr bool empty(initializer_list<_Elem> _Ilist) noexcept {
    return _Ilist.size() == 0;
}

_EXPORT_STD template <class _Container>
_NODISCARD constexpr auto data(_Container& _Cont) noexcept(noexcept(_Cont.data())) /* strengthened */
-> decltype(_Cont.data()) {
    return _Cont.data();
}

_EXPORT_STD template <class _Container>
_NODISCARD constexpr auto data(const _Container& _Cont) noexcept(noexcept(_Cont.data())) /* strengthened */
-> decltype(_Cont.data()) {
    return _Cont.data();
}

_EXPORT_STD template <class _Ty, size_t _Size>
_NODISCARD constexpr _Ty* data(_Ty(&_Array)[_Size]) noexcept {
    return _Array;
}

_EXPORT_STD template <class _Elem>
_NODISCARD constexpr const _Elem* data(initializer_list<_Elem> _Ilist) noexcept {
    return _Ilist.begin();
}

#if _HAS_CXX20
#if _HAS_CXX23
_EXPORT_STD template <indirectly_readable _Ty>
using iter_const_reference_t = common_reference_t<const iter_value_t<_Ty>&&, iter_reference_t<_Ty>>;

template <indirectly_readable _Iter>
using _Iter_const_rvalue_reference_t = common_reference_t<const iter_value_t<_Iter>&&, iter_rvalue_reference_t<_Iter>>;

template <class _Ty>
concept _Constant_iterator = input_iterator<_Ty> && same_as<iter_const_reference_t<_Ty>, iter_reference_t<_Ty>>;

_EXPORT_STD template <input_iterator _Iter>
class basic_const_iterator;

_EXPORT_STD template <input_iterator _Iter>
using const_iterator = conditional_t<_Constant_iterator<_Iter>, _Iter, basic_const_iterator<_Iter>>;

template <class _Sent>
struct _Const_sentinel {
    using type = _Sent;
};

template <input_iterator _Sent>
struct _Const_sentinel<_Sent> {
    using type = const_iterator<_Sent>;
};

_EXPORT_STD template <semiregular _Sent>
using const_sentinel = _Const_sentinel<_Sent>::type;

template <class _Ty>
concept _Not_a_const_iterator = !_Is_specialization_v<_Ty, basic_const_iterator>;

template <class>
struct _Basic_const_iterator_category {};

template <forward_iterator _Iter>
struct _Basic_const_iterator_category<_Iter> {
    using iterator_category = iterator_traits<_Iter>::iterator_category;
};

_EXPORT_STD template <input_iterator _Iter>
class basic_const_iterator : public _Basic_const_iterator_category<_Iter> {
private:
    /* [[no_unique_address]] */ _Iter _Current{};

    using _Reference = iter_const_reference_t<_Iter>;
    using _Rvalue_reference = _Iter_const_rvalue_reference_t<_Iter>;

    _NODISCARD static consteval auto _Get_iter_concept() noexcept {
        if constexpr (contiguous_iterator<_Iter>) {
            return contiguous_iterator_tag{};
        }
        else if constexpr (random_access_iterator<_Iter>) {
            return random_access_iterator_tag{};
        }
        else if constexpr (bidirectional_iterator<_Iter>) {
            return bidirectional_iterator_tag{};
        }
        else if constexpr (forward_iterator<_Iter>) {
            return forward_iterator_tag{};
        }
        else {
            return input_iterator_tag{};
        }
    }

public:
    using iterator_concept = decltype(_Get_iter_concept());
    using value_type = iter_value_t<_Iter>;
    using difference_type = iter_difference_t<_Iter>;

    // clang-format off
    basic_const_iterator() requires default_initializable<_Iter> = default;
    // clang-format on

    constexpr basic_const_iterator(_Iter _Current_) noexcept(is_nothrow_move_constructible_v<_Iter>) // strengthened
        : _Current(_STD move(_Current_)) {}

    template <convertible_to<_Iter> _Other>
    constexpr basic_const_iterator(basic_const_iterator<_Other> _Current_) noexcept(
        is_nothrow_constructible_v<_Iter, _Other>) // strengthened
        : _Current(_STD move(_Current_._Current)) {}

    template <_Different_from<basic_const_iterator> _Other>
        requires convertible_to<_Other, _Iter>
    constexpr basic_const_iterator(_Other&& _Current_) noexcept(
        is_nothrow_constructible_v<_Iter, _Other>) // strengthened
        : _Current(_STD forward<_Other>(_Current_)) {}

    _NODISCARD constexpr const _Iter& base() const& noexcept {
        return _Current;
    }

    _NODISCARD constexpr _Iter base() && noexcept(is_nothrow_move_constructible_v<_Iter>) /* strengthened */ {
        return _STD move(_Current);
    }

    _NODISCARD constexpr _Reference operator*() const
        noexcept(noexcept(static_cast<_Reference>(*_Current))) /* strengthened */ {
        return static_cast<_Reference>(*_Current);
    }

    _NODISCARD constexpr const auto* operator->() const
        noexcept(contiguous_iterator<_Iter> || noexcept(*_Current)) /* strengthened */
        requires is_lvalue_reference_v<iter_reference_t<_Iter>>
    && same_as<remove_cvref_t<iter_reference_t<_Iter>>, value_type>
    {
        if constexpr (contiguous_iterator<_Iter>) {
            return _STD to_address(_Current);
        }
        else {
            return _STD addressof(*_Current);
        }
    }

    constexpr basic_const_iterator& operator++() noexcept(noexcept(++_Current)) /* strengthened */ {
        ++_Current;
        return *this;
    }

    constexpr void operator++(int) noexcept(noexcept(++_Current)) /* strengthened */ {
        ++_Current;
    }

    constexpr basic_const_iterator operator++(int) noexcept(
        noexcept(++*this) && is_nothrow_copy_constructible_v<basic_const_iterator>) // strengthened
        requires forward_iterator<_Iter>
    {
        auto _Tmp = *this;
        ++*this;
        return _Tmp;
    }

    constexpr basic_const_iterator& operator--() noexcept(noexcept(--_Current)) // strengthened
        requires bidirectional_iterator<_Iter>
    {
        --_Current;
        return *this;
    }

    constexpr basic_const_iterator operator--(int) noexcept(
        noexcept(--*this) && is_nothrow_copy_constructible_v<basic_const_iterator>) // strengthened
        requires bidirectional_iterator<_Iter>
    {
        auto _Tmp = *this;
        --*this;
        return _Tmp;
    }

    constexpr basic_const_iterator& operator+=(const difference_type _Off) noexcept(
        noexcept(_Current += _Off)) // strengthened
        requires random_access_iterator<_Iter>
    {
        _Current += _Off;
        return *this;
    }

    constexpr basic_const_iterator& operator-=(const difference_type _Off) noexcept(
        noexcept(_Current -= _Off)) // strengthened
        requires random_access_iterator<_Iter>
    {
        _Current -= _Off;
        return *this;
    }

    _NODISCARD constexpr _Reference operator[](const difference_type _Idx) const
        noexcept(noexcept(static_cast<_Reference>(_Current[_Idx]))) // strengthened
        requires random_access_iterator<_Iter>
    {
        return static_cast<_Reference>(_Current[_Idx]);
    }

    template <sentinel_for<_Iter> _Sent>
    _NODISCARD constexpr bool operator==(const _Sent& _Se) const
        noexcept(noexcept(_STD _Fake_copy_init<bool>(_Current == _Se))) /* strengthened */ {
        return _Current == _Se;
    }

    template <_Not_a_const_iterator _Other>
        requires _Constant_iterator<_Other>&& convertible_to<const _Iter&, _Other>
    _NODISCARD constexpr operator _Other() const& noexcept(
        is_nothrow_convertible_v<const _Iter&, _Other>) /* strengthened */ {
        return _Current;
    }

    template <_Not_a_const_iterator _Other>
        requires _Constant_iterator<_Other>&& convertible_to<_Iter, _Other>
    _NODISCARD constexpr operator _Other() && noexcept(is_nothrow_convertible_v<_Iter, _Other>) /* strengthened */ {
        return _STD move(_Current);
    }

    _NODISCARD constexpr bool operator<(const basic_const_iterator& _Right) const
        noexcept(noexcept(_STD _Fake_copy_init<bool>(_Current < _Right._Current))) // strengthened
        requires random_access_iterator<_Iter>
    {
        return _Current < _Right._Current;
    }

    _NODISCARD constexpr bool operator>(const basic_const_iterator& _Right) const
        noexcept(noexcept(_STD _Fake_copy_init<bool>(_Current > _Right._Current))) // strengthened
        requires random_access_iterator<_Iter>
    {
        return _Current > _Right._Current;
    }

    _NODISCARD constexpr bool operator<=(const basic_const_iterator& _Right) const
        noexcept(noexcept(_STD _Fake_copy_init<bool>(_Current <= _Right._Current))) // strengthened
        requires random_access_iterator<_Iter>
    {
        return _Current <= _Right._Current;
    }

    _NODISCARD constexpr bool operator>=(const basic_const_iterator& _Right) const
        noexcept(noexcept(_STD _Fake_copy_init<bool>(_Current >= _Right._Current))) // strengthened
        requires random_access_iterator<_Iter>
    {
        return _Current >= _Right._Current;
    }

    _NODISCARD constexpr auto operator<=>(const basic_const_iterator& _Right) const
        noexcept(noexcept(_Current <=> _Right._Current)) // strengthened
        requires random_access_iterator<_Iter>&& three_way_comparable<_Iter>
    {
        return _Current <=> _Right._Current;
    }

    template <_Different_from<basic_const_iterator> _Other>
        requires random_access_iterator<_Iter>&& totally_ordered_with<_Iter, _Other>
    _NODISCARD constexpr bool operator<(const _Other& _Right) const
        noexcept(noexcept(_STD _Fake_copy_init<bool>(_Current < _Right))) /* strengthened */ {
        return _Current < _Right;
    }

    template <_Different_from<basic_const_iterator> _Other>
        requires random_access_iterator<_Iter>&& totally_ordered_with<_Iter, _Other>
    _NODISCARD constexpr bool operator>(const _Other& _Right) const
        noexcept(noexcept(_STD _Fake_copy_init<bool>(_Current > _Right))) /* strengthened */ {
        return _Current > _Right;
    }

    template <_Different_from<basic_const_iterator> _Other>
        requires random_access_iterator<_Iter>&& totally_ordered_with<_Iter, _Other>
    _NODISCARD constexpr bool operator<=(const _Other& _Right) const
        noexcept(noexcept(_STD _Fake_copy_init<bool>(_Current <= _Right))) /* strengthened */ {
        return _Current <= _Right;
    }

    template <_Different_from<basic_const_iterator> _Other>
        requires random_access_iterator<_Iter>&& totally_ordered_with<_Iter, _Other>
    _NODISCARD constexpr bool operator>=(const _Other& _Right) const
        noexcept(noexcept(_STD _Fake_copy_init<bool>(_Current >= _Right))) /* strengthened */ {
        return _Current >= _Right;
    }

    template <_Different_from<basic_const_iterator> _Other>
        requires random_access_iterator<_Iter>&& totally_ordered_with<_Iter, _Other>
    && three_way_comparable_with<_Iter, _Other>
        _NODISCARD constexpr auto operator<=>(const _Other& _Right) const
        noexcept(noexcept(_Current <=> _Right)) /* strengthened */ {
        return _Current <=> _Right;
    }

    template <_Not_a_const_iterator _Other>
        requires random_access_iterator<_Iter>&& totally_ordered_with<_Iter, _Other>
    _NODISCARD_FRIEND constexpr bool operator<(const _Other& _Left, const basic_const_iterator& _Right) noexcept(
        noexcept(_STD _Fake_copy_init<bool>(_Left < _Right._Current))) /* strengthened */ {
        return _Left < _Right._Current;
    }

    template <_Not_a_const_iterator _Other>
        requires random_access_iterator<_Iter>&& totally_ordered_with<_Iter, _Other>
    _NODISCARD_FRIEND constexpr bool operator>(const _Other& _Left, const basic_const_iterator& _Right) noexcept(
        noexcept(_STD _Fake_copy_init<bool>(_Left > _Right._Current))) /* strengthened */ {
        return _Left > _Right._Current;
    }

    template <_Not_a_const_iterator _Other>
        requires random_access_iterator<_Iter>&& totally_ordered_with<_Iter, _Other>
    _NODISCARD_FRIEND constexpr bool operator<=(const _Other& _Left, const basic_const_iterator& _Right) noexcept(
        noexcept(_STD _Fake_copy_init<bool>(_Left <= _Right._Current))) /* strengthened */ {
        return _Left <= _Right._Current;
    }

    template <_Not_a_const_iterator _Other>
        requires random_access_iterator<_Iter>&& totally_ordered_with<_Iter, _Other>
    _NODISCARD_FRIEND constexpr bool operator>=(const _Other& _Left, const basic_const_iterator& _Right) noexcept(
        noexcept(_STD _Fake_copy_init<bool>(_Left >= _Right._Current))) /* strengthened */ {
        return _Left >= _Right._Current;
    }

    _NODISCARD_FRIEND constexpr basic_const_iterator operator+(const basic_const_iterator& _It,
        const difference_type _Off) noexcept(noexcept(basic_const_iterator{ _It._Current + _Off })) // strengthened
        requires random_access_iterator<_Iter>
    {
        return basic_const_iterator{ _It._Current + _Off };
    }

    _NODISCARD_FRIEND constexpr basic_const_iterator operator+(const difference_type _Off,
        const basic_const_iterator& _It) noexcept(noexcept(basic_const_iterator{ _It._Current + _Off })) // strengthened
        requires random_access_iterator<_Iter>
    {
        return basic_const_iterator{ _It._Current + _Off };
    }

    _NODISCARD_FRIEND constexpr basic_const_iterator operator-(const basic_const_iterator& _It,
        const difference_type _Off) noexcept(noexcept(basic_const_iterator{ _It._Current - _Off })) // strengthened
        requires random_access_iterator<_Iter>
    {
        return basic_const_iterator{ _It._Current - _Off };
    }

    template <sized_sentinel_for<_Iter> _Sent>
    _NODISCARD constexpr difference_type operator-(const _Sent& _Se) const
        noexcept(noexcept(_Current - _Se)) /* strengthened */ {
        return _Current - _Se;
    }

    template <_Not_a_const_iterator _Sent>
        requires sized_sentinel_for<_Sent, _Iter>
    _NODISCARD_FRIEND constexpr difference_type operator-(const _Sent& _Se, const basic_const_iterator& _It) noexcept(
        noexcept(_Se - _It._Current)) /* strengthened */ {
        return _Se - _It._Current;
    }

    _NODISCARD_FRIEND constexpr _Rvalue_reference iter_move(const basic_const_iterator& _It) noexcept(
        noexcept(static_cast<_Rvalue_reference>(_RANGES iter_move(_It._Current)))) {
        return static_cast<_Rvalue_reference>(_RANGES iter_move(_It._Current));
    }
};

template <class _Ty1, common_with<_Ty1> _Ty2>
    requires input_iterator<common_type_t<_Ty1, _Ty2>>
struct common_type<basic_const_iterator<_Ty1>, _Ty2> {
    using type = basic_const_iterator<common_type_t<_Ty1, _Ty2>>;
};

template <class _Ty1, common_with<_Ty1> _Ty2>
    requires input_iterator<common_type_t<_Ty1, _Ty2>>
struct common_type<_Ty2, basic_const_iterator<_Ty1>> {
    using type = basic_const_iterator<common_type_t<_Ty1, _Ty2>>;
};

template <class _Ty1, common_with<_Ty1> _Ty2>
    requires input_iterator<common_type_t<_Ty1, _Ty2>>
struct common_type<basic_const_iterator<_Ty1>, basic_const_iterator<_Ty2>> {
    using type = basic_const_iterator<common_type_t<_Ty1, _Ty2>>;
};

_EXPORT_STD template <input_iterator _Iter>
_NODISCARD constexpr const_iterator<_Iter> make_const_iterator(_Iter _It) noexcept(
    is_nothrow_constructible_v<const_iterator<_Iter>, _Iter&>) /* strengthened */ {
    return _It;
}

_EXPORT_STD template <semiregular _Sent>
_NODISCARD constexpr const_sentinel<_Sent> make_const_sentinel(_Sent _Se) noexcept(
    is_nothrow_constructible_v<const_sentinel<_Sent>, _Sent&>) /* strengthened */ {
    return _Se;
}
#endif // _HAS_CXX23

namespace ranges {
    template <class>
    inline constexpr bool _Has_complete_elements = false;

    template <class _Ty>
        requires requires(_Ty& __t) { sizeof(__t[0]); }
    inline constexpr bool _Has_complete_elements<_Ty> = true;

    _EXPORT_STD template <class>
        inline constexpr bool enable_borrowed_range = false;

    template <class _Rng>
    concept _Should_range_access = is_lvalue_reference_v<_Rng> || enable_borrowed_range<remove_cvref_t<_Rng>>;

    namespace _Begin {
#if defined(__clang__) || defined(__EDG__) // TRANSITION, VSO-1681199
        void begin() = delete; // Block unqualified name lookup
#else // ^^^ no workaround / workaround vvv
        void begin();
#endif // ^^^ workaround ^^^

        template <class _Ty>
        concept _Has_member = requires(_Ty __t) {
            { _STD _Fake_copy_init(__t.begin()) } -> input_or_output_iterator;
        };

        template <class _Ty>
        concept _Has_ADL = _Has_class_or_enum_type<_Ty> && requires(_Ty __t) {
            { _STD _Fake_copy_init(begin(__t)) } -> input_or_output_iterator; // intentional ADL
        };

        class _Cpo {
        private:
            enum class _St { _None, _Array, _Member, _Non_member };

            template <class _Ty>
            _NODISCARD static consteval _Choice_t<_St> _Choose() noexcept {
                _STL_INTERNAL_STATIC_ASSERT(is_lvalue_reference_v<_Ty>);
                if constexpr (is_array_v<remove_reference_t<_Ty>>) {
                    static_assert(_Has_complete_elements<_Ty>,
                        "The range access customization point objects "
                        "std::ranges::begin, std::ranges::end, std::ranges::rbegin, std::ranges::rend, "
                        "and std::ranges::data do not accept arrays with incomplete element types.");
                    return { _St::_Array, true };
                }
                else if constexpr (_Has_member<_Ty>) {
                    return { _St::_Member, noexcept(_STD _Fake_copy_init(_STD declval<_Ty>().begin())) };
                }
                else if constexpr (_Has_ADL<_Ty>) {
                    return { _St::_Non_member,
                        noexcept(_STD _Fake_copy_init(begin(_STD declval<_Ty>()))) }; // intentional ADL
                }
                else {
                    return { _St::_None };
                }
            }

            template <class _Ty>
            static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();

        public:
            template <_Should_range_access _Ty>
                requires (_Choice<_Ty&>._Strategy != _St::_None)
            _NODISCARD _STATIC_CALL_OPERATOR constexpr auto operator()(_Ty&& _Val) _CONST_CALL_OPERATOR
                noexcept(_Choice<_Ty&>._No_throw) {
                constexpr _St _Strat = _Choice<_Ty&>._Strategy;

                if constexpr (_Strat == _St::_Array) {
                    return _Val;
                }
                else if constexpr (_Strat == _St::_Member) {
                    return _Val.begin();
                }
                else if constexpr (_Strat == _St::_Non_member) {
                    return begin(_Val); // intentional ADL
                }
                else {
                    static_assert(_Always_false<_Ty>, "Should be unreachable");
                }
            }
        };
    } // namespace _Begin

    inline namespace _Cpos {
        _EXPORT_STD inline constexpr _Begin::_Cpo begin;
    }

    _EXPORT_STD template <class _Ty>
        using iterator_t = decltype(_RANGES begin(_STD declval<_Ty&>()));

    namespace _End {
#if defined(__clang__) || defined(__EDG__) // TRANSITION, VSO-1681199
        void end() = delete; // Block unqualified name lookup
#else // ^^^ no workaround / workaround vvv
        void end();
#endif // ^^^ workaround ^^^

        template <class _Ty>
        concept _Has_member = requires(_Ty __t) {
            { _STD _Fake_copy_init(__t.end()) } -> sentinel_for<iterator_t<_Ty>>;
        };

        template <class _Ty>
        concept _Has_ADL = _Has_class_or_enum_type<_Ty> && requires(_Ty __t) {
            { _STD _Fake_copy_init(end(__t)) } -> sentinel_for<iterator_t<_Ty>>; // intentional ADL
        };

        class _Cpo {
        private:
            enum class _St { _None, _Array, _Member, _Non_member };

            template <class _Ty>
            _NODISCARD static consteval _Choice_t<_St> _Choose() noexcept {
                _STL_INTERNAL_STATIC_ASSERT(is_lvalue_reference_v<_Ty>);
                using _UnRef = remove_reference_t<_Ty>;

                if constexpr (is_array_v<_UnRef>) {
                    static_assert(_Has_complete_elements<_UnRef>,
                        "The range access customization point objects "
                        "std::ranges::begin, std::ranges::end, std::ranges::rbegin, std::ranges::rend, "
                        "and std::ranges::data do not accept arrays with incomplete element types.");
                    if constexpr (extent_v<_UnRef> != 0) {
                        return { _St::_Array, true };
                    }
                    else {
                        return { _St::_None };
                    }
                }
                else if constexpr (_Has_member<_Ty>) {
                    return { _St::_Member, noexcept(_STD _Fake_copy_init(_STD declval<_Ty>().end())) };
                }
                else if constexpr (_Has_ADL<_Ty>) {
                    return {
                        _St::_Non_member, noexcept(_STD _Fake_copy_init(end(_STD declval<_Ty>()))) }; // intentional ADL
                }
                else {
                    return { _St::_None };
                }
            }

            template <class _Ty>
            static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();

        public:
            template <_Should_range_access _Ty>
                requires (_Choice<_Ty&>._Strategy != _St::_None)
            _NODISCARD _STATIC_CALL_OPERATOR constexpr auto operator()(_Ty&& _Val) _CONST_CALL_OPERATOR
                noexcept(_Choice<_Ty&>._No_throw) {
                constexpr _St _Strat = _Choice<_Ty&>._Strategy;

                if constexpr (_Strat == _St::_Array) {
                    // extent_v<remove_reference_t<_Ty&>> reuses specializations from _Choose
                    return _Val + extent_v<remove_reference_t<_Ty&>>;
                }
                else if constexpr (_Strat == _St::_Member) {
                    return _Val.end();
                }
                else if constexpr (_Strat == _St::_Non_member) {
                    return end(_Val); // intentional ADL
                }
                else {
                    static_assert(_Always_false<_Ty>, "should be unreachable");
                }
            }
        };
    } // namespace _End

    inline namespace _Cpos {
        _EXPORT_STD inline constexpr _End::_Cpo end;
    }

    _EXPORT_STD template <class _Rng>
        concept range = requires(_Rng & __r) {
        _RANGES begin(__r);
        _RANGES end(__r);
    };

    _EXPORT_STD template <class _Rng>
        concept input_range = range<_Rng> && input_iterator<iterator_t<_Rng>>;

    _EXPORT_STD template <range _Rng>
        using sentinel_t = decltype(_RANGES end(_STD declval<_Rng&>()));

    template <class _Wrapped>
    concept _Weakly_unwrappable = _Allow_inheriting_unwrap_v<remove_cvref_t<_Wrapped>>
        && requires(_Wrapped && _Wr) { _STD forward<_Wrapped>(_Wr)._Unwrapped(); };

    template <class _Sent>
    concept _Weakly_unwrappable_sentinel = _Weakly_unwrappable<const remove_reference_t<_Sent>&>;

    template <class _Iter>
    concept _Weakly_unwrappable_iterator =
        _Weakly_unwrappable<_Iter> && requires(_Iter && _It, remove_cvref_t<_Iter>&_MutIt) {
        _MutIt._Seek_to(_STD forward<_Iter>(_It)._Unwrapped());
    };

    template <class _Sent, class _Iter>
    concept _Unwrappable_sentinel_for = _Weakly_unwrappable_sentinel<_Sent> && _Weakly_unwrappable_iterator<_Iter>
        && requires(_Iter && _It, const remove_reference_t<_Sent>&_Se) {
            {
                _Se._Unwrapped()
            } -> sentinel_for<decltype(_STD forward<_Iter>(_It)._Unwrapped())>;
    };

    template <class _Sent, class _Iter>
    _NODISCARD constexpr decltype(auto) _Unwrap_iter(_Iter&& _It) noexcept(
        !_Unwrappable_sentinel_for<_Sent, _Iter> || _Has_nothrow_unwrapped<_Iter>) {
        _STL_INTERNAL_STATIC_ASSERT(sentinel_for<remove_cvref_t<_Sent>, remove_cvref_t<_Iter>>);
        if constexpr (is_pointer_v<remove_cvref_t<_Iter>>) {
            return _It + 0;
        }
        else if constexpr (_Unwrappable_sentinel_for<_Sent, _Iter>) {
            return static_cast<_Iter&&>(_It)._Unwrapped();
        }
        else {
            return static_cast<_Iter&&>(_It);
        }
    }

    template <class _Iter, class _Sent>
    _NODISCARD constexpr decltype(auto) _Unwrap_sent(_Sent&& _Se) noexcept(
        !_Unwrappable_sentinel_for<_Sent, _Iter> || _Has_nothrow_unwrapped<_Sent>) {
        _STL_INTERNAL_STATIC_ASSERT(sentinel_for<remove_cvref_t<_Sent>, remove_cvref_t<_Iter>>);
        if constexpr (is_pointer_v<remove_cvref_t<_Sent>>) {
            return _Se + 0;
        }
        else if constexpr (_Unwrappable_sentinel_for<_Sent, _Iter>) {
            return static_cast<_Sent&&>(_Se)._Unwrapped();
        }
        else {
            return static_cast<_Sent&&>(_Se);
        }
    }

    template <range _Rng, class _Iter>
    _NODISCARD constexpr decltype(auto) _Unwrap_range_iter(_Iter&& _It) noexcept(
        noexcept(_RANGES _Unwrap_iter<sentinel_t<_Rng>>(static_cast<_Iter&&>(_It)))) {
        _STL_INTERNAL_STATIC_ASSERT(same_as<remove_cvref_t<_Iter>, iterator_t<_Rng>>);
        return _RANGES _Unwrap_iter<sentinel_t<_Rng>>(static_cast<_Iter&&>(_It));
    }

    template <range _Rng, class _Sent>
    _NODISCARD constexpr decltype(auto) _Unwrap_range_sent(_Sent&& _Se) noexcept(
        noexcept(_RANGES _Unwrap_sent<iterator_t<_Rng>>(static_cast<_Sent&&>(_Se)))) {
        _STL_INTERNAL_STATIC_ASSERT(same_as<remove_cvref_t<_Sent>, sentinel_t<_Rng>>);
        return _RANGES _Unwrap_sent<iterator_t<_Rng>>(static_cast<_Sent&&>(_Se));
    }

    template <class _Iter, class _Sent>
    using _Unwrap_iter_t = remove_cvref_t<decltype(_RANGES _Unwrap_iter<_Sent>(_STD declval<_Iter>()))>;
    template <class _Sent, class _Iter>
    using _Unwrap_sent_t = remove_cvref_t<decltype(_RANGES _Unwrap_sent<_Iter>(_STD declval<_Sent>()))>;

    template <range _Rng>
    using _Unwrapped_iterator_t = _Unwrap_iter_t<iterator_t<_Rng>, sentinel_t<_Rng>>;
    template <range _Rng>
    using _Unwrapped_sentinel_t = _Unwrap_sent_t<sentinel_t<_Rng>, iterator_t<_Rng>>;

    namespace _Unchecked_begin {
        template <class _Ty>
        concept _Has_member = requires(_Ty & __t) {
            { __t._Unchecked_begin() } -> input_or_output_iterator;
        };

        template <class _Ty>
        concept _Can_begin = requires(_Ty & __t) { _RANGES _Unwrap_range_iter<_Ty>(_RANGES begin(__t)); };

        class _Cpo {
        private:
            enum class _St { _None, _Member, _Unwrap };

            template <class _Ty>
            _NODISCARD static consteval _Choice_t<_St> _Choose() noexcept {
                _STL_INTERNAL_STATIC_ASSERT(is_lvalue_reference_v<_Ty>);
                if constexpr (_Has_member<_Ty>) {
                    _STL_INTERNAL_STATIC_ASSERT(
                        same_as<decltype(_STD declval<_Ty>()._Unchecked_begin()), _Unwrapped_iterator_t<_Ty>>);
                    return { _St::_Member, noexcept(_STD _Fake_copy_init(_STD declval<_Ty>()._Unchecked_begin())) };
                }
                else if constexpr (_Can_begin<_Ty>) {
                    return { _St::_Unwrap, noexcept(_STD _Fake_copy_init(
                                              _RANGES _Unwrap_range_iter<_Ty>(_RANGES begin(_STD declval<_Ty>())))) };
                }
                else {
                    return { _St::_None };
                }
            }

            template <class _Ty>
            static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();

        public:
            template <_Should_range_access _Ty>
                requires (_Choice<_Ty&>._Strategy != _St::_None)
            _NODISCARD _STATIC_CALL_OPERATOR constexpr auto operator()(_Ty&& _Val) _CONST_CALL_OPERATOR
                noexcept(_Choice<_Ty&>._No_throw) {
                constexpr _St _Strat = _Choice<_Ty&>._Strategy;

                if constexpr (_Strat == _St::_Member) {
                    return _Val._Unchecked_begin();
                }
                else if constexpr (_Strat == _St::_Unwrap) {
                    return _RANGES _Unwrap_range_iter<_Ty>(_RANGES begin(_Val));
                }
                else {
                    static_assert(_Always_false<_Ty>, "Should be unreachable");
                }
            }
        };
    } // namespace _Unchecked_begin

    inline namespace _Cpos {
        inline constexpr _Unchecked_begin::_Cpo _Ubegin;
    }

    namespace _Unchecked_end {
        template <class _Ty>
        concept _Has_member = _Unchecked_begin::_Has_member<_Ty> && requires(_Ty & __t) {
            __t._Unchecked_begin(); // required explicitly for better diagnostics
            { __t._Unchecked_end() } -> sentinel_for<decltype(__t._Unchecked_begin())>;
        };

        template <class _Ty>
        concept _Can_end = requires(_Ty & __t) { _RANGES _Unwrap_range_sent<_Ty>(_RANGES end(__t)); };

        class _Cpo {
        private:
            enum class _St { _None, _Member, _Unwrap };

            template <class _Ty>
            _NODISCARD static consteval _Choice_t<_St> _Choose() noexcept {
                _STL_INTERNAL_STATIC_ASSERT(is_lvalue_reference_v<_Ty>);
                if constexpr (_Has_member<_Ty>) {
                    return { _St::_Member, noexcept(_STD declval<_Ty>()._Unchecked_end()) };
                }
                else if constexpr (_Can_end<_Ty>) {
                    return { _St::_Unwrap, noexcept(_RANGES _Unwrap_range_sent<_Ty>(_RANGES end(_STD declval<_Ty>()))) };
                }
                else {
                    return { _St::_None };
                }
            }

            template <class _Ty>
            static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();

        public:
            template <_Should_range_access _Ty>
                requires (_Choice<_Ty&>._Strategy != _St::_None)
            _NODISCARD _STATIC_CALL_OPERATOR constexpr auto operator()(_Ty&& _Val) _CONST_CALL_OPERATOR
                noexcept(_Choice<_Ty&>._No_throw) {
                constexpr _St _Strat = _Choice<_Ty&>._Strategy;

                if constexpr (_Strat == _St::_Member) {
                    return _Val._Unchecked_end();
                }
                else if constexpr (_Strat == _St::_Unwrap) {
                    return _RANGES _Unwrap_range_sent<_Ty>(_RANGES end(_Val));
                }
                else {
                    static_assert(_Always_false<_Ty>, "Should be unreachable");
                }
            }
        };
    } // namespace _Unchecked_end

    inline namespace _Cpos {
        inline constexpr _Unchecked_end::_Cpo _Uend;
    }

    _EXPORT_STD template <class _Rng>
        concept borrowed_range = range<_Rng> && _Should_range_access<_Rng>;

    _EXPORT_STD template <range _Rng>
        using range_difference_t = iter_difference_t<iterator_t<_Rng>>;

    _EXPORT_STD template <range _Rng>
        using range_value_t = iter_value_t<iterator_t<_Rng>>;

    _EXPORT_STD template <range _Rng>
        using range_reference_t = iter_reference_t<iterator_t<_Rng>>;

    _EXPORT_STD template <range _Rng>
        using range_rvalue_reference_t = iter_rvalue_reference_t<iterator_t<_Rng>>;

    _EXPORT_STD template <range _Rng>
        using range_common_reference_t = iter_common_reference_t<iterator_t<_Rng>>;

#if _HAS_CXX23
    _EXPORT_STD template <class _Rng>
        concept constant_range = input_range<_Rng> && _Constant_iterator<iterator_t<_Rng>>;

    template <input_range _Rng>
    _NODISCARD _MSVC_INTRINSIC constexpr auto& _Possibly_const_range(_Rng& _Range) noexcept {
        if constexpr (constant_range<const _Rng> && !constant_range<_Rng>) {
            return _STD as_const(_Range);
        }
        else {
            return _Range;
        }
    }

    template <class _Ty>
    _NODISCARD _MSVC_INTRINSIC constexpr auto _As_const_pointer(const _Ty* _Ptr) noexcept {
        return _Ptr;
    }
#endif // _HAS_CXX23

    struct _Cbegin_fn {
#if _HAS_CXX23
        template <class _Ty>
        using _Begin_on_const = decltype(_RANGES begin(_RANGES _Possibly_const_range(_STD declval<_Ty&>())));

        template <_Should_range_access _Ty>
            requires requires(_Ty& _Val) {
            typename _Begin_on_const<_Ty>;
            typename const_iterator<_Begin_on_const<_Ty>>;
            const_iterator<_Begin_on_const<_Ty>>{_RANGES begin(_RANGES _Possibly_const_range(_Val))};
        }
        _NODISCARD _STATIC_CALL_OPERATOR constexpr auto operator()(_Ty&& _Val) _CONST_CALL_OPERATOR noexcept(
            noexcept(const_iterator<_Begin_on_const<_Ty>>{_RANGES begin(_RANGES _Possibly_const_range(_Val))})) {
            return const_iterator<_Begin_on_const<_Ty>>{_RANGES begin(_RANGES _Possibly_const_range(_Val))};
        }
#else // ^^^ _HAS_CXX23 / !_HAS_CXX23 vvv
        template <class _Ty, class _CTy = _Const_thru_ref<_Ty>>
        _NODISCARD _STATIC_CALL_OPERATOR constexpr auto operator()(_Ty&& _Val) _CONST_CALL_OPERATOR
            noexcept(noexcept(_RANGES begin(static_cast<_CTy&&>(_Val))))
            requires requires { _RANGES begin(static_cast<_CTy&&>(_Val)); }
        {
            return _RANGES begin(static_cast<_CTy&&>(_Val));
        }
#endif // ^^^ !_HAS_CXX23 ^^^
    };

    inline namespace _Cpos {
        _EXPORT_STD inline constexpr _Cbegin_fn cbegin;
    }

    struct _Cend_fn {
#if _HAS_CXX23
        template <class _Ty>
        using _End_on_const = decltype(_RANGES end(_RANGES _Possibly_const_range(_STD declval<_Ty&>())));

        template <_Should_range_access _Ty>
            requires requires(_Ty& _Val) {
            typename _End_on_const<_Ty>;
            typename const_sentinel<_End_on_const<_Ty>>;
            const_sentinel<_End_on_const<_Ty>>{_RANGES end(_RANGES _Possibly_const_range(_Val))};
        }
        _NODISCARD _STATIC_CALL_OPERATOR constexpr auto operator()(_Ty&& _Val) _CONST_CALL_OPERATOR
            noexcept(noexcept(const_sentinel<_End_on_const<_Ty>>{_RANGES end(_RANGES _Possibly_const_range(_Val))})) {
            return const_sentinel<_End_on_const<_Ty>>{_RANGES end(_RANGES _Possibly_const_range(_Val))};
        }
#else // ^^^ _HAS_CXX23 / !_HAS_CXX23 vvv
        template <class _Ty, class _CTy = _Const_thru_ref<_Ty>>
        _NODISCARD _STATIC_CALL_OPERATOR constexpr auto operator()(_Ty&& _Val) _CONST_CALL_OPERATOR
            noexcept(noexcept(_RANGES end(static_cast<_CTy&&>(_Val))))
            requires requires { _RANGES end(static_cast<_CTy&&>(_Val)); }
        {
            return _RANGES end(static_cast<_CTy&&>(_Val));
        }
#endif // ^^^ !_HAS_CXX23 ^^^
    };

    inline namespace _Cpos {
        _EXPORT_STD inline constexpr _Cend_fn cend;
    }

    namespace _Rbegin {
#if defined(__clang__) || defined(__EDG__) // TRANSITION, VSO-1681199
        void rbegin() = delete; // Block unqualified name lookup
#else // ^^^ no workaround / workaround vvv
        void rbegin();
#endif // ^^^ workaround ^^^

        template <class _Ty>
        concept _Has_member = requires(_Ty __t) {
            { _STD _Fake_copy_init(__t.rbegin()) } -> input_or_output_iterator;
        };

        template <class _Ty>
        concept _Has_ADL = _Has_class_or_enum_type<_Ty> && requires(_Ty __t) {
            { _STD _Fake_copy_init(rbegin(__t)) } -> input_or_output_iterator; // intentional ADL
        };

        template <class _Ty>
        concept _Can_make_reverse = requires(_Ty __t) {
            { _RANGES begin(__t) } -> bidirectional_iterator;
            { _RANGES end(__t) } -> same_as<decltype(_RANGES begin(__t))>;
        };

        class _Cpo {
        private:
            enum class _St { _None, _Member, _Non_member, _Make_reverse };

            template <class _Ty>
            _NODISCARD static consteval _Choice_t<_St> _Choose() noexcept {
                _STL_INTERNAL_STATIC_ASSERT(is_lvalue_reference_v<_Ty>);
                if constexpr (_Has_member<_Ty>) {
                    return { _St::_Member, noexcept(_STD _Fake_copy_init(_STD declval<_Ty>().rbegin())) };
                }
                else if constexpr (_Has_ADL<_Ty>) {
                    return { _St::_Non_member,
                        noexcept(_STD _Fake_copy_init(rbegin(_STD declval<_Ty>()))) }; // intentional ADL
                }
                else if constexpr (_Can_make_reverse<_Ty>) {
                    return { _St::_Make_reverse, noexcept(_STD make_reverse_iterator(_RANGES end(_STD declval<_Ty>()))) };
                }
                else {
                    return { _St::_None };
                }
            }

            template <class _Ty>
            static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();

        public:
            template <_Should_range_access _Ty>
                requires (_Choice<_Ty&>._Strategy != _St::_None)
            _NODISCARD _STATIC_CALL_OPERATOR constexpr auto operator()(_Ty&& _Val) _CONST_CALL_OPERATOR
                noexcept(_Choice<_Ty&>._No_throw) {
                constexpr _St _Strat = _Choice<_Ty&>._Strategy;

                if constexpr (_Strat == _St::_Member) {
                    return _Val.rbegin();
                }
                else if constexpr (_Strat == _St::_Non_member) {
                    return rbegin(_Val); // intentional ADL
                }
                else if constexpr (_Strat == _St::_Make_reverse) {
                    return _STD make_reverse_iterator(_RANGES end(_Val));
                }
                else {
                    static_assert(_Always_false<_Ty>, "should be unreachable");
                }
            }
        };
    } // namespace _Rbegin

    inline namespace _Cpos {
        _EXPORT_STD inline constexpr _Rbegin::_Cpo rbegin;
    }

    namespace _Rend {
#if defined(__clang__) || defined(__EDG__) // TRANSITION, VSO-1681199
        void rend() = delete; // Block unqualified name lookup
#else // ^^^ no workaround / workaround vvv
        void rend();
#endif // ^^^ workaround ^^^

        template <class _Ty>
        concept _Has_member = requires(_Ty __t) {
            { _STD _Fake_copy_init(__t.rend()) } -> sentinel_for<decltype(_RANGES rbegin(__t))>;
        };

        template <class _Ty>
        concept _Has_ADL = _Has_class_or_enum_type<_Ty> && requires(_Ty __t) {
            // intentional ADL
            { _STD _Fake_copy_init(rend(__t)) } -> sentinel_for<decltype(_RANGES rbegin(__t))>;
        };

        template <class _Ty>
        concept _Can_make_reverse = requires(_Ty __t) {
            { _RANGES begin(__t) } -> bidirectional_iterator;
            { _RANGES end(__t) } -> same_as<decltype(_RANGES begin(__t))>;
        };

        class _Cpo {
        private:
            enum class _St { _None, _Member, _Non_member, _Make_reverse };

            template <class _Ty>
            _NODISCARD static consteval _Choice_t<_St> _Choose() noexcept {
                _STL_INTERNAL_STATIC_ASSERT(is_lvalue_reference_v<_Ty>);
                if constexpr (_Has_member<_Ty>) {
                    return { _St::_Member, noexcept(_STD _Fake_copy_init(_STD declval<_Ty>().rend())) };
                }
                else if constexpr (_Has_ADL<_Ty>) {
                    return {
                        _St::_Non_member, noexcept(_STD _Fake_copy_init(rend(_STD declval<_Ty>()))) }; // intentional ADL
                }
                else if constexpr (_Can_make_reverse<_Ty>) {
                    return {
                        _St::_Make_reverse, noexcept(_STD make_reverse_iterator(_RANGES begin(_STD declval<_Ty>()))) };
                }
                else {
                    return { _St::_None };
                }
            }

            template <class _Ty>
            static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();

        public:
            template <_Should_range_access _Ty>
                requires (_Choice<_Ty&>._Strategy != _St::_None)
            _NODISCARD _STATIC_CALL_OPERATOR constexpr auto operator()(_Ty&& _Val) _CONST_CALL_OPERATOR
                noexcept(_Choice<_Ty&>._No_throw) {
                constexpr _St _Strat = _Choice<_Ty&>._Strategy;

                if constexpr (_Strat == _St::_Member) {
                    return _Val.rend();
                }
                else if constexpr (_Strat == _St::_Non_member) {
                    return rend(_Val); // intentional ADL
                }
                else if constexpr (_Strat == _St::_Make_reverse) {
                    return _STD make_reverse_iterator(_RANGES begin(_Val));
                }
                else {
                    static_assert(_Always_false<_Ty>, "should be unreachable");
                }
            }
        };
    } // namespace _Rend

    inline namespace _Cpos {
        _EXPORT_STD inline constexpr _Rend::_Cpo rend;
    }

    struct _Crbegin_fn {
#if _HAS_CXX23
        template <class _Ty>
        using _Rbegin_on_const = decltype(_RANGES rbegin(_RANGES _Possibly_const_range(_STD declval<_Ty&>())));

        template <_Should_range_access _Ty>
            requires requires(_Ty& _Val) {
            typename _Rbegin_on_const<_Ty>;
            typename const_iterator<_Rbegin_on_const<_Ty>>;
            const_iterator<_Rbegin_on_const<_Ty>>{_RANGES rbegin(_RANGES _Possibly_const_range(_Val))};
        }
        _NODISCARD _STATIC_CALL_OPERATOR constexpr auto operator()(_Ty&& _Val) _CONST_CALL_OPERATOR noexcept(
            noexcept(const_iterator<_Rbegin_on_const<_Ty>>{_RANGES rbegin(_RANGES _Possibly_const_range(_Val))})) {
            return const_iterator<_Rbegin_on_const<_Ty>>{_RANGES rbegin(_RANGES _Possibly_const_range(_Val))};
        }
#else // ^^^ _HAS_CXX23 / !_HAS_CXX23 vvv
        template <class _Ty, class _CTy = _Const_thru_ref<_Ty>>
        _NODISCARD _STATIC_CALL_OPERATOR constexpr auto operator()(_Ty&& _Val) _CONST_CALL_OPERATOR
            noexcept(noexcept(_RANGES rbegin(static_cast<_CTy&&>(_Val))))
            requires requires { _RANGES rbegin(static_cast<_CTy&&>(_Val)); }
        {
            return _RANGES rbegin(static_cast<_CTy&&>(_Val));
        }
#endif // ^^^ !_HAS_CXX23 ^^^
    };

    inline namespace _Cpos {
        _EXPORT_STD inline constexpr _Crbegin_fn crbegin;
    }

    struct _Crend_fn {
#if _HAS_CXX23
        template <class _Ty>
        using _Rend_on_const = decltype(_RANGES rend(_RANGES _Possibly_const_range(_STD declval<_Ty&>())));

        template <_Should_range_access _Ty>
            requires requires(_Ty& _Val) {
            typename _Rend_on_const<_Ty>;
            typename const_sentinel<_Rend_on_const<_Ty>>;
            const_sentinel<_Rend_on_const<_Ty>>{_RANGES rend(_RANGES _Possibly_const_range(_Val))};
        }
        _NODISCARD _STATIC_CALL_OPERATOR constexpr auto operator()(_Ty&& _Val) _CONST_CALL_OPERATOR
            noexcept(noexcept(const_sentinel<_Rend_on_const<_Ty>>{_RANGES rend(_RANGES _Possibly_const_range(_Val))})) {
            return const_sentinel<_Rend_on_const<_Ty>>{_RANGES rend(_RANGES _Possibly_const_range(_Val))};
        }
#else // ^^^ _HAS_CXX23 / !_HAS_CXX23 vvv
        template <class _Ty, class _CTy = _Const_thru_ref<_Ty>>
        _NODISCARD _STATIC_CALL_OPERATOR constexpr auto operator()(_Ty&& _Val) _CONST_CALL_OPERATOR
            noexcept(noexcept(_RANGES rend(static_cast<_CTy&&>(_Val))))
            requires requires { _RANGES rend(static_cast<_CTy&&>(_Val)); }
        {
            return _RANGES rend(static_cast<_CTy&&>(_Val));
        }
#endif // ^^^ !_HAS_CXX23 ^^^
    };

    inline namespace _Cpos {
        _EXPORT_STD inline constexpr _Crend_fn crend;
    }

    _EXPORT_STD template <class>
        inline constexpr bool disable_sized_range = false;

    namespace _Size {
#if defined(__clang__) || defined(__EDG__) // TRANSITION, VSO-1681199
        void size() = delete; // Block unqualified name lookup
#else // ^^^ no workaround / workaround vvv
        void size();
#endif // ^^^ workaround ^^^

        template <class _Ty, class _UnCV>
        concept _Has_member = !disable_sized_range<_UnCV> && requires(_Ty __t) {
            { _STD _Fake_copy_init(__t.size()) } -> _Integer_like;
        };

        template <class _Ty, class _UnCV>
        concept _Has_ADL = _Has_class_or_enum_type<_Ty> && !disable_sized_range<_UnCV> && requires(_Ty __t) {
            { _STD _Fake_copy_init(size(__t)) } -> _Integer_like; // intentional ADL
        };

        template <class _Ty>
        concept _Can_difference = requires(_Ty __t) {
            { _RANGES begin(__t) } -> forward_iterator;
            { _RANGES end(__t) } -> sized_sentinel_for<decltype(_RANGES begin(__t))>;
        };

        class _Cpo {
        private:
            enum class _St { _None, _Array, _Member, _Non_member, _Subtract };

            template <class _Ty>
            _NODISCARD static consteval _Choice_t<_St> _Choose() noexcept {
                _STL_INTERNAL_STATIC_ASSERT(is_lvalue_reference_v<_Ty>);
                using _UnCV = remove_cvref_t<_Ty>;

                if constexpr (is_array_v<_UnCV>) {
                    if constexpr (extent_v<_UnCV> != 0) {
                        return { _St::_Array, true };
                    }
                    else {
                        return { _St::_None };
                    }
                }
                else if constexpr (_Has_member<_Ty, _UnCV>) {
                    return { _St::_Member, noexcept(_STD _Fake_copy_init(_STD declval<_Ty>().size())) };
                }
                else if constexpr (_Has_ADL<_Ty, _UnCV>) {
                    return {
                        _St::_Non_member, noexcept(_STD _Fake_copy_init(size(_STD declval<_Ty>()))) }; // intentional ADL
                }
                else if constexpr (_Can_difference<_Ty>) {
                    return { _St::_Subtract,
                        noexcept(_RANGES end(_STD declval<_Ty>()) - _RANGES begin(_STD declval<_Ty>())) };
                }
                else {
                    return { _St::_None };
                }
            }

            template <class _Ty>
            static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();

        public:
            template <class _Ty>
                requires (_Choice<_Ty&>._Strategy != _St::_None)
            _NODISCARD _STATIC_CALL_OPERATOR constexpr auto operator()(_Ty&& _Val) _CONST_CALL_OPERATOR
                noexcept(_Choice<_Ty&>._No_throw) {
                constexpr _St _Strat = _Choice<_Ty&>._Strategy;

                if constexpr (_Strat == _St::_Array) {
                    // extent_v<remove_cvref_t<_Ty&>> reuses specializations from _Choose
                    return extent_v<remove_cvref_t<_Ty&>>;
                }
                else if constexpr (_Strat == _St::_Member) {
                    return _Val.size();
                }
                else if constexpr (_Strat == _St::_Non_member) {
                    return size(_Val); // intentional ADL
                }
                else if constexpr (_Strat == _St::_Subtract) {
                    const auto _Delta = _RANGES end(_Val) - _RANGES begin(_Val);
                    return static_cast<_Make_unsigned_like_t<remove_cv_t<decltype(_Delta)>>>(_Delta);
                }
                else {
                    static_assert(_Always_false<_Ty>, "should be unreachable");
                }
            }
        };
    } // namespace _Size

    inline namespace _Cpos {
        _EXPORT_STD inline constexpr _Size::_Cpo size;
    }

    namespace _Empty {
        template <class _Ty>
        concept _Has_member = requires(_Ty __t) { static_cast<bool>(__t.empty()); };

        template <class _Ty>
        concept _Has_size = requires(_Ty __t) { _RANGES size(__t); };

        template <class _Ty>
        concept _Can_begin_end = requires(_Ty __t) {
            { _RANGES begin(__t) } -> forward_iterator;
            _RANGES end(__t);
        };

        class _Cpo {
        private:
            enum class _St { _None, _Member, _Size, _Compare };

            template <class _Ty>
            _NODISCARD static consteval _Choice_t<_St> _Choose() noexcept {
                _STL_INTERNAL_STATIC_ASSERT(is_lvalue_reference_v<_Ty>);
                if constexpr (is_unbounded_array_v<remove_reference_t<_Ty>>) {
                    return { _St::_None };
                }
                else if constexpr (_Has_member<_Ty>) {
                    return { _St::_Member, noexcept(static_cast<bool>(_STD declval<_Ty>().empty())) };
                }
                else if constexpr (_Has_size<_Ty>) {
                    return { _St::_Size, noexcept(_RANGES size(_STD declval<_Ty>())) };
                }
                else if constexpr (_Can_begin_end<_Ty>) {
                    constexpr auto _Nothrow = noexcept(
                        static_cast<bool>(_RANGES begin(_STD declval<_Ty>()) == _RANGES end(_STD declval<_Ty>())));
                    return { _St::_Compare, _Nothrow };
                }
                else {
                    return { _St::_None };
                }
            }

            template <class _Ty>
            static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();

        public:
            template <class _Ty>
                requires (_Choice<_Ty&>._Strategy != _St::_None)
            _NODISCARD _STATIC_CALL_OPERATOR constexpr bool operator()(_Ty&& _Val) _CONST_CALL_OPERATOR
                noexcept(_Choice<_Ty&>._No_throw) {
                constexpr _St _Strat = _Choice<_Ty&>._Strategy;

                if constexpr (_Strat == _St::_Member) {
                    return static_cast<bool>(_Val.empty());
                }
                else if constexpr (_Strat == _St::_Size) {
                    return _RANGES size(_Val) == 0;
                }
                else if constexpr (_Strat == _St::_Compare) {
                    return static_cast<bool>(_RANGES begin(_Val) == _RANGES end(_Val));
                }
                else {
                    static_assert(_Always_false<_Ty>, "should be unreachable");
                }
            }
        };
    } // namespace _Empty

    inline namespace _Cpos {
        _EXPORT_STD inline constexpr _Empty::_Cpo empty;
    }

    namespace _Data {
        template <class _Ty>
        concept _Points_to_object = is_pointer_v<_Ty> && is_object_v<remove_pointer_t<_Ty>>;

        template <class _Ty>
        concept _Has_member = requires(_Ty __t) {
            { _STD _Fake_copy_init(__t.data()) } -> _Points_to_object;
        };

        template <class _Ty>
        concept _Has_contiguous_iterator = requires(_Ty __t) {
            { _RANGES begin(__t) } -> contiguous_iterator;
        };

        class _Cpo {
        private:
            enum class _St { _None, _Member, _Address };

            template <class _Ty>
            _NODISCARD static consteval _Choice_t<_St> _Choose() noexcept {
                _STL_INTERNAL_STATIC_ASSERT(is_lvalue_reference_v<_Ty>);
                if constexpr (_Has_member<_Ty>) {
                    return { _St::_Member, noexcept(_STD declval<_Ty>().data()) };
                }
                else if constexpr (_Has_contiguous_iterator<_Ty>) {
                    return { _St::_Address, noexcept(_STD to_address(_RANGES begin(_STD declval<_Ty>()))) };
                }
                else {
                    return { _St::_None };
                }
            }

            template <class _Ty>
            static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();

        public:
            template <_Should_range_access _Ty>
                requires (_Choice<_Ty&>._Strategy != _St::_None)
            _NODISCARD _STATIC_CALL_OPERATOR constexpr auto operator()(_Ty&& _Val) _CONST_CALL_OPERATOR
                noexcept(_Choice<_Ty&>._No_throw) {
                constexpr _St _Strat = _Choice<_Ty&>._Strategy;

                if constexpr (_Strat == _St::_Member) {
                    return _Val.data();
                }
                else if constexpr (_Strat == _St::_Address) {
                    return _STD to_address(_RANGES begin(_Val));
                }
                else {
                    static_assert(_Always_false<_Ty>, "should be unreachable");
                }
            }
        };
    } // namespace _Data

    inline namespace _Cpos {
        _EXPORT_STD inline constexpr _Data::_Cpo data;
    }

    struct _Cdata_fn {
#if _HAS_CXX23
        template <_Should_range_access _Ty>
            requires requires(_Ty& _Val) { //
            _RANGES _As_const_pointer(_RANGES data(_RANGES _Possibly_const_range(_Val)));
        }
        _NODISCARD _STATIC_CALL_OPERATOR constexpr auto operator()(_Ty&& _Val) _CONST_CALL_OPERATOR
            noexcept(noexcept(_RANGES data(_RANGES _Possibly_const_range(_Val)))) {
            return _RANGES _As_const_pointer(_RANGES data(_RANGES _Possibly_const_range(_Val)));
        }
#else // ^^^ _HAS_CXX23 / !_HAS_CXX23 vvv
        template <class _Ty, class _CTy = _Const_thru_ref<_Ty>>
        _NODISCARD _STATIC_CALL_OPERATOR constexpr auto operator()(_Ty&& _Val) _CONST_CALL_OPERATOR
            noexcept(noexcept(_RANGES data(static_cast<_CTy&&>(_Val))))
            requires requires { _RANGES data(static_cast<_CTy&&>(_Val)); }
        {
            return _RANGES data(static_cast<_CTy&&>(_Val));
        }
#endif // ^^^ !_HAS_CXX23 ^^^
    };

    inline namespace _Cpos {
        _EXPORT_STD inline constexpr _Cdata_fn cdata;
    }

    _EXPORT_STD template <class _Rng>
        concept sized_range = range<_Rng> && requires(_Rng & __r) { _RANGES size(__r); };

    _EXPORT_STD template <sized_range _Rng>
        using range_size_t = decltype(_RANGES size(_STD declval<_Rng&>()));

    _EXPORT_STD struct view_base {};

    template <class _Ty, template <class...> class _Template>
    concept _Strictly_derived_from_specialization_of =
        is_object_v<_Ty> && _Derived_from_specialization_of<_Ty, _Template>;

    _EXPORT_STD template <class _Derived>
        requires is_class_v<_Derived>&& same_as<_Derived, remove_cv_t<_Derived>>
    class view_interface;

    _EXPORT_STD template <class _Ty>
        inline constexpr bool enable_view =
        derived_from<_Ty, view_base> || _Strictly_derived_from_specialization_of<_Ty, view_interface>;

    _EXPORT_STD template <class _Ty>
        concept view = range<_Ty> && movable<_Ty> && enable_view<_Ty>;

    _EXPORT_STD template <class _Rng, class _Ty>
        concept output_range = range<_Rng> && output_iterator<iterator_t<_Rng>, _Ty>;

    _EXPORT_STD template <class _Rng>
        concept forward_range = range<_Rng> && forward_iterator<iterator_t<_Rng>>;

    _EXPORT_STD template <class _Rng>
        concept bidirectional_range = range<_Rng> && bidirectional_iterator<iterator_t<_Rng>>;

    _EXPORT_STD template <class _Rng>
        concept random_access_range = range<_Rng> && random_access_iterator<iterator_t<_Rng>>;

    _EXPORT_STD template <class _Rng>
        concept contiguous_range = range<_Rng> && contiguous_iterator<iterator_t<_Rng>> && requires(_Rng & __r) {
            { _RANGES data(__r) } -> same_as<add_pointer_t<range_reference_t<_Rng>>>;
    };

    class _Advance_fn {
    public:
        template <input_or_output_iterator _It>
        _STATIC_CALL_OPERATOR constexpr void operator()(_It& _Where, iter_difference_t<_It> _Off) _CONST_CALL_OPERATOR {
            if constexpr (random_access_iterator<_It>) {
                _Where += _Off;
            }
            else {
                if constexpr (!bidirectional_iterator<_It>) {
                    _STL_ASSERT(_Off >= 0, "negative advance of non-bidirectional iterator");
                }

                decltype(auto) _UWhere = _STD _Get_unwrapped_n(_STD move(_Where), _Off);
                constexpr bool _Need_rewrap = !is_reference_v<decltype(_STD _Get_unwrapped_n(_STD move(_Where), _Off))>;

                if constexpr (bidirectional_iterator<_It>) {
                    for (; _Off < 0; ++_Off) {
                        --_UWhere;
                    }
                }

                for (; _Off > 0; --_Off) {
                    ++_UWhere;
                }

                if constexpr (_Need_rewrap) {
                    _STD _Seek_wrapped(_Where, _STD move(_UWhere));
                }
            }
        }

        template <input_or_output_iterator _It, sentinel_for<_It> _Se>
        _STATIC_CALL_OPERATOR constexpr void operator()(_It& _Where, _Se _Last) _CONST_CALL_OPERATOR {
            if constexpr (assignable_from<_It&, _Se>) {
                _Where = static_cast<_Se&&>(_Last);
            }
            else if constexpr (sized_sentinel_for<_Se, _It>) {
                operator()(_Where, _Last - _Where);
            }
            else {
                _STD _Adl_verify_range(_Where, _Last);

                decltype(auto) _UWhere = _RANGES _Unwrap_iter<_Se>(static_cast<_It&&>(_Where));
                constexpr bool _Need_rewrap =
                    !is_reference_v<decltype(_RANGES _Unwrap_iter<_Se>(static_cast<_It&&>(_Where)))>;
                decltype(auto) _ULast = _RANGES _Unwrap_sent<_It>(static_cast<_Se&&>(_Last));

                while (_UWhere != _ULast) {
                    ++_UWhere;
                }

                if constexpr (_Need_rewrap) {
                    _STD _Seek_wrapped(_Where, _STD move(_UWhere));
                }
            }
        }

        template <input_or_output_iterator _It, sentinel_for<_It> _Se>
        _STATIC_CALL_OPERATOR constexpr iter_difference_t<_It> operator()(
            _It& _Where, iter_difference_t<_It> _Off, _Se _Last) _CONST_CALL_OPERATOR {
            if constexpr (sized_sentinel_for<_Se, _It>) {
                const iter_difference_t<_It> _Delta = _Last - _Where;
                if ((_Off < 0 && _Off <= _Delta) || (_Off > 0 && _Off >= _Delta)) {
                    if constexpr (assignable_from<_It&, _Se>) {
                        _Where = static_cast<_Se&&>(_Last);
                    }
                    else {
                        operator()(_Where, _Delta);
                    }
                    return _Off - _Delta;
                }

                operator()(_Where, _Off);
                return 0;
            }
            else {
                // performance note: develop unwrapping technology for (i, n, s)?
                if constexpr (bidirectional_iterator<_It>) {
                    for (; _Off < 0 && _Where != _Last; ++_Off) {
                        --_Where;
                    }
                }
                else {
                    _STL_ASSERT(_Off >= 0, "negative advance of non-bidirectional iterator");
                }

                for (; _Off > 0 && _Where != _Last; --_Off) {
                    ++_Where;
                }

                return _Off;
            }
        }
    };

    _EXPORT_STD inline constexpr _Advance_fn advance;

    class _Distance_fn {
    public:
        template <class _It, sentinel_for<_It> _Se>
            requires (!sized_sentinel_for<_Se, _It>)
        _NODISCARD _STATIC_CALL_OPERATOR constexpr iter_difference_t<_It> operator()(
            _It _First, _Se _Last) _CONST_CALL_OPERATOR
            noexcept(noexcept(_Distance_unchecked(
                _STD _Get_unwrapped(_STD move(_First)), _STD _Get_unwrapped(_STD move(_Last))))) /* strengthened */ {
            _STD _Adl_verify_range(_First, _Last);
            return _Distance_unchecked(
                _RANGES _Unwrap_iter<_Se>(_STD move(_First)), _RANGES _Unwrap_sent<_It>(_STD move(_Last)));
        }

        template <class _It, sized_sentinel_for<decay_t<_It>> _Se>
        _NODISCARD _STATIC_CALL_OPERATOR constexpr iter_difference_t<decay_t<_It>> operator()(
            _It&& _First, const _Se _Last) _CONST_CALL_OPERATOR
            noexcept(noexcept(_Last - static_cast<const decay_t<_It>&>(_First))) /* strengthened */ {
            return _Last - static_cast<const decay_t<_It>&>(_First);
        }

        template <range _Rng>
        _NODISCARD _STATIC_CALL_OPERATOR constexpr range_difference_t<_Rng> operator()(
            _Rng&& _Range) _CONST_CALL_OPERATOR noexcept(_Nothrow_size<_Rng>) /* strengthened */ {
            if constexpr (sized_range<_Rng>) {
                return static_cast<range_difference_t<_Rng>>(_RANGES size(_Range));
            }
            else {
                return _Distance_unchecked(_Ubegin(_Range), _Uend(_Range));
            }
        }

    private:
        template <class _It, class _Se>
        _NODISCARD static constexpr iter_difference_t<_It> _Distance_unchecked(_It _First, const _Se _Last) noexcept(
            noexcept(++_First != _Last)) {
            _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se, _It>);

            iter_difference_t<_It> _Count = 0;
            for (; _First != _Last; ++_First) {
                ++_Count;
            }

            return _Count;
        }

        template <class _Rng>
        static constexpr bool _Nothrow_size =
            noexcept(_Distance_unchecked(_Ubegin(_STD declval<_Rng&>()), _Uend(_STD declval<_Rng&>())));

        template <sized_range _Rng>
        static constexpr bool _Nothrow_size<_Rng> = noexcept(_RANGES size(_STD declval<_Rng&>()));
    };

    _EXPORT_STD inline constexpr _Distance_fn distance;

    class _Ssize_fn {
    public:
        template <class _Rng>
        _NODISCARD _STATIC_CALL_OPERATOR constexpr auto operator()(_Rng&& _Range) _CONST_CALL_OPERATOR
            noexcept(noexcept(_RANGES size(_Range)))
            requires requires { _RANGES size(_Range); }
        {
            using _Sty = _Make_signed_like_t<decltype(_RANGES size(_Range))>;
            using _Ty = common_type_t<conditional_t<is_integral_v<_Sty>, ptrdiff_t, _Sty>, _Sty>;
            return static_cast<_Ty>(_RANGES size(_Range));
        }
    };

    inline namespace _Cpos {
        _EXPORT_STD inline constexpr _Ssize_fn ssize;
    }

    class _Next_fn {
    public:
        template <input_or_output_iterator _It>
        _NODISCARD _STATIC_CALL_OPERATOR constexpr _It operator()(_It _Where) _CONST_CALL_OPERATOR {
            ++_Where;
            return _Where;
        }

        template <input_or_output_iterator _It>
        _NODISCARD _STATIC_CALL_OPERATOR constexpr _It operator()(
            _It _Where, const iter_difference_t<_It> _Off) _CONST_CALL_OPERATOR {
            _RANGES advance(_Where, _Off);
            return _Where;
        }

        template <input_or_output_iterator _It, sentinel_for<_It> _Se>
        _NODISCARD _STATIC_CALL_OPERATOR constexpr _It operator()(_It _Where, _Se _Last) _CONST_CALL_OPERATOR {
            _RANGES advance(_Where, static_cast<_Se&&>(_Last));
            return _Where;
        }

        template <input_or_output_iterator _It, sentinel_for<_It> _Se>
        _NODISCARD _STATIC_CALL_OPERATOR constexpr _It operator()(
            _It _Where, const iter_difference_t<_It> _Off, _Se _Last) _CONST_CALL_OPERATOR {
            _RANGES advance(_Where, _Off, static_cast<_Se&&>(_Last));
            return _Where;
        }
    };

    _EXPORT_STD inline constexpr _Next_fn next;

    class _Prev_fn {
    public:
        template <bidirectional_iterator _It>
        _NODISCARD _STATIC_CALL_OPERATOR constexpr _It operator()(_It _Where) _CONST_CALL_OPERATOR {
            --_Where;
            return _Where;
        }

        template <bidirectional_iterator _It>
        _NODISCARD _STATIC_CALL_OPERATOR constexpr _It operator()(
            _It _Where, const iter_difference_t<_It> _Off) _CONST_CALL_OPERATOR {
            _STL_ASSERT(_Off != _Min_possible_v<iter_difference_t<_It>>, "integer overflow");
            _RANGES advance(_Where, -_Off);
            return _Where;
        }

        template <bidirectional_iterator _It>
        _NODISCARD _STATIC_CALL_OPERATOR constexpr _It operator()(
            _It _Where, const iter_difference_t<_It> _Off, _It _Last) _CONST_CALL_OPERATOR {
            _STL_ASSERT(_Off != _Min_possible_v<iter_difference_t<_It>>, "integer overflow");
            _RANGES advance(_Where, -_Off, static_cast<_It&&>(_Last));
            return _Where;
        }
    };

    _EXPORT_STD inline constexpr _Prev_fn prev;

    template <forward_iterator _It, sentinel_for<_It> _Se>
    _NODISCARD constexpr _It _Find_last_iterator(
        const _It& _First, const _Se& _Last, const iter_difference_t<_It> _Count) {
        // Find the iterator in [_First, _Last) (of length _Count) which equals _Last
        _STL_INTERNAL_CHECK(_RANGES distance(_First, _Last) == _Count);
        if constexpr (is_same_v<_It, _Se>) {
            return _Last;
        }
        else {
            return _RANGES next(_First, _Count);
        }
    }

    _EXPORT_STD struct equal_to {
        template <class _Ty1, class _Ty2>
            requires equality_comparable_with<_Ty1, _Ty2>
        _NODISCARD constexpr bool operator()(_Ty1&& _Left, _Ty2&& _Right) const noexcept(
            noexcept(static_cast<bool>(static_cast<_Ty1&&>(_Left) == static_cast<_Ty2&&>(_Right)))) /* strengthened */ {
            return static_cast<bool>(static_cast<_Ty1&&>(_Left) == static_cast<_Ty2&&>(_Right));
        }

        using is_transparent = int;
    };

    _EXPORT_STD struct less {
        template <class _Ty1, class _Ty2>
            requires totally_ordered_with<_Ty1, _Ty2>
        _NODISCARD constexpr bool operator()(_Ty1&& _Left, _Ty2&& _Right) const noexcept(
            noexcept(static_cast<bool>(static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right)))) /* strengthened */ {
            return static_cast<bool>(static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right));
        }

        using is_transparent = int;
    };

    _EXPORT_STD struct greater {
        template <class _Ty1, class _Ty2>
            requires totally_ordered_with<_Ty1, _Ty2>
        _NODISCARD constexpr bool operator()(_Ty1&& _Left, _Ty2&& _Right) const noexcept(
            noexcept(static_cast<bool>(static_cast<_Ty2&&>(_Right) < static_cast<_Ty1&&>(_Left)))) /* strengthened */ {
            return static_cast<bool>(static_cast<_Ty2&&>(_Right) < static_cast<_Ty1&&>(_Left));
        }

        using is_transparent = int;
    };

    _EXPORT_STD template <class _Rng>
        concept common_range = range<_Rng> && same_as<iterator_t<_Rng>, sentinel_t<_Rng>>;

    template <class _It, class _Se>
    concept _Bidi_common = is_same_v<_It, _Se>&& bidirectional_iterator<_It>;
    template <class _Rng>
    concept _Bidi_common_range = common_range<_Rng> && bidirectional_iterator<iterator_t<_Rng>>;

    template <class _Ty>
    concept _Can_empty = requires(_Ty __t) { _RANGES empty(__t); };

    _EXPORT_STD template <class _Derived>
        requires is_class_v<_Derived>&& same_as<_Derived, remove_cv_t<_Derived>>
    class view_interface {
    private:
        _NODISCARD constexpr _Derived& _Cast() noexcept {
            static_assert(derived_from<_Derived, view_interface>,
                "view_interface's template argument D must derive from view_interface<D> "
                "(N4950 [view.interface.general]/2).");
            static_assert(view<_Derived>,
                "view_interface's template argument must model the view concept (N4950 [view.interface.general]/2).");
            return static_cast<_Derived&>(*this);
        }

        _NODISCARD constexpr const _Derived& _Cast() const noexcept {
            static_assert(derived_from<_Derived, view_interface>,
                "view_interface's template argument D must derive from view_interface<D> "
                "(N4950 [view.interface.general]/2).");
            static_assert(view<_Derived>,
                "view_interface's template argument must model the view concept (N4950 [view.interface.general]/2).");
            return static_cast<const _Derived&>(*this);
        }

    public:
        _NODISCARD constexpr bool empty()
            requires sized_range<_Derived> || forward_range<_Derived>
        {
            auto& _Self = _Cast();
            if constexpr (sized_range<_Derived>) {
                return _RANGES size(_Self) == 0;
            }
            else {
                return _RANGES begin(_Self) == _RANGES end(_Self);
            }
        }

        _NODISCARD constexpr bool empty() const
            requires sized_range<const _Derived> || forward_range<const _Derived>
        {
            auto& _Self = _Cast();
            if constexpr (sized_range<const _Derived>) {
                return _RANGES size(_Self) == 0;
            }
            else {
                return _RANGES begin(_Self) == _RANGES end(_Self);
            }
        }

#if _HAS_CXX23
        _NODISCARD constexpr auto cbegin()
            requires input_range<_Derived>
        {
            return _RANGES cbegin(_Cast());
        }

        _NODISCARD constexpr auto cbegin() const
            requires input_range<const _Derived>
        {
            return _RANGES cbegin(_Cast());
        }

        _NODISCARD constexpr auto cend()
            requires input_range<_Derived>
        {
            return _RANGES cend(_Cast());
        }

        _NODISCARD constexpr auto cend() const
            requires input_range<const _Derived>
        {
            return _RANGES cend(_Cast());
        }
#endif // _HAS_CXX23

        constexpr explicit operator bool()
            requires _Can_empty<_Derived>
        {
            return !_RANGES empty(_Cast());
        }

        constexpr explicit operator bool() const
            requires _Can_empty<const _Derived>
        {
            return !_RANGES empty(_Cast());
        }

        _NODISCARD constexpr auto data()
            requires contiguous_iterator<iterator_t<_Derived>>
        {
            return _STD to_address(_RANGES begin(_Cast()));
        }

        _NODISCARD constexpr auto data() const
            requires range<const _Derived>&& contiguous_iterator<iterator_t<const _Derived>>
        {
            return _STD to_address(_RANGES begin(_Cast()));
        }

        _NODISCARD constexpr auto size()
            requires forward_range<_Derived>&& sized_sentinel_for<sentinel_t<_Derived>, iterator_t<_Derived>>
        {
            auto& _Self = _Cast();
            return _STD _To_unsigned_like(_RANGES end(_Self) - _RANGES begin(_Self));
        }

        _NODISCARD constexpr auto size() const
            requires forward_range<const _Derived>
        && sized_sentinel_for<sentinel_t<const _Derived>, iterator_t<const _Derived>>
        {
            auto& _Self = _Cast();
            return _STD _To_unsigned_like(_RANGES end(_Self) - _RANGES begin(_Self));
        }

        _NODISCARD constexpr decltype(auto) front()
            requires forward_range<_Derived>
        {
            auto& _Self = _Cast();
#if _CONTAINER_DEBUG_LEVEL > 0
            _STL_VERIFY(!_RANGES empty(_Self), "front called on empty view_interface");
#endif // _CONTAINER_DEBUG_LEVEL > 0
            return *_RANGES begin(_Self);
        }

        _NODISCARD constexpr decltype(auto) front() const
            requires forward_range<const _Derived>
        {
            auto& _Self = _Cast();
#if _CONTAINER_DEBUG_LEVEL > 0
            _STL_VERIFY(!_RANGES empty(_Self), "front called on empty view_interface");
#endif // _CONTAINER_DEBUG_LEVEL > 0
            return *_RANGES begin(_Self);
        }

        _NODISCARD constexpr decltype(auto) back()
            requires bidirectional_range<_Derived>&& common_range<_Derived>
        {
            auto& _Self = _Cast();
#if _CONTAINER_DEBUG_LEVEL > 0
            _STL_VERIFY(!_RANGES empty(_Self), "back called on empty view_interface");
#endif // _CONTAINER_DEBUG_LEVEL > 0
            auto _Last = _RANGES end(_Self);
            return *--_Last;
        }

        _NODISCARD constexpr decltype(auto) back() const
            requires bidirectional_range<const _Derived>&& common_range<const _Derived>
        {
            auto& _Self = _Cast();
#if _CONTAINER_DEBUG_LEVEL > 0
            _STL_VERIFY(!_RANGES empty(_Self), "back called on empty view_interface");
#endif // _CONTAINER_DEBUG_LEVEL > 0
            auto _Last = _RANGES end(_Self);
            return *--_Last;
        }

        template <random_access_range _Rng = _Derived>
        _NODISCARD constexpr decltype(auto) operator[](const range_difference_t<_Rng> _Idx) {
            auto& _Self = _Cast();
#if _CONTAINER_DEBUG_LEVEL > 0
            if constexpr (sized_range<_Derived>) {
                using _U_diff = _Make_unsigned_like_t<range_difference_t<_Rng>>;
                _STL_VERIFY(static_cast<_U_diff>(_Idx) < static_cast<_U_diff>(_RANGES size(_Self)),
                    "index out of range for view_interface");
            }
#endif // _CONTAINER_DEBUG_LEVEL > 0
            return _RANGES begin(_Self)[_Idx];
        }

        template <random_access_range _Rng = const _Derived>
        _NODISCARD constexpr decltype(auto) operator[](const range_difference_t<_Rng> _Idx) const {
            auto& _Self = _Cast();
#if _CONTAINER_DEBUG_LEVEL > 0
            if constexpr (sized_range<_Derived>) {
                using _U_diff = _Make_unsigned_like_t<range_difference_t<_Rng>>;
                _STL_VERIFY(static_cast<_U_diff>(_Idx) < static_cast<_U_diff>(_RANGES size(_Self)),
                    "index out of range for view_interface");
            }
#endif // _CONTAINER_DEBUG_LEVEL > 0
            return _RANGES begin(_Self)[_Idx];
        }
    };
} // namespace ranges

namespace ranges {
    template <class _From, class _To>
    concept _Uses_nonqualification_pointer_conversion =
        is_pointer_v<_From> && is_pointer_v<_To>
        && !convertible_to<remove_pointer_t<_From>(*)[], remove_pointer_t<_To>(*)[]>;

    template <class _From, class _To>
    concept _Convertible_to_non_slicing =
        convertible_to<_From, _To> && !_Uses_nonqualification_pointer_conversion<decay_t<_From>, decay_t<_To>>;

#if !_HAS_CXX23
    template <class _Ty>
    concept _Pair_like = !is_reference_v<_Ty> && requires(_Ty __t) {
        typename tuple_size<_Ty>::type;
        requires derived_from<tuple_size<_Ty>, integral_constant<size_t, 2>>;
        typename tuple_element_t<0, remove_const_t<_Ty>>;
        typename tuple_element_t<1, remove_const_t<_Ty>>;
        { _STD get<0>(__t) } -> convertible_to<const tuple_element_t<0, _Ty>&>;
        { _STD get<1>(__t) } -> convertible_to<const tuple_element_t<1, _Ty>&>;
    };
#endif // !_HAS_CXX23

    template <class _Ty, class _First, class _Second>
    concept _Pair_like_convertible_from = !range<_Ty>
#if _HAS_CXX23
        && !is_reference_v<_Ty>
#endif // _HAS_CXX23
        && _Pair_like<_Ty> && constructible_from<_Ty, _First, _Second>
        && _Convertible_to_non_slicing<_First, tuple_element_t<0, _Ty>>
        && convertible_to<_Second, tuple_element_t<1, _Ty>>;

    template <class _It, class _Se, subrange_kind _Ki>
    concept _Store_size = (_Ki == subrange_kind::sized) && !sized_sentinel_for<_Se, _It>;

    template <class _It, class _Se, subrange_kind _Ki>
    class _Subrange_base : public view_interface<subrange<_It, _Se, _Ki>> {
    protected:
        using _Size_type = _Make_unsigned_like_t<iter_difference_t<_It>>;

    public:
        _Subrange_base() = default;
        constexpr explicit _Subrange_base(const _Size_type&) noexcept {}
    };

    template <class _It, class _Se, subrange_kind _Ki>
        requires _Store_size<_It, _Se, _Ki>
    class _Subrange_base<_It, _Se, _Ki> : public view_interface<subrange<_It, _Se, _Ki>> {
    protected:
        using _Size_type = _Make_unsigned_like_t<iter_difference_t<_It>>;

        _Size_type _Size = 0;

    public:
        _Subrange_base() = default;
        constexpr explicit _Subrange_base(const _Size_type& _Size_) noexcept : _Size(_Size_) {}
    };

    _EXPORT_STD template <input_or_output_iterator _It, sentinel_for<_It> _Se, subrange_kind _Ki>
        requires (_Ki == subrange_kind::sized || !sized_sentinel_for<_Se, _It>)
    class subrange : public _Subrange_base<_It, _Se, _Ki> {
    private:
        using _Size_type = _Make_unsigned_like_t<iter_difference_t<_It>>;

        // TRANSITION, [[no_unique_address]]:
        /* [[no_unique_address]] */ _It _First{};
        /* [[no_unique_address]] */ _Se _Last{};
        // [[no_unique_address]] conditional_t<_Store_size<_It, _Se, _Ki>, _Size_type, _Nil> _Size{};

        template <class _Rng>
        constexpr subrange(true_type, _Rng&& _Val)
            : subrange(_STD forward<_Rng>(_Val), static_cast<_Size_type>(_RANGES size(_Val))) {
            // delegation target for subrange(_Rng&&) when we must store the range size
            _STL_INTERNAL_STATIC_ASSERT(_Store_size<_It, _Se, _Ki>);
        }

        template <class _Rng>
        constexpr subrange(false_type, _Rng&& _Val) : subrange(_RANGES begin(_Val), _RANGES end(_Val)) {
            // delegation target for subrange(_Rng&&) when we need not store the range size
            _STL_INTERNAL_STATIC_ASSERT(!_Store_size<_It, _Se, _Ki>);
        }

    public:
        // clang-format off
        subrange() requires default_initializable<_It> = default;
        // clang-format on

        template <_Convertible_to_non_slicing<_It> _It2>
        constexpr subrange(_It2 _First_, _Se _Last_)
            requires (!_Store_size<_It, _Se, _Ki>)
        : _First(_STD move(_First_)), _Last(_STD move(_Last_)) {}

        template <_Convertible_to_non_slicing<_It> _It2>
        constexpr subrange(_It2 _First_, _Se _Last_, const _Size_type _Size_)
            requires (_Ki == subrange_kind::sized)
        : _Subrange_base<_It, _Se, _Ki>(_Size_), _First(_STD move(_First_)), _Last(_STD move(_Last_)) {
            if constexpr (sized_sentinel_for<_Se, _It>) {
                _STL_ASSERT(_Size_ == static_cast<_Size_type>(_Last - _First),
                    "This constructor's third argument should be equal to the distance "
                    "between the first and second arguments (N4950 [range.subrange.ctor]/3).");
            }
        }

        template <_Different_from<subrange> _Rng>
            requires (borrowed_range<_Rng>&& _Convertible_to_non_slicing<iterator_t<_Rng>, _It>
        && convertible_to<sentinel_t<_Rng>, _Se>)
            constexpr subrange(_Rng&& _Val)
            requires (!_Store_size<_It, _Se, _Ki> || sized_range<_Rng>)
        : subrange{ bool_constant<_Store_size<_It, _Se, _Ki>>{}, _STD forward<_Rng>(_Val) } {}

        template <borrowed_range _Rng>
            requires (_Convertible_to_non_slicing<iterator_t<_Rng>, _It>&& convertible_to<sentinel_t<_Rng>, _Se>)
        constexpr subrange(_Rng&& _Val, const _Size_type _Count)
            requires (_Ki == subrange_kind::sized)
        : subrange{ _RANGES begin(_Val), _RANGES end(_Val), _Count } {}

        template <_Different_from<subrange> _Pair_like>
            requires _Pair_like_convertible_from<_Pair_like, const _It&, const _Se&>
        constexpr operator _Pair_like() const {
            return _Pair_like(_First, _Last);
        }

        _NODISCARD constexpr _It begin() const
            requires copyable<_It>
        {
            return _First;
        }
        _NODISCARD constexpr _It begin()
            requires (!copyable<_It>)
        {
            return _STD move(_First);
        }

        _NODISCARD constexpr _Se end() const {
            return _Last;
        }

        _NODISCARD constexpr bool empty() const {
            return _First == _Last;
        }

        _NODISCARD constexpr _Size_type size() const
            requires (_Ki == subrange_kind::sized)
        {
            if constexpr (_Store_size<_It, _Se, _Ki>) {
                return this->_Size;
            }
            else {
                return static_cast<_Size_type>(_Last - _First);
            }
        }

        _NODISCARD constexpr subrange next() const&
            requires forward_iterator<_It>
        {
            auto _Tmp = *this;
            if (_Tmp._First != _Tmp._Last) {
                ++_Tmp._First;
                if constexpr (_Store_size<_It, _Se, _Ki>) {
                    --_Tmp._Size;
                }
            }
            return _Tmp;
        }
        _NODISCARD constexpr subrange next(const iter_difference_t<_It> _Count) const&
            requires forward_iterator<_It>
        {
            auto _Tmp = *this;
            _Tmp.advance(_Count);
            return _Tmp;
        }

        _NODISCARD constexpr subrange next()&& {
            if (_First != _Last) {
                ++_First;
                if constexpr (_Store_size<_It, _Se, _Ki>) {
                    --this->_Size;
                }
            }
            return _STD move(*this);
        }
        _NODISCARD constexpr subrange next(const iter_difference_t<_It> _Count)&& {
            advance(_Count);
            return _STD move(*this);
        }

        _NODISCARD constexpr subrange prev() const
            requires bidirectional_iterator<_It>
        {
            auto _Tmp = *this;
            --_Tmp._First;
            if constexpr (_Store_size<_It, _Se, _Ki>) {
                ++_Tmp._Size;
            }
            return _Tmp;
        }
        _NODISCARD constexpr subrange prev(const iter_difference_t<_It> _Count) const
            requires bidirectional_iterator<_It>
        {
            auto _Tmp = *this;
            _Tmp.advance(-_Count);
            return _Tmp;
        }

        constexpr subrange& advance(const iter_difference_t<_It> _Count) {
            if constexpr (bidirectional_iterator<_It>) {
                if (_Count < 0) {
                    _RANGES advance(_First, _Count);
                    if constexpr (_Store_size<_It, _Se, _Ki>) {
                        this->_Size += static_cast<_Size_type>(-_Count);
                    }
                    return *this;
                }
            }

            const auto _Remainder = _RANGES advance(_First, _Count, _Last);
            if constexpr (_Store_size<_It, _Se, _Ki>) {
                this->_Size -= static_cast<_Size_type>(_Count - _Remainder);
            }
            return *this;
        }
    };

    template <input_or_output_iterator _It, sentinel_for<_It> _Se>
    subrange(_It, _Se) -> subrange<_It, _Se>;

    template <input_or_output_iterator _It, sentinel_for<_It> _Se>
    subrange(_It, _Se, _Make_unsigned_like_t<iter_difference_t<_It>>) -> subrange<_It, _Se, subrange_kind::sized>;

    template <borrowed_range _Rng>
    subrange(_Rng&&) -> subrange<iterator_t<_Rng>, sentinel_t<_Rng>,
        (sized_range<_Rng> || sized_sentinel_for<sentinel_t<_Rng>, iterator_t<_Rng>>) ? subrange_kind::sized
        : subrange_kind::unsized>;

    template <borrowed_range _Rng>
    subrange(_Rng&&, _Make_unsigned_like_t<range_difference_t<_Rng>>)
        -> subrange<iterator_t<_Rng>, sentinel_t<_Rng>, subrange_kind::sized>;

    template <class _It, class _Se, subrange_kind _Ki>
    inline constexpr bool enable_borrowed_range<subrange<_It, _Se, _Ki>> = true;

    _EXPORT_STD template <size_t _Idx, class _It, class _Se, subrange_kind _Ki>
        requires ((_Idx == 0 && copyable<_It>) || _Idx == 1)
    _NODISCARD constexpr auto get(const subrange<_It, _Se, _Ki>& _Val) {
        if constexpr (_Idx == 0) {
            return _Val.begin();
        }
        else {
            return _Val.end();
        }
    }

    _EXPORT_STD template <size_t _Idx, class _It, class _Se, subrange_kind _Ki>
        requires (_Idx < 2)
    _NODISCARD constexpr auto get(subrange<_It, _Se, _Ki>&& _Val) {
        if constexpr (_Idx == 0) {
            return _Val.begin();
        }
        else {
            return _Val.end();
        }
    }

    _EXPORT_STD struct dangling {
        constexpr dangling() noexcept = default;
        template <class... _Args>
        constexpr dangling(_Args&&...) noexcept {}
    };

    _EXPORT_STD template <range _Rng>
        using borrowed_iterator_t = conditional_t<borrowed_range<_Rng>, iterator_t<_Rng>, dangling>;

    _EXPORT_STD template <range _Rng>
        using borrowed_subrange_t = conditional_t<borrowed_range<_Rng>, subrange<iterator_t<_Rng>>, dangling>;
} // namespace ranges
#endif // _HAS_CXX20

struct _Container_proxy;
struct _Iterator_base12;

struct _Default_sentinel {}; // empty struct to serve as the end of a range

#if _HAS_CXX20
_EXPORT_STD template <semiregular>
class move_sentinel;

template <class>
struct _Move_iterator_category {};

template <class _Iter>
    requires requires { typename _Iter_cat_t<_Iter>; }
struct _Move_iterator_category<_Iter> {
    using iterator_category = conditional_t<derived_from<_Iter_cat_t<_Iter>, random_access_iterator_tag>,
        random_access_iterator_tag, _Iter_cat_t<_Iter>>;
};
#else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
template <class _Iter>
struct _Move_iterator_category {
    using iterator_category = _Iter_cat_t<_Iter>;
};
#endif // ^^^ !_HAS_CXX20 ^^^

_EXPORT_STD template <class _Iter>
class move_iterator : public _Move_iterator_category<_Iter> {
private:
    _Iter _Current{};

public:
    using iterator_type = _Iter;
    using value_type = _Iter_value_t<_Iter>;
    using difference_type = _Iter_diff_t<_Iter>;
    using pointer = _Iter;

#if _HAS_CXX20
private:
    static constexpr auto _Get_iter_concept() {
        if constexpr (random_access_iterator<_Iter>) {
            return random_access_iterator_tag{};
        }
        else if constexpr (bidirectional_iterator<_Iter>) {
            return bidirectional_iterator_tag{};
        }
        else if constexpr (forward_iterator<_Iter>) {
            return forward_iterator_tag{};
        }
        else {
            return input_iterator_tag{};
        }
    }

public:
    using iterator_concept = decltype(_Get_iter_concept());

    using reference = iter_rvalue_reference_t<_Iter>;
#else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
    using reference =
        conditional_t<is_reference_v<_Iter_ref_t<_Iter>>, remove_reference_t<_Iter_ref_t<_Iter>>&&, _Iter_ref_t<_Iter>>;
#endif // ^^^ !_HAS_CXX20 ^^^

    _CONSTEXPR17 move_iterator() = default;

    _CONSTEXPR17 explicit move_iterator(_Iter _Right) noexcept(is_nothrow_move_constructible_v<_Iter>) // strengthened
        : _Current(_STD move(_Right)) {}

    template <class _Other>
#if _HAS_CXX20
        requires (!is_same_v<_Other, _Iter>) && convertible_to<const _Other&, _Iter>
#endif // _HAS_CXX20
    _CONSTEXPR17 move_iterator(const move_iterator<_Other>& _Right) noexcept(
        is_nothrow_constructible_v<_Iter, const _Other&>) // strengthened
        : _Current(_Right.base()) {
    }

    template <class _Other>
#if _HAS_CXX20
        requires (!is_same_v<_Other, _Iter>)
    && convertible_to<const _Other&, _Iter>&& assignable_from<_Iter&, const _Other&>
#endif // _HAS_CXX20
        _CONSTEXPR17 move_iterator& operator=(const move_iterator<_Other>& _Right) noexcept(
            is_nothrow_assignable_v<_Iter&, const _Other&>) /* strengthened */ {
        _Current = _Right.base();
        return *this;
    }

#if _HAS_CXX20
    _NODISCARD constexpr const iterator_type& base() const& noexcept {
        return _Current;
    }
    _NODISCARD constexpr iterator_type base() && noexcept(is_nothrow_move_constructible_v<_Iter>) /* strengthened */ {
        return _STD move(_Current);
    }
#else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
    _NODISCARD _CONSTEXPR17 iterator_type base() const
        noexcept(is_nothrow_copy_constructible_v<_Iter>) /* strengthened */ {
        return _Current;
    }
#endif // ^^^ !_HAS_CXX20 ^^^

    _NODISCARD _CONSTEXPR17 reference operator*() const
#if _HAS_CXX20
        noexcept(noexcept(_RANGES iter_move(_Current))) /* strengthened */ {
        return _RANGES iter_move(_Current);
    }
#else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
        noexcept(noexcept(static_cast<reference>(*_Current))) /* strengthened */ {
        return static_cast<reference>(*_Current);
    }
#endif // ^^^ !_HAS_CXX20 ^^^

    _CXX20_DEPRECATE_MOVE_ITERATOR_ARROW _NODISCARD _CONSTEXPR17 pointer operator->() const
        noexcept(is_nothrow_copy_constructible_v<_Iter>) /* strengthened */ {
        return _Current;
    }

    _CONSTEXPR17 move_iterator& operator++() noexcept(noexcept(++_Current)) /* strengthened */ {
        ++_Current;
        return *this;
    }

    _CONSTEXPR17 auto operator++(int) noexcept(is_nothrow_copy_constructible_v<_Iter> //
        && noexcept(++_Current)) /* strengthened */ {
#if _HAS_CXX20
        if constexpr (forward_iterator<_Iter>) {
#endif // _HAS_CXX20
            move_iterator _Tmp = *this;
            ++_Current;
            return _Tmp;
#if _HAS_CXX20
        }
        else {
            ++_Current;
        }
#endif // _HAS_CXX20
    }

    _CONSTEXPR17 move_iterator& operator--() noexcept(noexcept(--_Current)) /* strengthened */ {
        --_Current;
        return *this;
    }

    _CONSTEXPR17 move_iterator operator--(int) noexcept(is_nothrow_copy_constructible_v<_Iter> //
        && noexcept(--_Current)) /* strengthened */ {
        move_iterator _Tmp = *this;
        --_Current;
        return _Tmp;
    }

    template <class _Iter2 = _Iter>
    _NODISCARD auto operator==(_Default_sentinel _Sentinel) const noexcept
        -> decltype(_STD declval<const _Iter2&>() == _Sentinel) {
        return _Current == _Sentinel;
    }

    template <class _Iter2 = _Iter>
    _NODISCARD auto operator!=(_Default_sentinel _Sentinel) const noexcept
        -> decltype(_STD declval<const _Iter2&>() != _Sentinel) {
        return _Current != _Sentinel;
    }

    _NODISCARD _CONSTEXPR17 move_iterator operator+(const difference_type _Off) const
        noexcept(noexcept(move_iterator(_Current + _Off))) /* strengthened */ {
        return move_iterator(_Current + _Off);
    }

    _CONSTEXPR17 move_iterator& operator+=(const difference_type _Off) noexcept(
        noexcept(_Current += _Off)) /* strengthened */ {
        _Current += _Off;
        return *this;
    }

    _NODISCARD _CONSTEXPR17 move_iterator operator-(const difference_type _Off) const
        noexcept(noexcept(move_iterator(_Current - _Off))) /* strengthened */ {
        return move_iterator(_Current - _Off);
    }

    _CONSTEXPR17 move_iterator& operator-=(const difference_type _Off) noexcept(
        noexcept(_Current -= _Off)) /* strengthened */ {
        _Current -= _Off;
        return *this;
    }

    _NODISCARD _CONSTEXPR17 reference operator[](const difference_type _Off) const
#if _HAS_CXX20
        noexcept(noexcept(_RANGES iter_move(_Current + _Off))) /* strengthened */ {
        return _RANGES iter_move(_Current + _Off);
#else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
        noexcept(noexcept(_STD move(_Current[_Off]))) /* strengthened */ {
        return _STD move(_Current[_Off]);
#endif // ^^^ !_HAS_CXX20 ^^^
    }

#if _HAS_CXX20
    template <sentinel_for<_Iter> _Sent>
    _NODISCARD_FRIEND constexpr bool
        operator==(const move_iterator & _Left, const move_sentinel<_Sent>&_Right) noexcept(
            noexcept(_STD _Fake_copy_init<bool>(_Left._Current == _Right._Get_last()))) /* strengthened */ {
        return _Left._Current == _Right._Get_last();
    }

    template <sized_sentinel_for<_Iter> _Sent>
    _NODISCARD_FRIEND constexpr difference_type operator-(const move_sentinel<_Sent>&_Left,
        const move_iterator & _Right) noexcept(noexcept(_Left._Get_last() - _Right._Current)) /* strengthened */ {
        return _Left._Get_last() - _Right._Current;
    }

    template <sized_sentinel_for<_Iter> _Sent>
    _NODISCARD_FRIEND constexpr difference_type operator-(const move_iterator & _Left,
        const move_sentinel<_Sent>&_Right) noexcept(noexcept(_Left._Current - _Right._Get_last())) /* strengthened */ {
        return _Left._Current - _Right._Get_last();
    }

    _NODISCARD_FRIEND constexpr reference iter_move(const move_iterator & _It) noexcept(
        noexcept(_RANGES iter_move(_It._Current))) {
        return _RANGES iter_move(_It._Current);
    }

    template <indirectly_swappable<_Iter> _Iter2>
    friend constexpr void iter_swap(const move_iterator & _Left, const move_iterator<_Iter2>&_Right) noexcept(
        noexcept(_RANGES iter_swap(_Left._Current, _Right.base()))) {
        _RANGES iter_swap(_Left._Current, _Right.base());
    }
#endif // _HAS_CXX20

    template <class _Iter2, enable_if_t<_Range_verifiable_v<_Iter, _Iter2>, int> = 0>
    friend constexpr void _Verify_range(const move_iterator & _First, const move_iterator<_Iter2>&_Last) noexcept {
        _Verify_range(_First._Current, _Last._Get_current());
    }
#if _HAS_CXX20
    template <sentinel_for<_Iter> _Sent, enable_if_t<_Range_verifiable_v<_Iter, _Sent>, int> = 0>
    friend constexpr void _Verify_range(const move_iterator & _First, const move_sentinel<_Sent>&_Last) noexcept {
        _Verify_range(_First._Current, _Last._Get_last());
    }
#endif // _HAS_CXX20

    using _Prevent_inheriting_unwrap = move_iterator;

    template <class _Iter2 = iterator_type, enable_if_t<_Offset_verifiable_v<_Iter2>, int> = 0>
    constexpr void _Verify_offset(const difference_type _Off) const noexcept {
        _Current._Verify_offset(_Off);
    }

    template <class _Iter2 = iterator_type, enable_if_t<_Unwrappable_v<const _Iter2&>, int> = 0>
    _NODISCARD constexpr move_iterator<_Unwrapped_t<const _Iter2&>> _Unwrapped() const& noexcept(
        noexcept(static_cast<move_iterator<_Unwrapped_t<const _Iter2&>>>(_Current._Unwrapped()))) {
        return static_cast<move_iterator<_Unwrapped_t<const _Iter2&>>>(_Current._Unwrapped());
    }
    template <class _Iter2 = iterator_type, enable_if_t<_Unwrappable_v<_Iter2>, int> = 0>
    _NODISCARD constexpr move_iterator<_Unwrapped_t<_Iter2>> _Unwrapped() && noexcept(
        noexcept(static_cast<move_iterator<_Unwrapped_t<_Iter2>>>(_STD move(_Current)._Unwrapped()))) {
        return static_cast<move_iterator<_Unwrapped_t<_Iter2>>>(_STD move(_Current)._Unwrapped());
    }

    static constexpr bool _Unwrap_when_unverified = _Do_unwrap_when_unverified_v<iterator_type>;

    template <class _Src, enable_if_t<_Wrapped_seekable_v<iterator_type, const _Src&>, int> = 0>
    constexpr void _Seek_to(const move_iterator<_Src>&_It) noexcept(noexcept(_Current._Seek_to(_It._Get_current()))) {
        _Current._Seek_to(_It._Get_current());
    }
    template <class _Src, enable_if_t<_Wrapped_seekable_v<iterator_type, _Src>, int> = 0>
    constexpr void _Seek_to(move_iterator<_Src> && _It) noexcept(
        noexcept(_Current._Seek_to(_STD move(_It)._Get_current()))) {
        _Current._Seek_to(_STD move(_It)._Get_current());
    }

    _NODISCARD constexpr const iterator_type& _Get_current() const& noexcept {
        return _Current;
    }
    _NODISCARD constexpr iterator_type&& _Get_current() && noexcept {
        return _STD move(_Current);
    }
    };

_EXPORT_STD template <class _Iter1, class _Iter2>
_NODISCARD _CONSTEXPR17 bool
operator==(const move_iterator<_Iter1>& _Left, const move_iterator<_Iter2>& _Right) noexcept(
    noexcept(_STD _Fake_copy_init<bool>(_Left.base() == _Right.base()))) /* strengthened */
#if _HAS_CXX20
    requires requires {
        { _Left.base() == _Right.base() } -> _Implicitly_convertible_to<bool>;
}
#endif // _HAS_CXX20
{
    return _Left.base() == _Right.base();
}

#if !_HAS_CXX20
template <class _Iter1, class _Iter2>
_NODISCARD _CONSTEXPR17 bool operator!=(const move_iterator<_Iter1>& _Left,
    const move_iterator<_Iter2>& _Right) noexcept(noexcept(_Left == _Right)) /* strengthened */ {
    return !(_Left == _Right);
}
#endif // !_HAS_CXX20

_EXPORT_STD template <class _Iter1, class _Iter2>
_NODISCARD _CONSTEXPR17 bool
operator<(const move_iterator<_Iter1>& _Left, const move_iterator<_Iter2>& _Right) noexcept(
    noexcept(_STD _Fake_copy_init<bool>(_Left.base() < _Right.base()))) /* strengthened */
#if _HAS_CXX20
    requires requires {
        { _Left.base() < _Right.base() } -> _Implicitly_convertible_to<bool>;
}
#endif // _HAS_CXX20
{
    return _Left.base() < _Right.base();
}

_EXPORT_STD template <class _Iter1, class _Iter2>
_NODISCARD _CONSTEXPR17 bool operator>(const move_iterator<_Iter1>& _Left,
    const move_iterator<_Iter2>& _Right) noexcept(noexcept(_Right < _Left)) /* strengthened */
{
    return _Right < _Left;
}

_EXPORT_STD template <class _Iter1, class _Iter2>
_NODISCARD _CONSTEXPR17 bool operator<=(const move_iterator<_Iter1>& _Left,
    const move_iterator<_Iter2>& _Right) noexcept(noexcept(_Right < _Left)) /* strengthened */
#if _HAS_CXX20
    requires requires { _Right < _Left; }
#endif // _HAS_CXX20
{
    return !(_Right < _Left);
}

_EXPORT_STD template <class _Iter1, class _Iter2>
_NODISCARD _CONSTEXPR17 bool operator>=(const move_iterator<_Iter1>& _Left,
    const move_iterator<_Iter2>& _Right) noexcept(noexcept(_Left < _Right)) /* strengthened */
#if _HAS_CXX20
    requires requires { _Left < _Right; }
#endif // _HAS_CXX20
{
    return !(_Left < _Right);
}

#if _HAS_CXX20
_EXPORT_STD template <class _Iter1, three_way_comparable_with<_Iter1> _Iter2>
_NODISCARD constexpr compare_three_way_result_t<_Iter1, _Iter2> operator<=>(const move_iterator<_Iter1>& _Left,
    const move_iterator<_Iter2>& _Right) noexcept(noexcept(_Left.base() <=> _Right.base())) /* strengthened */ {
    return _Left.base() <=> _Right.base();
}
#endif // _HAS_CXX20

_EXPORT_STD template <class _Iter1, class _Iter2>
_NODISCARD _CONSTEXPR17 auto operator-(const move_iterator<_Iter1>& _Left,
    const move_iterator<_Iter2>& _Right) noexcept(noexcept(_Left.base() - _Right.base())) /* strengthened */
    -> decltype(_Left.base() - _Right.base()) {
    return _Left.base() - _Right.base();
}

_EXPORT_STD template <class _Iter>
_NODISCARD _CONSTEXPR17 move_iterator<_Iter>
operator+(typename move_iterator<_Iter>::difference_type _Off, const move_iterator<_Iter>& _Right) noexcept(
    noexcept(move_iterator<_Iter>(_Right.base() + _Off))) /* strengthened */
#if _HAS_CXX20
    requires requires {
        { _Right.base() + _Off } -> same_as<_Iter>;
}
#endif // _HAS_CXX20
{
    return move_iterator<_Iter>(_Right.base() + _Off);
}

_EXPORT_STD template <class _Iter>
_NODISCARD _CONSTEXPR17 move_iterator<_Iter> make_move_iterator(_Iter _It) noexcept(
    is_nothrow_move_constructible_v<_Iter>) /* strengthened */ {
    return move_iterator<_Iter>(_STD move(_It));
}

#if _HAS_CXX20
template <class _Iter1, class _Iter2>
    requires (!sized_sentinel_for<_Iter1, _Iter2>)
inline constexpr bool disable_sized_sentinel_for<move_iterator<_Iter1>, move_iterator<_Iter2>> = true;

_EXPORT_STD struct unreachable_sentinel_t;
namespace _Unreachable_sentinel_detail {
    struct _Base {
        template <weakly_incrementable _Winc>
        _NODISCARD_FRIEND constexpr bool operator==(const unreachable_sentinel_t&, const _Winc&) noexcept {
            return false;
        }
    };
} // namespace _Unreachable_sentinel_detail
_EXPORT_STD struct unreachable_sentinel_t : _Unreachable_sentinel_detail::_Base {}; // TRANSITION, /permissive-

_EXPORT_STD inline constexpr unreachable_sentinel_t unreachable_sentinel{};
#endif // _HAS_CXX20

// _Iterator_is_contiguous<_Iter> reports whether an iterator is known to be contiguous.
// (Without concepts, this detection is limited, which will limit when we can activate optimizations.)

#if _HAS_CXX20
// When concepts are available, we can detect arbitrary contiguous iterators.
template <class _Iter>
inline constexpr bool _Iterator_is_contiguous = contiguous_iterator<_Iter>;

template <class _Iter>
_NODISCARD constexpr auto _To_address(const _Iter& _Val) noexcept {
    _STL_INTERNAL_STATIC_ASSERT(contiguous_iterator<_Iter>);
    return _STD to_address(_Val);
}
#else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
// When concepts aren't available, we can detect pointers. (Iterators should be unwrapped before using this.)
template <class _Iter>
_INLINE_VAR constexpr bool _Iterator_is_contiguous = is_pointer_v<_Iter>;

template <class _Iter>
_NODISCARD constexpr auto _To_address(const _Iter& _Val) noexcept {
    _STL_INTERNAL_STATIC_ASSERT(is_pointer_v<_Iter>);
    return _Val;
}
#endif // ^^^ !_HAS_CXX20 ^^^

template <class _Iter>
_NODISCARD constexpr auto _To_address(const move_iterator<_Iter>& _Val) noexcept {
    return _To_address(_Val.base());
}

// _Iterators_are_contiguous<_Iter1, _Iter2> reports whether both iterators are known to be contiguous.

template <class _Iter1, class _Iter2>
_INLINE_VAR constexpr bool _Iterators_are_contiguous =
_Iterator_is_contiguous<_Iter1> && _Iterator_is_contiguous<_Iter2>;

template <class _Iter>
_INLINE_VAR constexpr bool _Iterator_is_volatile = is_volatile_v<remove_reference_t<_Iter_ref_t<_Iter>>>;

template <class _Source, class _Dest>
_INLINE_VAR constexpr bool _Is_pointer_address_convertible = is_void_v<_Source>
|| is_void_v<_Dest>
// NOTE: is_same_v is required for function pointers to work
|| is_same_v<remove_cv_t<_Source>, remove_cv_t<_Dest>>
#ifdef __cpp_lib_is_pointer_interconvertible
|| is_pointer_interconvertible_base_of_v<_Dest, _Source>
#endif // defined(__cpp_lib_is_pointer_interconvertible)
;

template <class _Source, class _Dest, class _SourceRef, class _DestRef>
struct _Trivial_cat {
    using _USource = _Unwrap_enum_t<_Source>;
    using _UDest = _Unwrap_enum_t<_Dest>;

    static constexpr bool _Same_size_and_compatible =
        sizeof(_Source) == sizeof(_Dest)
        // If _UDest is bool, _USource also needs to be bool
        // Conversion from non-bool => non-bool | bool => bool | bool => non-bool is fine.
        // Conversion from non-bool => bool is not fine.
        && is_same_v<bool, _USource> >= is_same_v<bool, _UDest>
        && (is_same_v<_USource, _UDest> || (is_integral_v<_USource> && is_integral_v<_UDest>)
            || (is_floating_point_v<_USource> && is_floating_point_v<_UDest>));

    static constexpr bool _Bitcopy_constructible =
        _Same_size_and_compatible && is_trivially_constructible_v<_Dest, _SourceRef>;

    static constexpr bool _Bitcopy_assignable =
        _Same_size_and_compatible && is_trivially_assignable_v<_DestRef, _SourceRef>;
};

template <class _Source, class _Dest, class _SourceRef, class _DestRef>
struct _Trivial_cat<_Source*, _Dest*, _SourceRef, _DestRef> {
    static constexpr bool _Bitcopy_constructible =
        _Is_pointer_address_convertible<_Source, _Dest>&& is_trivially_constructible_v<_Dest*, _SourceRef>;

    static constexpr bool _Bitcopy_assignable =
        _Is_pointer_address_convertible<_Source, _Dest>&& is_trivially_assignable_v<_DestRef, _SourceRef>;
};

struct _False_trivial_cat {
    static constexpr bool _Bitcopy_constructible = false;
    static constexpr bool _Bitcopy_assignable = false;
};

template <class _SourceIt, class _DestIt,
    bool _Are_contiguous = _Iterators_are_contiguous<_SourceIt, _DestIt> && !_Iterator_is_volatile<_SourceIt>
    && !_Iterator_is_volatile<_DestIt>>
    struct _Iter_move_cat : _Trivial_cat<_Iter_value_t<_SourceIt>, _Iter_value_t<_DestIt>,
    remove_reference_t<_Iter_ref_t<_SourceIt>>&&, _Iter_ref_t<_DestIt>> {};

template <class _SourceIt, class _DestIt>
struct _Iter_move_cat<_SourceIt, _DestIt, false> : _False_trivial_cat {};

template <class _SourceIt, class _DestIt>
struct _Iter_move_cat<move_iterator<_SourceIt>, _DestIt, false> : _Iter_move_cat<_SourceIt, _DestIt> {};

template <class _SourceIt, class _DestIt,
    bool _Are_contiguous = _Iterators_are_contiguous<_SourceIt, _DestIt> && !_Iterator_is_volatile<_SourceIt>
    && !_Iterator_is_volatile<_DestIt>>
    struct _Iter_copy_cat
    : _Trivial_cat<_Iter_value_t<_SourceIt>, _Iter_value_t<_DestIt>, _Iter_ref_t<_SourceIt>, _Iter_ref_t<_DestIt>> {};

template <class _SourceIt, class _DestIt>
struct _Iter_copy_cat<_SourceIt, _DestIt, false> : _False_trivial_cat {};

template <class _SourceIt, class _DestIt>
struct _Iter_copy_cat<move_iterator<_SourceIt>, _DestIt, false> : _Iter_move_cat<_SourceIt, _DestIt> {};

template <class _Iter1, class _Sent1, class _Iter2>
_CONSTEXPR20 void _Verify_ranges_do_not_overlap(const _Iter1& _First1, const _Sent1& _Last1, const _Iter2& _First2) {
#if _ITERATOR_DEBUG_LEVEL == 2
    if constexpr (_Iterators_are_contiguous<_Iter1, _Iter2>
#if _HAS_CXX20
        && sized_sentinel_for<_Sent1, _Iter1>
#endif // _HAS_CXX20
        ) {
#if _HAS_CXX20
        if (_STD is_constant_evaluated()) {
            return;
        }
#endif // _HAS_CXX20

        const auto _Offset = _Last1 - _First1;
        const auto _Ptr1Offset = _Offset * sizeof(*_STD _To_address(_First1));
        const auto _Ptr2Offset = _Offset * sizeof(*_STD _To_address(_First2));
        // This cast to `cv char*` allows us to compare pointers to distinct types,
        // in case one range provides storage for the other.
        const auto _PtrFirst1 = reinterpret_cast<const volatile char*>(_STD _To_address(_First1));
        const auto _PtrLast1 = _PtrFirst1 + _Ptr1Offset;
        const auto _PtrFirst2 = reinterpret_cast<const volatile char*>(_STD _To_address(_First2));
        const auto _PtrLast2 = _PtrFirst2 + _Ptr2Offset;
        _STL_VERIFY(_PtrLast1 <= _PtrFirst2 || _PtrLast2 <= _PtrFirst1, "ranges should not overlap each other");
    }
#else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 / _ITERATOR_DEBUG_LEVEL != 2 vvv
    (void)_First1;
    (void)_Last1;
    (void)_First2;
#endif // _ITERATOR_DEBUG_LEVEL != 2 ^^^
}

template <class _CtgIt, class _OutCtgIt>
_OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {
    auto _FirstPtr = _STD _To_address(_First);
    auto _LastPtr = _STD _To_address(_Last);
    auto _DestPtr = _STD _To_address(_Dest);
    const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
    const char* const _Last_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
    char* const _Dest_ch = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
    const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);
    _CSTD memmove(_Dest_ch, _First_ch, _Count);
    if constexpr (is_pointer_v<_OutCtgIt>) {
        return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);
    }
    else {
        return _Dest + (_LastPtr - _FirstPtr);
    }
}

template <class _CtgIt, class _OutCtgIt>
_OutCtgIt _Copy_memmove_n(_CtgIt _First, const size_t _Count, _OutCtgIt _Dest) {
    const auto _Result = _STD _Copy_memmove(_First, _First + _Count, _Dest);
    if constexpr (is_pointer_v<_OutCtgIt>) {
        return _Result;
    }
    else { // _Result is unused so the compiler can optimize it away
        return _Dest + static_cast<_Iter_diff_t<_OutCtgIt>>(_Count);
    }
}

template <class _It, bool _RequiresMutable = false>
_INLINE_VAR constexpr bool _Is_vb_iterator = false;

template <class _VbIt, class _OutIt>
_CONSTEXPR20 _OutIt _Copy_vbool(_VbIt _First, _VbIt _Last, _OutIt _Dest);

template <class _VbIt>
_NODISCARD _CONSTEXPR20 _Iter_diff_t<_VbIt> _Count_vbool(_VbIt _First, _VbIt _Last, bool _Val) noexcept;

template <class _VbIt>
_CONSTEXPR20 void _Fill_vbool(_VbIt _First, _VbIt _Last, bool _Val) noexcept;

template <class _VbIt>
_NODISCARD _CONSTEXPR20 _VbIt _Find_vbool(_VbIt _First, _VbIt _Last, bool _Val) noexcept;

template <class _InIt, class _SizeTy, class _OutIt>
_CONSTEXPR20 _OutIt _Copy_n_unchecked4(_InIt _First, _SizeTy _Count, _OutIt _Dest) {
    // copy _First + [0, _Count) to _Dest + [0, _Count), returning _Dest + _Count
    // note: has callers outside the copy family
#if _HAS_CXX20
    _STL_INTERNAL_STATIC_ASSERT(_Integer_like<_SizeTy>);
#endif // _HAS_CXX20

    if constexpr (_Iter_copy_cat<_InIt, _OutIt>::_Bitcopy_assignable) {
#if _HAS_CXX20
        if (!_STD is_constant_evaluated())
#endif // _HAS_CXX20
        {
            return _Copy_memmove_n(_First, static_cast<size_t>(_Count), _Dest);
        }
    }

    for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {
        *_Dest = *_First;
    }

    return _Dest;
}

template <class _InIt, class _Sent, class _OutIt>
using _Sent_copy_cat = conditional_t<
#if _HAS_CXX20
    is_same_v<_Sent, _InIt> || sized_sentinel_for<_Sent, _InIt>,
#else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
    is_same_v<_Sent, _InIt>,
#endif // ^^^ !_HAS_CXX20 ^^^
    _Iter_copy_cat<_InIt, _OutIt>, _False_trivial_cat>;

template <class _InIt, class _Sent, class _OutIt>
_CONSTEXPR20 _OutIt _Copy_unchecked(_InIt _First, _Sent _Last, _OutIt _Dest) {
    // copy [_First, _Last) to [_Dest, ...)
    // note: _Copy_unchecked has callers other than the copy family
    if constexpr (_Is_vb_iterator<_InIt> && _Is_vb_iterator<_OutIt, true>) {
        return _STD _Copy_vbool(_First, _Last, _Dest);
    }
    else {
        if constexpr (_Sent_copy_cat<_InIt, _Sent, _OutIt>::_Bitcopy_assignable) {
#if _HAS_CXX20
            if (!_STD is_constant_evaluated())
#endif // _HAS_CXX20
            {
#if _HAS_CXX20
                if constexpr (!is_same_v<_InIt, _Sent>) {
                    return _STD _Copy_memmove_n(_First, static_cast<size_t>(_Last - _First), _Dest);
                }
                else
#endif // _HAS_CXX20
                {
                    return _STD _Copy_memmove(_First, _Last, _Dest);
                }
            }
        }

        for (; _First != _Last; ++_Dest, (void) ++_First) {
            *_Dest = *_First;
        }

        return _Dest;
    }
}

_EXPORT_STD template <class _InIt, class _OutIt>
_CONSTEXPR20 _OutIt copy(_InIt _First, _InIt _Last, _OutIt _Dest) { // copy [_First, _Last) to [_Dest, ...)
    _STD _Adl_verify_range(_First, _Last);
    const auto _UFirst = _STD _Get_unwrapped(_First);
    const auto _ULast = _STD _Get_unwrapped(_Last);
    const auto _UDest = _STD _Get_unwrapped_n(_Dest, _STD _Idl_distance<_InIt>(_UFirst, _ULast));
    _STD _Seek_wrapped(_Dest, _STD _Copy_unchecked(_UFirst, _ULast, _UDest));
    return _Dest;
}

#if _HAS_CXX17
_EXPORT_STD template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
_FwdIt2 copy(_ExPo&&, _FwdIt1 _First, _FwdIt1 _Last, _FwdIt2 _Dest) noexcept /* terminates */ {
    // copy [_First, _Last) to [_Dest, ...)
    // not parallelized as benchmarks show it isn't worth it
    _REQUIRE_PARALLEL_ITERATOR(_FwdIt1);
    _REQUIRE_CPP17_MUTABLE_ITERATOR(_FwdIt2);
    return _STD copy(_First, _Last, _Dest);
}
#endif // _HAS_CXX17

#if _HAS_CXX20
namespace ranges {
    template <class _To, class _From>
    concept _Convertible_from = convertible_to<_From, _To>;

    _EXPORT_STD template <class _In, class _Out>
        struct in_out_result {
        /* [[no_unique_address]] */ _In in;
        /* [[no_unique_address]] */ _Out out;

        template <_Convertible_from<const _In&> _IIn, _Convertible_from<const _Out&> _OOut>
        constexpr operator in_out_result<_IIn, _OOut>() const& {
            return { in, out };
        }

        template <_Convertible_from<_In> _IIn, _Convertible_from<_Out> _OOut>
        constexpr operator in_out_result<_IIn, _OOut>()&& {
            return { _STD move(in), _STD move(out) };
        }
    };

    template <forward_iterator _It, class _Se>
        requires sentinel_for<remove_cvref_t<_Se>, _It>
    _NODISCARD constexpr _Unwrap_iter_t<_It, _Se> _Get_final_iterator_unwrapped(
        const _Unwrap_iter_t<_It, _Se>& _UFirst, _Se&& _Last) {
        // find the iterator in [_UFirst, _Unwrap_sent<_It>(_Last)) which equals _Unwrap_sent<_It>(_Last)
        // [possibly O(N)]
        if constexpr (is_same_v<_Unwrap_iter_t<_It, _Se>, _Unwrap_sent_t<_Se, _It>>) {
            return _RANGES _Unwrap_sent<_It>(_STD forward<_Se>(_Last));
        }
        else {
            return _RANGES next(_UFirst, _RANGES _Unwrap_sent<_It>(_STD forward<_Se>(_Last)));
        }
    }

    template <forward_range _Rng>
    _NODISCARD constexpr auto _Get_final_iterator_unwrapped(_Rng& _Range) {
        // find the (unwrapped) iterator in _Range which equals _Uend(_Range) [possibly O(N)]
        if constexpr (common_range<_Rng>) {
            if constexpr (same_as<decltype(_Uend(_Range)), _Unwrapped_iterator_t<_Rng>>) {
                return _Uend(_Range);
            }
            else {
                return _RANGES _Unwrap_range_sent<_Rng>(_RANGES end(_Range));
            }
        }
        else if constexpr (sized_range<_Rng>) {
            return _RANGES next(_Ubegin(_Range), _RANGES distance(_Range));
        }
        else {
            return _RANGES next(_Ubegin(_Range), _Uend(_Range));
        }
    }

    template <forward_range _Rng>
    _NODISCARD constexpr auto _Get_final_iterator_unwrapped(_Rng& _Range, const _Unwrapped_iterator_t<_Rng>& _Mid) {
        // find the (unwrapped) iterator in _Range which equals _Uend(_Range) [possibly O(N)]
        // Pre: [ranges::begin(_Range), _Mid) and [_Mid, ranges::end(_Range)) denote ranges
        if constexpr (common_range<_Rng>) {
            if constexpr (same_as<decltype(_Uend(_Range)), _Unwrapped_iterator_t<_Rng>>) {
                return _Uend(_Range);
            }
            else {
                return _Unwrap_range_sent<_Rng>(_RANGES end(_Range));
            }
        }
        else if constexpr (sized_range<_Rng>) {
            const auto _Dist = _RANGES distance(_Range);
            if constexpr (sized_sentinel_for<_Unwrapped_iterator_t<_Rng>, _Unwrapped_iterator_t<_Rng>>) {
                return _RANGES next(_Mid, _Dist - (_Mid - _Ubegin(_Range)));
            }
            else {
                return _RANGES next(_Ubegin(_Range), _Dist);
            }
        }
        else {
            return _RANGES next(_Mid, _Uend(_Range));
        }
    }

#if _HAS_CXX23
    _EXPORT_STD template <class _Out, class _Ty>
        struct out_value_result {
        /* [[no_unique_address]] */ _Out out;
        /* [[no_unique_address]] */ _Ty value;

        template <_Convertible_from<const _Out&> _OOut, _Convertible_from<const _Ty&> _TTy>
        constexpr operator out_value_result<_OOut, _TTy>() const& {
            return { out, value };
        }

        template <_Convertible_from<_Out> _OOut, _Convertible_from<_Ty> _TTy>
        constexpr operator out_value_result<_OOut, _TTy>()&& {
            return { _STD move(out), _STD move(value) };
        }
    };
#endif // _HAS_CXX23

    _EXPORT_STD template <class _In, class _Out>
        using copy_result = in_out_result<_In, _Out>;

    template <input_iterator _It, sentinel_for<_It> _Se, weakly_incrementable _Out>
        requires indirectly_copyable<_It, _Out>
    _NODISCARD constexpr copy_result<_It, _Out> _Copy_unchecked(_It _First, _Se _Last, _Out _Result) {
        if constexpr (_Sent_copy_cat<_It, _Se, _Out>::_Bitcopy_assignable) {
            if (!_STD is_constant_evaluated()) {
                if constexpr (is_same_v<_It, _Se>) {
                    _Result = _STD _Copy_memmove(_STD move(_First), _Last, _STD move(_Result));
                    return { _STD move(_Last), _STD move(_Result) };
                }
                else {
                    const auto _Count = static_cast<size_t>(_Last - _First);
                    _Result = _STD _Copy_memmove_n(_First, _Count, _STD move(_Result));
                    _First += _Count;
                    return { _STD move(_First), _STD move(_Result) };
                }
            }
        }

        for (; _First != _Last; ++_First, (void) ++_Result) {
            *_Result = *_First;
        }

        return { _STD move(_First), _STD move(_Result) };
    }

    class _Copy_fn {
    public:
        template <input_iterator _It, sentinel_for<_It> _Se, weakly_incrementable _Out>
            requires indirectly_copyable<_It, _Out>
        _STATIC_CALL_OPERATOR constexpr copy_result<_It, _Out> operator()(
            _It _First, _Se _Last, _Out _Result) _CONST_CALL_OPERATOR {
            _STD _Adl_verify_range(_First, _Last);
            auto _UResult = _RANGES _Copy_unchecked(_RANGES _Unwrap_iter<_Se>(_STD move(_First)),
                _RANGES _Unwrap_sent<_It>(_STD move(_Last)), _STD move(_Result));
            _STD _Seek_wrapped(_First, _STD move(_UResult.in));
            return { _STD move(_First), _STD move(_UResult.out) };
        }

        template <input_range _Rng, weakly_incrementable _Out>
            requires indirectly_copyable<iterator_t<_Rng>, _Out>
        _STATIC_CALL_OPERATOR constexpr copy_result<borrowed_iterator_t<_Rng>, _Out> operator()(
            _Rng&& _Range, _Out _Result) _CONST_CALL_OPERATOR {
            auto _First = _RANGES begin(_Range);
            auto _UResult = _RANGES _Copy_unchecked(
                _RANGES _Unwrap_range_iter<_Rng>(_STD move(_First)), _Uend(_Range), _STD move(_Result));
            _STD _Seek_wrapped(_First, _STD move(_UResult.in));
            return { _STD move(_First), _STD move(_UResult.out) };
        }
    };

    _EXPORT_STD inline constexpr _Copy_fn copy;
} // namespace ranges
#endif // _HAS_CXX20

_EXPORT_STD template <class _InIt, class _Diff, class _OutIt>
_CONSTEXPR20 _OutIt copy_n(_InIt _First, _Diff _Count_raw, _OutIt _Dest) {
    // copy [_First, _First + _Count) to [_Dest, ...)
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (0 < _Count) {
        if constexpr (_Is_vb_iterator<_InIt> && _Is_vb_iterator<_OutIt, true>) {
            return _STD _Copy_vbool(_First, _First + _Count, _Dest);
        }
        else {
            auto _UFirst = _STD _Get_unwrapped_n(_First, _Count);
            auto _UDest = _STD _Get_unwrapped_n(_Dest, _Count);
            if constexpr (_Iter_copy_cat<decltype(_UFirst), decltype(_UDest)>::_Bitcopy_assignable) {
#if _HAS_CXX20
                if (!_STD is_constant_evaluated())
#endif // _HAS_CXX20
                {
                    _UDest = _STD _Copy_memmove_n(_UFirst, static_cast<size_t>(_Count), _UDest);
                    _STD _Seek_wrapped(_Dest, _UDest);
                    return _Dest;
                }
            }

            for (;;) {
                *_UDest = *_UFirst;
                ++_UDest;
                --_Count;
                // note that we avoid an extra ++_First here to allow istream_iterator to work, see LWG-2471
                if (_Count == 0) {
                    break;
                }

                ++_UFirst;
            }

            _STD _Seek_wrapped(_Dest, _UDest);
        }
    }

    return _Dest;
}

#if _HAS_CXX17
_EXPORT_STD template <class _ExPo, class _FwdIt1, class _Diff, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
_FwdIt2 copy_n(_ExPo&&, _FwdIt1 _First, _Diff _Count_raw, _FwdIt2 _Dest) noexcept /* terminates */ {
    // copy [_First, _First + _Count) to [_Dest, ...)
    // not parallelized as benchmarks show it isn't worth it
    _REQUIRE_PARALLEL_ITERATOR(_FwdIt1);
    _REQUIRE_CPP17_MUTABLE_ITERATOR(_FwdIt2);
    return _STD copy_n(_First, _Count_raw, _Dest);
}
#endif // _HAS_CXX17

template <class _CtgIt1, class _CtgIt2>
_CtgIt2 _Copy_backward_memmove(_CtgIt1 _First, _CtgIt1 _Last, _CtgIt2 _Dest) {
    // implement copy_backward-like function as memmove
    auto _FirstPtr = _STD _To_address(_First);
    auto _LastPtr = _STD _To_address(_Last);
    auto _DestPtr = _STD _To_address(_Dest);
    const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
    const char* const _Last_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
    char* const _Dest_ch = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
    const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);
    auto _Result = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);
    if constexpr (is_pointer_v<_CtgIt2>) {
        return static_cast<_CtgIt2>(_Result);
    }
    else {
        return _Dest - (_LastPtr - _FirstPtr);
    }
}

template <class _BidIt1, class _BidIt2>
_BidIt2 _Copy_backward_memmove(move_iterator<_BidIt1> _First, move_iterator<_BidIt1> _Last, _BidIt2 _Dest) {
    return _STD _Copy_backward_memmove(_First.base(), _Last.base(), _Dest);
}

template <class _BidIt1, class _BidIt2>
_NODISCARD _CONSTEXPR20 _BidIt2 _Copy_backward_unchecked(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {
    // copy [_First, _Last) backwards to [..., _Dest)
    if constexpr (_Iter_copy_cat<_BidIt1, _BidIt2>::_Bitcopy_assignable) {
#if _HAS_CXX20
        if (!_STD is_constant_evaluated())
#endif // _HAS_CXX20
        {
            return _STD _Copy_backward_memmove(_First, _Last, _Dest);
        }
    }

    while (_First != _Last) {
        *--_Dest = *--_Last;
    }

    return _Dest;
}

_EXPORT_STD template <class _BidIt1, class _BidIt2>
_CONSTEXPR20 _BidIt2 copy_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {
    // copy [_First, _Last) backwards to [..., _Dest)
    _STD _Adl_verify_range(_First, _Last);
    const auto _UFirst = _STD _Get_unwrapped(_First);
    const auto _ULast = _STD _Get_unwrapped(_Last);
    const auto _UDest = _STD _Get_unwrapped_n(_Dest, -_STD _Idl_distance<_BidIt1>(_UFirst, _ULast));
    _STD _Seek_wrapped(_Dest, _STD _Copy_backward_unchecked(_UFirst, _ULast, _UDest));
    return _Dest;
}

template <class _InIt, class _OutIt>
_CONSTEXPR20 _OutIt _Move_unchecked(_InIt _First, _InIt _Last, _OutIt _Dest) {
    // move [_First, _Last) to [_Dest, ...)
    // note: _Move_unchecked has callers other than the move family
    if constexpr (_Is_vb_iterator<_InIt> && _Is_vb_iterator<_OutIt, true>) {
        return _STD _Copy_vbool(_First, _Last, _Dest);
    }
    else {
        if constexpr (_Iter_move_cat<_InIt, _OutIt>::_Bitcopy_assignable) {
#if _HAS_CXX20
            if (!_STD is_constant_evaluated())
#endif // _HAS_CXX20
            {
                return _STD _Copy_memmove(_First, _Last, _Dest);
            }
        }

        for (; _First != _Last; ++_Dest, (void) ++_First) {
            *_Dest = _STD move(*_First);
        }

        return _Dest;
    }
}

_EXPORT_STD template <class _InIt, class _OutIt>
_CONSTEXPR20 _OutIt move(_InIt _First, _InIt _Last, _OutIt _Dest) {
    // move [_First, _Last) to [_Dest, ...)
    _STD _Adl_verify_range(_First, _Last);
    const auto _UFirst = _STD _Get_unwrapped(_First);
    const auto _ULast = _STD _Get_unwrapped(_Last);
    const auto _UDest = _STD _Get_unwrapped_n(_Dest, _STD _Idl_distance<_InIt>(_UFirst, _ULast));
    _STD _Seek_wrapped(_Dest, _STD _Move_unchecked(_UFirst, _ULast, _UDest));
    return _Dest;
}

#if _HAS_CXX17
_EXPORT_STD template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
_FwdIt2 move(_ExPo&&, _FwdIt1 _First, _FwdIt1 _Last, _FwdIt2 _Dest) noexcept /* terminates */ {
    // move [_First, _Last) to [_Dest, ...)
    // not parallelized as benchmarks show it isn't worth it
    _REQUIRE_CPP17_MUTABLE_ITERATOR(_FwdIt1);
    _REQUIRE_CPP17_MUTABLE_ITERATOR(_FwdIt2);
    return _STD move(_First, _Last, _Dest);
}
#endif // _HAS_CXX17

template <class _BidIt1, class _BidIt2>
_CONSTEXPR20 _BidIt2 _Move_backward_unchecked(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {
    // move [_First, _Last) backwards to [..., _Dest)
    // note: _Move_backward_unchecked has callers other than the move_backward family
    if constexpr (_Iter_move_cat<_BidIt1, _BidIt2>::_Bitcopy_assignable) {
#if _HAS_CXX20
        if (!_STD is_constant_evaluated())
#endif // _HAS_CXX20
        {
            return _STD _Copy_backward_memmove(_First, _Last, _Dest);
        }
    }

    while (_First != _Last) {
        *--_Dest = _STD move(*--_Last);
    }

    return _Dest;
}

_EXPORT_STD template <class _BidIt1, class _BidIt2>
_CONSTEXPR20 _BidIt2 move_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {
    // move [_First, _Last) backwards to [..., _Dest)
    _STD _Adl_verify_range(_First, _Last);
    const auto _UFirst = _STD _Get_unwrapped(_First);
    const auto _ULast = _STD _Get_unwrapped(_Last);
    const auto _UDest = _STD _Get_unwrapped_n(_Dest, -_STD _Idl_distance<_BidIt1>(_UFirst, _ULast));
    _STD _Seek_wrapped(_Dest, _STD _Move_backward_unchecked(_UFirst, _ULast, _UDest));
    return _Dest;
}

template <class _Ty>
struct _Is_character : false_type {}; // by default, not a character type

template <>
struct _Is_character<char> : true_type {}; // chars are characters

template <>
struct _Is_character<signed char> : true_type {}; // signed chars are also characters

template <>
struct _Is_character<unsigned char> : true_type {}; // unsigned chars are also characters

#ifdef __cpp_char8_t
template <>
struct _Is_character<char8_t> : true_type {}; // UTF-8 code units are sort-of characters
#endif // defined(__cpp_char8_t)

template <class _Ty>
struct _Is_character_or_bool : _Is_character<_Ty>::type {};

template <>
struct _Is_character_or_bool<bool> : true_type {};

template <class _Ty>
struct _Is_character_or_byte_or_bool : _Is_character_or_bool<_Ty>::type {};

#ifdef __cpp_lib_byte
template <>
struct _Is_character_or_byte_or_bool<byte> : true_type {};
#endif // defined(__cpp_lib_byte)

// _Fill_memset_is_safe determines if _FwdIt and _Ty are eligible for memset optimization in fill.
// Need to explicitly test for volatile because _Unwrap_enum_t discards qualifiers.
template <class _FwdIt, class _Ty, bool = _Iterator_is_contiguous<_FwdIt>>
_INLINE_VAR constexpr bool _Fill_memset_is_safe = conjunction_v<is_scalar<_Ty>,
    _Is_character_or_byte_or_bool<_Unwrap_enum_t<remove_reference_t<_Iter_ref_t<_FwdIt>>>>,
    negation<is_volatile<remove_reference_t<_Iter_ref_t<_FwdIt>>>>, is_assignable<_Iter_ref_t<_FwdIt>, const _Ty&>>;

template <class _FwdIt, class _Ty>
_INLINE_VAR constexpr bool _Fill_memset_is_safe<_FwdIt, _Ty, false> = false;

template <class _FwdIt, class _Ty, bool = _Iterator_is_contiguous<_FwdIt>>
_INLINE_VAR constexpr bool _Fill_zero_memset_is_safe =
conjunction_v<is_scalar<_Ty>, is_scalar<_Iter_value_t<_FwdIt>>, negation<is_member_pointer<_Iter_value_t<_FwdIt>>>,
    negation<is_volatile<remove_reference_t<_Iter_ref_t<_FwdIt>>>>, is_assignable<_Iter_ref_t<_FwdIt>, const _Ty&>>;

template <class _FwdIt, class _Ty>
_INLINE_VAR constexpr bool _Fill_zero_memset_is_safe<_FwdIt, _Ty, false> = false;

template <class _CtgIt, class _Ty>
void _Fill_memset(_CtgIt _Dest, const _Ty _Val, const size_t _Count) {
    // implicitly convert (a cast would suppress warnings); also handles _Iter_value_t<_CtgIt> being bool
    _Iter_value_t<_CtgIt> _Dest_val = _Val;
    _CSTD memset(_STD _To_address(_Dest), static_cast<unsigned char>(_Dest_val), _Count);
}

template <class _CtgIt>
void _Fill_zero_memset(_CtgIt _Dest, const size_t _Count) {
    _CSTD memset(_STD _To_address(_Dest), 0, _Count * sizeof(_Iter_value_t<_CtgIt>));
}

template <class _Ty>
_NODISCARD bool _Is_all_bits_zero(const _Ty& _Val) {
    // checks if scalar type has all bits set to zero
    _STL_INTERNAL_STATIC_ASSERT(is_scalar_v<_Ty> && !is_member_pointer_v<_Ty>);
    if constexpr (is_same_v<_Ty, nullptr_t>) {
        return true;
    }
    else {
        constexpr _Ty _Zero{};
        return _CSTD memcmp(&_Val, &_Zero, sizeof(_Ty)) == 0;
    }
}

_EXPORT_STD template <class _FwdIt, class _Ty>
_CONSTEXPR20 void fill(const _FwdIt _First, const _FwdIt _Last, const _Ty& _Val) {
    // copy _Val through [_First, _Last)
    _STD _Adl_verify_range(_First, _Last);
    if constexpr (_Is_vb_iterator<_FwdIt, true>) {
        _STD _Fill_vbool(_First, _Last, _Val);
    }
    else {
        auto _UFirst = _STD _Get_unwrapped(_First);
        const auto _ULast = _STD _Get_unwrapped(_Last);
#if _HAS_CXX20
        if (!_STD is_constant_evaluated())
#endif // _HAS_CXX20
        {
            if constexpr (_Fill_memset_is_safe<decltype(_UFirst), _Ty>) {
                _STD _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
                return;
            }
            else if constexpr (_Fill_zero_memset_is_safe<decltype(_UFirst), _Ty>) {
                if (_STD _Is_all_bits_zero(_Val)) {
                    _STD _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
                    return;
                }
            }
        }

        for (; _UFirst != _ULast; ++_UFirst) {
            *_UFirst = _Val;
        }
    }
}

#if _HAS_CXX17
_EXPORT_STD template <class _ExPo, class _FwdIt, class _Ty, _Enable_if_execution_policy_t<_ExPo> = 0>
void fill(_ExPo&&, _FwdIt _First, _FwdIt _Last, const _Ty& _Val) noexcept /* terminates */ {
    // copy _Val through [_First, _Last)
    // not parallelized as benchmarks show it isn't worth it
    _REQUIRE_CPP17_MUTABLE_ITERATOR(_FwdIt);
    return _STD fill(_First, _Last, _Val);
}
#endif // _HAS_CXX17

_EXPORT_STD template <class _OutIt, class _Diff, class _Ty>
_CONSTEXPR20 _OutIt fill_n(_OutIt _Dest, const _Diff _Count_raw, const _Ty& _Val) {
    // copy _Val _Count times through [_Dest, ...)
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (0 < _Count) {
        if constexpr (_Is_vb_iterator<_OutIt, true>) {
            const auto _Last = _Dest + static_cast<typename _OutIt::difference_type>(_Count);
            _STD _Fill_vbool(_Dest, _Last, _Val);
            return _Last;
        }
        else {
            auto _UDest = _STD _Get_unwrapped_n(_Dest, _Count);
#if _HAS_CXX20
            if (!_STD is_constant_evaluated())
#endif // _HAS_CXX20
            {
                if constexpr (_Fill_memset_is_safe<decltype(_UDest), _Ty>) {
                    _STD _Fill_memset(_UDest, _Val, static_cast<size_t>(_Count));
                    _STD _Seek_wrapped(_Dest, _UDest + _Count);
                    return _Dest;
                }
                else if constexpr (_Fill_zero_memset_is_safe<decltype(_UDest), _Ty>) {
                    if (_STD _Is_all_bits_zero(_Val)) {
                        _STD _Fill_zero_memset(_UDest, static_cast<size_t>(_Count));
                        _STD _Seek_wrapped(_Dest, _UDest + _Count);
                        return _Dest;
                    }
                }
            }

            for (; 0 < _Count; --_Count, (void) ++_UDest) {
                *_UDest = _Val;
            }

            _STD _Seek_wrapped(_Dest, _UDest);
        }
    }
    return _Dest;
}

#if _HAS_CXX17
_EXPORT_STD template <class _ExPo, class _FwdIt, class _Diff, class _Ty, _Enable_if_execution_policy_t<_ExPo> = 0>
_FwdIt fill_n(_ExPo&&, _FwdIt _Dest, _Diff _Count_raw, const _Ty& _Val) noexcept /* terminates */ {
    // copy _Val _Count times through [_Dest, ...)
    // not parallelized as benchmarks show it isn't worth it
    _REQUIRE_CPP17_MUTABLE_ITERATOR(_FwdIt);
    return _STD fill_n(_Dest, _Count_raw, _Val);
}
#endif // _HAS_CXX17

#if _HAS_CXX20
namespace ranges {
    class _Fill_n_fn {
    public:
        template <class _Ty, output_iterator<const _Ty&> _It>
        _STATIC_CALL_OPERATOR constexpr _It operator()(
            _It _First, iter_difference_t<_It> _Count, const _Ty& _Value) _CONST_CALL_OPERATOR {
            if (_Count > 0) {
                auto _UFirst = _STD _Get_unwrapped_n(_STD move(_First), _Count);
                if (!_STD is_constant_evaluated()) {
                    if constexpr (_Fill_memset_is_safe<decltype(_UFirst), _Ty>) {
                        _STD _Fill_memset(_UFirst, _Value, static_cast<size_t>(_Count));
                        _STD _Seek_wrapped(_First, _UFirst + _Count); // no need to move since _UFirst is a pointer
                        return _First;
                    }
                    else if constexpr (_Fill_zero_memset_is_safe<decltype(_UFirst), _Ty>) {
                        if (_STD _Is_all_bits_zero(_Value)) {
                            _STD _Fill_zero_memset(_UFirst, static_cast<size_t>(_Count));
                            _STD _Seek_wrapped(_First, _UFirst + _Count); // no need to move since _UFirst is a pointer
                            return _First;
                        }
                    }
                }

                for (; _Count > 0; ++_UFirst, (void) --_Count) {
                    *_UFirst = _Value;
                }

                _STD _Seek_wrapped(_First, _STD move(_UFirst));
            }

            return _First;
        }
    };

    _EXPORT_STD inline constexpr _Fill_n_fn fill_n;
} // namespace ranges
#endif // _HAS_CXX20

template <class _Ty1, class _Ty2, class = void>
_INLINE_VAR constexpr bool _Can_compare_with_operator_equal = false;

template <class _Ty1, class _Ty2>
_INLINE_VAR constexpr bool
_Can_compare_with_operator_equal<_Ty1, _Ty2, void_t<decltype(_STD declval<_Ty1&>() == _STD declval<_Ty2&>())>> =
true;

template <class _Ty1, class _Ty2>
_INLINE_VAR constexpr bool _Is_pointer_address_comparable =
_Can_compare_with_operator_equal<_Ty1*, _Ty2*>
&& (_Is_pointer_address_convertible<_Ty1, _Ty2> || _Is_pointer_address_convertible<_Ty2, _Ty1>);

// _Can_memcmp_elements<_Elem1, _Elem2> reports whether `_Elem1 == _Elem2` can be optimized to memcmp.
// Here, _Elem1 and _Elem2 aren't top-level const, because we remove_const_t before using _Can_memcmp_elements.

// Integral types are eligible for memcmp in very specific cases.
// * They must be the same size. (`int == long` is eligible; `int == long long` isn't.)
// * The usual arithmetic conversions must preserve bit patterns. (This is true for `int == unsigned int`,
//   but false for `short == unsigned short`.)
#pragma warning(push)
#pragma warning(disable : 4806) // no value of type 'bool' promoted to type 'char' can equal the given constant
template <class _Elem1, class _Elem2,
    bool = sizeof(_Elem1) == sizeof(_Elem2) && is_integral_v<_Elem1>&& is_integral_v<_Elem2>>
    _INLINE_VAR constexpr bool _Can_memcmp_elements =
    is_same_v<_Elem1, bool> || is_same_v<_Elem2, bool> || static_cast<_Elem1>(-1) == static_cast<_Elem2>(-1);
#pragma warning(pop)

#ifdef __cpp_lib_byte
// Allow memcmping std::byte.
// inline is required here as explicit specializations of variable templates are problematic in C++14.
// However, std::byte is C++17 and above so we are safe.
template <>
inline constexpr bool _Can_memcmp_elements<byte, byte, false> = true;
#endif // defined(__cpp_lib_byte)

// Pointer elements are eligible for memcmp when they point to the same type, ignoring cv-qualification.
// This handles pointers to object types, pointers to void, and pointers to function types.
template <class _Ty1, class _Ty2>
_INLINE_VAR constexpr bool _Can_memcmp_elements<_Ty1*, _Ty2*, false> = _Is_pointer_address_comparable<_Ty1, _Ty2>;

template <class _Elem1, class _Elem2>
_INLINE_VAR constexpr bool _Can_memcmp_elements<_Elem1, _Elem2, false> = false;

// _Can_memcmp_elements_with_pred<_Elem1, _Elem2, _Pr> reports whether the memcmp optimization is applicable,
// given contiguously stored elements. (This avoids having to repeat the metaprogramming that finds the element types.)
// _Elem1 and _Elem2 aren't top-level const here.
template <class _Elem1, class _Elem2, class _Pr>
_INLINE_VAR constexpr bool _Can_memcmp_elements_with_pred = false;

// With equal_to<_Elem3> we need to make sure that both _Elem1 and _Elem2 are convertible to _Elem3 without changing
// object representation (we use _Iter_copy_cat for this task) and _Elem3 can be safely memcmp'ed with itself
template <class _Elem1, class _Elem2, class _Elem3>
_INLINE_VAR constexpr bool _Can_memcmp_elements_with_pred<_Elem1, _Elem2, equal_to<_Elem3>> =
_Iter_copy_cat<_Elem1*, _Elem3*>::_Bitcopy_constructible&& _Iter_copy_cat<_Elem2*, _Elem3*>::_Bitcopy_constructible
&& _Can_memcmp_elements<remove_cv_t<_Elem3>, remove_cv_t<_Elem3>>;

// equal_to<> is transparent.
template <class _Elem1, class _Elem2>
_INLINE_VAR constexpr bool _Can_memcmp_elements_with_pred<_Elem1, _Elem2, equal_to<>> =
_Can_memcmp_elements<_Elem1, _Elem2>;

#if _HAS_CXX20
// ranges::equal_to is also transparent.
template <class _Elem1, class _Elem2>
_INLINE_VAR constexpr bool _Can_memcmp_elements_with_pred<_Elem1, _Elem2, _RANGES equal_to> =
_Can_memcmp_elements<_Elem1, _Elem2>;
#endif // _HAS_CXX20

// _Equal_memcmp_is_safe<_Iter1, _Iter2, _Pr> reports whether we can activate the memcmp optimization
// for arbitrary iterators and predicates.
// It ignores top-level constness on the iterators and on the elements.
template <class _Iter1, class _Iter2, class _Pr>
_INLINE_VAR constexpr bool _Equal_memcmp_is_safe_helper =
_Iterators_are_contiguous<_Iter1, _Iter2> && !_Iterator_is_volatile<_Iter1> && !_Iterator_is_volatile<_Iter2>
&& _Can_memcmp_elements_with_pred<_Iter_value_t<_Iter1>, _Iter_value_t<_Iter2>, _Pr>;

template <class _Iter1, class _Iter2, class _Pr>
_INLINE_VAR constexpr bool _Equal_memcmp_is_safe =
_Equal_memcmp_is_safe_helper<remove_const_t<_Iter1>, remove_const_t<_Iter2>, _Pr>;

template <class _CtgIt1, class _CtgIt2>
_NODISCARD int _Memcmp_ranges(_CtgIt1 _First1, _CtgIt1 _Last1, _CtgIt2 _First2) {
    _STL_INTERNAL_STATIC_ASSERT(sizeof(_Iter_value_t<_CtgIt1>) == sizeof(_Iter_value_t<_CtgIt2>));
    const auto _First1_ch = reinterpret_cast<const char*>(_STD _To_address(_First1));
    const auto _Last1_ch = reinterpret_cast<const char*>(_STD _To_address(_Last1));
    const auto _First2_ch = reinterpret_cast<const char*>(_STD _To_address(_First2));
    return _CSTD memcmp(_First1_ch, _First2_ch, static_cast<size_t>(_Last1_ch - _First1_ch));
}

template <class _CtgIt1, class _CtgIt2>
_NODISCARD int _Memcmp_count(_CtgIt1 _First1, _CtgIt2 _First2, const size_t _Count) {
    _STL_INTERNAL_STATIC_ASSERT(sizeof(_Iter_value_t<_CtgIt1>) == sizeof(_Iter_value_t<_CtgIt2>));
    const auto _First1_ch = reinterpret_cast<const char*>(_STD _To_address(_First1));
    const auto _First2_ch = reinterpret_cast<const char*>(_STD _To_address(_First2));
    return _CSTD memcmp(_First1_ch, _First2_ch, _Count * sizeof(_Iter_value_t<_CtgIt1>));
}

_EXPORT_STD template <class _InIt1, class _InIt2, class _Pr>
_NODISCARD _CONSTEXPR20 bool equal(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, _Pr _Pred) {
    // compare [_First1, _Last1) to [_First2, ...)
    _STD _Adl_verify_range(_First1, _Last1);
    auto _UFirst1 = _STD _Get_unwrapped(_First1);
    const auto _ULast1 = _STD _Get_unwrapped(_Last1);
    auto _UFirst2 = _STD _Get_unwrapped_n(_First2, _STD _Idl_distance<_InIt1>(_UFirst1, _ULast1));
    if constexpr (_Equal_memcmp_is_safe<decltype(_UFirst1), decltype(_UFirst2), _Pr>) {
#if _HAS_CXX20
        if (!_STD is_constant_evaluated())
#endif // _HAS_CXX20
        {
            return _STD _Memcmp_ranges(_UFirst1, _ULast1, _UFirst2) == 0;
        }
    }

    for (; _UFirst1 != _ULast1; ++_UFirst1, (void) ++_UFirst2) {
        if (!_Pred(*_UFirst1, *_UFirst2)) {
            return false;
        }
    }

    return true;
}

#if _HAS_CXX17
_EXPORT_STD template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
_NODISCARD bool equal(_ExPo&& _Exec, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2,
    _Pr _Pred) noexcept; // terminates
#endif // _HAS_CXX17

_EXPORT_STD template <class _InIt1, class _InIt2>
_NODISCARD _CONSTEXPR20 bool equal(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2) {
    // compare [_First1, _Last1) to [_First2, ...)
    return _STD equal(_First1, _Last1, _First2, equal_to<>{});
}

#if _HAS_CXX17
_EXPORT_STD template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
_NODISCARD bool equal(_ExPo&& _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2) noexcept
/* terminates */ {
    // compare [_First1, _Last1) to [_First2, ...)
    return _STD equal(_STD forward<_ExPo>(_Exec), _First1, _Last1, _First2, equal_to{});
}
#endif // _HAS_CXX17

_EXPORT_STD template <class _InIt1, class _InIt2, class _Pr>
_NODISCARD _CONSTEXPR20 bool equal(
    const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2, _Pr _Pred) {
    // compare [_First1, _Last1) to [_First2, _Last2)
    _STD _Adl_verify_range(_First1, _Last1);
    _STD _Adl_verify_range(_First2, _Last2);
    auto _UFirst1 = _STD _Get_unwrapped(_First1);
    const auto _ULast1 = _STD _Get_unwrapped(_Last1);
    auto _UFirst2 = _STD _Get_unwrapped(_First2);
    const auto _ULast2 = _STD _Get_unwrapped(_Last2);
    if constexpr (_Is_ranges_random_iter_v<_InIt1> && _Is_ranges_random_iter_v<_InIt2>) {
        if (_ULast1 - _UFirst1 != _ULast2 - _UFirst2) {
            return false;
        }

        return _STD equal(_UFirst1, _ULast1, _UFirst2, _STD _Pass_fn(_Pred));
    }
    else {
        for (;;) {
            if (_UFirst1 == _ULast1) {
                return _UFirst2 == _ULast2;
            }

            if (_UFirst2 == _ULast2) {
                return false;
            }

            if (!_Pred(*_UFirst1, *_UFirst2)) {
                return false;
            }

            ++_UFirst1;
            ++_UFirst2;
        }
    }
}

#if _HAS_CXX17
_EXPORT_STD template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
_NODISCARD bool equal(
    _ExPo&& _Exec, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred) noexcept; // terminates
#endif // _HAS_CXX17

_EXPORT_STD template <class _InIt1, class _InIt2>
_NODISCARD _CONSTEXPR20 bool equal(
    const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2) {
    // compare [_First1, _Last1) to [_First2, _Last2)
    return _STD equal(_First1, _Last1, _First2, _Last2, equal_to<>{});
}

#if _HAS_CXX17
_EXPORT_STD template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
_NODISCARD bool equal(_ExPo&& _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2,
    const _FwdIt2 _Last2) noexcept /* terminates */ {
    // compare [_First1, _Last1) to [_First2, _Last2)
    return _STD equal(_STD forward<_ExPo>(_Exec), _First1, _Last1, _First2, _Last2, equal_to{});
}
#endif // _HAS_CXX17

#if _HAS_CXX20
namespace ranges {
    template <forward_range _Rng, class _It>
    _NODISCARD constexpr iterator_t<_Rng> _Rewrap_iterator(_Rng&& _Range, _It&& _Val) {
        _STL_INTERNAL_STATIC_ASSERT(is_same_v<remove_cvref_t<_It>, _Unwrapped_iterator_t<_Rng>>);

        if constexpr (is_same_v<remove_cvref_t<_It>, iterator_t<_Rng>>) {
            return _STD forward<_It>(_Val);
        }
        else {
            auto _Result = _RANGES begin(_Range);
            _Result._Seek_to(_STD forward<_It>(_Val));
            return _Result;
        }
    }

    _EXPORT_STD template <class _In1, class _In2>
        struct in_in_result {
        /* [[no_unique_address]] */ _In1 in1;
        /* [[no_unique_address]] */ _In2 in2;

        template <_Convertible_from<const _In1&> _IIn1, _Convertible_from<const _In2&> _IIn2>
        constexpr operator in_in_result<_IIn1, _IIn2>() const& {
            return { in1, in2 };
        }

        template <_Convertible_from<_In1> _IIn1, _Convertible_from<_In2> _IIn2>
        constexpr operator in_in_result<_IIn1, _IIn2>()&& {
            return { _STD move(in1), _STD move(in2) };
        }
    };

    _EXPORT_STD template <class _In1, class _In2>
        using mismatch_result = in_in_result<_In1, _In2>;

    template <input_iterator _It1, input_iterator _It2, class _Pr, class _Pj1, class _Pj2>
        requires indirectly_comparable<_It1, _It2, _Pr, _Pj1, _Pj2>
    _NODISCARD constexpr mismatch_result<_It1, _It2> _Mismatch_n(
        _It1 _First1, _It2 _First2, iter_difference_t<_It1> _Count, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
        _STL_INTERNAL_CHECK(_Count >= 0);
        for (; _Count != 0; ++_First1, (void) ++_First2, --_Count) {
            if (!_STD invoke(_Pred, _STD invoke(_Proj1, *_First1), _STD invoke(_Proj2, *_First2))) {
                break;
            }
        }

        return { _STD move(_First1), _STD move(_First2) };
    }

    template <input_iterator _It1, sentinel_for<_It1> _Se1, input_iterator _It2, sentinel_for<_It2> _Se2, class _Pr,
        class _Pj1, class _Pj2>
        requires indirectly_comparable<_It1, _It2, _Pr, _Pj1, _Pj2>
    _NODISCARD constexpr mismatch_result<_It1, _It2> _Mismatch_4(
        _It1 _First1, _Se1 _Last1, _It2 _First2, _Se2 _Last2, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
        for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, (void) ++_First2) {
            if (!_STD invoke(_Pred, _STD invoke(_Proj1, *_First1), _STD invoke(_Proj2, *_First2))) {
                break;
            }
        }

        return { _STD move(_First1), _STD move(_First2) };
    }

    class _Mismatch_fn {
    public:
        template <input_iterator _It1, sentinel_for<_It1> _Se1, input_iterator _It2, sentinel_for<_It2> _Se2,
            class _Pr = ranges::equal_to, class _Pj1 = identity, class _Pj2 = identity>
            requires indirectly_comparable<_It1, _It2, _Pr, _Pj1, _Pj2>
        _NODISCARD _STATIC_CALL_OPERATOR constexpr mismatch_result<_It1, _It2> operator()(_It1 _First1, _Se1 _Last1,
            _It2 _First2, _Se2 _Last2, _Pr _Pred = {}, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) _CONST_CALL_OPERATOR {
            _STD _Adl_verify_range(_First1, _Last1);
            _STD _Adl_verify_range(_First2, _Last2);

            if constexpr (sized_sentinel_for<_Se1, _It1> && sized_sentinel_for<_Se2, _It2>) {
                iter_difference_t<_It1> _Count1 = _Last1 - _First1;
                const iter_difference_t<_It2> _Count2 = _Last2 - _First2;
                if (_Count1 > _Count2) {
                    _Count1 = static_cast<decltype(_Count1)>(_Count2);
                }

                auto _Result = _RANGES _Mismatch_n(_STD _Get_unwrapped(_STD move(_First1)),
                    _STD _Get_unwrapped(_STD move(_First2)), _Count1, _STD _Pass_fn(_Pred), _STD _Pass_fn(_Proj1),
                    _STD _Pass_fn(_Proj2));
                _STD _Seek_wrapped(_First1, _STD move(_Result.in1));
                _STD _Seek_wrapped(_First2, _STD move(_Result.in2));
                return { _STD move(_First1), _STD move(_First2) };
            }
            else {
                auto _Result = _RANGES _Mismatch_4(_RANGES _Unwrap_iter<_Se1>(_STD move(_First1)),
                    _RANGES _Unwrap_sent<_It1>(_STD move(_Last1)), _RANGES _Unwrap_iter<_Se2>(_STD move(_First2)),
                    _RANGES _Unwrap_sent<_It2>(_STD move(_Last2)), _STD _Pass_fn(_Pred), _STD _Pass_fn(_Proj1),
                    _STD _Pass_fn(_Proj2));
                _STD _Seek_wrapped(_First1, _STD move(_Result.in1));
                _STD _Seek_wrapped(_First2, _STD move(_Result.in2));
                return { _STD move(_First1), _STD move(_First2) };
            }
        }

        template <input_range _Rng1, input_range _Rng2, class _Pr = ranges::equal_to, class _Pj1 = identity,
            class _Pj2 = identity>
            requires indirectly_comparable<iterator_t<_Rng1>, iterator_t<_Rng2>, _Pr, _Pj1, _Pj2>
        _NODISCARD
            _STATIC_CALL_OPERATOR constexpr mismatch_result<borrowed_iterator_t<_Rng1>, borrowed_iterator_t<_Rng2>>
            operator()(_Rng1&& _Range1, _Rng2&& _Range2, _Pr _Pred = {}, _Pj1 _Proj1 = {},
                _Pj2 _Proj2 = {}) _CONST_CALL_OPERATOR {
            if constexpr (sized_range<_Rng1> && sized_range<_Rng2>) {
                range_difference_t<_Rng1> _Count1 = _RANGES distance(_Range1);
                const range_difference_t<_Rng2> _Count2 = _RANGES distance(_Range2);
                if (_Count1 > _Count2) {
                    _Count1 = static_cast<range_difference_t<_Rng1>>(_Count2);
                }

                auto _First1 = _RANGES begin(_Range1);
                auto _First2 = _RANGES begin(_Range2);
                auto _Result = _RANGES _Mismatch_n(_STD _Get_unwrapped(_STD move(_First1)),
                    _STD _Get_unwrapped(_STD move(_First2)), _Count1, _STD _Pass_fn(_Pred), _STD _Pass_fn(_Proj1),
                    _STD _Pass_fn(_Proj2));
                _STD _Seek_wrapped(_First1, _STD move(_Result.in1));
                _STD _Seek_wrapped(_First2, _STD move(_Result.in2));
                return { _STD move(_First1), _STD move(_First2) };
            }
            else {
                auto _First1 = _RANGES begin(_Range1);
                auto _First2 = _RANGES begin(_Range2);
                auto _Result = _RANGES _Mismatch_4(_RANGES _Unwrap_range_iter<_Rng1>(_STD move(_First1)),
                    _Uend(_Range1), _RANGES _Unwrap_range_iter<_Rng2>(_STD move(_First2)), _Uend(_Range2),
                    _STD _Pass_fn(_Pred), _STD _Pass_fn(_Proj1), _STD _Pass_fn(_Proj2));
                _STD _Seek_wrapped(_First1, _STD move(_Result.in1));
                _STD _Seek_wrapped(_First2, _STD move(_Result.in2));
                return { _STD move(_First1), _STD move(_First2) };
            }
        }
    };

    _EXPORT_STD inline constexpr _Mismatch_fn mismatch;
} // namespace ranges
#endif // _HAS_CXX20

template <class _Elem1, class _Elem2>
_INLINE_VAR constexpr bool _Lex_compare_memcmp_classify_elements = conjunction_v<_Is_character_or_bool<_Elem1>,
    _Is_character_or_bool<_Elem2>, is_unsigned<_Elem1>, is_unsigned<_Elem2>>;

#ifdef __cpp_lib_byte
template <>
inline constexpr bool _Lex_compare_memcmp_classify_elements<byte, byte> = true;
#endif // defined(__cpp_lib_byte)

template <class _Elem1, class _Elem2, class _Pr>
struct _Lex_compare_memcmp_classify_pred {
    using _Pred = void;
};

template <class _Elem1, class _Elem2, class _Elem3>
struct _Lex_compare_memcmp_classify_pred<_Elem1, _Elem2, less<_Elem3>> {
    using _Pred = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem3, _Elem3>
        && _Iter_copy_cat<_Elem1*, _Elem3*>::_Bitcopy_constructible
        && _Iter_copy_cat<_Elem2*, _Elem3*>::_Bitcopy_constructible,
        less<int>, void>;
};

template <class _Elem1, class _Elem2>
struct _Lex_compare_memcmp_classify_pred<_Elem1, _Elem2, less<>> {
    using _Pred = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2>, less<int>, void>;
};

template <class _Elem1, class _Elem2, class _Elem3>
struct _Lex_compare_memcmp_classify_pred<_Elem1, _Elem2, greater<_Elem3>> {
    using _Pred = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem3, _Elem3>
        && _Iter_copy_cat<_Elem1*, _Elem3*>::_Bitcopy_constructible
        && _Iter_copy_cat<_Elem2*, _Elem3*>::_Bitcopy_constructible,
        greater<int>, void>;
};

template <class _Elem1, class _Elem2>
struct _Lex_compare_memcmp_classify_pred<_Elem1, _Elem2, greater<>> {
    using _Pred = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2>, greater<int>, void>;
};

#if _HAS_CXX20
template <class _Elem1, class _Elem2>
struct _Lex_compare_memcmp_classify_pred<_Elem1, _Elem2, _RANGES less> {
    using _Pred = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2>, less<int>, void>;
};

template <class _Elem1, class _Elem2>
struct _Lex_compare_memcmp_classify_pred<_Elem1, _Elem2, _RANGES greater> {
    using _Pred = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2>, greater<int>, void>;
};
#endif // _HAS_CXX20

template <class _It1, class _It2, class _Pr>
using _Lex_compare_memcmp_classify =
conditional_t<_Iterators_are_contiguous<_It1, _It2> && !_Iterator_is_volatile<_It1> && !_Iterator_is_volatile<_It2>,
    typename _Lex_compare_memcmp_classify_pred<_Iter_value_t<_It1>, _Iter_value_t<_It2>, _Pr>::_Pred, void>;

_EXPORT_STD template <class _InIt1, class _InIt2, class _Pr>
_NODISCARD _CONSTEXPR20 bool lexicographical_compare(
    const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2, _Pr _Pred) {
    // order [_First1, _Last1) vs. [_First2, _Last2)
    _STD _Adl_verify_range(_First1, _Last1);
    _STD _Adl_verify_range(_First2, _Last2);
    auto _UFirst1 = _STD _Get_unwrapped(_First1);
    const auto _ULast1 = _STD _Get_unwrapped(_Last1);
    auto _UFirst2 = _STD _Get_unwrapped(_First2);
    const auto _ULast2 = _STD _Get_unwrapped(_Last2);

    using _Memcmp_pred = _Lex_compare_memcmp_classify<decltype(_UFirst1), decltype(_UFirst2), _Pr>;
    if constexpr (!is_void_v<_Memcmp_pred>) {
#if _HAS_CXX20
        if (!_STD is_constant_evaluated())
#endif // _HAS_CXX20
        {
            const auto _Num1 = static_cast<size_t>(_ULast1 - _UFirst1);
            const auto _Num2 = static_cast<size_t>(_ULast2 - _UFirst2);
            const int _Ans = _STD _Memcmp_count(_UFirst1, _UFirst2, (_STD min)(_Num1, _Num2));
            return _Memcmp_pred{}(_Ans, 0) || (_Ans == 0 && _Num1 < _Num2);
        }
    }

    for (; _UFirst1 != _ULast1 && _UFirst2 != _ULast2; ++_UFirst1, (void) ++_UFirst2) { // something to compare, do it
        if (_DEBUG_LT_PRED(_Pred, *_UFirst1, *_UFirst2)) {
            return true;
        }
        else if (_Pred(*_UFirst2, *_UFirst1)) {
            return false;
        }
    }

    return _UFirst1 == _ULast1 && _UFirst2 != _ULast2;
}

_EXPORT_STD template <class _InIt1, class _InIt2>
_NODISCARD _CONSTEXPR20 bool lexicographical_compare(
    const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2) {
    // order [_First1, _Last1) vs. [_First2, _Last2)
    return _STD lexicographical_compare(_First1, _Last1, _First2, _Last2, less<>{});
}

#if _HAS_CXX17
_EXPORT_STD template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
_NODISCARD bool lexicographical_compare(_ExPo&&, const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2,
    const _FwdIt2 _Last2, _Pr _Pred) noexcept /* terminates */ {
    // order [_First1, _Last1) vs. [_First2, _Last2)
    // not parallelized at present, parallelism expected to be feasible in a future release
    _REQUIRE_PARALLEL_ITERATOR(_FwdIt1);
    _REQUIRE_PARALLEL_ITERATOR(_FwdIt2);
    return _STD lexicographical_compare(_First1, _Last1, _First2, _Last2, _STD _Pass_fn(_Pred));
}

_EXPORT_STD template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
_NODISCARD bool lexicographical_compare(_ExPo&&, const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2,
    const _FwdIt2 _Last2) noexcept /* terminates */ {
    // order [_First1, _Last1) vs. [_First2, _Last2)
    // not parallelized at present, parallelism expected to be feasible in a future release
    _REQUIRE_PARALLEL_ITERATOR(_FwdIt1);
    _REQUIRE_PARALLEL_ITERATOR(_FwdIt2);
    return _STD lexicographical_compare(_First1, _Last1, _First2, _Last2);
}
#endif // _HAS_CXX17

#if _HAS_CXX20
template <class _Elem1, class _Elem2, class _Cmp>
struct _Lex_compare_three_way_memcmp_classify_comp {
    using _Comp = void;
};

template <class _Elem1, class _Elem2>
struct _Lex_compare_three_way_memcmp_classify_comp<_Elem1, _Elem2, compare_three_way> {
    using _Comp = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2>
        && three_way_comparable_with<const _Elem1&, const _Elem2&>,
        compare_three_way, void>;
};

template <class _Elem1, class _Elem2>
struct _Lex_compare_three_way_memcmp_classify_comp<_Elem1, _Elem2, _Strong_order::_Cpo> {
    using _Comp =
        conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2>&& _Can_strong_order<_Elem1, _Elem2>,
        _Strong_order::_Cpo, void>;
};

template <class _Elem1, class _Elem2>
struct _Lex_compare_three_way_memcmp_classify_comp<_Elem1, _Elem2, _Weak_order::_Cpo> {
    using _Comp =
        conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2>&& _Can_weak_order<_Elem1, _Elem2>,
        _Weak_order::_Cpo, void>;
};

template <class _Elem1, class _Elem2>
struct _Lex_compare_three_way_memcmp_classify_comp<_Elem1, _Elem2, _Partial_order::_Cpo> {
    using _Comp =
        conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2>&& _Can_partial_order<_Elem1, _Elem2>,
        _Partial_order::_Cpo, void>;
};

template <class _It1, class _It2, class _Cmp>
using _Lex_compare_three_way_memcmp_classify =
conditional_t<_Iterators_are_contiguous<_It1, _It2> && !_Iterator_is_volatile<_It1> && !_Iterator_is_volatile<_It2>,
    typename _Lex_compare_three_way_memcmp_classify_comp<_Iter_value_t<_It1>, _Iter_value_t<_It2>, _Cmp>::_Comp,
    void>;

_EXPORT_STD template <class _InIt1, class _InIt2, class _Cmp>
_NODISCARD constexpr auto lexicographical_compare_three_way(const _InIt1 _First1, const _InIt1 _Last1,
    const _InIt2 _First2, const _InIt2 _Last2, _Cmp _Comp) -> decltype(_Comp(*_First1, *_First2)) {
    _STD _Adl_verify_range(_First1, _Last1);
    _STD _Adl_verify_range(_First2, _Last2);
    auto _UFirst1 = _STD _Get_unwrapped(_First1);
    const auto _ULast1 = _STD _Get_unwrapped(_Last1);
    auto _UFirst2 = _STD _Get_unwrapped(_First2);
    const auto _ULast2 = _STD _Get_unwrapped(_Last2);

    using _Memcmp_pred = _Lex_compare_three_way_memcmp_classify<decltype(_UFirst1), decltype(_UFirst2), _Cmp>;
    if constexpr (!is_void_v<_Memcmp_pred>) {
        if (!_STD is_constant_evaluated()) {
            const auto _Num1 = static_cast<size_t>(_ULast1 - _UFirst1);
            const auto _Num2 = static_cast<size_t>(_ULast2 - _UFirst2);
            const int _Ans = _STD _Memcmp_count(_UFirst1, _UFirst2, (_STD min)(_Num1, _Num2));
            if (_Ans == 0) {
                return _Num1 <=> _Num2;
            }
            else {
                return _Memcmp_pred{}(_Ans, 0);
            }
        }
    }

    for (;;) {
        if (_UFirst1 == _ULast1) {
            return _UFirst2 == _ULast2 ? strong_ordering::equal : strong_ordering::less;
        }

        if (_UFirst2 == _ULast2) {
            return strong_ordering::greater;
        }

        if (const auto _CmpResult = _Comp(*_UFirst1, *_UFirst2); _CmpResult != 0) {
            return _CmpResult;
        }

        ++_UFirst1;
        ++_UFirst2;
    }
}

_EXPORT_STD template <class _InIt1, class _InIt2>
_NODISCARD constexpr auto lexicographical_compare_three_way(
    const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2) {
    return _STD lexicographical_compare_three_way(_First1, _Last1, _First2, _Last2, compare_three_way{});
}
#endif // _HAS_CXX20

template <class _Ty, class _Elem>
struct _Vector_alg_in_find_is_safe_object_pointers : false_type {};
template <class _Ty1, class _Ty2>
struct _Vector_alg_in_find_is_safe_object_pointers<_Ty1*, _Ty2*>
    : conjunction<
    // _Ty1* is an object pointer type
    disjunction<is_object<_Ty1>, is_void<_Ty1>>,
    // _Ty2* is an object pointer type
    disjunction<is_object<_Ty2>, is_void<_Ty2>>,
    // either _Ty1 is the same as _Ty2 (ignoring cv-qualifiers), or one of the two is void
    disjunction<is_same<remove_cv_t<_Ty1>, remove_cv_t<_Ty2>>, is_void<_Ty1>, is_void<_Ty2>>> {};

// Can we activate the vector algorithms for find/count?
template <class _Iter, class _Ty, class _Elem = _Iter_value_t<_Iter>>
_INLINE_VAR constexpr bool _Vector_alg_in_find_is_safe =
// The iterator must be contiguous so we can get raw pointers.
_Iterator_is_contiguous<_Iter>
// The iterator must not be volatile.
&& !_Iterator_is_volatile<_Iter>
// And one of the following conditions must be met:
&& disjunction_v<
#ifdef __cpp_lib_byte
    // We're finding a std::byte in a range of std::byte.
    conjunction<is_same<_Ty, byte>, is_same<_Elem, byte>>,
#endif // defined(__cpp_lib_byte)
    // We're finding an integer in a range of integers.
    // This case is the one that requires careful runtime handling in _Could_compare_equal_to_value_type.
    conjunction<is_integral<_Ty>, is_integral<_Elem>>,
    // We're finding an (object or function) pointer in a range of pointers of the same type.
    conjunction<is_pointer<_Ty>, is_same<_Ty, _Elem>>,
    // We're finding a nullptr in a range of (object or function) pointers.
    conjunction<is_same<_Ty, nullptr_t>, is_pointer<_Elem>>,
    // We're finding an object pointer in a range of object pointers, and:
    // - One of the pointer types is a cv void*.
    // - One of the pointer types is a cv1 U* and the other is a cv2 U*.
    _Vector_alg_in_find_is_safe_object_pointers<_Ty, _Elem>>;

template <class _InIt, class _Ty>
_NODISCARD constexpr bool _Could_compare_equal_to_value_type(const _Ty& _Val) {
    // check whether _Val is within the limits of _Elem
    _STL_INTERNAL_STATIC_ASSERT(_Vector_alg_in_find_is_safe<_InIt, _Ty>);

    if constexpr (disjunction_v<
#ifdef __cpp_lib_byte
        is_same<_Ty, byte>,
#endif // defined(__cpp_lib_byte)
        is_same<_Ty, bool>, is_pointer<_Ty>, is_same<_Ty, nullptr_t>>) {
        return true;
    }
    else {
        using _Elem = _Iter_value_t<_InIt>;
        _STL_INTERNAL_STATIC_ASSERT(is_integral_v<_Elem> && is_integral_v<_Ty>);

        if constexpr (is_same_v<_Elem, bool>) {
            return _Val == true || _Val == false;
        }
        else if constexpr (is_signed_v<_Elem>) {
            // use instead of numeric_limits::min/max; avoid <limits> dependency
            constexpr _Elem _Min = static_cast<_Elem>(_Elem{ 1 } << (sizeof(_Elem) * CHAR_BIT - 1));
            constexpr _Elem _Max = static_cast<_Elem>(~_Min);

            if constexpr (is_signed_v<_Ty>) {
                // signed _Elem, signed _Ty
                return _Min <= _Val && _Val <= _Max;
            }
            else {
                // signed _Elem, unsigned _Ty
                if constexpr (_Elem{ -1 } == static_cast<_Ty>(-1)) {
                    // negative values of _Elem can compare equal to values of _Ty
                    return _Val <= _Max || static_cast<_Ty>(_Min) <= _Val;
                }
                else {
                    // negative values of _Elem cannot compare equal to values of _Ty
                    return _Val <= _Max;
                }
            }
        }
        else {
            constexpr _Elem _Max = static_cast<_Elem>(~_Elem{ 0 });

            if constexpr (is_unsigned_v<_Ty>) {
                // unsigned _Elem, unsigned _Ty
                return _Val <= _Max;
            }
            else {
                // unsigned _Elem, signed _Ty
                if constexpr (_Ty{ -1 } == static_cast<_Elem>(-1)) {
                    // negative values of _Ty can compare equal to values of _Elem
                    return _Val <= _Max;
                }
                else {
                    // negative values of _Ty cannot compare equal to values of _Elem
                    return 0 <= _Val && _Val <= _Max;
                }
            }
        }
    }
}

template <class _InIt, class _Ty>
_NODISCARD _CONSTEXPR20 _InIt _Find_unchecked(_InIt _First, const _InIt _Last, const _Ty& _Val) {
    // find first matching _Val; choose optimization
    // activate optimization for contiguous iterators to most scalar types (possibly const-qualified)
    if constexpr (_Vector_alg_in_find_is_safe<_InIt, _Ty>) {
#if _HAS_CXX20
        if (!_STD is_constant_evaluated())
#endif // _HAS_CXX20
        {
            if (!_STD _Could_compare_equal_to_value_type<_InIt>(_Val)) {
                return _Last;
            }
#if _USE_STD_VECTOR_ALGORITHMS
            const auto _First_ptr = _STD _To_address(_First);
            const auto _Result = _STD __std_find_trivial(_First_ptr, _STD _To_address(_Last), _Val);
            if constexpr (is_pointer_v<_InIt>) {
                return _Result;
            }
            else {
                return _First + (_Result - _First_ptr);
            }
#else // ^^^ _USE_STD_VECTOR_ALGORITHMS / !_USE_STD_VECTOR_ALGORITHMS vvv
            if constexpr (sizeof(_Iter_value_t<_InIt>) == 1) {
                const auto _First_ptr = _STD _To_address(_First);
                const auto _Result = static_cast<remove_reference_t<_Iter_ref_t<_InIt>>*>(
                    _CSTD memchr(_First_ptr, static_cast<unsigned char>(_Val), static_cast<size_t>(_Last - _First)));
                if constexpr (is_pointer_v<_InIt>) {
                    return _Result ? _Result : _Last;
                }
                else {
                    return _Result ? _First + (_Result - _First_ptr) : _Last;
                }
            }
            // TRANSITION, DevCom-1614562: not trying wmemchr
#endif // ^^^ !_USE_STD_VECTOR_ALGORITHMS ^^^
        }
    }

    for (; _First != _Last; ++_First) {
        if (*_First == _Val) {
            break;
        }
    }

    return _First;
}

_EXPORT_STD template <class _InIt, class _Ty>
_NODISCARD _CONSTEXPR20 _InIt find(_InIt _First, const _InIt _Last, const _Ty& _Val) { // find first matching _Val
    _STD _Adl_verify_range(_First, _Last);
    if constexpr (_Is_vb_iterator<_InIt> && is_same_v<_Ty, bool>) {
        return _STD _Find_vbool(_First, _Last, _Val);
    }
    else {
        _STD _Seek_wrapped(_First, _STD _Find_unchecked(_STD _Get_unwrapped(_First), _STD _Get_unwrapped(_Last), _Val));
        return _First;
    }
}

#if _HAS_CXX17
_EXPORT_STD template <class _ExPo, class _FwdIt, class _Ty, _Enable_if_execution_policy_t<_ExPo> = 0>
_NODISCARD _FwdIt find(_ExPo&& _Exec, _FwdIt _First, _FwdIt _Last, const _Ty& _Val) noexcept; // terminates
#endif // _HAS_CXX17

#if _HAS_CXX20
namespace ranges {
    template <class _Se, class _It>
    concept _Sized_or_unreachable_sentinel_for = sized_sentinel_for<_Se, _It> || same_as<_Se, unreachable_sentinel_t>;

    template <class _Rng>
    concept _Sized_or_infinite_range =
        range<_Rng> && (sized_range<_Rng> || same_as<sentinel_t<_Rng>, unreachable_sentinel_t>);

    // concept-constrained for strict enforcement as it is used by several algorithms
    template <input_iterator _It, sentinel_for<_It> _Se, class _Ty, class _Pj = identity>
        requires indirect_binary_predicate<ranges::equal_to, projected<_It, _Pj>, const _Ty*>
    _NODISCARD constexpr _It _Find_unchecked(_It _First, const _Se _Last, const _Ty& _Val, _Pj _Proj = {}) {
        constexpr bool _Is_sized = sized_sentinel_for<_Se, _It>;
        if constexpr (_Vector_alg_in_find_is_safe<_It, _Ty> && _Sized_or_unreachable_sentinel_for<_Se, _It>
            && same_as<_Pj, identity>) {
            if (!_STD is_constant_evaluated()) {
                if (!_STD _Could_compare_equal_to_value_type<_It>(_Val)) {
                    if constexpr (_Is_sized) {
                        return _RANGES next(_STD move(_First), _Last);
                    }
                    else {
                        _STL_ASSERT(false, "Tried to find a value in a range with unreachable sentinel "
                            "that cannot be represented by the range's value type");
                    }
                }

                using _Ptr_t = remove_reference_t<_Iter_ref_t<_It>>*;
#if _USE_STD_VECTOR_ALGORITHMS
                const auto _First_ptr = _STD _To_address(_First);

                _Ptr_t _Result;

                if constexpr (_Is_sized) {
                    const auto _Last_ptr = _First_ptr + (_Last - _First);

                    _Result = _STD __std_find_trivial(_First_ptr, _Last_ptr, _Val);
                }
                else {
                    _Result = _STD __std_find_trivial_unsized(_First_ptr, _Val);
                }

                if constexpr (is_pointer_v<_It>) {
                    return _Result;
                }
                else {
                    return _RANGES next(_STD move(_First), _Result - _First_ptr);
                }
#else // ^^^ _USE_STD_VECTOR_ALGORITHMS / !_USE_STD_VECTOR_ALGORITHMS vvv
                if constexpr (sizeof(_Iter_value_t<_It>) == 1) {
                    size_t _Count;
                    if constexpr (_Is_sized) {
                        _Count = static_cast<size_t>(_Last - _First);
                    }
                    else {
                        _Count = SIZE_MAX;
                    }

                    const auto _First_ptr = _STD to_address(_First);
                    const auto _Result =
                        static_cast<_Ptr_t>(_CSTD memchr(_First_ptr, static_cast<unsigned char>(_Val), _Count));
                    if (_Result) {
                        if constexpr (is_pointer_v<_It>) {
                            return _Result;
                        }
                        else {
                            return _RANGES next(_STD move(_First), _Result - _First_ptr);
                        }
                    }
                    else {
                        return _RANGES next(_STD move(_First), _Last);
                    }
                }
                // TRANSITION, DevCom-1614562: not trying wmemchr
#endif // ^^^ !_USE_STD_VECTOR_ALGORITHMS ^^^
            }
        }

        for (; _First != _Last; ++_First) {
            if (_STD invoke(_Proj, *_First) == _Val) {
                break;
            }
        }

        return _First;
    }

    class _Find_fn {
    public:
        template <input_iterator _It, sentinel_for<_It> _Se, class _Ty, class _Pj = identity>
            requires indirect_binary_predicate<ranges::equal_to, projected<_It, _Pj>, const _Ty*>
        _NODISCARD _STATIC_CALL_OPERATOR constexpr _It operator()(
            _It _First, _Se _Last, const _Ty& _Val, _Pj _Proj = {}) _CONST_CALL_OPERATOR {
            _STD _Adl_verify_range(_First, _Last);
            auto _UResult = _RANGES _Find_unchecked(_RANGES _Unwrap_iter<_Se>(_STD move(_First)),
                _RANGES _Unwrap_sent<_It>(_STD move(_Last)), _Val, _STD _Pass_fn(_Proj));

            _STD _Seek_wrapped(_First, _STD move(_UResult));
            return _First;
        }

        template <input_range _Rng, class _Ty, class _Pj = identity>
            requires indirect_binary_predicate<ranges::equal_to, projected<iterator_t<_Rng>, _Pj>, const _Ty*>
        _NODISCARD _STATIC_CALL_OPERATOR constexpr borrowed_iterator_t<_Rng> operator()(
            _Rng&& _Range, const _Ty& _Val, _Pj _Proj = {}) _CONST_CALL_OPERATOR {
            auto _First = _RANGES begin(_Range);
            auto _UResult = _RANGES _Find_unchecked(
                _RANGES _Unwrap_range_iter<_Rng>(_STD move(_First)), _Uend(_Range), _Val, _STD _Pass_fn(_Proj));

            _STD _Seek_wrapped(_First, _STD move(_UResult));
            return _First;
        }
    };

    _EXPORT_STD inline constexpr _Find_fn find;
} // namespace ranges
#endif // _HAS_CXX20

_EXPORT_STD template <class _InIt, class _Ty>
_NODISCARD _CONSTEXPR20 _Iter_diff_t<_InIt> count(const _InIt _First, const _InIt _Last, const _Ty& _Val) {
    // count elements that match _Val
    _STD _Adl_verify_range(_First, _Last);
    if constexpr (_Is_vb_iterator<_InIt> && is_same_v<_Ty, bool>) {
        return _STD _Count_vbool(_First, _Last, _Val);
    }
    else {
        auto _UFirst = _STD _Get_unwrapped(_First);
        const auto _ULast = _STD _Get_unwrapped(_Last);

#if _USE_STD_VECTOR_ALGORITHMS
        if constexpr (_Vector_alg_in_find_is_safe<decltype(_UFirst), _Ty>) {
#if _HAS_CXX20
            if (!_STD is_constant_evaluated())
#endif // _HAS_CXX20
            {
                if (!_STD _Could_compare_equal_to_value_type<decltype(_UFirst)>(_Val)) {
                    return 0;
                }

                return static_cast<_Iter_diff_t<_InIt>>(
                    _STD __std_count_trivial(_STD _To_address(_UFirst), _STD _To_address(_ULast), _Val));
            }
        }
#endif // _USE_STD_VECTOR_ALGORITHMS

        _Iter_diff_t<_InIt> _Count = 0;

        for (; _UFirst != _ULast; ++_UFirst) {
            if (*_UFirst == _Val) {
                ++_Count;
            }
        }

        return _Count;
    }
}

#if _HAS_CXX17
_EXPORT_STD template <class _ExPo, class _FwdIt, class _Ty, _Enable_if_execution_policy_t<_ExPo> = 0>
_NODISCARD _Iter_diff_t<_FwdIt> count(
    _ExPo&& _Exec, _FwdIt _First, _FwdIt _Last, const _Ty& _Val) noexcept; // terminates
#endif // _HAS_CXX17

template <class _InIt, class _Ty, class _Pr>
_NODISCARD constexpr _InIt _Find_pr(_InIt _First, const _InIt _Last, const _Ty& _Val, _Pr _Pred) {
    for (; _First != _Last; ++_First) {
        if (_Pred(*_First, _Val)) {
            break;
        }
    }

    return _First;
}

template <class _InIt, class _Ty, class _Pr>
_NODISCARD constexpr _Iter_diff_t<_InIt> _Count_pr(_InIt _First, const _InIt _Last, const _Ty& _Val, _Pr _Pred) {
    _Iter_diff_t<_InIt> _Count = 0;

    for (; _First != _Last; ++_First) {
        if (_Pred(*_First, _Val)) {
            ++_Count;
        }
    }

    return _Count;
}

enum class _TrimResult : unsigned char { _KeepTrimming, _HaveWorkAfterTrimming, _ReturnFalse, _ReturnTrue };

template <class _BidIt1, class _BidIt2, class _Pr>
_NODISCARD _CONSTEXPR20 _TrimResult _Trim_equal(
    _BidIt1& _First1, _BidIt1& _Back1, _BidIt2& _First2, _BidIt2& _Back2, _Pr _Pred) {
    // advances the iterators, trimming matching prefixes then matching suffixes
    // from [_First1, _Back1] and [_First2, _Back2]
    _STL_INTERNAL_CHECK(_First1 != _Back1);
    _STL_INTERNAL_CHECK(_STD distance(_First1, _Back1) == _STD distance(_First2, _Back2));
    if (_Pred(*_First1, *_First2)) {
        do {
            ++_First1;
            ++_First2;
            if (_First1 == _Back1) {
                // only one element is left
                return _Pred(*_First1, *_First2) ? _TrimResult::_ReturnTrue : _TrimResult::_ReturnFalse;
            }
        } while (_Pred(*_First1, *_First2));
    }
    else {
        if (!_Pred(*_Back1, *_Back2)) {
            // nothing to trim
            return _TrimResult::_HaveWorkAfterTrimming;
        }
        --_Back1;
        --_Back2;
    }

    for (;;) {
        if (_First1 == _Back1) {
            // only one element is left, it can't match because it wasn't trimmed by the first loop
            return _TrimResult::_ReturnFalse;
        }

        if (!_Pred(*_Back1, *_Back2)) {
            return _TrimResult::_KeepTrimming;
        }
        --_Back1;
        --_Back2;
    }
}

template <class _BidIt1, class _BidIt2, class _Pr>
_NODISCARD _CONSTEXPR20 _TrimResult _Trim_reversed(
    _BidIt1& _First1, _BidIt1& _Back1, _BidIt2& _First2, _BidIt2& _Back2, _Pr _Pred) {
    // advances the iterators, trimming each range's prefix that matches the other range's suffix
    // from [_First1, _Back1] and [_First2, _Back2]
    _STL_INTERNAL_CHECK(_First1 != _Back1);
    _STL_INTERNAL_CHECK(_STD distance(_First1, _Back1) == _STD distance(_First2, _Back2));
    if (_Pred(*_First1, *_Back2)) {
        do {
            ++_First1;
            --_Back2;
            if (_First1 == _Back1) {
                // only one element is left
                return _Pred(*_First1, *_First2) ? _TrimResult::_ReturnTrue : _TrimResult::_ReturnFalse;
            }
        } while (_Pred(*_First1, *_Back2));
    }
    else {
        if (!_Pred(*_Back1, *_First2)) {
            // nothing to trim
            return _TrimResult::_HaveWorkAfterTrimming;
        }
        --_Back1;
        ++_First2;
    }

    for (;;) {
        if (_First1 == _Back1) {
            // only one element is left, it can't match because it wasn't trimmed by the first loop
            return _TrimResult::_ReturnFalse;
        }

        if (!_Pred(*_Back1, *_First2)) {
            return _TrimResult::_KeepTrimming;
        }
        --_Back1;
        ++_First2;
    }
}

template <class _BidIt1, class _BidIt2, class _Pr>
_NODISCARD _CONSTEXPR20 _TrimResult _Trim_completely(
    _BidIt1& _First1, _BidIt1& _Back1, _BidIt2& _First2, _BidIt2& _Back2, _Pr _Pred) {
    // alternates between calling _Trim_reversed and _Trim_equal until no more trimming is possible
    _TrimResult _Res = _TrimResult::_KeepTrimming;

    for (bool _Check_reversed = true; _Res == _TrimResult::_KeepTrimming; _Check_reversed = !_Check_reversed) {
        if (_Check_reversed) {
            _Res = _STD _Trim_reversed(_First1, _Back1, _First2, _Back2, _Pred);
        }
        else {
            _Res = _STD _Trim_equal(_First1, _Back1, _First2, _Back2, _Pred);
        }
    }

    return _Res;
}

template <class _FwdIt1, class _FwdIt2, class _Pr>
_NODISCARD _CONSTEXPR20 bool _Check_match_counts(
    _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred) {
    // test if [_First1, _Last1) == permuted [_First2, _Last2), after matching prefix removal
    _STL_INTERNAL_CHECK(!_Pred(*_First1, *_First2));
    _STL_INTERNAL_CHECK(_STD distance(_First1, _Last1) == _STD distance(_First2, _Last2));
    if constexpr (_Is_ranges_bidi_iter_v<_FwdIt1> && _Is_ranges_bidi_iter_v<_FwdIt2>) {
        do { // find last inequality
            --_Last1;
            --_Last2;
        } while (_Pred(*_Last1, *_Last2));

        if (_First1 == _Last1) {
            return false;
        }

        const _TrimResult _Res = _STD _Trim_completely(_First1, _Last1, _First2, _Last2, _Pred);

        if (_Res != _TrimResult::_HaveWorkAfterTrimming) {
            return _Res == _TrimResult::_ReturnTrue;
        }

        ++_Last1;
        ++_Last2;
    }

    for (_FwdIt1 _Next1 = _First1; _Next1 != _Last1; ++_Next1) {
        if (_Next1 == _STD _Find_pr(_First1, _Next1, *_Next1, _Pred)) { // new value, compare match counts
            _Iter_diff_t<_FwdIt2> _Count2 = _STD _Count_pr(_First2, _Last2, *_Next1, _Pred);
            if (_Count2 == 0) {
                return false; // second range lacks value, not a permutation
            }

            _FwdIt1 _Skip1 = _STD _Next_iter(_Next1);
            _Iter_diff_t<_FwdIt1> _Count1 = _STD _Count_pr(_Skip1, _Last1, *_Next1, _Pred) + 1;
            if (_Count2 != _Count1) {
                return false; // match counts differ, not a permutation
            }
        }
    }

    return true;
}

_EXPORT_STD template <class _BidIt>
_CONSTEXPR20 void reverse(const _BidIt _First, const _BidIt _Last) { // reverse elements in [_First, _Last)
    _STD _Adl_verify_range(_First, _Last);
    auto _UFirst = _STD _Get_unwrapped(_First);
    auto _ULast = _STD _Get_unwrapped(_Last);
#if _USE_STD_VECTOR_ALGORITHMS
    using _Elem = remove_reference_t<_Iter_ref_t<decltype(_UFirst)>>;
    constexpr bool _Allow_vectorization = conjunction_v<bool_constant<_Iterator_is_contiguous<decltype(_UFirst)>>,
        _Is_trivially_swappable<_Elem>, negation<is_volatile<_Elem>>>;
    constexpr size_t _Nx = sizeof(_Elem);

    if constexpr (_Allow_vectorization && _Nx <= 8 && (_Nx & (_Nx - 1)) == 0) {
#if _HAS_CXX20
        if (!_STD is_constant_evaluated())
#endif // _HAS_CXX20
        {
            if constexpr (_Nx == 1) {
                ::__std_reverse_trivially_swappable_1(_STD _To_address(_UFirst), _STD _To_address(_ULast));
            }
            else if constexpr (_Nx == 2) {
                ::__std_reverse_trivially_swappable_2(_STD _To_address(_UFirst), _STD _To_address(_ULast));
            }
            else if constexpr (_Nx == 4) {
                ::__std_reverse_trivially_swappable_4(_STD _To_address(_UFirst), _STD _To_address(_ULast));
            }
            else {
                ::__std_reverse_trivially_swappable_8(_STD _To_address(_UFirst), _STD _To_address(_ULast));
            }

            return;
        }
    }
#endif // _USE_STD_VECTOR_ALGORITHMS

    for (; _UFirst != _ULast && _UFirst != --_ULast; ++_UFirst) {
        swap(*_UFirst, *_ULast); // intentional ADL
    }
}

#if _HAS_CXX17
_EXPORT_STD template <class _ExPo, class _BidIt, _Enable_if_execution_policy_t<_ExPo> = 0>
void reverse(_ExPo&&, _BidIt _First, _BidIt _Last) noexcept /* terminates */ {
    // reverse elements in [_First, _Last)
    // not parallelized as benchmarks show it isn't worth it
    _REQUIRE_CPP17_MUTABLE_BIDIRECTIONAL_ITERATOR(_BidIt);
    return _STD reverse(_First, _Last);
}
#endif // _HAS_CXX17

template <class _BidIt>
constexpr pair<_BidIt, _BidIt> _Reverse_until_sentinel_unchecked(_BidIt _First, _BidIt _Sentinel, _BidIt _Last) {
    // reverse until either _First or _Last hits _Sentinel
    while (_First != _Sentinel && _Last != _Sentinel) {
        swap(*_First, *--_Last); // intentional ADL
        ++_First;
    }

    return pair<_BidIt, _BidIt>(_First, _Last);
}

_EXPORT_STD template <class _FwdIt>
_CONSTEXPR20 _FwdIt rotate(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last) {
    // exchange the ranges [_First, _Mid) and [_Mid, _Last)
    // that is, rotates [_First, _Last) left by distance(_First, _Mid) positions
    // returns the iterator pointing at *_First's new home
    _STD _Adl_verify_range(_First, _Mid);
    _STD _Adl_verify_range(_Mid, _Last);
    auto _UFirst = _STD _Get_unwrapped(_First);
    auto _UMid = _STD _Get_unwrapped(_Mid);
    const auto _ULast = _STD _Get_unwrapped(_Last);
    if (_UFirst == _UMid) {
        return _Last;
    }

    if (_UMid == _ULast) {
        return _First;
    }

    if constexpr (_Is_cpp17_random_iter_v<_FwdIt>) {
        _STD reverse(_UFirst, _UMid);
        _STD reverse(_UMid, _ULast);
        _STD reverse(_UFirst, _ULast);
        _STD _Seek_wrapped(_First, _UFirst + (_ULast - _UMid));
    }
    else if constexpr (_Is_cpp17_bidi_iter_v<_FwdIt>) {
        _STD reverse(_UFirst, _UMid);
        _STD reverse(_UMid, _ULast);
        auto _Tmp = _STD _Reverse_until_sentinel_unchecked(_UFirst, _UMid, _ULast);
        _STD reverse(_Tmp.first, _Tmp.second);
        _STD _Seek_wrapped(_First, _UMid != _Tmp.first ? _Tmp.first : _Tmp.second);
    }
    else {
        auto _UNext = _UMid;
        do { // rotate the first cycle
            swap(*_UFirst, *_UNext); // intentional ADL
            ++_UFirst;
            ++_UNext;
            if (_UFirst == _UMid) {
                _UMid = _UNext;
            }
        } while (_UNext != _ULast);
        _STD _Seek_wrapped(_First, _UFirst);
        while (_UMid != _ULast) { // rotate subsequent cycles
            _UNext = _UMid;
            do {
                swap(*_UFirst, *_UNext); // intentional ADL
                ++_UFirst;
                ++_UNext;
                if (_UFirst == _UMid) {
                    _UMid = _UNext;
                }
            } while (_UNext != _ULast);
        }
    }

    return _First;
}

#if _HAS_CXX17
_EXPORT_STD template <class _ExPo, class _FwdIt, _Enable_if_execution_policy_t<_ExPo> = 0>
_FwdIt rotate(_ExPo&&, _FwdIt _First, _FwdIt _Mid, _FwdIt _Last) noexcept /* terminates */ {
    // rotate [_First, _Last) left by distance(_First, _Mid) positions
    // not parallelized as benchmarks show it isn't worth it
    _REQUIRE_CPP17_MUTABLE_ITERATOR(_FwdIt);
    return _STD rotate(_First, _Mid, _Last);
}
#endif // _HAS_CXX17

_EXPORT_STD template <class _InIt, class _Pr>
_NODISCARD _CONSTEXPR20 _InIt find_if(_InIt _First, const _InIt _Last, _Pr _Pred) { // find first satisfying _Pred
    _STD _Adl_verify_range(_First, _Last);
    auto _UFirst = _STD _Get_unwrapped(_First);
    const auto _ULast = _STD _Get_unwrapped(_Last);
    for (; _UFirst != _ULast; ++_UFirst) {
        if (_Pred(*_UFirst)) {
            break;
        }
    }

    _STD _Seek_wrapped(_First, _UFirst);
    return _First;
}

#if _HAS_CXX20
namespace ranges {
    template <class _Result, class _Wrapped, class _Unwrapped>
    _NODISCARD constexpr _Result _Rewrap_subrange(_Wrapped& _Val, subrange<_Unwrapped>&& _UResult) {
        // conditionally computes a wrapped subrange from a wrapped iterator or range and unwrapped subrange
        if constexpr (is_same_v<_Result, dangling>) {
            return dangling{};
        }
        else if constexpr (is_same_v<_Result, subrange<_Unwrapped>>) {
            return _STD move(_UResult);
        }
        else if constexpr (range<_Wrapped>) {
            _STL_INTERNAL_STATIC_ASSERT(forward_range<_Wrapped>);
            _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Unwrapped, _Unwrapped_iterator_t<_Wrapped>>);
            _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Result, subrange<iterator_t<_Wrapped>>>);

            auto _First = _RANGES begin(_Val);
            auto _Last = _First;
            _First._Seek_to(_UResult.begin());
            _Last._Seek_to(_UResult.end());
            return _Result{ _STD move(_First), _STD move(_Last) };
        }
        else {
            _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Unwrapped, _Unwrapped_t<_Wrapped>>);
            _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Result, subrange<_Wrapped>>);

            auto _Last = _Val;
            _Val._Seek_to(_UResult.begin());
            _Last._Seek_to(_UResult.end());
            return _Result{ _STD move(_Val), _STD move(_Last) };
        }
    }

    // concept-constrained for strict enforcement as it is used by several algorithms
    template <input_iterator _It, sentinel_for<_It> _Se, class _Pj, indirect_unary_predicate<projected<_It, _Pj>> _Pr>
    _NODISCARD constexpr _It _Find_if_unchecked(_It _First, const _Se _Last, _Pr _Pred, _Pj _Proj) {
        for (; _First != _Last; ++_First) {
            if (_STD invoke(_Pred, _STD invoke(_Proj, *_First))) {
                break;
            }
        }

        return _First;
    }

    class _Find_if_fn {
    public:
        template <input_iterator _It, sentinel_for<_It> _Se, class _Pj = identity,
            indirect_unary_predicate<projected<_It, _Pj>> _Pr>
        _NODISCARD _STATIC_CALL_OPERATOR constexpr _It operator()(
            _It _First, _Se _Last, _Pr _Pred, _Pj _Proj = {}) _CONST_CALL_OPERATOR {
            _STD _Adl_verify_range(_First, _Last);
            auto _UResult = _RANGES _Find_if_unchecked(_RANGES _Unwrap_iter<_Se>(_STD move(_First)),
                _RANGES _Unwrap_sent<_It>(_STD move(_Last)), _STD _Pass_fn(_Pred), _STD _Pass_fn(_Proj));

            _STD _Seek_wrapped(_First, _STD move(_UResult));
            return _First;
        }

        template <input_range _Rng, class _Pj = identity,
            indirect_unary_predicate<projected<iterator_t<_Rng>, _Pj>> _Pr>
        _NODISCARD _STATIC_CALL_OPERATOR constexpr borrowed_iterator_t<_Rng> operator()(
            _Rng&& _Range, _Pr _Pred, _Pj _Proj = {}) _CONST_CALL_OPERATOR {
            auto _First = _RANGES begin(_Range);
            auto _UResult = _RANGES _Find_if_unchecked(_RANGES _Unwrap_range_iter<_Rng>(_STD move(_First)),
                _Uend(_Range), _STD _Pass_fn(_Pred), _STD _Pass_fn(_Proj));

            _STD _Seek_wrapped(_First, _STD move(_UResult));
            return _First;
        }
    };

    _EXPORT_STD inline constexpr _Find_if_fn find_if;

    class _Find_if_not_fn {
    public:
        template <input_iterator _It, sentinel_for<_It> _Se, class _Pj = identity,
            indirect_unary_predicate<projected<_It, _Pj>> _Pr>
        _NODISCARD _STATIC_CALL_OPERATOR constexpr _It operator()(
            _It _First, _Se _Last, _Pr _Pred, _Pj _Proj = {}) _CONST_CALL_OPERATOR {
            _STD _Adl_verify_range(_First, _Last);

            auto _UResult = _Find_if_not_unchecked(_RANGES _Unwrap_iter<_Se>(_STD move(_First)),
                _RANGES _Unwrap_sent<_It>(_STD move(_Last)), _STD _Pass_fn(_Pred), _STD _Pass_fn(_Proj));

            _STD _Seek_wrapped(_First, _STD move(_UResult));
            return _First;
        }

        template <input_range _Rng, class _Pj = identity,
            indirect_unary_predicate<projected<iterator_t<_Rng>, _Pj>> _Pr>
        _NODISCARD _STATIC_CALL_OPERATOR constexpr borrowed_iterator_t<_Rng> operator()(
            _Rng&& _Range, _Pr _Pred, _Pj _Proj = {}) _CONST_CALL_OPERATOR {
            auto _First = _RANGES begin(_Range);

            auto _UResult = _Find_if_not_unchecked(_RANGES _Unwrap_range_iter<_Rng>(_STD move(_First)), _Uend(_Range),
                _STD _Pass_fn(_Pred), _STD _Pass_fn(_Proj));

            _STD _Seek_wrapped(_First, _STD move(_UResult));
            return _First;
        }

    private:
        template <class _It, class _Se, class _Pj, class _Pr>
        _NODISCARD static constexpr _It _Find_if_not_unchecked(_It _First, const _Se _Last, _Pr _Pred, _Pj _Proj) {
            _STL_INTERNAL_STATIC_ASSERT(input_iterator<_It>);
            _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se, _It>);
            _STL_INTERNAL_STATIC_ASSERT(indirect_unary_predicate<_Pr, projected<_It, _Pj>>);

            for (; _First != _Last; ++_First) {
                if (!_STD invoke(_Pred, _STD invoke(_Proj, *_First))) {
                    break;
                }
            }

            return _First;
        }
    };

    _EXPORT_STD inline constexpr _Find_if_not_fn find_if_not;

    class _Adjacent_find_fn {
    public:
        template <forward_iterator _It, sentinel_for<_It> _Se, class _Pj = identity,
            indirect_binary_predicate<projected<_It, _Pj>, projected<_It, _Pj>> _Pr = ranges::equal_to>
        _NODISCARD _STATIC_CALL_OPERATOR constexpr _It operator()(
            _It _First, _Se _Last, _Pr _Pred = {}, _Pj _Proj = {}) _CONST_CALL_OPERATOR {
            _STD _Adl_verify_range(_First, _Last);

            auto _UResult = _Adjacent_find_unchecked(_RANGES _Unwrap_iter<_Se>(_STD move(_First)),
                _RANGES _Unwrap_sent<_It>(_STD move(_Last)), _STD _Pass_fn(_Pred), _STD _Pass_fn(_Proj));

            _STD _Seek_wrapped(_First, _STD move(_UResult));
            return _First;
        }

        template <forward_range _Rng, class _Pj = identity,
            indirect_binary_predicate<projected<iterator_t<_Rng>, _Pj>, projected<iterator_t<_Rng>, _Pj>> _Pr =
            ranges::equal_to>
        _NODISCARD _STATIC_CALL_OPERATOR constexpr borrowed_iterator_t<_Rng> operator()(
            _Rng&& _Range, _Pr _Pred = {}, _Pj _Proj = {}) _CONST_CALL_OPERATOR {
            auto _UResult =
                _Adjacent_find_unchecked(_Ubegin(_Range), _Uend(_Range), _STD _Pass_fn(_Pred), _STD _Pass_fn(_Proj));

            return _RANGES _Rewrap_iterator(_Range, _STD move(_UResult));
        }

    private:
        template <class _It, class _Se, class _Pj, class _Pr>
        _NODISCARD static constexpr _It _Adjacent_find_unchecked(_It _First, const _Se _Last, _Pr _Pred, _Pj _Proj) {
            // find first satisfying _Pred with successor
            _STL_INTERNAL_STATIC_ASSERT(forward_iterator<_It>);
            _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se, _It>);
            _STL_INTERNAL_STATIC_ASSERT(indirect_binary_predicate<_Pr, projected<_It, _Pj>, projected<_It, _Pj>>);

            if (_First == _Last) {
                return _First;
            }

            for (auto _Next = _First;; ++_First) {
                if (++_Next == _Last) {
                    return _Next;
                }

                if (_STD invoke(_Pred, _STD invoke(_Proj, *_First), _STD invoke(_Proj, *_Next))) {
                    return _First;
                }
            }
        }
    };

    _EXPORT_STD inline constexpr _Adjacent_find_fn adjacent_find;

    template <class _It1, class _It2, class _Se2, class _Pr, class _Pj1, class _Pj2>
    concept _Equal_rev_pred_can_memcmp = is_same_v<_Pj1, identity>&& is_same_v<_Pj2, identity>
        && sized_sentinel_for<_Se2, _It2>&& _Equal_memcmp_is_safe<_It1, _It2, _Pr>;

    template <forward_iterator _It1, input_iterator _It2, sentinel_for<_It2> _Se2, class _Pr, class _Pj1, class _Pj2>
        requires indirectly_comparable<_It1, _It2, _Pr, _Pj1, _Pj2>
    _NODISCARD constexpr pair<bool, _It1> _Equal_rev_pred(
        _It1 _First1, _It2 _First2, const _Se2 _Last2, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
        // Returns {true, _First1 + (_Last2 - _First2)} if [_First1, ...) equals [_First2, _Last2), and {false, {}}
        // otherwise.
        constexpr bool _Optimize = _Equal_rev_pred_can_memcmp<_It1, _It2, _Se2, _Pr, _Pj1, _Pj2>;
        if constexpr (_Optimize) {
            if (!_STD is_constant_evaluated()) {
                bool _Ans;
                if constexpr (same_as<_It2, _Se2>) {
                    _Ans = _STD _Memcmp_ranges(_First2, _Last2, _First1) == 0;
                }
                else {
                    _Ans = _STD _Memcmp_count(_First1, _First2, static_cast<size_t>(_Last2 - _First2)) == 0;
                }

                if (_Ans) {
                    _First1 += (_Last2 - _First2);
                    return { true, _STD move(_First1) };
                }
                else {
                    return { false, _It1 {} };
                }
            }
        }

        for (; _First2 != _Last2; ++_First1, (void) ++_First2) {
            if (!_STD invoke(_Pred, _STD invoke(_Proj1, *_First1), _STD invoke(_Proj2, *_First2))) {
                return { false, _It1 {} };
            }
        }

        return { true, _STD move(_First1) };
    }

    class _Search_fn {
    public:
        template <forward_iterator _It1, sentinel_for<_It1> _Se1, forward_iterator _It2, sentinel_for<_It2> _Se2,
            class _Pr = ranges::equal_to, class _Pj1 = identity, class _Pj2 = identity>
            requires indirectly_comparable<_It1, _It2, _Pr, _Pj1, _Pj2>
        _NODISCARD _STATIC_CALL_OPERATOR constexpr subrange<_It1> operator()(_It1 _First1, _Se1 _Last1, _It2 _First2,
            _Se2 _Last2, _Pr _Pred = {}, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) _CONST_CALL_OPERATOR {
            _STD _Adl_verify_range(_First1, _Last1);
            _STD _Adl_verify_range(_First2, _Last2);
            auto _UFirst1 = _RANGES _Unwrap_iter<_Se1>(_STD move(_First1));
            auto _ULast1 = _RANGES _Unwrap_sent<_It1>(_STD move(_Last1));
            auto _UFirst2 = _RANGES _Unwrap_iter<_Se2>(_STD move(_First2));
            auto _ULast2 = _RANGES _Unwrap_sent<_It2>(_STD move(_Last2));

            if constexpr (sized_sentinel_for<_Se1, _It1> && sized_sentinel_for<_Se2, _It2>) {
                const auto _Count1 = _ULast1 - _UFirst1;
                const auto _Count2 = _ULast2 - _UFirst2;
                auto _UResult = _Search_sized(_STD move(_UFirst1), _STD move(_ULast1), _Count1, _STD move(_UFirst2),
                    _STD move(_ULast2), _Count2, _STD _Pass_fn(_Pred), _STD _Pass_fn(_Proj1), _STD _Pass_fn(_Proj2));
                return _RANGES _Rewrap_subrange<subrange<_It1>>(_First1, _STD move(_UResult));
            }
            else {
                auto _UResult = _Search_unsized(_STD move(_UFirst1), _STD move(_ULast1), _STD move(_UFirst2),
                    _STD move(_ULast2), _STD _Pass_fn(_Pred), _STD _Pass_fn(_Proj1), _STD _Pass_fn(_Proj2));
                return _RANGES _Rewrap_subrange<subrange<_It1>>(_First1, _STD move(_UResult));
            }
        }

        template <forward_range _Rng1, forward_range _Rng2, class _Pr = ranges::equal_to, class _Pj1 = identity,
            class _Pj2 = identity>
            requires indirectly_comparable<iterator_t<_Rng1>, iterator_t<_Rng2>, _Pr, _Pj1, _Pj2>
        _NODISCARD _STATIC_CALL_OPERATOR constexpr borrowed_subrange_t<_Rng1> operator()(
            _Rng1&& _Range1, _Rng2&& _Range2, _Pr _Pred = {}, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) _CONST_CALL_OPERATOR {
            if constexpr (sized_range<_Rng1> && sized_range<_Rng2>) {
                const auto _Count1 = _RANGES distance(_Range1);
                const auto _Count2 = _RANGES distance(_Range2);
                auto _UResult = _Search_sized(_Ubegin(_Range1), _Uend(_Range1), _Count1, _Ubegin(_Range2),
                    _Uend(_Range2), _Count2, _STD _Pass_fn(_Pred), _STD _Pass_fn(_Proj1), _STD _Pass_fn(_Proj2));
                return _RANGES _Rewrap_subrange<borrowed_subrange_t<_Rng1>>(_Range1, _STD move(_UResult));
            }
            else {
                auto _UResult = _Search_unsized(_Ubegin(_Range1), _Uend(_Range1), _Ubegin(_Range2), _Uend(_Range2),
                    _STD _Pass_fn(_Pred), _STD _Pass_fn(_Proj1), _STD _Pass_fn(_Proj2));
                return _RANGES _Rewrap_subrange<borrowed_subrange_t<_Rng1>>(_Range1, _STD move(_UResult));
            }
        }

    private:
        template <class _It1, class _Se1, class _It2, class _Se2, class _Pr, class _Pj1, class _Pj2>
        _NODISCARD static constexpr subrange<_It1> _Search_sized(_It1 _First1, const _Se1 _Last1,
            iter_difference_t<_It1> _Count1, _It2 _First2, const _Se2 _Last2, const iter_difference_t<_It2> _Count2,
            _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
            _STL_INTERNAL_STATIC_ASSERT(forward_iterator<_It1>);
            _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se1, _It1>);
            _STL_INTERNAL_STATIC_ASSERT(forward_iterator<_It2>);
            _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se2, _It2>);
            _STL_INTERNAL_STATIC_ASSERT(indirectly_comparable<_It1, _It2, _Pr, _Pj1, _Pj2>);
            _STL_INTERNAL_CHECK(_RANGES distance(_First1, _Last1) == _Count1);
            _STL_INTERNAL_CHECK(_RANGES distance(_First2, _Last2) == _Count2);

            for (; _Count1 >= _Count2; ++_First1, (void) --_Count1) {
                auto _Match_and_mid1 = _RANGES _Equal_rev_pred(_First1, _First2, _Last2, _Pred, _Proj1, _Proj2);
                if (_Match_and_mid1.first) {
                    return { _STD move(_First1), _STD move(_Match_and_mid1.second) };
                }
            }

            _First1 = _RANGES _Find_last_iterator(_First1, _Last1, _Count1);
            return { _First1, _First1 };
        }

        template <class _It1, class _Se1, class _It2, class _Se2, class _Pr, class _Pj1, class _Pj2>
        _NODISCARD static constexpr subrange<_It1> _Search_unsized(
            _It1 _First1, const _Se1 _Last1, _It2 _First2, const _Se2 _Last2, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
            _STL_INTERNAL_STATIC_ASSERT(forward_iterator<_It1>);
            _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se1, _It1>);
            _STL_INTERNAL_STATIC_ASSERT(forward_iterator<_It2>);
            _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se2, _It2>);
            _STL_INTERNAL_STATIC_ASSERT(indirectly_comparable<_It1, _It2, _Pr, _Pj1, _Pj2>);

            for (;; ++_First1) {
                auto _Mid1 = _First1;
                for (auto _Mid2 = _First2;; ++_Mid1, (void) ++_Mid2) {
                    if (_Mid2 == _Last2) { // match
                        return { _STD move(_First1), _STD move(_Mid1) };
                    }

                    if (_Mid1 == _Last1) { // not enough haystack left to find a match
                        return { _Mid1, _Mid1 };
                    }

                    if (!_STD invoke(_Pred, _STD invoke(_Proj1, *_Mid1), _STD invoke(_Proj2, *_Mid2))) { // mismatch
                        break;
                    }
                }
            }
        }
    };

    _EXPORT_STD inline constexpr _Search_fn search;
} // namespace ranges
#endif // _HAS_CXX20

template <class _Iter, class _Pr, class _Elem = _Iter_value_t<_Iter>>
_INLINE_VAR constexpr bool _Is_min_max_optimization_safe = // Activate the vector algorithms for min_/max_element?
_Iterator_is_contiguous<_Iter> // The iterator must be contiguous so we can get raw pointers.
&& !_Iterator_is_volatile<_Iter> // The iterator must not be volatile.
&& conjunction_v<disjunction<
#if _USE_STD_VECTOR_FLOATING_ALGORITHMS
#if defined(__LDBL_DIG__) && __LDBL_DIG__ == 18
    is_same<_Elem, float>, is_same<_Elem, double>,
#else // ^^^ 80-bit long double (not supported by MSVC in general, see GH-1316) / 64-bit long double vvv
    is_floating_point<_Elem>, // Element is floating-point or...
#endif // ^^^ 64-bit long double ^^^
#endif // _USE_STD_VECTOR_FLOATING_ALGORITHMS
    is_integral<_Elem>, is_pointer<_Elem>>, // ... integral or pointer type.
    disjunction< // And either of the following:
#if _HAS_CXX20
    is_same<_Pr, _RANGES less>, // predicate is ranges::less
#endif // _HAS_CXX20
    is_same<_Pr, less<>>, is_same<_Pr, less<_Elem>>>>; // predicate is less

template <class _FwdIt, class _Pr>
constexpr _FwdIt _Max_element_unchecked(_FwdIt _First, _FwdIt _Last, _Pr _Pred) { // find largest element
#if _USE_STD_VECTOR_ALGORITHMS
    if constexpr (_Is_min_max_optimization_safe<_FwdIt, _Pr>) {
        if (!_Is_constant_evaluated()) {
            const auto _First_ptr = _STD _To_address(_First);
            const auto _Result = _STD __std_max_element(_First_ptr, _STD _To_address(_Last));
            if constexpr (is_pointer_v<_FwdIt>) {
                return _Result;
            }
            else {
                return _First + (_Result - _First_ptr);
            }
        }
    }
#endif // _USE_STD_VECTOR_ALGORITHMS

    _FwdIt _Found = _First;
    if (_First != _Last) {
        while (++_First != _Last) {
            if (_DEBUG_LT_PRED(_Pred, *_Found, *_First)) {
                _Found = _First;
            }
        }
    }

    return _Found;
}

_EXPORT_STD template <class _FwdIt, class _Pr>
_NODISCARD constexpr _FwdIt max_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred) { // find largest element
    _STD _Adl_verify_range(_First, _Last);
    _STD _Seek_wrapped(_First,
        _STD _Max_element_unchecked(_STD _Get_unwrapped(_First), _STD _Get_unwrapped(_Last), _STD _Pass_fn(_Pred)));
    return _First;
}

_EXPORT_STD template <class _FwdIt>
_NODISCARD constexpr _FwdIt max_element(_FwdIt _First, _FwdIt _Last) { // find largest element
    return _STD max_element(_First, _Last, less<>{});
}

#if _HAS_CXX17
_EXPORT_STD template <class _ExPo, class _FwdIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
_NODISCARD _FwdIt max_element(_ExPo&&, _FwdIt _First, _FwdIt _Last, _Pr _Pred) noexcept /* terminates */ {
    // find largest element
    // not parallelized at present, parallelism expected to be feasible in a future release
    _REQUIRE_PARALLEL_ITERATOR(_FwdIt);
    return _STD max_element(_First, _Last, _STD _Pass_fn(_Pred));
}

_EXPORT_STD template <class _ExPo, class _FwdIt, _Enable_if_execution_policy_t<_ExPo> = 0>
_NODISCARD _FwdIt max_element(_ExPo&&, _FwdIt _First, _FwdIt _Last) noexcept /* terminates */ {
    // find largest element
    // not parallelized at present, parallelism expected to be feasible in a future release
    _REQUIRE_PARALLEL_ITERATOR(_FwdIt);
    return _STD max_element(_First, _Last);
}

#if _HAS_CXX20
namespace ranges {
    template <class _It, class _Se, class _Pr, class _Pj>
    _NODISCARD constexpr _It _Max_element_unchecked(_It _First, const _Se _Last, _Pr _Pred, _Pj _Proj) {
        _STL_INTERNAL_STATIC_ASSERT(forward_iterator<_It>);
        _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se, _It>);
        _STL_INTERNAL_STATIC_ASSERT(indirect_strict_weak_order<_Pr, projected<_It, _Pj>>);

#if _USE_STD_VECTOR_ALGORITHMS
        if constexpr (is_same_v<_Pj, identity> && _Is_min_max_optimization_safe<_It, _Pr>
            && sized_sentinel_for<_Se, _It>) {
            if (!_STD is_constant_evaluated()) {
                const auto _First_ptr = _STD to_address(_First);
                const auto _Last_ptr = _First_ptr + (_Last - _First);
                const auto _Result = _STD __std_max_element(_First_ptr, _Last_ptr);
                if constexpr (is_pointer_v<_It>) {
                    return _Result;
                }
                else {
                    return _First + (_Result - _First_ptr);
                }
            }
        }
#endif // _USE_STD_VECTOR_ALGORITHMS

        auto _Found = _First;
        if (_First == _Last) {
            return _Found;
        }

        while (++_First != _Last) {
            if (_STD invoke(_Pred, _STD invoke(_Proj, *_Found), _STD invoke(_Proj, *_First))) {
                _Found = _First;
            }
        }

        return _Found;
    }

    class _Max_element_fn {
    public:
        template <forward_iterator _It, sentinel_for<_It> _Se, class _Pj = identity,
            indirect_strict_weak_order<projected<_It, _Pj>> _Pr = ranges::less>
        _NODISCARD _STATIC_CALL_OPERATOR constexpr _It operator()(
            _It _First, _Se _Last, _Pr _Pred = {}, _Pj _Proj = {}) _CONST_CALL_OPERATOR {
            _STD _Adl_verify_range(_First, _Last);
            _STD _Seek_wrapped(
                _First, _RANGES _Max_element_unchecked(_RANGES _Unwrap_iter<_Se>(_STD move(_First)),
                    _RANGES _Unwrap_sent<_It>(_STD move(_Last)), _STD _Pass_fn(_Pred), _STD _Pass_fn(_Proj)));
            return _First;
        }

        template <forward_range _Rng, class _Pj = identity,
            indirect_strict_weak_order<projected<iterator_t<_Rng>, _Pj>> _Pr = ranges::less>
        _NODISCARD _STATIC_CALL_OPERATOR constexpr borrowed_iterator_t<_Rng> operator()(
            _Rng&& _Range, _Pr _Pred = {}, _Pj _Proj = {}) _CONST_CALL_OPERATOR {
            auto _UResult = _RANGES _Max_element_unchecked(
                _Ubegin(_Range), _Uend(_Range), _STD _Pass_fn(_Pred), _STD _Pass_fn(_Proj));
            return _RANGES _Rewrap_iterator(_Range, _STD move(_UResult));
        }
    };

    _EXPORT_STD inline constexpr _Max_element_fn max_element;
} // namespace ranges
#endif // _HAS_CXX20
#endif // _HAS_CXX17

_EXPORT_STD template <class _Ty, class _Pr>
_NODISCARD constexpr _Ty(max)(initializer_list<_Ty> _Ilist, _Pr _Pred) {
    // return leftmost/largest
    _STL_ASSERT(
        _Ilist.size() != 0, "An initializer_list passed to std::max must not be empty. (N4971 [alg.min.max]/13)");
#if _USE_STD_VECTOR_ALGORITHMS
    if constexpr (_Is_min_max_optimization_safe<const _Ty*, _Pr>) {
        if (!_Is_constant_evaluated()) {
            return static_cast<_Ty>(_STD __std_max(_Ilist.begin(), _Ilist.end()));
        }
    }
#endif // _USE_STD_VECTOR_ALGORITHMS
    const _Ty* _Res = _STD _Max_element_unchecked(_Ilist.begin(), _Ilist.end(), _STD _Pass_fn(_Pred));
    return *_Res;
}

_EXPORT_STD template <class _Ty>
_NODISCARD constexpr _Ty(max)(initializer_list<_Ty> _Ilist) {
    // return leftmost/largest
    return (_STD max)(_Ilist, less<>{});
}

#if _HAS_CXX20
namespace ranges {
    template <class _It>
    concept _Prefer_iterator_copies = // When we have a choice, should we copy iterators or copy elements?
        // pre: input_iterator<_It>
        sizeof(_It) <= 2 * sizeof(iter_value_t<_It>)
        && (is_trivially_copyable_v<_It> || !is_trivially_copyable_v<iter_value_t<_It>>);

    class _Max_fn {
    public:
        template <class _Ty, class _Pj = identity,
            indirect_strict_weak_order<projected<const _Ty*, _Pj>> _Pr = ranges::less>
        _NODISCARD _STATIC_CALL_OPERATOR constexpr const _Ty& operator()(
            const _Ty& _Left, const _Ty& _Right, _Pr _Pred = {}, _Pj _Proj = {}) _CONST_CALL_OPERATOR {
            if (_STD invoke(_Pred, _STD invoke(_Proj, _Left), _STD invoke(_Proj, _Right))) {
                return _Right;
            }
            else {
                return _Left;
            }
        }

        template <copyable _Ty, class _Pj = identity,
            indirect_strict_weak_order<projected<const _Ty*, _Pj>> _Pr = ranges::less>
        _NODISCARD _STATIC_CALL_OPERATOR constexpr _Ty operator()(
            initializer_list<_Ty> _Range, _Pr _Pred = {}, _Pj _Proj = {}) _CONST_CALL_OPERATOR {
            const auto _First = _Range.begin();
            const auto _Last = _Range.end();
            _STL_ASSERT(_First != _Last,
                "An initializer_list passed to std::ranges::max must not be empty. (N4971 [alg.min.max]/13)");
#if _USE_STD_VECTOR_ALGORITHMS
            if constexpr (is_same_v<_Pj, identity> && _Is_min_max_optimization_safe<const _Ty*, _Pr>) {
                if (!_STD is_constant_evaluated()) {
                    return static_cast<_Ty>(_STD __std_max(_First, _Last));
                }
            }
#endif // _USE_STD_VECTOR_ALGORITHMS
            return *_RANGES _Max_element_unchecked(_First, _Last, _STD _Pass_fn(_Pred), _STD _Pass_fn(_Proj));
        }

        template <input_range _Rng, class _Pj = identity,
            indirect_strict_weak_order<projected<iterator_t<_Rng>, _Pj>> _Pr = ranges::less>
            requires indirectly_copyable_storable<iterator_t<_Rng>, range_value_t<_Rng>*>
        _NODISCARD _STATIC_CALL_OPERATOR constexpr range_value_t<_Rng> operator()(
            _Rng&& _Range, _Pr _Pred = {}, _Pj _Proj = {}) _CONST_CALL_OPERATOR {
            auto _UFirst = _Ubegin(_Range);
            auto _ULast = _Uend(_Range);
            _STL_ASSERT(
                _UFirst != _ULast, "A range passed to std::ranges::max must not be empty. (N4971 [alg.min.max]/13)");
#if _USE_STD_VECTOR_ALGORITHMS
            if constexpr (is_same_v<_Pj, identity> && _Is_min_max_optimization_safe<decltype(_UFirst), _Pr>
                && sized_sentinel_for<decltype(_ULast), decltype(_UFirst)>) {
                if (!_STD is_constant_evaluated()) {
                    const auto _First_ptr = _STD to_address(_UFirst);
                    const auto _Last_ptr = _First_ptr + (_ULast - _UFirst);
                    return static_cast<range_value_t<_Rng>>(_STD __std_max(_First_ptr, _Last_ptr));
                }
            }
#endif // _USE_STD_VECTOR_ALGORITHMS
            if constexpr (forward_range<_Rng> && _Prefer_iterator_copies<iterator_t<_Rng>>) {
                return static_cast<range_value_t<_Rng>>(*_RANGES _Max_element_unchecked(
                    _STD move(_UFirst), _STD move(_ULast), _STD _Pass_fn(_Pred), _STD _Pass_fn(_Proj)));
            }
            else {
                range_value_t<_Rng> _Found(*_UFirst);
                while (++_UFirst != _ULast) {
                    if (_STD invoke(_Pred, _STD invoke(_Proj, _Found), _STD invoke(_Proj, *_UFirst))) {
                        _Found = *_UFirst;
                    }
                }

                return _Found;
            }
        }
    };

    _EXPORT_STD inline constexpr _Max_fn max;
} // namespace ranges
#endif // _HAS_CXX20

template <class _FwdIt, class _Pr>
constexpr _FwdIt _Min_element_unchecked(_FwdIt _First, _FwdIt _Last, _Pr _Pred) { // find smallest element
#if _USE_STD_VECTOR_ALGORITHMS
    if constexpr (_Is_min_max_optimization_safe<_FwdIt, _Pr>) {
        if (!_Is_constant_evaluated()) {
            const auto _First_ptr = _STD _To_address(_First);
            const auto _Result = _STD __std_min_element(_First_ptr, _STD _To_address(_Last));
            if constexpr (is_pointer_v<_FwdIt>) {
                return _Result;
            }
            else {
                return _First + (_Result - _First_ptr);
            }
        }
    }
#endif // _USE_STD_VECTOR_ALGORITHMS

    _FwdIt _Found = _First;
    if (_First != _Last) {
        while (++_First != _Last) {
            if (_DEBUG_LT_PRED(_Pred, *_First, *_Found)) {
                _Found = _First;
            }
        }
    }

    return _Found;
}

_EXPORT_STD template <class _FwdIt, class _Pr>
_NODISCARD constexpr _FwdIt min_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred) { // find smallest element
    _STD _Adl_verify_range(_First, _Last);
    _STD _Seek_wrapped(_First,
        _STD _Min_element_unchecked(_STD _Get_unwrapped(_First), _STD _Get_unwrapped(_Last), _STD _Pass_fn(_Pred)));
    return _First;
}

_EXPORT_STD template <class _FwdIt>
_NODISCARD constexpr _FwdIt min_element(_FwdIt _First, _FwdIt _Last) { // find smallest element
    return _STD min_element(_First, _Last, less<>{});
}

#if _HAS_CXX17
_EXPORT_STD template <class _ExPo, class _FwdIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
_NODISCARD _FwdIt min_element(_ExPo&&, _FwdIt _First, _FwdIt _Last, _Pr _Pred) noexcept /* terminates */ {
    // find smallest element
    // not parallelized at present, parallelism expected to be feasible in a future release
    _REQUIRE_PARALLEL_ITERATOR(_FwdIt);
    return _STD min_element(_First, _Last, _STD _Pass_fn(_Pred));
}

_EXPORT_STD template <class _ExPo, class _FwdIt, _Enable_if_execution_policy_t<_ExPo> = 0>
_NODISCARD _FwdIt min_element(_ExPo&&, _FwdIt _First, _FwdIt _Last) noexcept /* terminates */ {
    // find smallest element
    // not parallelized at present, parallelism expected to be feasible in a future release
    _REQUIRE_PARALLEL_ITERATOR(_FwdIt);
    return _STD min_element(_First, _Last);
}

#if _HAS_CXX20
namespace ranges {
    template <class _It, class _Se, class _Pr, class _Pj>
    _NODISCARD constexpr _It _Min_element_unchecked(_It _First, const _Se _Last, _Pr _Pred, _Pj _Proj) {
        _STL_INTERNAL_STATIC_ASSERT(forward_iterator<_It>);
        _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se, _It>);
        _STL_INTERNAL_STATIC_ASSERT(indirect_strict_weak_order<_Pr, projected<_It, _Pj>>);

#if _USE_STD_VECTOR_ALGORITHMS
        if constexpr (is_same_v<_Pj, identity> && _Is_min_max_optimization_safe<_It, _Pr>
            && sized_sentinel_for<_Se, _It>) {
            if (!_STD is_constant_evaluated()) {
                const auto _First_ptr = _STD to_address(_First);
                const auto _Last_ptr = _First_ptr + (_Last - _First);
                const auto _Result = _STD __std_min_element(_First_ptr, _Last_ptr);
                if constexpr (is_pointer_v<_It>) {
                    return _Result;
                }
                else {
                    return _First + (_Result - _First_ptr);
                }
            }
        }
#endif // _USE_STD_VECTOR_ALGORITHMS

        auto _Found = _First;
        if (_First == _Last) {
            return _Found;
        }

        while (++_First != _Last) {
            if (_STD invoke(_Pred, _STD invoke(_Proj, *_First), _STD invoke(_Proj, *_Found))) {
                _Found = _First;
            }
        }

        return _Found;
    }

    class _Min_element_fn {
    public:
        template <forward_iterator _It, sentinel_for<_It> _Se, class _Pj = identity,
            indirect_strict_weak_order<projected<_It, _Pj>> _Pr = ranges::less>
        _NODISCARD _STATIC_CALL_OPERATOR constexpr _It operator()(
            _It _First, _Se _Last, _Pr _Pred = {}, _Pj _Proj = {}) _CONST_CALL_OPERATOR {
            _STD _Adl_verify_range(_First, _Last);
            _STD _Seek_wrapped(
                _First, _RANGES _Min_element_unchecked(_RANGES _Unwrap_iter<_Se>(_STD move(_First)),
                    _RANGES _Unwrap_sent<_It>(_STD move(_Last)), _STD _Pass_fn(_Pred), _STD _Pass_fn(_Proj)));
            return _First;
        }

        template <forward_range _Rng, class _Pj = identity,
            indirect_strict_weak_order<projected<iterator_t<_Rng>, _Pj>> _Pr = ranges::less>
        _NODISCARD _STATIC_CALL_OPERATOR constexpr borrowed_iterator_t<_Rng> operator()(
            _Rng&& _Range, _Pr _Pred = {}, _Pj _Proj = {}) _CONST_CALL_OPERATOR {
            auto _UResult = _RANGES _Min_element_unchecked(
                _Ubegin(_Range), _Uend(_Range), _STD _Pass_fn(_Pred), _STD _Pass_fn(_Proj));
            return _RANGES _Rewrap_iterator(_Range, _STD move(_UResult));
        }
    };

    _EXPORT_STD inline constexpr _Min_element_fn min_element;
} // namespace ranges
#endif // _HAS_CXX20
#endif // _HAS_CXX17

_EXPORT_STD template <class _Ty, class _Pr>
_NODISCARD constexpr _Ty(min)(initializer_list<_Ty> _Ilist, _Pr _Pred) {
    // return leftmost/smallest
    _STL_ASSERT(
        _Ilist.size() != 0, "An initializer_list passed to std::min must not be empty. (N4971 [alg.min.max]/5)");
#if _USE_STD_VECTOR_ALGORITHMS
    if constexpr (_Is_min_max_optimization_safe<const _Ty*, _Pr>) {
        if (!_Is_constant_evaluated()) {
            return static_cast<_Ty>(_STD __std_min(_Ilist.begin(), _Ilist.end()));
        }
    }
#endif // _USE_STD_VECTOR_ALGORITHMS
    const _Ty* _Res = _STD _Min_element_unchecked(_Ilist.begin(), _Ilist.end(), _STD _Pass_fn(_Pred));
    return *_Res;
}

_EXPORT_STD template <class _Ty>
_NODISCARD constexpr _Ty(min)(initializer_list<_Ty> _Ilist) {
    // return leftmost/smallest
    return (_STD min)(_Ilist, less<>{});
}

#if _HAS_CXX20
namespace ranges {
    class _Min_fn {
    public:
        template <class _Ty, class _Pj = identity,
            indirect_strict_weak_order<projected<const _Ty*, _Pj>> _Pr = ranges::less>
        _NODISCARD _STATIC_CALL_OPERATOR constexpr const _Ty& operator()(
            const _Ty& _Left, const _Ty& _Right, _Pr _Pred = {}, _Pj _Proj = {}) _CONST_CALL_OPERATOR {
            if (_STD invoke(_Pred, _STD invoke(_Proj, _Right), _STD invoke(_Proj, _Left))) {
                return _Right;
            }
            else {
                return _Left;
            }
        }

        template <copyable _Ty, class _Pj = identity,
            indirect_strict_weak_order<projected<const _Ty*, _Pj>> _Pr = ranges::less>
        _NODISCARD _STATIC_CALL_OPERATOR constexpr _Ty operator()(
            initializer_list<_Ty> _Range, _Pr _Pred = {}, _Pj _Proj = {}) _CONST_CALL_OPERATOR {
            const auto _First = _Range.begin();
            const auto _Last = _Range.end();
            _STL_ASSERT(_First != _Last,
                "An initializer_list passed to std::ranges::min must not be empty. (N4971 [alg.min.max]/5)");
#if _USE_STD_VECTOR_ALGORITHMS
            if constexpr (is_same_v<_Pj, identity> && _Is_min_max_optimization_safe<const _Ty*, _Pr>) {
                if (!_STD is_constant_evaluated()) {
                    return static_cast<_Ty>(_STD __std_min(_First, _Last));
                }
            }
#endif // _USE_STD_VECTOR_ALGORITHMS
            return *_RANGES _Min_element_unchecked(_First, _Last, _STD _Pass_fn(_Pred), _STD _Pass_fn(_Proj));
        }

        template <input_range _Rng, class _Pj = identity,
            indirect_strict_weak_order<projected<iterator_t<_Rng>, _Pj>> _Pr = ranges::less>
            requires indirectly_copyable_storable<iterator_t<_Rng>, range_value_t<_Rng>*>
        _NODISCARD _STATIC_CALL_OPERATOR constexpr range_value_t<_Rng> operator()(
            _Rng&& _Range, _Pr _Pred = {}, _Pj _Proj = {}) _CONST_CALL_OPERATOR {
            auto _UFirst = _Ubegin(_Range);
            auto _ULast = _Uend(_Range);
            _STL_ASSERT(
                _UFirst != _ULast, "A range passed to std::ranges::min must not be empty. (N4971 [alg.min.max]/5)");
#if _USE_STD_VECTOR_ALGORITHMS
            if constexpr (is_same_v<_Pj, identity> && _Is_min_max_optimization_safe<decltype(_UFirst), _Pr>
                && sized_sentinel_for<decltype(_ULast), decltype(_UFirst)>) {
                if (!_STD is_constant_evaluated()) {
                    const auto _First_ptr = _STD to_address(_UFirst);
                    const auto _Last_ptr = _First_ptr + (_ULast - _UFirst);
                    return static_cast<range_value_t<_Rng>>(_STD __std_min(_First_ptr, _Last_ptr));
                }
            }
#endif // _USE_STD_VECTOR_ALGORITHMS
            if constexpr (forward_range<_Rng> && _Prefer_iterator_copies<iterator_t<_Rng>>) {
                return static_cast<range_value_t<_Rng>>(*_RANGES _Min_element_unchecked(
                    _STD move(_UFirst), _STD move(_ULast), _STD _Pass_fn(_Pred), _STD _Pass_fn(_Proj)));
            }
            else {
                range_value_t<_Rng> _Found(*_UFirst);
                while (++_UFirst != _ULast) {
                    if (_STD invoke(_Pred, _STD invoke(_Proj, *_UFirst), _STD invoke(_Proj, _Found))) {
                        _Found = *_UFirst;
                    }
                }

                return _Found;
            }
        }
    };

    _EXPORT_STD inline constexpr _Min_fn min;
} // namespace ranges
#endif // _HAS_CXX20

_EXPORT_STD template <class _FwdIt, class _Ty, class _Pr>
_NODISCARD _CONSTEXPR20 _FwdIt lower_bound(_FwdIt _First, const _FwdIt _Last, const _Ty& _Val, _Pr _Pred) {
    // find first element not before _Val
    _STD _Adl_verify_range(_First, _Last);
    auto _UFirst = _STD _Get_unwrapped(_First);
    _Iter_diff_t<_FwdIt> _Count = _STD distance(_UFirst, _STD _Get_unwrapped(_Last));

    while (0 < _Count) { // divide and conquer, find half that contains answer
        const _Iter_diff_t<_FwdIt> _Count2 = _Count / 2;
        const auto _UMid = _STD next(_UFirst, _Count2);
        if (_Pred(*_UMid, _Val)) { // try top half
            _UFirst = _STD _Next_iter(_UMid);
            _Count -= _Count2 + 1;
        }
        else {
            _Count = _Count2;
        }
    }

    _STD _Seek_wrapped(_First, _UFirst);
    return _First;
}

_EXPORT_STD template <class _FwdIt, class _Ty>
_NODISCARD _CONSTEXPR20 _FwdIt lower_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val) {
    // find first element not before _Val
    return _STD lower_bound(_First, _Last, _Val, less<>{});
}

_EXPORT_STD template <class _FwdIt, class _Ty, class _Pr>
_NODISCARD _CONSTEXPR20 _FwdIt upper_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val, _Pr _Pred) {
    // find first element that _Val is before
    _STD _Adl_verify_range(_First, _Last);
    auto _UFirst = _STD _Get_unwrapped(_First);
    _Iter_diff_t<_FwdIt> _Count = _STD distance(_UFirst, _STD _Get_unwrapped(_Last));

    while (0 < _Count) { // divide and conquer, find half that contains answer
        _Iter_diff_t<_FwdIt> _Count2 = _Count / 2;
        const auto _UMid = _STD next(_UFirst, _Count2);
        if (_Pred(_Val, *_UMid)) {
            _Count = _Count2;
        }
        else { // try top half
            _UFirst = _STD _Next_iter(_UMid);
            _Count -= _Count2 + 1;
        }
    }

    _STD _Seek_wrapped(_First, _UFirst);
    return _First;
}

_EXPORT_STD template <class _FwdIt, class _Ty>
_NODISCARD _CONSTEXPR20 _FwdIt upper_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val) {
    // find first element that _Val is before
    return _STD upper_bound(_First, _Last, _Val, less<>{});
}

template <class _FwdIt1, class _FwdIt2>
_CONSTEXPR20 _FwdIt2 _Swap_ranges_unchecked(_FwdIt1 _First1, const _FwdIt1 _Last1, _FwdIt2 _First2) {
    // swap [_First1, _Last1) with [_First2, ...)

#if _USE_STD_VECTOR_ALGORITHMS
    using _Elem1 = remove_reference_t<_Iter_ref_t<_FwdIt1>>;
    using _Elem2 = remove_reference_t<_Iter_ref_t<_FwdIt2>>;
    if constexpr (is_same_v<_Elem1, _Elem2> && _Is_trivially_swappable_v<_Elem1>
        && _Iterators_are_contiguous<_FwdIt1, _FwdIt2>) {
#if _HAS_CXX20
        if (!_STD is_constant_evaluated())
#endif // _HAS_CXX20
        {
            ::__std_swap_ranges_trivially_swappable_noalias(
                _STD _To_address(_First1), _STD _To_address(_Last1), _STD _To_address(_First2));
            return _First2 + (_Last1 - _First1);
        }
    }
#endif // _USE_STD_VECTOR_ALGORITHMS

    for (; _First1 != _Last1; ++_First1, (void) ++_First2) {
        swap(*_First1, *_First2); // intentional ADL
    }

    return _First2;
}

extern "C++" [[noreturn]] _CRTIMP2_PURE void __CLRCALL_PURE_OR_CDECL _Xbad_alloc();
extern "C++" [[noreturn]] _CRTIMP2_PURE void __CLRCALL_PURE_OR_CDECL _Xinvalid_argument(_In_z_ const char*);
extern "C++" [[noreturn]] _CRTIMP2_PURE void __CLRCALL_PURE_OR_CDECL _Xlength_error(_In_z_ const char*);
extern "C++" [[noreturn]] _CRTIMP2_PURE void __CLRCALL_PURE_OR_CDECL _Xout_of_range(_In_z_ const char*);
extern "C++" [[noreturn]] _CRTIMP2_PURE void __CLRCALL_PURE_OR_CDECL _Xoverflow_error(_In_z_ const char*);
extern "C++" [[noreturn]] _CRTIMP2_PURE void __CLRCALL_PURE_OR_CDECL _Xruntime_error(_In_z_ const char*);
extern "C++" [[noreturn]] _CRTIMP2_PURE void __CLRCALL_PURE_OR_CDECL _XGetLastError();

_EXPORT_STD template <class _Category, class _Ty, class _Diff = ptrdiff_t, class _Pointer = _Ty*,
    class _Reference = _Ty&>
    struct _CXX17_DEPRECATE_ITERATOR_BASE_CLASS iterator { // base type for iterator classes
    using iterator_category = _Category;
    using value_type = _Ty;
    using difference_type = _Diff;
    using pointer = _Pointer;
    using reference = _Reference;
};

template <class _Ty, enable_if_t<is_floating_point_v<_Ty>, int> = 0>
_NODISCARD constexpr auto _Float_abs_bits(const _Ty& _Xx) noexcept {
    using _Traits = _Floating_type_traits<_Ty>;
    using _Uint_type = typename _Traits::_Uint_type;
    const auto _Bits = _Bit_cast<_Uint_type>(_Xx);
    return _Bits & ~_Traits::_Shifted_sign_mask;
}

template <class _Ty, enable_if_t<is_floating_point_v<_Ty>, int> = 0>
_NODISCARD constexpr _Ty _Float_abs(const _Ty _Xx) noexcept { // constexpr floating-point abs()
    return _Bit_cast<_Ty>(_Float_abs_bits(_Xx));
}

template <class _Ty, enable_if_t<is_floating_point_v<_Ty>, int> = 0>
_NODISCARD constexpr _Ty _Float_copysign(const _Ty _Magnitude, const _Ty _Sign) { // constexpr copysign()
    using _Traits = _Floating_type_traits<_Ty>;
    using _Uint_type = typename _Traits::_Uint_type;
    const auto _Signbit = _Bit_cast<_Uint_type>(_Sign) & _Traits::_Shifted_sign_mask;
    return _Bit_cast<_Ty>(_Float_abs_bits(_Magnitude) | _Signbit);
}

template <class _Ty, enable_if_t<is_floating_point_v<_Ty>, int> = 0>
_NODISCARD constexpr bool _Is_nan(const _Ty _Xx) noexcept { // constexpr isnan()
    using _Traits = _Floating_type_traits<_Ty>;
    return _Float_abs_bits(_Xx) > _Traits::_Shifted_exponent_mask;
}

// TRANSITION, workaround x86 ABI
// On x86 ABI, floating-point by-value arguments and return values are passed in 80-bit x87 registers.
// When the value is a 32-bit or 64-bit signaling NaN, the conversion to/from 80-bit raises FE_INVALID
// and turns it into a quiet NaN. This behavior is undesirable if we want to test for signaling NaNs.
template <class _Ty, enable_if_t<is_floating_point_v<_Ty>, int> = 0>
_NODISCARD constexpr bool _Is_signaling_nan(const _Ty& _Xx) noexcept { // returns true if input is a signaling NaN
    using _Traits = _Floating_type_traits<_Ty>;
    const auto _Abs_bits = _Float_abs_bits(_Xx);
    return _Abs_bits > _Traits::_Shifted_exponent_mask && ((_Abs_bits & _Traits::_Special_nan_mantissa_mask) == 0);
}

template <class _Ty, enable_if_t<is_floating_point_v<_Ty>, int> = 0>
_NODISCARD constexpr bool _Is_inf(const _Ty _Xx) noexcept { // constexpr isinf()
    using _Traits = _Floating_type_traits<_Ty>;
    return _Float_abs_bits(_Xx) == _Traits::_Shifted_exponent_mask;
}

template <class _Ty, enable_if_t<is_floating_point_v<_Ty>, int> = 0>
_NODISCARD constexpr bool _Is_finite(const _Ty _Xx) noexcept { // constexpr isfinite()
    using _Traits = _Floating_type_traits<_Ty>;
    return _Float_abs_bits(_Xx) < _Traits::_Shifted_exponent_mask;
}

#if _HAS_CXX17
_EXPORT_STD struct monostate {};
#endif // _HAS_CXX17

#if _HAS_CXX23
template <_Integer_like _Int>
_NODISCARD constexpr bool _Add_overflow(const _Int _Left, const _Int _Right, _Int& _Out) {
#ifdef __clang__
    if constexpr (integral<_Int>) {
        return __builtin_add_overflow(_Left, _Right, &_Out);
    }
    else
#endif // defined(__clang__)
    {
        if constexpr (!_Signed_integer_like<_Int>) {
            _Out = static_cast<_Int>(_Left + _Right);
            return _Out < _Left || _Out < _Right;
        }
        else {
            using _UInt = _Make_unsigned_like_t<_Int>;
            _Out = static_cast<_Int>(static_cast<_UInt>(_Left) + static_cast<_UInt>(_Right));
            return (_Left > 0 && _Right > 0 && _Out <= 0) || (_Left < 0 && _Right < 0 && _Out >= 0);
        }
    }
}

template <_Integer_like _Int>
_NODISCARD constexpr bool _Mul_overflow(const _Int _Left, const _Int _Right, _Int& _Out) {
#ifdef __clang__
    if constexpr (integral<_Int>) {
        return __builtin_mul_overflow(_Left, _Right, &_Out);
    }
    else
#endif // defined(__clang__)
    {
        if constexpr (!_Signed_integer_like<_Int>) {
            // use instead of numeric_limits::max; avoid <limits> dependency
            constexpr auto _UInt_max = static_cast<_Int>(-1);
            const bool _Overflow = _Left != 0 && _Right > _UInt_max / _Left;
            if (!_Overflow) {
                _Out = static_cast<_Int>(_Left * _Right);
            }
            return _Overflow;
        }
        else {
            // vvv Based on llvm::MulOverflow vvv
            // https://github.com/llvm/llvm-project/blob/88e5206/llvm/include/llvm/Support/MathExtras.h#L725-L750
            //===----------------------------------------------------------------------===//
            //
            // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
            // See https://llvm.org/LICENSE.txt for license information.
            // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
            //
            //===----------------------------------------------------------------------===//
            using _UInt = _Make_unsigned_like_t<_Int>;
            const _UInt _ULeft =
                static_cast<_UInt>(_Left < 0 ? (0 - static_cast<_UInt>(_Left)) : static_cast<_UInt>(_Left));
            const _UInt _URight =
                static_cast<_UInt>(_Right < 0 ? (0 - static_cast<_UInt>(_Right)) : static_cast<_UInt>(_Right));
            const _UInt _UResult = static_cast<_UInt>(_ULeft * _URight);

            const bool _Negative = (_Left < 0) != (_Right < 0);
            _Out = static_cast<_Int>(_Negative ? (0 - _UResult) : _UResult);
            if (_ULeft == 0 || _URight == 0) {
                return false;
            }

            // use instead of numeric_limits::max; avoid <limits> dependency
            constexpr auto _Int_max = static_cast<_UInt>(static_cast<_UInt>(-1) / 2);
            if (_Negative) {
                return _ULeft > (_Int_max + _UInt{ 1 }) / _URight;
            }
            else {
                return _ULeft > _Int_max / _URight;
            }
            // ^^^ Based on llvm::MulOverflow ^^^
        }
    }
}
#endif // _HAS_CXX23

_STD_END

// TRANSITION, non-_Ugly attribute tokens
#pragma pop_macro("intrinsic")
#pragma pop_macro("msvc")

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#endif // _STL_COMPILER_PREPROCESSOR


#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_STD_BEGIN
_EXPORT_STD template <class _Container>
class back_insert_iterator { // wrap pushes to back of container as output iterator
public:
    using iterator_category = output_iterator_tag;
    using value_type = void;
    using pointer = void;
    using reference = void;

    using container_type = _Container;

#if _HAS_CXX20
    using difference_type = ptrdiff_t;
#else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
    using difference_type = void;
#endif // ^^^ !_HAS_CXX20 ^^^

    _CONSTEXPR20 explicit back_insert_iterator(_Container& _Cont) noexcept /* strengthened */
        : container(_STD addressof(_Cont)) {}

    _CONSTEXPR20 back_insert_iterator& operator=(const typename _Container::value_type& _Val) {
        container->push_back(_Val);
        return *this;
    }

    _CONSTEXPR20 back_insert_iterator& operator=(typename _Container::value_type&& _Val) {
        container->push_back(_STD move(_Val));
        return *this;
    }

    _NODISCARD _CONSTEXPR20 back_insert_iterator& operator*() noexcept /* strengthened */ {
        return *this;
    }

    _CONSTEXPR20 back_insert_iterator& operator++() noexcept /* strengthened */ {
        return *this;
    }

    _CONSTEXPR20 back_insert_iterator operator++(int) noexcept /* strengthened */ {
        return *this;
    }

protected:
    _Container* container;
};

_EXPORT_STD template <class _Container>
_NODISCARD _CONSTEXPR20 back_insert_iterator<_Container> back_inserter(_Container& _Cont) noexcept /* strengthened */ {
    // return a back_insert_iterator
    return back_insert_iterator<_Container>(_Cont);
}

_EXPORT_STD template <class _Container>
class front_insert_iterator { // wrap pushes to front of container as output iterator
public:
    using iterator_category = output_iterator_tag;
    using value_type = void;
    using pointer = void;
    using reference = void;

    using container_type = _Container;

#if _HAS_CXX20
    using difference_type = ptrdiff_t;
#else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
    using difference_type = void;
#endif // ^^^ !_HAS_CXX20 ^^^

    _CONSTEXPR20 explicit front_insert_iterator(_Container& _Cont) : container(_STD addressof(_Cont)) {}

    _CONSTEXPR20 front_insert_iterator& operator=(const typename _Container::value_type& _Val) {
        // push value into container
        container->push_front(_Val);
        return *this;
    }

    _CONSTEXPR20 front_insert_iterator& operator=(typename _Container::value_type&& _Val) { // push value into container
        container->push_front(_STD move(_Val));
        return *this;
    }

    _NODISCARD _CONSTEXPR20 front_insert_iterator& operator*() { // pretend to return designated value
        return *this;
    }

    _CONSTEXPR20 front_insert_iterator& operator++() { // pretend to preincrement
        return *this;
    }

    _CONSTEXPR20 front_insert_iterator operator++(int) { // pretend to postincrement
        return *this;
    }

protected:
    _Container* container;
};

_EXPORT_STD template <class _Container>
_NODISCARD _CONSTEXPR20 front_insert_iterator<_Container> front_inserter(_Container& _Cont) {
    return front_insert_iterator<_Container>(_Cont);
}

_EXPORT_STD template <class _Container>
class insert_iterator { // wrap inserts into container as output iterator
public:
    using iterator_category = output_iterator_tag;
    using value_type = void;
    using pointer = void;
    using reference = void;

    using container_type = _Container;
#if _HAS_CXX20
    using difference_type = ptrdiff_t;
    using _Wrapped_iter = ranges::iterator_t<_Container>;
#else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
    using difference_type = void;
    using _Wrapped_iter = typename _Container::iterator;
#endif // ^^^ !_HAS_CXX20 ^^^

    _CONSTEXPR20 insert_iterator(_Container& _Cont, _Wrapped_iter _Where)
        : container(_STD addressof(_Cont)), iter(_STD move(_Where)) {}

    _CONSTEXPR20 insert_iterator& operator=(const typename _Container::value_type& _Val) {
        // insert into container and increment stored iterator
        iter = container->insert(iter, _Val);
        ++iter;
        return *this;
    }

    _CONSTEXPR20 insert_iterator& operator=(typename _Container::value_type&& _Val) { // push value into container
        iter = container->insert(iter, _STD move(_Val));
        ++iter;
        return *this;
    }

    _NODISCARD _CONSTEXPR20 insert_iterator& operator*() { // pretend to return designated value
        return *this;
    }

    _CONSTEXPR20 insert_iterator& operator++() { // pretend to preincrement
        return *this;
    }

    _CONSTEXPR20 insert_iterator& operator++(int) { // pretend to postincrement
        return *this;
    }

protected:
    _Container* container;
    _Wrapped_iter iter;
};

#if !_HAS_CXX20
template <class _Container>
_NODISCARD _CONSTEXPR20 insert_iterator<_Container> inserter(_Container& _Cont, typename _Container::iterator _Where) {
    return insert_iterator<_Container>(_Cont, _Where);
}
#else // ^^^ !_HAS_CXX20 / _HAS_CXX20 vvv
_EXPORT_STD template <class _Container>
_NODISCARD constexpr insert_iterator<_Container> inserter(_Container& _Cont, _RANGES iterator_t<_Container> _Where) {
    return insert_iterator<_Container>(_Cont, _Where);
}

_EXPORT_STD template <semiregular _Se>
class move_sentinel {
public:
    constexpr move_sentinel() = default;

    constexpr explicit move_sentinel(_Se _Val) noexcept(is_nothrow_move_constructible_v<_Se>) // strengthened
        : _Last(_STD move(_Val)) {}

    template <class _Se2>
        requires convertible_to<const _Se2&, _Se>
    constexpr move_sentinel(const move_sentinel<_Se2>& _Val) noexcept(
        is_nothrow_constructible_v<_Se, const _Se2&>) // strengthened
        : _Last(_Val._Get_last()) {}

    template <class _Se2>
        requires assignable_from<_Se&, const _Se2&>
    constexpr move_sentinel& operator=(const move_sentinel<_Se2>& _Val) noexcept(
        is_nothrow_assignable_v<_Se&, const _Se2&>) /* strengthened */ {
        _Last = _Val._Get_last();
        return *this;
    }

    _NODISCARD constexpr _Se base() const noexcept(is_nothrow_copy_constructible_v<_Se>) /* strengthened */ {
        return _Last;
    }

    _NODISCARD constexpr const _Se& _Get_last() const noexcept {
        return _Last;
    }

    using _Prevent_inheriting_unwrap = move_sentinel;

    // clang-format off
    _NODISCARD constexpr move_sentinel<_Unwrapped_t<const _Se&>> _Unwrapped() const&
        noexcept(noexcept(move_sentinel<_Unwrapped_t<const _Se&>>{_Last._Unwrapped()}))
        requires _RANGES _Weakly_unwrappable_sentinel<_Se> {
        // clang-format on
        return move_sentinel<_Unwrapped_t<const _Se&>>{_Last._Unwrapped()};
    }
    // clang-format off
    _NODISCARD constexpr move_sentinel<_Unwrapped_t<_Se>> _Unwrapped() &&
        noexcept(noexcept(move_sentinel<_Unwrapped_t<_Se>>{_STD move(_Last)._Unwrapped()}))
        requires _RANGES _Weakly_unwrappable_sentinel<_Se> {
        // clang-format on
        return move_sentinel<_Unwrapped_t<_Se>>{_STD move(_Last)._Unwrapped()};
    }

private:
    _Se _Last{};
};
#endif // ^^^ _HAS_CXX20 ^^^

_EXPORT_STD template <class _Ty, class _Elem = char, class _Traits = char_traits<_Elem>, class _Diff = ptrdiff_t>
class istream_iterator {
public:
    using iterator_category = input_iterator_tag;
    using value_type = _Ty;
    using difference_type = _Diff;
    using pointer = const _Ty*;
    using reference = const _Ty&;
    using char_type = _Elem;
    using traits_type = _Traits;
    using istream_type = basic_istream<_Elem, _Traits>;

    static_assert(conjunction_v<is_default_constructible<_Ty>, is_copy_constructible<_Ty>, is_copy_assignable<_Ty>>,
        "istream_iterator<T> requires T to be default constructible, copy constructible, and copy assignable. "
        "(N4950 [istream.iterator]/2)");

    constexpr istream_iterator() noexcept(is_nothrow_default_constructible_v<_Ty>) /* strengthened */ {}

#if _HAS_CXX20
    constexpr istream_iterator(default_sentinel_t) noexcept(
        is_nothrow_default_constructible_v<_Ty>) /* strengthened */ {}
#endif // _HAS_CXX20

    istream_iterator(istream_type& _Istr) : _Myistr(_STD addressof(_Istr)) {
        _Getval();
    }

    _NODISCARD const _Ty& operator*() const noexcept /* strengthened */ {
        _STL_ASSERT(_Myistr, "The stored stream pointer in_stream must be non-null");
        return _Myval;
    }

    _NODISCARD const _Ty* operator->() const noexcept /* strengthened */ {
        _STL_ASSERT(_Myistr, "The stored stream pointer in_stream must be non-null");
        return _STD addressof(_Myval);
    }

    istream_iterator& operator++() {
        _Getval();
        return *this;
    }

    istream_iterator operator++(int) {
        istream_iterator _Tmp = *this;
        _Getval();
        return _Tmp;
    }

    _NODISCARD bool _Equal(const istream_iterator& _Right) const noexcept {
        return _Myistr == _Right._Myistr;
    }

#if _HAS_CXX20
    _NODISCARD_FRIEND bool operator==(const istream_iterator& _Left, default_sentinel_t) noexcept /* strengthened */ {
        return !_Left._Myistr;
    }
#endif // _HAS_CXX20

private:
    void _Getval() { // get a _Ty value if possible
        _STL_ASSERT(_Myistr, "The stored stream pointer in_stream must be non-null");
        if (!(*_Myistr >> _Myval)) {
            _Myistr = nullptr;
        }
    }

    istream_type* _Myistr{ nullptr }; // pointer to input stream
    _Ty _Myval{}; // lookahead value (valid if _Myistr is not null)
};

_EXPORT_STD template <class _Ty, class _Elem, class _Traits, class _Diff>
_NODISCARD bool operator==(const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Left,
    const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Right) noexcept /* strengthened */ {
    return _Left._Equal(_Right);
}

#if !_HAS_CXX20
template <class _Ty, class _Elem, class _Traits, class _Diff>
_NODISCARD bool operator!=(const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Left,
    const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Right) noexcept /* strengthened */ {
    return !(_Left == _Right);
}
#endif // !_HAS_CXX20

_EXPORT_STD template <class _Ty, class _Elem = char, class _Traits = char_traits<_Elem>>
class ostream_iterator {
public:
    using iterator_category = output_iterator_tag;
    using value_type = void;
#if _HAS_CXX20
    using difference_type = ptrdiff_t;
#else
    using difference_type = void;
#endif
    using pointer = void;
    using reference = void;
    using char_type = _Elem;
    using traits_type = _Traits;
    using ostream_type = basic_ostream<_Elem, _Traits>;

    ostream_iterator(ostream_type& _Ostr, const _Elem* const _Delim = nullptr) noexcept /* strengthened */
        : _Mydelim(_Delim), _Myostr(_STD addressof(_Ostr)) {}

    ostream_iterator& operator=(const _Ty& _Val) { // insert value into output stream, followed by delimiter
        *_Myostr << _Val;
        if (_Mydelim) {
            *_Myostr << _Mydelim;
        }

        return *this;
    }

    _NODISCARD ostream_iterator& operator*() noexcept /* strengthened */ {
        return *this;
    }

    ostream_iterator& operator++() noexcept /* strengthened */ {
        return *this;
    }

    ostream_iterator& operator++(int) noexcept /* strengthened */ {
        return *this;
    }

private:
    const _Elem* _Mydelim; // pointer to delimiter string (NB: not freed)
    ostream_type* _Myostr; // pointer to output stream
};

_EXPORT_STD template <class _Elem, class _Traits>
class istreambuf_iterator {
public:
    using iterator_category = input_iterator_tag;
    using value_type = _Elem;
    using difference_type = typename _Traits::off_type;
    using pointer = const _Elem*;
    using reference = _Elem;
    using char_type = _Elem;
    using traits_type = _Traits;
    using int_type = typename traits_type::int_type;
    using streambuf_type = basic_streambuf<_Elem, _Traits>;
    using istream_type = basic_istream<_Elem, _Traits>;

    constexpr istreambuf_iterator() noexcept : _Strbuf(nullptr), _Got(true), _Val() {}
#if _HAS_CXX20
    constexpr istreambuf_iterator(default_sentinel_t) noexcept : _Strbuf(nullptr), _Got(true), _Val() {}
#endif // _HAS_CXX20

    istreambuf_iterator(istream_type& _Istr) noexcept : _Strbuf(_Istr.rdbuf()), _Got(!_Strbuf), _Val() {}

    istreambuf_iterator(streambuf_type* _Sb) noexcept : _Strbuf(_Sb), _Got(!_Sb), _Val() {}

private:
    class _Istreambuf_proxy {
    public:
        _NODISCARD _Elem operator*() const noexcept(is_nothrow_copy_constructible_v<_Elem>) /* strengthened */ {
            return _Keep;
        }

    private:
        friend istreambuf_iterator;
        _Istreambuf_proxy(streambuf_type* _Strbuf_, _Elem _Keep_) noexcept(
            is_nothrow_copy_constructible_v<_Elem>) // strengthened
            : _Strbuf(_Strbuf_), _Keep(_Keep_) {}

        streambuf_type* _Strbuf;
        _Elem _Keep;
    };

public:
    istreambuf_iterator(const _Istreambuf_proxy& _Px) noexcept : _Strbuf(_Px._Strbuf), _Got(!_Strbuf), _Val() {}

    _NODISCARD _Elem operator*() const {
        if (!_Got) {
            _Peek();
        }

#if _ITERATOR_DEBUG_LEVEL == 2
        _STL_VERIFY(_Strbuf, "istreambuf_iterator is not dereferenceable");
#endif // _ITERATOR_DEBUG_LEVEL == 2

        return _Val;
    }

    istreambuf_iterator& operator++() {
#if _ITERATOR_DEBUG_LEVEL == 2
        _STL_VERIFY(_Strbuf, "istreambuf_iterator is not incrementable");
#endif // _ITERATOR_DEBUG_LEVEL == 2

        _Inc();
        return *this;
    }

    _Istreambuf_proxy operator++(int) {
        if (!_Got) {
            _Peek();
        }

        _Istreambuf_proxy _Tmp{ _Strbuf, _Val };
        ++*this;
        return _Tmp;
    }

    _NODISCARD bool equal(const istreambuf_iterator& _Right) const {
        if (!_Got) {
            _Peek();
        }

        if (!_Right._Got) {
            _Right._Peek();
        }

        return (!_Strbuf && !_Right._Strbuf) || (_Strbuf && _Right._Strbuf);
    }

#if _HAS_CXX20
    _NODISCARD_FRIEND bool operator==(const istreambuf_iterator& _Left, default_sentinel_t) {
        if (!_Left._Got) {
            _Left._Peek();
        }

        return !_Left._Strbuf;
    }
#endif // _HAS_CXX20

private:
    void _Inc() { // skip to next input element
        if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {
            _Strbuf = nullptr;
            _Got = true;
        }
        else {
            _Got = false;
        }
    }

    _Elem _Peek() const { // peek at next input element
        int_type _Meta;
        if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {
            _Strbuf = nullptr;
        }
        else {
            _Val = traits_type::to_char_type(_Meta);
        }

        _Got = true;
        return _Val;
    }

    mutable streambuf_type* _Strbuf; // the wrapped stream buffer
    mutable bool _Got; // true if _Val is valid
    mutable _Elem _Val; // next element to deliver
};

_EXPORT_STD template <class _Elem, class _Traits>
_NODISCARD bool operator==(
    const istreambuf_iterator<_Elem, _Traits>& _Left, const istreambuf_iterator<_Elem, _Traits>& _Right) {
    return _Left.equal(_Right);
}

#if !_HAS_CXX20
template <class _Elem, class _Traits>
_NODISCARD bool operator!=(
    const istreambuf_iterator<_Elem, _Traits>& _Left, const istreambuf_iterator<_Elem, _Traits>& _Right) {
    return !(_Left == _Right);
}
#endif // !_HAS_CXX20

_EXPORT_STD template <class _Elem, class _Traits>
class ostreambuf_iterator {
public:
    using iterator_category = output_iterator_tag;
    using value_type = void;
#if _HAS_CXX20
    using difference_type = ptrdiff_t;
#else
    using difference_type = void;
#endif
    using pointer = void;
    using reference = void;
    using char_type = _Elem;
    using traits_type = _Traits;
    using streambuf_type = basic_streambuf<_Elem, _Traits>;
    using ostream_type = basic_ostream<_Elem, _Traits>;

    ostreambuf_iterator(streambuf_type* _Sb) noexcept : _Strbuf(_Sb) {}

    ostreambuf_iterator(ostream_type& _Ostr) noexcept : _Strbuf(_Ostr.rdbuf()) {}

    ostreambuf_iterator& operator=(_Elem _Right) { // store element and increment
        if (!_Strbuf || traits_type::eq_int_type(_Traits::eof(), _Strbuf->sputc(_Right))) {
            _Failed = true;
        }

        return *this;
    }

    _NODISCARD ostreambuf_iterator& operator*() noexcept /* strengthened */ {
        return *this;
    }

    ostreambuf_iterator& operator++() noexcept /* strengthened */ {
        return *this;
    }

    ostreambuf_iterator& operator++(int) noexcept /* strengthened */ {
        return *this;
    }

    _NODISCARD bool failed() const noexcept {
        return _Failed;
    }

private:
    bool _Failed = false; // true if any stores have failed
    streambuf_type* _Strbuf;
};

#if _HAS_CXX20
enum class _Variantish_state : unsigned char { _Nothing, _Holds_first, _Holds_second };

struct _Variantish_empty_tag {
    explicit _Variantish_empty_tag() = default;
};

template <class _Ty1, class _Ty2>
class _Variantish {
public:
    constexpr explicit _Variantish(_Variantish_empty_tag) noexcept : _Contains{ _Variantish_state::_Nothing } {}

    constexpr _Variantish() noexcept(is_nothrow_default_constructible_v<_Ty1>)
        requires default_initializable<_Ty1>
    : _First{}, _Contains{ _Variantish_state::_Holds_first } {}

    template <class... _Types>
    constexpr explicit _Variantish(in_place_type_t<_Ty1>, _Types&&... _Args) noexcept(
        is_nothrow_constructible_v<_Ty1, _Types...>)
        : _First(_STD forward<_Types>(_Args)...), _Contains{ _Variantish_state::_Holds_first } {}

    template <class... _Types>
        requires _Different_from<_Ty1, _Ty2>
    constexpr explicit _Variantish(in_place_type_t<_Ty2>, _Types&&... _Args) noexcept(
        is_nothrow_constructible_v<_Ty2, _Types...>)
        : _Second(_STD forward<_Types>(_Args)...), _Contains{ _Variantish_state::_Holds_second } {}

    template <class _Uty1, class _Uty2>
        requires _Different_from<_Variantish<_Uty1, _Uty2>, _Variantish>
    constexpr _Variantish(const _Variantish<_Uty1, _Uty2>& _That) noexcept(
        is_nothrow_constructible_v<_Ty1, const _Uty1&>&& is_nothrow_constructible_v<_Ty2, const _Uty2&>)
        : _Contains{ _That._Contains } {
        switch (_That._Contains) {
        case _Variantish_state::_Holds_first:
            _STD _Construct_in_place(_First, _That._Get_first());
            break;
        case _Variantish_state::_Holds_second:
            _STD _Construct_in_place(_Second, _That._Get_second());
            break;
        case _Variantish_state::_Nothing:
            break;
        }
    }

    // clang-format off
    constexpr _Variantish(const _Variantish&) requires is_trivially_copy_constructible_v<_Ty1>
        && is_trivially_copy_constructible_v<_Ty2> = default;
    // clang-format on

    constexpr _Variantish(const _Variantish& _That) noexcept(
        is_nothrow_copy_constructible_v<_Ty1>&& is_nothrow_copy_constructible_v<_Ty2>)
        : _Contains{ _That._Contains } {
        switch (_Contains) {
        case _Variantish_state::_Holds_first:
            _STD _Construct_in_place(_First, _That._Get_first());
            break;
        case _Variantish_state::_Holds_second:
            _STD _Construct_in_place(_Second, _That._Get_second());
            break;
        case _Variantish_state::_Nothing:
            break;
        }
    }

    // clang-format off
    constexpr _Variantish(_Variantish&&) requires is_trivially_move_constructible_v<_Ty1>
        && is_trivially_move_constructible_v<_Ty2> = default;
    // clang-format on

    constexpr _Variantish(_Variantish&& _That) noexcept(
        is_nothrow_move_constructible_v<_Ty1>&& is_nothrow_move_constructible_v<_Ty2>)
        : _Contains{ _That._Contains } {
        switch (_Contains) {
        case _Variantish_state::_Holds_first:
            _STD _Construct_in_place(_First, _STD move(_That._Get_first()));
            break;
        case _Variantish_state::_Holds_second:
            _STD _Construct_in_place(_Second, _STD move(_That._Get_second()));
            break;
        case _Variantish_state::_Nothing:
            break;
        }
    }

    constexpr ~_Variantish() {
        _Raw_clear();
    }

    // clang-format off
    constexpr ~_Variantish() requires is_trivially_destructible_v<_Ty1>&& is_trivially_destructible_v<_Ty2> = default;

    constexpr _Variantish& operator=(const _Variantish&) requires is_trivially_destructible_v<_Ty1>
        && is_trivially_destructible_v<_Ty2>
        && is_trivially_copy_constructible_v<_Ty1>
        && is_trivially_copy_constructible_v<_Ty2>
        && is_trivially_copy_assignable_v<_Ty1>
        && is_trivially_copy_assignable_v<_Ty2> = default;
    // clang-format on

    constexpr _Variantish& operator=(const _Variantish& _That) noexcept(
        is_nothrow_copy_constructible_v<_Ty1>&& is_nothrow_copy_constructible_v<_Ty2>
        && is_nothrow_copy_assignable_v<_Ty1>&& is_nothrow_copy_assignable_v<_Ty2>) {
        if (_Contains == _That._Contains) {
            switch (_Contains) {
            case _Variantish_state::_Holds_first:
                _Get_first() = _That._Get_first();
                break;
            case _Variantish_state::_Holds_second:
                _Get_second() = _That._Get_second();
                break;
            case _Variantish_state::_Nothing:
                break;
            }

            return *this;
        }

        _Clear();

        switch (_That._Contains) {
        case _Variantish_state::_Holds_first:
            _STD _Construct_in_place(_First, _That._Get_first());
            break;
        case _Variantish_state::_Holds_second:
            _STD _Construct_in_place(_Second, _That._Get_second());
            break;
        case _Variantish_state::_Nothing:
            break;
        }

        _Contains = _That._Contains;

        return *this;
    }

    // clang-format off
    constexpr _Variantish& operator=(_Variantish&&) requires is_trivially_destructible_v<_Ty1>
        && is_trivially_destructible_v<_Ty2>
        && is_trivially_move_constructible_v<_Ty1>
        && is_trivially_move_constructible_v<_Ty2>
        && is_trivially_move_assignable_v<_Ty1>
        && is_trivially_move_assignable_v<_Ty2> = default;
    // clang-format on

    constexpr _Variantish& operator=(_Variantish&& _That) noexcept(
        is_nothrow_move_constructible_v<_Ty1>&& is_nothrow_move_constructible_v<_Ty2>
        && is_nothrow_move_assignable_v<_Ty1>&& is_nothrow_move_assignable_v<_Ty2>) {
        if (_Contains == _That._Contains) {
            switch (_Contains) {
            case _Variantish_state::_Holds_first:
                _Get_first() = _STD move(_That._Get_first());
                break;
            case _Variantish_state::_Holds_second:
                _Get_second() = _STD move(_That._Get_second());
                break;
            case _Variantish_state::_Nothing:
                break;
            }

            return *this;
        }

        _Clear();

        switch (_That._Contains) {
        case _Variantish_state::_Holds_first:
            _STD _Construct_in_place(_First, _STD move(_That._Get_first()));
            break;
        case _Variantish_state::_Holds_second:
            _STD _Construct_in_place(_Second, _STD move(_That._Get_second()));
            break;
        case _Variantish_state::_Nothing:
            break;
        }

        _Contains = _That._Contains;

        return *this;
    }

    template <class _Uty1, class _Uty2>
        requires _Different_from<_Variantish<_Uty1, _Uty2>, _Variantish>
    constexpr _Variantish& operator=(const _Variantish<_Uty1, _Uty2>& _That) noexcept(
        is_nothrow_constructible_v<_Ty1, const _Uty1&>&& is_nothrow_constructible_v<_Ty2, const _Uty2&>
        && is_nothrow_assignable_v<_Ty1&, const _Uty1&>&& is_nothrow_assignable_v<_Ty2&, const _Uty2&>) {
        if (_Contains == _That._Contains) {
            switch (_Contains) {
            case _Variantish_state::_Holds_first:
                _Get_first() = _That._Get_first();
                break;
            case _Variantish_state::_Holds_second:
                _Get_second() = _That._Get_second();
                break;
            case _Variantish_state::_Nothing:
                break;
            }

            return *this;
        }

        _Clear();

        switch (_That._Contains) {
        case _Variantish_state::_Holds_first:
            _STD _Construct_in_place(_First, _That._Get_first());
            break;
        case _Variantish_state::_Holds_second:
            _STD _Construct_in_place(_Second, _That._Get_second());
            break;
        case _Variantish_state::_Nothing:
            break;
        }

        _Contains = _That._Contains;

        return *this;
    }

    // clang-format off
    friend constexpr void swap(_Variantish& _Left, _Variantish& _Right) noexcept(
        is_nothrow_move_constructible_v<_Ty1>&& is_nothrow_move_constructible_v<_Ty2>
        && is_nothrow_swappable_v<_Ty1>&& is_nothrow_swappable_v<_Ty2>)
        requires (!_Is_trivially_swappable_v<_Ty1> || !_Is_trivially_swappable_v<_Ty2>) {
        // clang-format on
        if (_Left._Contains == _Right._Contains) {
            switch (_Left._Contains) {
            case _Variantish_state::_Holds_first:
                _RANGES swap(_Left._Get_first(), _Right._Get_first());
                break;
            case _Variantish_state::_Holds_second:
                _RANGES swap(_Left._Get_second(), _Right._Get_second());
                break;
            case _Variantish_state::_Nothing:
                break;
            }

            return;
        }

        auto _Tmp = _STD move(_Left);
        _Left = _STD move(_Right);
        _Right = _STD move(_Tmp);
    }

    constexpr void _Raw_clear() noexcept {
        switch (_Contains) {
        case _Variantish_state::_Holds_first:
            _First.~_Ty1();
            break;
        case _Variantish_state::_Holds_second:
            _Second.~_Ty2();
            break;
        case _Variantish_state::_Nothing:
            break;
        }
    }

    _NODISCARD constexpr _Ty1& _Get_first() noexcept {
        return _First;
    }
    _NODISCARD constexpr const _Ty1& _Get_first() const noexcept {
        return _First;
    }

    _NODISCARD constexpr _Ty2& _Get_second() noexcept {
        return _Second;
    }
    _NODISCARD constexpr const _Ty2& _Get_second() const noexcept {
        return _Second;
    }

    constexpr void _Clear() noexcept {
        _Raw_clear();
        _Contains = _Variantish_state::_Nothing;
    }

    template <class... _Types>
    constexpr void _Emplace_first(_Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty1, _Types...>) {
        _Clear();

        _STD _Construct_in_place(_First, _STD forward<_Types>(_Args)...);
        _Contains = _Variantish_state::_Holds_first;
    }

    template <class... _Types>
    constexpr void _Emplace_second(_Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty2, _Types...>) {
        _Clear();

        _STD _Construct_in_place(_Second, _STD forward<_Types>(_Args)...);
        _Contains = _Variantish_state::_Holds_second;
    }

    union {
        remove_cv_t<_Ty1> _First;
        remove_cv_t<_Ty2> _Second;
    };

    _Variantish_state _Contains;
};

// clang-format off
template <class _Iter>
concept _Use_postfix_proxy = !requires(_Iter & __it) { { *__it++ } -> _Can_reference; }
&& indirectly_readable<_Iter>
&& constructible_from<iter_value_t<_Iter>, iter_reference_t<_Iter>>
&& move_constructible<iter_value_t<_Iter>>;
// clang-format on

_EXPORT_STD template <input_or_output_iterator _Iter, sentinel_for<_Iter> _Se>
    requires (!same_as<_Iter, _Se>&& copyable<_Iter>)
class common_iterator {
private:
    struct _Proxy_base {
        iter_value_t<_Iter> _Keep;

        constexpr explicit _Proxy_base(iter_reference_t<_Iter>&& _Right) noexcept(
            is_nothrow_constructible_v<iter_value_t<_Iter>, iter_reference_t<_Iter>>) // strengthened
            : _Keep(_STD forward<iter_reference_t<_Iter>>(_Right)) {}
    };

public:
    // clang-format off
    constexpr common_iterator() requires default_initializable<_Iter> = default;
    // clang-format on

    constexpr common_iterator(_Iter _Right) noexcept(is_nothrow_move_constructible_v<_Iter>) // strengthened
        : _Val{ in_place_type<_Iter>, _STD move(_Right) } {}

    constexpr common_iterator(_Se _Right) noexcept(is_nothrow_move_constructible_v<_Se>) // strengthened
        : _Val{ in_place_type<_Se>, _STD move(_Right) } {}

    constexpr explicit common_iterator(_Variantish_empty_tag _Tag) noexcept : _Val{ _Tag } {}

    template <class _OIter, class _OSe>
        requires convertible_to<const _OIter&, _Iter>&& convertible_to<const _OSe&, _Se>
    constexpr common_iterator(const common_iterator<_OIter, _OSe>& _Right) noexcept(
        is_nothrow_constructible_v<_Iter, const _OIter&>
        && is_nothrow_constructible_v<_Se, const _OSe&>) // strengthened
        : _Val{ _Right._Get_val() } {}

    template <class _OIter, class _OSe>
        requires convertible_to<const _OIter&, _Iter>&& convertible_to<const _OSe&, _Se>
    && assignable_from<_Iter&, const _OIter&>&& assignable_from<_Se&, const _OSe&>
        constexpr common_iterator& operator=(const common_iterator<_OIter, _OSe>& _Right) noexcept(
            is_nothrow_constructible_v<_Iter, const _OIter&>&& is_nothrow_constructible_v<_Se, const _OSe&>
            && is_nothrow_assignable_v<_Iter&, const _OIter&>
            && is_nothrow_assignable_v<_Se&, const _OSe&>) /* strengthened */ {
        _Val = _Right._Get_val();
        return *this;
    }

    _NODISCARD constexpr decltype(auto) operator*() {
#if _ITERATOR_DEBUG_LEVEL != 0
        _STL_VERIFY(_Val._Contains == _Variantish_state::_Holds_first,
            "common_iterator can only be dereferenced if it holds an iterator");
#endif // _ITERATOR_DEBUG_LEVEL != 0
        return *_Val._Get_first();
    }

    _NODISCARD constexpr decltype(auto) operator*() const
        requires _Dereferenceable<const _Iter>
    {
#if _ITERATOR_DEBUG_LEVEL != 0
        _STL_VERIFY(_Val._Contains == _Variantish_state::_Holds_first,
            "common_iterator can only be dereferenced if it holds an iterator");
#endif // _ITERATOR_DEBUG_LEVEL != 0
        return *_Val._Get_first();
    }

    _NODISCARD constexpr auto operator->() const
        requires indirectly_readable<const _Iter>
    && (_Has_member_arrow<const _Iter&> || is_reference_v<iter_reference_t<_Iter>>
        || constructible_from<iter_value_t<_Iter>, iter_reference_t<_Iter>>)
    {
#if _ITERATOR_DEBUG_LEVEL != 0
        _STL_VERIFY(_Val._Contains == _Variantish_state::_Holds_first,
            "common_iterator can only be dereferenced if it holds an iterator");
#endif // _ITERATOR_DEBUG_LEVEL != 0
        if constexpr (_Has_member_arrow<const _Iter&> || is_pointer_v<_Iter>) {
            return _Val._Get_first();
        }
        else if constexpr (is_reference_v<iter_reference_t<_Iter>>) {
            auto&& _Tmp = *_Val._Get_first();
            return _STD addressof(_Tmp);
        }
        else {
            class _Arrow_proxy : private _Proxy_base {
            public:
                friend common_iterator;

                using _Proxy_base::_Proxy_base;

                _NODISCARD constexpr const iter_value_t<_Iter>* operator->() const noexcept {
                    return _STD addressof(this->_Keep);
                }
            };

            return _Arrow_proxy{ *_Val._Get_first() };
        }
    }

    constexpr common_iterator& operator++() {
#if _ITERATOR_DEBUG_LEVEL != 0
        _STL_VERIFY(_Val._Contains == _Variantish_state::_Holds_first,
            "common_iterator can only be incremented if it holds an iterator");
#endif // _ITERATOR_DEBUG_LEVEL != 0
        ++_Val._Get_first();
        return *this;
    }

    constexpr decltype(auto) operator++(int) {
#if _ITERATOR_DEBUG_LEVEL != 0
        _STL_VERIFY(_Val._Contains == _Variantish_state::_Holds_first,
            "common_iterator can only be incremented if it holds an iterator");
#endif // _ITERATOR_DEBUG_LEVEL != 0
        if constexpr (forward_iterator<_Iter>) {
            common_iterator _Tmp = *this;
            ++_Val._Get_first();
            return _Tmp;
        }
        else if constexpr (_Use_postfix_proxy<_Iter>) {
            class _Postfix_proxy : private _Proxy_base {
            public:
                friend common_iterator;

                using _Proxy_base::_Proxy_base;

                _NODISCARD constexpr const iter_value_t<_Iter>& operator*() const noexcept {
                    return this->_Keep;
                }
            };

            _Postfix_proxy _Tmp{ *_Val._Get_first() };
            ++_Val._Get_first();
            return _Tmp;
        }
        else {
            return _Val._Get_first()++;
        }
    }

    template <class _OIter, sentinel_for<_Iter> _OSe>
        requires sentinel_for<_Se, _OIter>
    _NODISCARD_FRIEND constexpr bool operator==(
        const common_iterator& _Left, const common_iterator<_OIter, _OSe>& _Right) {
        auto& _Right_val = _Right._Get_val();
#if _ITERATOR_DEBUG_LEVEL != 0
        _STL_VERIFY(
            _Left._Val._Contains != _Variantish_state::_Nothing && _Right_val._Contains != _Variantish_state::_Nothing,
            "common_iterators can only be compared if both hold a value");
#endif // _ITERATOR_DEBUG_LEVEL != 0

        if (_Left._Val._Contains == _Variantish_state::_Holds_first) {
            if (_Right_val._Contains == _Variantish_state::_Holds_first) {
                if constexpr (equality_comparable_with<_Iter, _OIter>) {
                    return _Left._Val._Get_first() == _Right_val._Get_first();
                }
                else {
                    return true;
                }
            }
            else {
                return _Left._Val._Get_first() == _Right_val._Get_second();
            }
        }
        else {
            if (_Right_val._Contains == _Variantish_state::_Holds_first) {
                return _Left._Val._Get_second() == _Right_val._Get_first();
            }
            else {
                return true;
            }
        }
    }

    template <sized_sentinel_for<_Iter> _OIter, sized_sentinel_for<_Iter> _OSe>
        requires sized_sentinel_for<_Se, _OIter>
    _NODISCARD_FRIEND constexpr iter_difference_t<_OIter> operator-(
        const common_iterator& _Left, const common_iterator<_OIter, _OSe>& _Right) {
        auto& _Right_val = _Right._Get_val();
#if _ITERATOR_DEBUG_LEVEL != 0
        _STL_VERIFY(
            _Left._Val._Contains != _Variantish_state::_Nothing && _Right_val._Contains != _Variantish_state::_Nothing,
            "Cannot take difference of valueless common_iterators");
#endif // _ITERATOR_DEBUG_LEVEL != 0

        if (_Left._Val._Contains == _Variantish_state::_Holds_first) {
            if (_Right_val._Contains == _Variantish_state::_Holds_first) {
                return _Left._Val._Get_first() - _Right_val._Get_first();
            }
            else {
                return _Left._Val._Get_first() - _Right_val._Get_second();
            }
        }
        else {
            if (_Right_val._Contains == _Variantish_state::_Holds_first) {
                return _Left._Val._Get_second() - _Right_val._Get_first();
            }
            else {
                return 0;
            }
        }
    }

    _NODISCARD_FRIEND constexpr decltype(auto) iter_move(const common_iterator& _Right) noexcept(
        noexcept(_RANGES iter_move(_Right._Val._Get_first())))
        requires input_iterator<_Iter>
    {
#if _ITERATOR_DEBUG_LEVEL != 0
        _STL_VERIFY(_Right._Val._Contains == _Variantish_state::_Holds_first,
            "can only iter_move from common_iterator if it holds an iterator");
#endif // _ITERATOR_DEBUG_LEVEL != 0
        return _RANGES iter_move(_Right._Val._Get_first());
    }

    template <indirectly_swappable<_Iter> _OIter, class _OSe>
    friend constexpr void iter_swap(const common_iterator& _Left, const common_iterator<_OIter, _OSe>& _Right) noexcept(
        noexcept(_RANGES iter_swap(_Left._Val._Get_first(), _Right._Get_val()._Get_first()))) {
        auto& _Right_val = _Right._Get_val();
#if _ITERATOR_DEBUG_LEVEL != 0
        _STL_VERIFY(_Left._Val._Contains == _Variantish_state::_Holds_first
            && _Right_val._Contains == _Variantish_state::_Holds_first,
            "can only iter_swap common_iterators if both hold iterators");
#endif // _ITERATOR_DEBUG_LEVEL != 0
        return _RANGES iter_swap(_Left._Val._Get_first(), _Right_val._Get_first());
    }

    _NODISCARD constexpr _Variantish<_Iter, _Se>& _Get_val() noexcept {
        return _Val;
    }
    _NODISCARD constexpr const _Variantish<_Iter, _Se>& _Get_val() const noexcept {
        return _Val;
    }

private:
    _Variantish<_Iter, _Se> _Val;
};

template <class _Iter, class _Se>
struct incrementable_traits<common_iterator<_Iter, _Se>> {
    using difference_type = iter_difference_t<_Iter>;
};

template <class, class>
struct _Common_iterator_pointer_type {
    using pointer = void;
};

template <class _Iter, class _Se>
    requires _Has_member_arrow<const common_iterator<_Iter, _Se>&>
struct _Common_iterator_pointer_type<_Iter, _Se> {
    using pointer = decltype(_STD declval<const common_iterator<_Iter, _Se>&>().operator->());
};

template <class _Iter>
concept _Has_forward_category = requires {
    typename _Iter_cat_t<_Iter>;
    requires derived_from<_Iter_cat_t<_Iter>, forward_iterator_tag>;
};

template <class _Iter>
struct _Common_iterator_category_base {};

template <class _Iter>
    requires is_integral_v<iter_difference_t<_Iter>>
struct _Common_iterator_category_base<_Iter> {
    using iterator_category = conditional_t<_Has_forward_category<_Iter>, forward_iterator_tag, input_iterator_tag>;
};

template <input_iterator _Iter, class _Se>
struct iterator_traits<common_iterator<_Iter, _Se>> : _Common_iterator_category_base<_Iter> {
    using iterator_concept = conditional_t<forward_iterator<_Iter>, forward_iterator_tag, input_iterator_tag>;
    using value_type = iter_value_t<_Iter>;
    using difference_type = iter_difference_t<_Iter>;
    using pointer = _Common_iterator_pointer_type<_Iter, _Se>::pointer;
    using reference = iter_reference_t<_Iter>;
};

template <class _Iter>
struct _Counted_iterator_value_type_base {};

template <indirectly_readable _Iter>
struct _Counted_iterator_value_type_base<_Iter> {
    using value_type = iter_value_t<_Iter>;
};

template <class _Iter>
struct _Counted_iterator_category_base : _Counted_iterator_value_type_base<_Iter> {};

template <_Has_member_iterator_category _Iter>
struct _Counted_iterator_category_base<_Iter> : _Counted_iterator_value_type_base<_Iter> {
    using iterator_category = _Iter::iterator_category;
};

template <class _Iter>
struct _Counted_iterator_concept_base : _Counted_iterator_category_base<_Iter> {};

template <_Has_member_iterator_concept _Iter>
struct _Counted_iterator_concept_base<_Iter> : _Counted_iterator_category_base<_Iter> {
    using iterator_concept = _Iter::iterator_concept;
};

_EXPORT_STD template <input_or_output_iterator _Iter>
class counted_iterator : public _Counted_iterator_concept_base<_Iter> {
public:
    using iterator_type = _Iter;
    using difference_type = iter_difference_t<_Iter>;

    // [counted.iter.const]
    // clang-format off
    constexpr counted_iterator() requires default_initializable<_Iter> = default;
    // clang-format on

    constexpr counted_iterator(_Iter _Right, const iter_difference_t<_Iter> _Diff) noexcept(
        is_nothrow_move_constructible_v<_Iter>) // strengthened
        : _Current(_STD move(_Right)), _Length(_Diff) {
#if _ITERATOR_DEBUG_LEVEL != 0
        _STL_VERIFY(_Diff >= 0, "counted_iterator requires non-negative length n");
#endif // _ITERATOR_DEBUG_LEVEL != 0
    }

    template <class _Other>
        requires convertible_to<const _Other&, _Iter>
    constexpr counted_iterator(const counted_iterator<_Other>& _Right) noexcept(
        is_nothrow_constructible_v<_Iter, const _Other&>) // strengthened
        : _Current(_Right.base()), _Length(_Right.count()) {}

    template <class _Other>
        requires assignable_from<_Iter&, const _Other&>
    constexpr counted_iterator& operator=(const counted_iterator<_Other>& _Right) noexcept(
        is_nothrow_assignable_v<_Iter&, const _Other&>) /* strengthened */ {
        _Current = _Right.base();
        _Length = _Right.count();
        return *this;
    }

    // [counted.iter.access]
    _NODISCARD constexpr const _Iter& base() const& noexcept {
        return _Current;
    }

    _NODISCARD constexpr _Iter base() && noexcept(is_nothrow_move_constructible_v<_Iter>) /* strengthened */ {
        return _STD move(_Current);
    }

    _NODISCARD constexpr iter_difference_t<_Iter> count() const noexcept {
        return _Length;
    }

    // [counted.iter.elem]
    _NODISCARD constexpr decltype(auto) operator*() noexcept(noexcept(*_Current)) /* strengthened */ {
#if _ITERATOR_DEBUG_LEVEL != 0
        _STL_VERIFY(_Length > 0, "counted_iterator dereference beyond end of range");
#endif // _ITERATOR_DEBUG_LEVEL != 0
        return *_Current;
    }

    _NODISCARD constexpr decltype(auto) operator*() const noexcept(noexcept(*_Current)) /* strengthened */
        requires _Dereferenceable<const _Iter>
    {
#if _ITERATOR_DEBUG_LEVEL != 0
        _STL_VERIFY(_Length > 0, "counted_iterator dereference beyond end of range");
#endif // _ITERATOR_DEBUG_LEVEL != 0
        return *_Current;
    }

    _NODISCARD constexpr auto operator->() const noexcept
        requires contiguous_iterator<_Iter>
    {
        return _STD to_address(_Current);
    }

    _NODISCARD constexpr decltype(auto) operator[](const iter_difference_t<_Iter> _Diff) const
        requires random_access_iterator<_Iter>
    {
#if _ITERATOR_DEBUG_LEVEL != 0
        _STL_VERIFY(_Diff < _Length, "counted_iterator index out of range");
#endif // _ITERATOR_DEBUG_LEVEL != 0
        return _Current[_Diff];
    }

    // [counted.iter.nav]
    constexpr counted_iterator& operator++() {
#if _ITERATOR_DEBUG_LEVEL != 0
        _STL_VERIFY(_Length > 0, "counted_iterator increment beyond end of range");
#endif // _ITERATOR_DEBUG_LEVEL != 0
        ++_Current;
        --_Length;
        return *this;
    }

    constexpr decltype(auto) operator++(int) {
#if _ITERATOR_DEBUG_LEVEL != 0
        _STL_VERIFY(_Length > 0, "counted_iterator increment beyond end of range");
#endif // _ITERATOR_DEBUG_LEVEL != 0
        --_Length;
        _TRY_BEGIN
            return _Current++;

        _CATCH_ALL
            ++_Length;

        _RERAISE;
        _CATCH_END
    }

    constexpr counted_iterator operator++(int)
        requires forward_iterator<_Iter>
    {
#if _ITERATOR_DEBUG_LEVEL != 0
        _STL_VERIFY(_Length > 0, "counted_iterator increment beyond end of range");
#endif // _ITERATOR_DEBUG_LEVEL != 0
        counted_iterator _Tmp = *this;
        ++_Current;
        --_Length;
        return _Tmp;
    }

    constexpr counted_iterator& operator--()
        requires bidirectional_iterator<_Iter>
    {
        --_Current;
        ++_Length;
        return *this;
    }

    constexpr counted_iterator operator--(int)
        requires bidirectional_iterator<_Iter>
    {
        counted_iterator _Tmp = *this;
        --_Current;
        ++_Length;
        return _Tmp;
    }

    _NODISCARD constexpr counted_iterator operator+(const iter_difference_t<_Iter> _Diff) const
        requires random_access_iterator<_Iter>
    {
        return counted_iterator{ _Current + _Diff, static_cast<iter_difference_t<_Iter>>(_Length - _Diff) };
    }

    _NODISCARD_FRIEND constexpr counted_iterator operator+(
        const iter_difference_t<_Iter> _Diff, const counted_iterator& _Right)
        requires random_access_iterator<_Iter>
    {
        return counted_iterator{ _Right._Current + _Diff, static_cast<iter_difference_t<_Iter>>(_Right._Length - _Diff) };
    }

    constexpr counted_iterator& operator+=(const iter_difference_t<_Iter> _Diff)
        requires random_access_iterator<_Iter>
    {
#if _ITERATOR_DEBUG_LEVEL != 0
        _STL_VERIFY(_Diff <= _Length, "counted_iterator seek beyond end of range");
#endif // _ITERATOR_DEBUG_LEVEL != 0
        _Current += _Diff;
        _Length -= _Diff;
        return *this;
    }

    _NODISCARD constexpr counted_iterator operator-(const iter_difference_t<_Iter> _Diff) const
        requires random_access_iterator<_Iter>
    {
        return counted_iterator{ _Current - _Diff, static_cast<iter_difference_t<_Iter>>(_Length + _Diff) };
    }

    template <common_with<_Iter> _Other>
    _NODISCARD_FRIEND constexpr iter_difference_t<_Other> operator-(
        const counted_iterator& _Left, const counted_iterator<_Other>& _Right) noexcept /* strengthened */ {
#if _ITERATOR_DEBUG_LEVEL != 0
        _Same_sequence(_Left, _Right);
#endif // _ITERATOR_DEBUG_LEVEL != 0
        return _Right.count() - _Left._Length;
    }

    _NODISCARD_FRIEND constexpr iter_difference_t<_Iter> operator-(
        const counted_iterator& _Left, default_sentinel_t) noexcept /* strengthened */ {
        return -_Left._Length;
    }

    _NODISCARD_FRIEND constexpr iter_difference_t<_Iter> operator-(
        default_sentinel_t, const counted_iterator& _Right) noexcept /* strengthened */ {
        return _Right._Length;
    }

    constexpr counted_iterator& operator-=(const iter_difference_t<_Iter> _Diff)
        requires random_access_iterator<_Iter>
    {
#if _ITERATOR_DEBUG_LEVEL != 0
        _STL_VERIFY(-_Diff <= _Length, "counted_iterator decrement beyond end of range");
#endif // _ITERATOR_DEBUG_LEVEL != 0
        _Current -= _Diff;
        _Length += _Diff;
        return *this;
    }

    // [counted.iter.cmp]
    template <common_with<_Iter> _Other>
    _NODISCARD_FRIEND constexpr bool operator==(
        const counted_iterator& _Left, const counted_iterator<_Other>& _Right) noexcept /* strengthened */ {
#if _ITERATOR_DEBUG_LEVEL != 0
        _Same_sequence(_Left, _Right);
#endif // _ITERATOR_DEBUG_LEVEL != 0
        return _Left._Length == _Right.count();
    }

    _NODISCARD_FRIEND constexpr bool operator==(const counted_iterator& _Left, default_sentinel_t) noexcept
        /* strengthened */ {
        return _Left._Length == 0;
    }

    template <common_with<_Iter> _Other>
    _NODISCARD_FRIEND constexpr strong_ordering operator<=>(
        const counted_iterator& _Left, const counted_iterator<_Other>& _Right) noexcept /* strengthened */ {
#if _ITERATOR_DEBUG_LEVEL != 0
        _Same_sequence(_Left, _Right);
#endif // _ITERATOR_DEBUG_LEVEL != 0
        return _Right.count() <=> _Left._Length;
    }

    // [counted.iter.cust]
    _NODISCARD_FRIEND constexpr decltype(auto) iter_move(const counted_iterator& _Right) noexcept(
        noexcept(_RANGES iter_move(_Right._Current)))
        requires input_iterator<_Iter>
    {
        return _RANGES iter_move(_Right._Current);
    }

    template <indirectly_swappable<_Iter> _Other>
    friend constexpr void iter_swap(const counted_iterator& _Left, const counted_iterator<_Other>& _Right) noexcept(
        noexcept(_RANGES iter_swap(_Left._Current, _Right.base()))) {
        _RANGES iter_swap(_Left._Current, _Right.base());
    }

#if _ITERATOR_DEBUG_LEVEL != 0
    template <common_with<_Iter> _Other>
    friend constexpr void _Same_sequence(
        const counted_iterator& _Left, const counted_iterator<_Other>& _Right) noexcept {
#ifdef _M_CEE // TRANSITION, VSO-1665606
        (void) _Left;
        (void)_Right;
#else // ^^^ workaround / no workaround vvv

        // Per N4950 [counted.iterator]/3, two counted_iterators x and y refer to elements of the same sequence iff
        // for some integer n, next(x.base(), x.count() + n) and next(y.base(), y.count() + n)
        // "refer to the same (possibly past-the-end) element".
        // Iterator equality is a fair proxy for the vaguely-defined "refer to the same element".
        if constexpr (forward_iterator<_Iter> && forward_iterator<_Other>) {
            using _CIter = common_type_t<_Iter, _Other>;
            using _CDiff = common_type_t<iter_difference_t<_Iter>, iter_difference_t<_Other>>;

            const _CDiff _Diff = static_cast<_CDiff>(_Left._Length) - static_cast<_CDiff>(_Right.count());
            if (_Diff < 0) {
                _STL_VERIFY(
                    static_cast<_CIter>(_Left._Current) == _RANGES next(static_cast<_CIter>(_Right.base()), -_Diff),
                    "counted_iterators are from different ranges");
            }
            else {
                _STL_VERIFY(
                    _RANGES next(static_cast<_CIter>(_Left._Current), _Diff) == static_cast<_CIter>(_Right.base()),
                    "counted_iterators are from different ranges");
            }
        }
#endif // ^^^ no workaround ^^^
    }
#endif // _ITERATOR_DEBUG_LEVEL != 0

    template <common_with<_Iter> _Other>
    friend constexpr void _Verify_range(const counted_iterator& _Left, const counted_iterator<_Other>& _Right) {
        if constexpr (_Range_verifiable_v<_Iter, _Other>) {
            _Verify_range(_Left._Current, _Right.base());
        }
#if _ITERATOR_DEBUG_LEVEL != 0
        _Same_sequence(_Left, _Right);
#endif // _ITERATOR_DEBUG_LEVEL != 0
    }

    constexpr void _Verify_offset(const iter_difference_t<_Iter> _Off) const {
#if _ITERATOR_DEBUG_LEVEL != 0
        _STL_VERIFY(_Off <= _Length, "Offset larger than counted_iterator length");
#endif // _ITERATOR_DEBUG_LEVEL != 0
        if constexpr (_Offset_verifiable_v<_Iter>) {
            _Current._Verify_offset(_Off);
        }
    }

    using _Prevent_inheriting_unwrap = counted_iterator;

    _NODISCARD constexpr counted_iterator<_Unwrapped_t<const _Iter&>> _Unwrapped() const& noexcept(
        noexcept(counted_iterator<_Unwrapped_t<const _Iter&>>{_Current._Unwrapped(), _Length}))
        requires _Unwrappable_v<const _Iter&>
    {
        return counted_iterator<_Unwrapped_t<const _Iter&>>{_Current._Unwrapped(), _Length};
    }

    _NODISCARD constexpr counted_iterator<_Unwrapped_t<_Iter>> _Unwrapped() && noexcept(
        noexcept(counted_iterator<_Unwrapped_t<_Iter>>{_STD move(_Current)._Unwrapped(), _Length}))
        requires _Unwrappable_v<_Iter>
    {
        return counted_iterator<_Unwrapped_t<_Iter>>{_STD move(_Current)._Unwrapped(), _Length};
    }

    static constexpr bool _Unwrap_when_unverified = _Do_unwrap_when_unverified_v<_Iter>;

    template <class _Other>
        requires _Wrapped_seekable_v<_Iter, const _Other&>
    constexpr void _Seek_to(const counted_iterator<_Other>& _It) {
        _Current._Seek_to(_It.base());
        _Length = _It.count();
    }

    template <class _Other>
        requires _Wrapped_seekable_v<_Iter, _Other>
    constexpr void _Seek_to(counted_iterator<_Other>&& _It) {
        _Current._Seek_to(_STD move(_It).base());
        _Length = _It.count();
    }

private:
    _Iter _Current{};
    iter_difference_t<_Iter> _Length = 0;
};

template <input_iterator _Iter>
    requires (!_Is_from_primary<iterator_traits<_Iter>>)
struct iterator_traits<counted_iterator<_Iter>> : iterator_traits<_Iter> {
    using pointer = conditional_t<contiguous_iterator<_Iter>, add_pointer_t<iter_reference_t<_Iter>>, void>;
};
#endif // _HAS_CXX20

_STD_END

#pragma push_macro("stdext")
#pragma push_macro("checked_array_iterator")
#pragma push_macro("make_checked_array_iterator")
#pragma push_macro("make_unchecked_array_iterator")
#pragma push_macro("unchecked_array_iterator")
#undef stdext
#undef checked_array_iterator
#undef make_checked_array_iterator
#undef make_unchecked_array_iterator
#undef unchecked_array_iterator

_STDEXT_BEGIN
template <class _Ptr>
class _DEPRECATE_STDEXT_ARR_ITERS checked_array_iterator { // wrap a pointer with checking
private:
    using _Pointee_type = _STD remove_pointer_t<_Ptr>;
    static_assert(_STD is_pointer_v<_Ptr>&& _STD is_object_v<_Pointee_type>,
        "checked_array_iterator requires pointers to objects");

public:
    using iterator_category = _STD random_access_iterator_tag;
    using value_type = _STD remove_cv_t<_Pointee_type>;
    using difference_type = _STD ptrdiff_t;
    using pointer = _Ptr;
    using reference = _Pointee_type&;
#if _HAS_CXX20
    using iterator_concept = _STD contiguous_iterator_tag;
#endif // _HAS_CXX20

    constexpr checked_array_iterator() = default;

    constexpr checked_array_iterator(const _Ptr _Array, const size_t _Size, const size_t _Index = 0) noexcept
        : _Myarray(_Array), _Mysize(_Size), _Myindex(_Index) {
        _STL_VERIFY(_Index <= _Size, "checked_array_iterator construction index out of range");
    }

    _STL_DISABLE_DEPRECATED_WARNING
        template <class _Ty = _Pointee_type, _STD enable_if_t<!_STD is_const_v<_Ty>, int> = 0>
    constexpr operator checked_array_iterator<const _Ty*>() const noexcept {
        return checked_array_iterator<const _Ty*>{_Myarray, _Mysize, _Myindex};
    }
    _STL_RESTORE_DEPRECATED_WARNING

        _NODISCARD constexpr _Ptr base() const noexcept {
        return _Myarray + _Myindex;
    }

    _NODISCARD constexpr reference operator*() const noexcept {
        return *operator->();
    }

    _NODISCARD constexpr pointer operator->() const noexcept {
        _STL_VERIFY(_Myarray, "cannot dereference value-initialized or null checked_array_iterator");
        _STL_VERIFY(_Myindex < _Mysize, "cannot dereference end checked_array_iterator");
        return _Myarray + _Myindex;
    }

    constexpr checked_array_iterator& operator++() noexcept {
        _STL_VERIFY(_Myarray, "cannot increment value-initialized or null checked_array_iterator");
        _STL_VERIFY(_Myindex < _Mysize, "cannot increment checked_array_iterator past end");
        ++_Myindex;
        return *this;
    }

    constexpr checked_array_iterator operator++(int) noexcept {
        checked_array_iterator _Tmp = *this;
        ++*this;
        return _Tmp;
    }

    constexpr checked_array_iterator& operator--() noexcept {
        _STL_VERIFY(_Myarray, "cannot decrement value-initialized or null checked_array_iterator");
        _STL_VERIFY(_Myindex != 0, "cannot decrement checked_array_iterator before begin");
        --_Myindex;
        return *this;
    }

    constexpr checked_array_iterator operator--(int) noexcept {
        checked_array_iterator _Tmp = *this;
        --*this;
        return _Tmp;
    }

    constexpr checked_array_iterator& operator+=(const difference_type _Off) noexcept {
        if (_Off != 0) {
            _STL_VERIFY(_Myarray, "cannot seek value-initialized or null checked_array_iterator");
        }

        if (_Off < 0) {
            _STL_VERIFY(
                _Myindex >= size_t{ 0 } - static_cast<size_t>(_Off), "cannot seek checked_array_iterator before begin");
        }

        if (_Off > 0) {
            _STL_VERIFY(
                _Mysize - _Myindex >= static_cast<size_t>(_Off), "cannot seek checked_array_iterator after end");
        }

        _Myindex += _Off;
        return *this;
    }

    _NODISCARD constexpr checked_array_iterator operator+(const difference_type _Off) const noexcept {
        checked_array_iterator _Tmp = *this;
        _Tmp += _Off;
        return _Tmp;
    }

    _NODISCARD_FRIEND constexpr checked_array_iterator operator+(
        const difference_type _Off, const checked_array_iterator<_Ptr>& _Next) noexcept {
        return _Next + _Off;
    }

    constexpr checked_array_iterator& operator-=(const difference_type _Off) noexcept {
        if (_Off != 0) {
            _STL_VERIFY(_Myarray, "cannot seek value-initialized or null checked_array_iterator");
        }

        if (_Off > 0) {
            _STL_VERIFY(_Myindex >= static_cast<size_t>(_Off), "cannot seek checked_array_iterator before begin");
        }

        if (_Off < 0) {
            _STL_VERIFY(_Mysize - _Myindex >= size_t{ 0 } - static_cast<size_t>(_Off),
                "cannot seek checked_array_iterator after end");
        }

        _Myindex -= _Off;
        return *this;
    }

    _NODISCARD constexpr checked_array_iterator operator-(const difference_type _Off) const noexcept {
        checked_array_iterator _Tmp = *this;
        _Tmp -= _Off;
        return _Tmp;
    }

    _NODISCARD constexpr difference_type operator-(const checked_array_iterator& _Right) const noexcept {
        _STL_VERIFY(_Myarray == _Right._Myarray && _Mysize == _Right._Mysize,
            "cannot subtract incompatible checked_array_iterators");
        return static_cast<difference_type>(_Myindex - _Right._Myindex);
    }

    _NODISCARD constexpr reference operator[](const difference_type _Off) const noexcept {
        return *(*this + _Off);
    }

    _NODISCARD constexpr bool operator==(const checked_array_iterator& _Right) const noexcept {
        _STL_VERIFY(_Myarray == _Right._Myarray && _Mysize == _Right._Mysize,
            "cannot compare incompatible checked_array_iterators for equality");
        return _Myindex == _Right._Myindex;
    }

#if _HAS_CXX20
    _NODISCARD constexpr _STD strong_ordering operator<=>(const checked_array_iterator& _Right) const noexcept {
        _STL_VERIFY(_Myarray == _Right._Myarray && _Mysize == _Right._Mysize,
            "cannot compare incompatible checked_array_iterators");
        return _Myindex <=> _Right._Myindex;
    }
#else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
    _NODISCARD constexpr bool operator!=(const checked_array_iterator& _Right) const noexcept {
        return !(*this == _Right);
    }

    _NODISCARD constexpr bool operator<(const checked_array_iterator& _Right) const noexcept {
        _STL_VERIFY(_Myarray == _Right._Myarray && _Mysize == _Right._Mysize,
            "cannot compare incompatible checked_array_iterators");
        return _Myindex < _Right._Myindex;
    }

    _NODISCARD constexpr bool operator>(const checked_array_iterator& _Right) const noexcept {
        return _Right < *this;
    }

    _NODISCARD constexpr bool operator<=(const checked_array_iterator& _Right) const noexcept {
        return !(_Right < *this);
    }

    _NODISCARD constexpr bool operator>=(const checked_array_iterator& _Right) const noexcept {
        return !(*this < _Right);
    }
#endif // ^^^ !_HAS_CXX20 ^^^

    friend constexpr void _Verify_range(
        const checked_array_iterator& _First, const checked_array_iterator& _Last) noexcept {
        _STL_VERIFY(_First._Myarray == _Last._Myarray && _First._Mysize == _Last._Mysize,
            "mismatching checked_array_iterators");
        _STL_VERIFY(_First._Myindex <= _Last._Myindex, "transposed checked_array_iterator range");
    }

    constexpr void _Verify_offset(const difference_type _Off) const noexcept {
        if (_Off < 0) {
            _STL_VERIFY(_Myindex >= size_t{ 0 } - static_cast<size_t>(_Off),
                "cannot seek checked_array_iterator iterator before begin");
        }

        if (_Off > 0) {
            _STL_VERIFY(_Mysize - _Myindex >= static_cast<size_t>(_Off),
                "cannot seek checked_array_iterator iterator after end");
        }
    }

    using _Prevent_inheriting_unwrap = checked_array_iterator;

    _NODISCARD constexpr _Ptr _Unwrapped() const noexcept {
        return _Myarray + _Myindex;
    }

    constexpr void _Seek_to(_Ptr _It) noexcept {
        _Myindex = static_cast<size_t>(_It - _Myarray);
    }

private:
    _Ptr _Myarray = nullptr; // beginning of array
    size_t _Mysize = 0; // size of array
    size_t _Myindex = 0; // offset into array
};

_STL_DISABLE_DEPRECATED_WARNING
template <class _Ptr>
_DEPRECATE_STDEXT_ARR_ITERS _NODISCARD constexpr checked_array_iterator<_Ptr> make_checked_array_iterator(
    const _Ptr _Array, const size_t _Size, const size_t _Index = 0) noexcept {
    return checked_array_iterator<_Ptr>(_Array, _Size, _Index);
}
_STL_RESTORE_DEPRECATED_WARNING

template <class _Ptr>
class _DEPRECATE_STDEXT_ARR_ITERS unchecked_array_iterator { // wrap a pointer without checking, to silence warnings
private:
    using _Pointee_type = _STD remove_pointer_t<_Ptr>;
    static_assert(_STD is_pointer_v<_Ptr>&& _STD is_object_v<_Pointee_type>,
        "unchecked_array_iterator requires pointers to objects");

public:
    using iterator_category = _STD random_access_iterator_tag;
    using value_type = _STD remove_cv_t<_Pointee_type>;
    using difference_type = _STD ptrdiff_t;
    using pointer = _Ptr;
    using reference = _Pointee_type&;
#if _HAS_CXX20
    using iterator_concept = _STD contiguous_iterator_tag;
#endif // _HAS_CXX20

    constexpr unchecked_array_iterator() = default;

    constexpr explicit unchecked_array_iterator(const _Ptr _Src) noexcept : _Myptr(_Src) {}

    _STL_DISABLE_DEPRECATED_WARNING
        template <class _Ty = _Pointee_type, _STD enable_if_t<!_STD is_const_v<_Ty>, int> = 0>
    constexpr operator unchecked_array_iterator<const _Ty*>() const noexcept {
        return unchecked_array_iterator<const _Ty*>{_Myptr};
    }
    _STL_RESTORE_DEPRECATED_WARNING

        _NODISCARD constexpr _Ptr base() const noexcept {
        return _Myptr;
    }

    _NODISCARD constexpr reference operator*() const noexcept {
        return *_Myptr;
    }

    _NODISCARD constexpr pointer operator->() const noexcept {
        return _Myptr;
    }

    constexpr unchecked_array_iterator& operator++() noexcept {
        ++_Myptr;
        return *this;
    }

    constexpr unchecked_array_iterator operator++(int) noexcept {
        unchecked_array_iterator _Tmp = *this;
        ++_Myptr;
        return _Tmp;
    }

    constexpr unchecked_array_iterator& operator--() noexcept {
        --_Myptr;
        return *this;
    }

    constexpr unchecked_array_iterator operator--(int) noexcept {
        unchecked_array_iterator _Tmp = *this;
        --_Myptr;
        return _Tmp;
    }

    constexpr unchecked_array_iterator& operator+=(const difference_type _Off) noexcept {
        _Myptr += _Off;
        return *this;
    }

    _NODISCARD constexpr unchecked_array_iterator operator+(const difference_type _Off) const noexcept {
        unchecked_array_iterator _Tmp = *this;
        _Tmp += _Off;
        return _Tmp;
    }

    _NODISCARD_FRIEND constexpr unchecked_array_iterator operator+(
        const difference_type _Off, const unchecked_array_iterator& _Next) noexcept {
        return _Next + _Off;
    }

    constexpr unchecked_array_iterator& operator-=(const difference_type _Off) noexcept {
        return *this += -_Off;
    }

    _NODISCARD constexpr unchecked_array_iterator operator-(const difference_type _Off) const noexcept {
        unchecked_array_iterator _Tmp = *this;
        _Tmp -= _Off;
        return _Tmp;
    }

    _NODISCARD constexpr difference_type operator-(const unchecked_array_iterator& _Right) const noexcept {
        return _Myptr - _Right._Myptr;
    }

    _NODISCARD constexpr reference operator[](const difference_type _Off) const noexcept {
        return *(*this + _Off);
    }

    _NODISCARD constexpr bool operator==(const unchecked_array_iterator& _Right) const noexcept {
        return _Myptr == _Right._Myptr;
    }

#if _HAS_CXX20
    _NODISCARD constexpr _STD strong_ordering operator<=>(const unchecked_array_iterator& _Right) const noexcept {
        return _Myptr <=> _Right._Myptr;
    }
#else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
    _NODISCARD constexpr bool operator!=(const unchecked_array_iterator& _Right) const noexcept {
        return !(*this == _Right);
    }

    _NODISCARD constexpr bool operator<(const unchecked_array_iterator& _Right) const noexcept {
        return _Myptr < _Right._Myptr;
    }

    _NODISCARD constexpr bool operator>(const unchecked_array_iterator& _Right) const noexcept {
        return _Right < *this;
    }

    _NODISCARD constexpr bool operator<=(const unchecked_array_iterator& _Right) const noexcept {
        return !(_Right < *this);
    }

    _NODISCARD constexpr bool operator>=(const unchecked_array_iterator& _Right) const noexcept {
        return !(*this < _Right);
    }
#endif // ^^^ !_HAS_CXX20 ^^^

#if _ITERATOR_DEBUG_LEVEL != 0
    friend constexpr void _Verify_range(
        const unchecked_array_iterator _First, const unchecked_array_iterator _Last) noexcept {
        _STD _Verify_range(_First._Myptr, _Last._Myptr);
    }
#endif // _ITERATOR_DEBUG_LEVEL != 0

    using _Prevent_inheriting_unwrap = unchecked_array_iterator;

    static constexpr bool _Unwrap_when_unverified = true;

    _NODISCARD constexpr _Ptr _Unwrapped() const noexcept {
        return _Myptr;
    }

    constexpr void _Seek_to(_Ptr _It) noexcept {
        _Myptr = _It;
    }

private:
    _Ptr _Myptr = nullptr; // underlying pointer
};

_STL_DISABLE_DEPRECATED_WARNING
template <class _Ptr>
_DEPRECATE_STDEXT_ARR_ITERS _NODISCARD unchecked_array_iterator<_Ptr> make_unchecked_array_iterator(
    const _Ptr _It) noexcept {
    return unchecked_array_iterator<_Ptr>(_It);
}
_STL_RESTORE_DEPRECATED_WARNING
_STDEXT_END

#if _HAS_CXX20
_STD_BEGIN
_STL_DISABLE_DEPRECATED_WARNING
template <class _Ty>
struct pointer_traits<_STDEXT checked_array_iterator<_Ty*>> {
    using pointer = _STDEXT checked_array_iterator<_Ty*>;
    using element_type = _Ty;
    using difference_type = ptrdiff_t;

    _NODISCARD static constexpr element_type* to_address(const pointer _Iter) noexcept {
        return _Iter._Unwrapped();
    }
};
_STL_RESTORE_DEPRECATED_WARNING
_STD_END
#endif // _HAS_CXX20

#pragma pop_macro("unchecked_array_iterator")
#pragma pop_macro("make_unchecked_array_iterator")
#pragma pop_macro("make_checked_array_iterator")
#pragma pop_macro("checked_array_iterator")
#pragma pop_macro("stdext")

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _ITERATOR_

#define _STREAMBUF_
#ifndef _XIOSBASE_
#define _XIOSBASE_
#if _STL_COMPILER_PREPROCESSOR
// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#ifndef _SYSTEM_ERROR_
#define _SYSTEM_ERROR_
#if _STL_COMPILER_PREPROCESSOR
// __msvc_system_error_abi.hpp internal header (core)

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#ifndef __MSVC_SYSTEM_ERROR_ABI_HPP
#define __MSVC_SYSTEM_ERROR_ABI_HPP
#if _STL_COMPILER_PREPROCESSOR


#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

#ifdef _M_CEE_PURE
#define __CLRCALL_PURE_OR_STDCALL __clrcall
#else
#define __CLRCALL_PURE_OR_STDCALL __stdcall
#endif

extern "C" {
    _NODISCARD size_t __CLRCALL_PURE_OR_STDCALL __std_get_string_size_without_trailing_whitespace(
        const char* _Str, size_t _Size) noexcept;

    _NODISCARD size_t __CLRCALL_PURE_OR_STDCALL __std_system_error_allocate_message(
        unsigned long _Message_id, char** _Ptr_str) noexcept;
    void __CLRCALL_PURE_OR_STDCALL __std_system_error_deallocate_message(char* _Str) noexcept;
} // extern "C"

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)

#endif // _STL_COMPILER_PREPROCESSOR
#endif // __MSVC_SYSTEM_ERROR_ABI_HPP

// cerrno standard header (core)

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#ifndef _CERRNO_
#define _CERRNO_
#if _STL_COMPILER_PREPROCESSOR



#endif // _STL_COMPILER_PREPROCESSOR
#endif // _CERRNO_

// stdexcept standard header

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#ifndef _STDEXCEPT_
#define _STDEXCEPT_
#if _STL_COMPILER_PREPROCESSOR
// xstring internal header

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

// (<string_view> without emitting non-C++17 warnings)

#ifndef _XSTRING_
#define _XSTRING_
#if _STL_COMPILER_PREPROCESSOR


#if _HAS_CXX17
// xpolymorphic_allocator.h internal header

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#ifndef _XPOLYMORPHIC_ALLOCATOR_H
#define _XPOLYMORPHIC_ALLOCATOR_H
#if _STL_COMPILER_PREPROCESSOR
// tuple standard header (core)

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#ifndef _TUPLE_
#define _TUPLE_
#if _STL_COMPILER_PREPROCESSOR

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_STD_BEGIN
template <bool _Same, class _Dest, class... _Srcs>
_INLINE_VAR constexpr bool _Tuple_conditional_explicit_v0 = false;

template <class... _Dests, class... _Srcs>
_INLINE_VAR constexpr bool _Tuple_conditional_explicit_v0<true, tuple<_Dests...>, _Srcs...> =
!conjunction_v<is_convertible<_Srcs, _Dests>...>;

template <class _Dest, class... _Srcs>
_INLINE_VAR constexpr bool _Tuple_conditional_explicit_v =
_Tuple_conditional_explicit_v0<tuple_size_v<_Dest> == sizeof...(_Srcs), _Dest, _Srcs...>;

template <bool _Same, class _Dest, class... _Srcs>
_INLINE_VAR constexpr bool _Tuple_constructible_v0 = false;

template <class... _Dests, class... _Srcs>
_INLINE_VAR constexpr bool _Tuple_constructible_v0<true, tuple<_Dests...>, _Srcs...> =
conjunction_v<is_constructible<_Dests, _Srcs>...>;

template <class _Dest, class... _Srcs>
_INLINE_VAR constexpr bool _Tuple_constructible_v =
_Tuple_constructible_v0<tuple_size_v<_Dest> == sizeof...(_Srcs), _Dest, _Srcs...>;

template <class _Dest, class... _Srcs>
struct _Tuple_constructible_val : bool_constant<_Tuple_constructible_v<_Dest, _Srcs...>> {};

template <bool _Same, class _Dest, class... _Srcs>
_INLINE_VAR constexpr bool _Tuple_nothrow_constructible_v0 = false;

template <class... _Dests, class... _Srcs>
_INLINE_VAR constexpr bool _Tuple_nothrow_constructible_v0<true, tuple<_Dests...>, _Srcs...> =
conjunction_v<is_nothrow_constructible<_Dests, _Srcs>...>;

template <class _Dest, class... _Srcs>
_INLINE_VAR constexpr bool _Tuple_nothrow_constructible_v =
_Tuple_nothrow_constructible_v0<tuple_size_v<_Dest> == sizeof...(_Srcs), _Dest, _Srcs...>;

template <bool _Same, class _Dest, class... _Srcs>
_INLINE_VAR constexpr bool _Tuple_assignable_v0 = false;

template <class... _Dests, class... _Srcs>
_INLINE_VAR constexpr bool _Tuple_assignable_v0<true, tuple<_Dests...>, _Srcs...> =
conjunction_v<is_assignable<_Dests&, _Srcs>...>; // note _Dests& instead of _Dests

#if _HAS_CXX23
template <class... _Dests, class... _Srcs>
inline constexpr bool _Tuple_assignable_v0<true, const tuple<_Dests...>, _Srcs...> =
conjunction_v<is_assignable<const _Dests&, _Srcs>...>;
#endif // _HAS_CXX23

template <class _Dest, class... _Srcs>
_INLINE_VAR constexpr bool _Tuple_assignable_v =
_Tuple_assignable_v0<tuple_size_v<_Dest> == sizeof...(_Srcs), _Dest, _Srcs...>;

template <class _Dest, class... _Srcs>
struct _Tuple_assignable_val : bool_constant<_Tuple_assignable_v<_Dest, _Srcs...>> {};

template <bool _Same, class _Dest, class... _Srcs>
_INLINE_VAR constexpr bool _Tuple_nothrow_assignable_v0 = false;

template <class... _Dests, class... _Srcs>
_INLINE_VAR constexpr bool _Tuple_nothrow_assignable_v0<true, tuple<_Dests...>, _Srcs...> =
conjunction_v<is_nothrow_assignable<_Dests&, _Srcs>...>; // note _Dests& instead of _Dests

#if _HAS_CXX23
template <class... _Dests, class... _Srcs>
inline constexpr bool _Tuple_nothrow_assignable_v0<true, const tuple<_Dests...>, _Srcs...> =
conjunction_v<is_nothrow_assignable<const _Dests&, _Srcs>...>;
#endif // _HAS_CXX23

template <class _Dest, class... _Srcs>
_INLINE_VAR constexpr bool _Tuple_nothrow_assignable_v =
_Tuple_nothrow_assignable_v0<tuple_size_v<_Dest> == sizeof...(_Srcs), _Dest, _Srcs...>;

// Constrain tuple's converting constructors
template <class _Myself, class _OtherTuple, class... _Other>
struct _Tuple_convert_val : true_type {};

template <class _This, class _OtherTuple, class _Uty>
struct _Tuple_convert_val<tuple<_This>, _OtherTuple, _Uty>
    : bool_constant<!disjunction_v<is_same<_This, _Uty>, is_constructible<_This, _OtherTuple>,
    is_convertible<_OtherTuple, _This>>> {};

// Constrain tuple's perfect forwarding constructor (LWG-3121)
template <class _Myself, class _This2, class... _Rest2>
struct _Tuple_perfect_val : true_type {};

template <class _Myself, class _This2>
struct _Tuple_perfect_val<_Myself, _This2> : bool_constant<!is_same_v<_Myself, _Remove_cvref_t<_This2>>> {};

template <class _Ty0, class _Ty1, class _Uty0, class _Uty1>
struct _Tuple_perfect_val<tuple<_Ty0, _Ty1>, _Uty0, _Uty1>
    : bool_constant<disjunction_v<negation<is_same<_Remove_cvref_t<_Uty0>, allocator_arg_t>>,
    is_same<_Remove_cvref_t<_Ty0>, allocator_arg_t>>> {};

template <class _Ty0, class _Ty1, class _Ty2, class _Uty0, class _Uty1, class _Uty2>
struct _Tuple_perfect_val<tuple<_Ty0, _Ty1, _Ty2>, _Uty0, _Uty1, _Uty2>
    : bool_constant<disjunction_v<negation<is_same<_Remove_cvref_t<_Uty0>, allocator_arg_t>>,
    is_same<_Remove_cvref_t<_Ty0>, allocator_arg_t>>> {};

struct _Ignore { // struct that ignores assignments
    template <class _Ty>
    constexpr const _Ignore& operator=(const _Ty&) const noexcept /* strengthened */ {
        // do nothing
        return *this;
    }
};

_EXPORT_STD _INLINE_VAR constexpr _Ignore ignore{};

// Note: To improve throughput, this file uses extra _STD qualification for names that appear in the
// arguments of enable_if_t. Specifically, we qualify names which appear anywhere in the STL as members of
// some class - including injected-class-names! - that we know are not members of the class being defined.
// This avoids pointless class-member lookup for those names in this context.

template <class _Ty>
struct _Tuple_val { // stores each value in a tuple
    constexpr _Tuple_val() : _Val() {}

    template <class _Other>
    constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) {}

    template <class _Alloc, class... _Other, enable_if_t<!uses_allocator_v<_Ty, _Alloc>, int> = 0>
    constexpr _Tuple_val(const _Alloc&, allocator_arg_t, _Other&&... _Arg) : _Val(_STD forward<_Other>(_Arg)...) {}

    template <class _Alloc, class... _Other,
        enable_if_t<conjunction_v<_STD uses_allocator<_Ty, _Alloc>,
        _STD is_constructible<_Ty, _STD allocator_arg_t, const _Alloc&, _Other...>>,
        int> = 0>
        constexpr _Tuple_val(const _Alloc& _Al, allocator_arg_t, _Other&&... _Arg)
        : _Val(allocator_arg, _Al, _STD forward<_Other>(_Arg)...) {}

    template <class _Alloc, class... _Other,
        enable_if_t<conjunction_v<_STD uses_allocator<_Ty, _Alloc>,
        _STD negation<_STD is_constructible<_Ty, _STD allocator_arg_t, const _Alloc&, _Other...>>>,
        int> = 0>
    constexpr _Tuple_val(const _Alloc& _Al, allocator_arg_t, _Other&&... _Arg)
        : _Val(_STD forward<_Other>(_Arg)..., _Al) {}

    _Ty _Val;
};

struct _Exact_args_t {
    explicit _Exact_args_t() = default;
}; // tag type to disambiguate construction (from one arg per element)

struct _Unpack_tuple_t {
    explicit _Unpack_tuple_t() = default;
}; // tag type to disambiguate construction (from unpacking a tuple/pair)

struct _Alloc_exact_args_t {
    explicit _Alloc_exact_args_t() = default;
}; // tag type to disambiguate construction (from an allocator and one arg per element)

struct _Alloc_unpack_tuple_t {
    explicit _Alloc_unpack_tuple_t() = default;
}; // tag type to disambiguate construction (from an allocator and unpacking a tuple/pair)

#if _HAS_CXX23
template <class _Tuple, class _Other, class _Indices = make_index_sequence<tuple_size_v<_Tuple>>>
inline constexpr bool _Can_construct_values_from_tuple_like_v = false;

template <class... _Types, class _Other, size_t... _Indices>
inline constexpr bool _Can_construct_values_from_tuple_like_v<tuple<_Types...>, _Other, index_sequence<_Indices...>> =
conjunction_v<is_constructible<_Types, decltype(_STD get<_Indices>(_STD declval<_Other>()))>...>;

#if defined(__clang__) || defined(__EDG__) // TRANSITION, LLVM-59827 and VSO-1900279
template <class _TupleLike, class _Tuple>
concept _Can_construct_from_tuple_like =
_Different_from<_TupleLike, _Tuple>&& _Tuple_like<_TupleLike> && !_Is_subrange_v<remove_cvref_t<_TupleLike>>
&& (tuple_size_v<_Tuple> == tuple_size_v<remove_cvref_t<_TupleLike>>) //
&& _Can_construct_values_from_tuple_like_v<_Tuple, _TupleLike>
&& (tuple_size_v<_Tuple> != 1
    || (!is_convertible_v<_TupleLike, tuple_element_t<0, _Tuple>>
        && !is_constructible_v<tuple_element_t<0, _Tuple>, _TupleLike>));
#endif // ^^^ workaround ^^^

template <class _TTuple, class _UTuple, class _Indices = make_index_sequence<tuple_size_v<_UTuple>>>
struct _Three_way_comparison_result_with_tuple_like {};

template <class... _TTypes, class _UTuple, size_t... _Indices>
    requires
#if !defined(__clang__) && !defined(__EDG__) // TRANSITION, DevCom-10265237
(sizeof...(_TTypes) == sizeof...(_Indices)) &&
#endif // ^^^ workaround ^^^
(requires { typename _Synth_three_way_result<_TTypes, tuple_element_t<_Indices, _UTuple>>; } && ...)
struct _Three_way_comparison_result_with_tuple_like<tuple<_TTypes...>, _UTuple, index_sequence<_Indices...>> {
    using type = common_comparison_category_t<_Synth_three_way_result<_TTypes, tuple_element_t<_Indices, _UTuple>>...>;
};

template <class _TTuple, _Tuple_like _UTuple>
using _Three_way_comparison_result_with_tuple_like_t =
_Three_way_comparison_result_with_tuple_like<_TTuple, _UTuple>::type;

template <class _Ty>
concept _Tuple_like_non_tuple = !_Is_specialization_v<_Ty, tuple>&& _Tuple_like<_Ty>;
#endif // _HAS_CXX23

template <>
class tuple<> { // empty tuple
public:
    constexpr tuple() noexcept = default; /* strengthened */

    constexpr tuple(const tuple&) noexcept /* strengthened */ {} // TRANSITION, ABI: should be defaulted

#if _HAS_CXX23
    template <_Different_from<tuple> _Other>
        requires _Tuple_like<_Other> && (tuple_size_v<remove_cvref_t<_Other>> == 0)
    constexpr tuple(_Other&&) noexcept /* strengthened */ {}
#endif // _HAS_CXX23

    template <class _Alloc>
    _CONSTEXPR20 tuple(allocator_arg_t, const _Alloc&) noexcept /* strengthened */ {}

    template <class _Alloc>
    _CONSTEXPR20 tuple(allocator_arg_t, const _Alloc&, const tuple&) noexcept /* strengthened */ {}

#if _HAS_CXX23
    template <class _Alloc, _Different_from<tuple> _Other>
        requires _Tuple_like<_Other> && (tuple_size_v<remove_cvref_t<_Other>> == 0)
    constexpr tuple(allocator_arg_t, const _Alloc&, _Other&&) noexcept /* strengthened */ {}
#endif // _HAS_CXX23

    template <class _Tag, enable_if_t<is_same_v<_Tag, _STD _Exact_args_t>, int> = 0>
    constexpr tuple(_Tag) noexcept /* strengthened */ {}

    template <class _Tag, class _Alloc, enable_if_t<is_same_v<_Tag, _STD _Alloc_exact_args_t>, int> = 0>
    constexpr tuple(_Tag, const _Alloc&) noexcept /* strengthened */ {}

    constexpr tuple& operator=(const tuple&) = default;
#if _HAS_CXX23
    constexpr const tuple& operator=(const tuple&) const noexcept /* strengthened */ {
        return *this;
    }

    template <_Different_from<tuple> _Other>
        requires _Tuple_like<_Other> && (tuple_size_v<remove_cvref_t<_Other>> == 0)
    constexpr tuple& operator=(_Other&&) noexcept /* strengthened */ {
        return *this;
    }

    template <_Different_from<tuple> _Other>
        requires _Tuple_like<_Other> && (tuple_size_v<remove_cvref_t<_Other>> == 0)
    constexpr const tuple& operator=(_Other&&) const noexcept /* strengthened */ {
        return *this;
    }
#endif // _HAS_CXX23

    _CONSTEXPR20 void swap(tuple&) noexcept {}
#if _HAS_CXX23
    constexpr void swap(const tuple&) const noexcept {}
#endif // _HAS_CXX23

    constexpr bool _Equals(const tuple&) const noexcept {
        return true;
    }

#if _HAS_CXX20
    _NODISCARD constexpr strong_ordering _Three_way_compare(const tuple&) const noexcept {
        return strong_ordering::equal;
    }
#else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
    _NODISCARD constexpr bool _Less(const tuple&) const noexcept {
        return false;
    }
#endif // ^^^ !_HAS_CXX20 ^^^

#if _HAS_CXX23
    template <_Tuple_like_non_tuple _Other>
    _NODISCARD_FRIEND constexpr bool operator==(const tuple&, const _Other&) noexcept /* strengthened */ {
        static_assert(tuple_size_v<_Other> == 0, "Cannot compare tuples of different sizes (N4950 [tuple.rel]/2).");
        return true;
    }

    template <_Tuple_like_non_tuple _Other>
        requires (tuple_size_v<remove_cvref_t<_Other>> == 0)
    _NODISCARD_FRIEND constexpr strong_ordering operator<=>(const tuple&, const _Other&) noexcept /* strengthened */ {
        return strong_ordering::equal;
    }
#endif // _HAS_CXX23
};

template <class _This, class... _Rest>
class tuple<_This, _Rest...> : private tuple<_Rest...> { // recursive tuple definition
public:
    using _This_type = _This;
    using _Mybase = tuple<_Rest...>;

    template <class _Tag, class _This2, class... _Rest2, enable_if_t<is_same_v<_Tag, _STD _Exact_args_t>, int> = 0>
    constexpr tuple(_Tag, _This2&& _This_arg, _Rest2&&... _Rest_arg)
        : _Mybase(_Exact_args_t{}, _STD forward<_Rest2>(_Rest_arg)...), _Myfirst(_STD forward<_This2>(_This_arg)) {}

    template <class _Tag, class _Tpl, size_t... _Indices, enable_if_t<is_same_v<_Tag, _STD _Unpack_tuple_t>, int> = 0>
    constexpr tuple(_Tag, _Tpl&& _Right, index_sequence<_Indices...>);

    template <class _Tag, class _Tpl, enable_if_t<is_same_v<_Tag, _STD _Unpack_tuple_t>, int> = 0>
    constexpr tuple(_Tag, _Tpl&& _Right)
        : tuple(_Unpack_tuple_t{}, _STD forward<_Tpl>(_Right),
            make_index_sequence<tuple_size_v<remove_reference_t<_Tpl>>>{}) {}

    template <class _Tag, class _Alloc, class _This2, class... _Rest2,
        enable_if_t<is_same_v<_Tag, _STD _Alloc_exact_args_t>, int> = 0>
    constexpr tuple(_Tag, const _Alloc& _Al, _This2&& _This_arg, _Rest2&&... _Rest_arg)
        : _Mybase(_Alloc_exact_args_t{}, _Al, _STD forward<_Rest2>(_Rest_arg)...),
        _Myfirst(_Al, allocator_arg, _STD forward<_This2>(_This_arg)) {}

    template <class _Tag, class _Alloc, class _Tpl, size_t... _Indices,
        enable_if_t<is_same_v<_Tag, _STD _Alloc_unpack_tuple_t>, int> = 0>
    constexpr tuple(_Tag, const _Alloc& _Al, _Tpl&& _Right, index_sequence<_Indices...>);

    template <class _Tag, class _Alloc, class _Tpl, enable_if_t<is_same_v<_Tag, _STD _Alloc_unpack_tuple_t>, int> = 0>
    constexpr tuple(_Tag, const _Alloc& _Al, _Tpl&& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, _STD forward<_Tpl>(_Right),
            make_index_sequence<tuple_size_v<remove_reference_t<_Tpl>>>{}) {}

    template <class _This2 = _This,
        enable_if_t<conjunction_v<_STD is_default_constructible<_This2>, _STD is_default_constructible<_Rest>...>,
        int> = 0>
    constexpr explicit(
        !conjunction_v<_Is_implicitly_default_constructible<_This2>, _Is_implicitly_default_constructible<_Rest>...>)
        tuple() noexcept(conjunction_v<is_nothrow_default_constructible<_This2>,
            is_nothrow_default_constructible<_Rest>...>) // strengthened
        : _Mybase(), _Myfirst() {}

    template <class _This2 = _This, enable_if_t<_Tuple_constructible_v<tuple, const _This2&, const _Rest&...>, int> = 0>
    constexpr explicit(_Tuple_conditional_explicit_v<tuple, const _This2&, const _Rest&...>) tuple(
        const _This& _This_arg, const _Rest&... _Rest_arg) noexcept(conjunction_v<is_nothrow_copy_constructible<_This2>,
            is_nothrow_copy_constructible<_Rest>...>) // strengthened
        : tuple(_Exact_args_t{}, _This_arg, _Rest_arg...) {}

    template <class _This2, class... _Rest2,
        enable_if_t<conjunction_v<_STD _Tuple_perfect_val<tuple, _This2, _Rest2...>,
        _STD _Tuple_constructible_val<tuple, _This2, _Rest2...>>,
        int> = 0>
        constexpr explicit(_Tuple_conditional_explicit_v<tuple, _This2, _Rest2...>) tuple(_This2&& _This_arg,
            _Rest2&&... _Rest_arg) noexcept(_Tuple_nothrow_constructible_v<tuple, _This2, _Rest2...>) // strengthened
        : tuple(_Exact_args_t{}, _STD forward<_This2>(_This_arg), _STD forward<_Rest2>(_Rest_arg)...) {}

    tuple(const tuple&) = default;
    tuple(tuple&&) = default;

#if _HAS_CXX23
    template <class... _Other, enable_if_t<conjunction_v<_STD _Tuple_constructible_val<tuple, _Other&...>,
        _STD _Tuple_convert_val<tuple, tuple<_Other...>&, _Other...>>,
        int> = 0>
    constexpr explicit(_Tuple_conditional_explicit_v<tuple, _Other&...>)
        tuple(tuple<_Other...>& _Right) noexcept(_Tuple_nothrow_constructible_v<tuple, _Other&...>) // strengthened
        : tuple(_Unpack_tuple_t{}, _Right) {}
#endif // _HAS_CXX23

    template <class... _Other, enable_if_t<conjunction_v<_STD _Tuple_constructible_val<tuple, const _Other&...>,
        _STD _Tuple_convert_val<tuple, const tuple<_Other...>&, _Other...>>,
        int> = 0>
    constexpr explicit(_Tuple_conditional_explicit_v<tuple, const _Other&...>)
        tuple(const tuple<_Other...>& _Right) noexcept(
            _Tuple_nothrow_constructible_v<tuple, const _Other&...>) // strengthened
        : tuple(_Unpack_tuple_t{}, _Right) {}

    template <class... _Other, enable_if_t<conjunction_v<_STD _Tuple_constructible_val<tuple, _Other...>,
        _STD _Tuple_convert_val<tuple, tuple<_Other...>, _Other...>>,
        int> = 0>
    constexpr explicit(_Tuple_conditional_explicit_v<tuple, _Other...>)
        tuple(tuple<_Other...>&& _Right) noexcept(_Tuple_nothrow_constructible_v<tuple, _Other...>) // strengthened
        : tuple(_Unpack_tuple_t{}, _STD move(_Right)) {}

#if _HAS_CXX23
    template <class... _Other, enable_if_t<conjunction_v<_STD _Tuple_constructible_val<tuple, const _Other...>,
        _STD _Tuple_convert_val<tuple, const tuple<_Other...>, _Other...>>,
        int> = 0>
    constexpr explicit(_Tuple_conditional_explicit_v<tuple, const _Other...>)
        tuple(const tuple<_Other...>&& _Right) noexcept(
            _Tuple_nothrow_constructible_v<tuple, const _Other...>) // strengthened
        : tuple(_Unpack_tuple_t{}, _STD move(_Right)) {}

    template <class _First, class _Second, enable_if_t<_Tuple_constructible_v<tuple, _First&, _Second&>, int> = 0>
    constexpr explicit(_Tuple_conditional_explicit_v<tuple, _First&, _Second&>)
        tuple(pair<_First, _Second>& _Right) noexcept(
            _Tuple_nothrow_constructible_v<tuple, _First&, _Second&>) // strengthened
        : tuple(_Unpack_tuple_t{}, _Right) {}
#endif // _HAS_CXX23

    template <class _First, class _Second,
        enable_if_t<_Tuple_constructible_v<tuple, const _First&, const _Second&>, int> = 0>
    constexpr explicit(_Tuple_conditional_explicit_v<tuple, const _First&, const _Second&>)
        tuple(const pair<_First, _Second>& _Right) noexcept(
            _Tuple_nothrow_constructible_v<tuple, const _First&, const _Second&>) // strengthened
        : tuple(_Unpack_tuple_t{}, _Right) {}

    template <class _First, class _Second, enable_if_t<_Tuple_constructible_v<tuple, _First, _Second>, int> = 0>
    constexpr explicit(_Tuple_conditional_explicit_v<tuple, _First, _Second>) tuple(
        pair<_First, _Second>&& _Right) noexcept(_Tuple_nothrow_constructible_v<tuple, _First, _Second>) // strengthened
        : tuple(_Unpack_tuple_t{}, _STD move(_Right)) {}

#if _HAS_CXX23
    template <class _First, class _Second,
        enable_if_t<_Tuple_constructible_v<tuple, const _First, const _Second>, int> = 0>
    constexpr explicit(_Tuple_conditional_explicit_v<tuple, const _First, const _Second>)
        tuple(const pair<_First, _Second>&& _Right) noexcept(
            _Tuple_nothrow_constructible_v<tuple, const _First, const _Second>) // strengthened
        : tuple(_Unpack_tuple_t{}, _STD move(_Right)) {}

    template <class _Other, class _Indices = index_sequence_for<_Rest...>>
    static constexpr bool _Is_tuple_like_constructor_explicit_v = false;

    template <_Tuple_like _Other, size_t... _Indices>
    static constexpr bool _Is_tuple_like_constructor_explicit_v<_Other, index_sequence<_Indices...>> =
        negation_v<conjunction<is_convertible<decltype(_STD get<0>(_STD declval<_Other>())), _This>,
        is_convertible<decltype(_STD get<_Indices + 1>(_STD declval<_Other>())), _Rest>...>>;

#if defined(__clang__) || defined(__EDG__) // TRANSITION, LLVM-59827 and VSO-1900279
    template <class _Other, enable_if_t<_Can_construct_from_tuple_like<_Other, tuple>, int> = 0>
#else // ^^^ workaround / no workaround vvv
    template <_Different_from<tuple> _Other>
        requires _Tuple_like<_Other> && (!_Is_subrange_v<remove_cvref_t<_Other>>)
    && (1 + sizeof...(_Rest) == tuple_size_v<remove_cvref_t<_Other>>)
        && _Can_construct_values_from_tuple_like_v<tuple, _Other>
        && (sizeof...(_Rest) != 0 || (!is_convertible_v<_Other, _This> && !is_constructible_v<_This, _Other>))
#endif // ^^^ no workaround ^^^
        constexpr explicit(_Is_tuple_like_constructor_explicit_v<_Other>) tuple(_Other&& _Right)
        : tuple(_Unpack_tuple_t{}, _STD forward<_Other>(_Right)) {
    }
#endif // _HAS_CXX23

    template <class _Alloc, class _This2 = _This,
        enable_if_t<conjunction_v<_STD is_default_constructible<_This2>, _STD is_default_constructible<_Rest>...>,
        int> = 0>
    _CONSTEXPR20 explicit(
        !conjunction_v<_Is_implicitly_default_constructible<_This2>, _Is_implicitly_default_constructible<_Rest>...>)
        tuple(allocator_arg_t, const _Alloc& _Al)
        : _Mybase(allocator_arg, _Al), _Myfirst(_Al, allocator_arg) {}

    template <class _Alloc, class _This2 = _This,
        enable_if_t<_Tuple_constructible_v<tuple, const _This2&, const _Rest&...>, int> = 0>
    _CONSTEXPR20 explicit(_Tuple_conditional_explicit_v<tuple, const _This2&, const _Rest&...>)
        tuple(allocator_arg_t, const _Alloc& _Al, const _This& _This_arg, const _Rest&... _Rest_arg)
        : tuple(_Alloc_exact_args_t{}, _Al, _This_arg, _Rest_arg...) {}

    template <class _Alloc, class _This2, class... _Rest2,
        enable_if_t<conjunction_v<_STD _Tuple_perfect_val<tuple, _This2, _Rest2...>,
        _STD _Tuple_constructible_val<tuple, _This2, _Rest2...>>,
        int> = 0>
        _CONSTEXPR20 explicit(_Tuple_conditional_explicit_v<tuple, _This2, _Rest2...>)
        tuple(allocator_arg_t, const _Alloc& _Al, _This2&& _This_arg, _Rest2&&... _Rest_arg)
        : tuple(_Alloc_exact_args_t{}, _Al, _STD forward<_This2>(_This_arg), _STD forward<_Rest2>(_Rest_arg)...) {}

    template <class _Alloc, class _This2 = _This,
        enable_if_t<_Tuple_constructible_v<tuple, const _This2&, const _Rest&...>, int> = 0>
    _CONSTEXPR20 tuple(allocator_arg_t, const _Alloc& _Al, const tuple& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, _Right) {}

    template <class _Alloc, class _This2 = _This, enable_if_t<_Tuple_constructible_v<tuple, _This2, _Rest...>, int> = 0>
    _CONSTEXPR20 tuple(allocator_arg_t, const _Alloc& _Al, tuple&& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, _STD move(_Right)) {}

#if _HAS_CXX23
    template <class _Alloc, class... _Other,
        enable_if_t<conjunction_v<_STD _Tuple_constructible_val<tuple, _Other&...>,
        _STD _Tuple_convert_val<tuple, tuple<_Other...>&, _Other...>>,
        int> = 0>
        constexpr explicit(_Tuple_conditional_explicit_v<tuple, _Other&...>)
        tuple(allocator_arg_t, const _Alloc& _Al, tuple<_Other...>& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, _Right) {}
#endif // _HAS_CXX23

    template <class _Alloc, class... _Other,
        enable_if_t<conjunction_v<_STD _Tuple_constructible_val<tuple, const _Other&...>,
        _STD _Tuple_convert_val<tuple, const tuple<_Other...>&, _Other...>>,
        int> = 0>
        _CONSTEXPR20 explicit(_Tuple_conditional_explicit_v<tuple, const _Other&...>)
        tuple(allocator_arg_t, const _Alloc& _Al, const tuple<_Other...>& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, _Right) {}

    template <class _Alloc, class... _Other,
        enable_if_t<conjunction_v<_STD _Tuple_constructible_val<tuple, _Other...>,
        _STD _Tuple_convert_val<tuple, tuple<_Other...>, _Other...>>,
        int> = 0>
        _CONSTEXPR20 explicit(_Tuple_conditional_explicit_v<tuple, _Other...>)
        tuple(allocator_arg_t, const _Alloc& _Al, tuple<_Other...>&& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, _STD move(_Right)) {}

#if _HAS_CXX23
    template <class _Alloc, class... _Other,
        enable_if_t<conjunction_v<_STD _Tuple_constructible_val<tuple, const _Other...>,
        _STD _Tuple_convert_val<tuple, const tuple<_Other...>, _Other...>>,
        int> = 0>
        constexpr explicit(_Tuple_conditional_explicit_v<tuple, const _Other...>)
        tuple(allocator_arg_t, const _Alloc& _Al, const tuple<_Other...>&& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, _STD move(_Right)) {}

    template <class _Alloc, class _First, class _Second,
        enable_if_t<_Tuple_constructible_v<tuple, _First&, _Second&>, int> = 0>
    constexpr explicit(_Tuple_conditional_explicit_v<tuple, _First&, _Second&>)
        tuple(allocator_arg_t, const _Alloc& _Al, pair<_First, _Second>& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, _Right) {}
#endif // _HAS_CXX23

    template <class _Alloc, class _First, class _Second,
        enable_if_t<_Tuple_constructible_v<tuple, const _First&, const _Second&>, int> = 0>
    _CONSTEXPR20 explicit(_Tuple_conditional_explicit_v<tuple, const _First&, const _Second&>)
        tuple(allocator_arg_t, const _Alloc& _Al, const pair<_First, _Second>& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, _Right) {}

    template <class _Alloc, class _First, class _Second,
        enable_if_t<_Tuple_constructible_v<tuple, _First, _Second>, int> = 0>
    _CONSTEXPR20 explicit(_Tuple_conditional_explicit_v<tuple, _First, _Second>)
        tuple(allocator_arg_t, const _Alloc& _Al, pair<_First, _Second>&& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, _STD move(_Right)) {}

#if _HAS_CXX23
    template <class _Alloc, class _First, class _Second,
        enable_if_t<_Tuple_constructible_v<tuple, const _First, const _Second>, int> = 0>
    constexpr explicit(_Tuple_conditional_explicit_v<tuple, const _First, const _Second>)
        tuple(allocator_arg_t, const _Alloc& _Al, const pair<_First, _Second>&& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, _STD move(_Right)) {}

#if defined(__clang__) || defined(__EDG__) // TRANSITION, LLVM-59827 (Clang), VSO-1900279 (EDG)
    template <class _Alloc, class _Other, enable_if_t<_Can_construct_from_tuple_like<_Other, tuple>, int> = 0>
#else // ^^^ workaround / no workaround vvv
    template <class _Alloc, _Different_from<tuple> _Other>
        requires _Tuple_like<_Other> && (!_Is_subrange_v<remove_cvref_t<_Other>>)
    && (1 + sizeof...(_Rest) == tuple_size_v<remove_cvref_t<_Other>>)
        && _Can_construct_values_from_tuple_like_v<tuple, _Other>
        && (sizeof...(_Rest) != 0 || (!is_convertible_v<_Other, _This> && !is_constructible_v<_This, _Other>))
#endif // ^^^ no workaround ^^^
        constexpr explicit(_Is_tuple_like_constructor_explicit_v<_Other>)
        tuple(allocator_arg_t, const _Alloc& _Al, _Other&& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, _STD forward<_Other>(_Right)) {
    }
#endif // _HAS_CXX23

    tuple& operator=(const volatile tuple&) = delete;

    template <class _Myself = tuple, class _This2 = _This,
        enable_if_t<conjunction_v<_STD _Is_copy_assignable_no_precondition_check<_This2>,
        _STD _Is_copy_assignable_no_precondition_check<_Rest>...>,
        int> = 0>
    _CONSTEXPR20 tuple& operator=(_Identity_t<const _Myself&> _Right) noexcept(
        conjunction_v<is_nothrow_copy_assignable<_This2>, is_nothrow_copy_assignable<_Rest>...>) /* strengthened */ {
        _Myfirst._Val = _Right._Myfirst._Val;
        _Get_rest() = _Right._Get_rest();
        return *this;
    }

#if _HAS_CXX23
    template <class _Myself = tuple, class _This2 = _This,
        enable_if_t<conjunction_v<_STD _Is_copy_assignable_no_precondition_check<const _This2>,
        _STD _Is_copy_assignable_no_precondition_check<const _Rest>...>,
        int> = 0>
    constexpr const tuple& operator=(_Identity_t<const _Myself&> _Right) const
        noexcept(conjunction_v<is_nothrow_copy_assignable<const _This2>,
            is_nothrow_copy_assignable<const _Rest>...>) /* strengthened */ {
        _Myfirst._Val = _Right._Myfirst._Val;
        _Get_rest() = _Right._Get_rest();
        return *this;
    }
#endif // _HAS_CXX23

    template <class _Myself = tuple, class _This2 = _This,
        enable_if_t<conjunction_v<_STD _Is_move_assignable_no_precondition_check<_This2>,
        _STD _Is_move_assignable_no_precondition_check<_Rest>...>,
        int> = 0>
    _CONSTEXPR20 tuple& operator=(_Identity_t<_Myself&&> _Right) noexcept(
        conjunction_v<is_nothrow_move_assignable<_This2>, is_nothrow_move_assignable<_Rest>...>) {
        _Myfirst._Val = _STD forward<_This>(_Right._Myfirst._Val);
        _Get_rest() = _STD forward<_Mybase>(_Right._Get_rest());
        return *this;
    }

#if _HAS_CXX23
    template <class _Myself = tuple, class _This2 = _This,
        enable_if_t<conjunction_v<_STD _Is_assignable_no_precondition_check<const _This2&, _This2>,
        _STD _Is_assignable_no_precondition_check<const _Rest&, _Rest>...>,
        int> = 0>
    constexpr const tuple& operator=(_Identity_t<_Myself&&> _Right) const
        noexcept(conjunction_v<is_nothrow_assignable<const _This2&, _This2>,
            is_nothrow_assignable<const _Rest&, _Rest>...>) /* strengthened */ {
        _Myfirst._Val = _STD forward<_This>(_Right._Myfirst._Val);
        _Get_rest() = _STD forward<_Mybase>(_Right._Get_rest());
        return *this;
    }
#endif // _HAS_CXX23

    template <class... _Other, enable_if_t<conjunction_v<_STD negation<_STD is_same<tuple, _STD tuple<_Other...>>>,
        _STD _Tuple_assignable_val<tuple, const _Other&...>>,
        int> = 0>
    _CONSTEXPR20 tuple& operator=(const tuple<_Other...>& _Right) noexcept(
        _Tuple_nothrow_assignable_v<tuple, const _Other&...>) /* strengthened */ {
        _Myfirst._Val = _Right._Myfirst._Val;
        _Get_rest() = _Right._Get_rest();
        return *this;
    }

#if _HAS_CXX23
    template <class... _Other, enable_if_t<conjunction_v<_STD negation<_STD is_same<tuple, _STD tuple<_Other...>>>,
        _STD _Tuple_assignable_val<const tuple, const _Other&...>>,
        int> = 0>
    constexpr const tuple& operator=(const tuple<_Other...>& _Right) const
        noexcept(_Tuple_nothrow_assignable_v<const tuple, const _Other&...>) /* strengthened */ {
        _Myfirst._Val = _Right._Myfirst._Val;
        _Get_rest() = _Right._Get_rest();
        return *this;
    }
#endif // _HAS_CXX23

    template <class... _Other, enable_if_t<conjunction_v<_STD negation<_STD is_same<tuple, _STD tuple<_Other...>>>,
        _STD _Tuple_assignable_val<tuple, _Other...>>,
        int> = 0>
    _CONSTEXPR20 tuple& operator=(tuple<_Other...>&& _Right) noexcept(
        _Tuple_nothrow_assignable_v<tuple, _Other...>) /* strengthened */ {
        _Myfirst._Val = _STD forward<typename tuple<_Other...>::_This_type>(_Right._Myfirst._Val);
        _Get_rest() = _STD forward<typename tuple<_Other...>::_Mybase>(_Right._Get_rest());
        return *this;
    }

#if _HAS_CXX23
    template <class... _Other, enable_if_t<conjunction_v<_STD negation<_STD is_same<tuple, _STD tuple<_Other...>>>,
        _STD _Tuple_assignable_val<const tuple, _Other...>>,
        int> = 0>
    constexpr const tuple& operator=(tuple<_Other...>&& _Right) const
        noexcept(_Tuple_nothrow_assignable_v<const tuple, _Other...>) /* strengthened */ {
        _Myfirst._Val = _STD forward<typename tuple<_Other...>::_This_type>(_Right._Myfirst._Val);
        _Get_rest() = _STD forward<typename tuple<_Other...>::_Mybase>(_Right._Get_rest());
        return *this;
    }
#endif // _HAS_CXX23

    template <class _First, class _Second,
        enable_if_t<_Tuple_assignable_v<tuple, const _First&, const _Second&>, int> = 0>
    _CONSTEXPR20 tuple& operator=(const pair<_First, _Second>& _Right) noexcept(
        _Tuple_nothrow_assignable_v<tuple, const _First&, const _Second&>) /* strengthened */ {
        _Myfirst._Val = _Right.first;
        _Get_rest()._Myfirst._Val = _Right.second;
        return *this;
    }

#if _HAS_CXX23
    template <class _First, class _Second,
        enable_if_t<_Tuple_assignable_v<const tuple, const _First&, const _Second&>, int> = 0>
    constexpr const tuple& operator=(const pair<_First, _Second>& _Right) const
        noexcept(_Tuple_nothrow_assignable_v<const tuple, const _First&, const _Second&>) /* strengthened */ {
        _Myfirst._Val = _Right.first;
        _Get_rest()._Myfirst._Val = _Right.second;
        return *this;
    }
#endif // _HAS_CXX23

    template <class _First, class _Second, enable_if_t<_Tuple_assignable_v<tuple, _First, _Second>, int> = 0>
    _CONSTEXPR20 tuple& operator=(pair<_First, _Second>&& _Right) noexcept(
        _Tuple_nothrow_assignable_v<tuple, _First, _Second>) /* strengthened */ {
        _Myfirst._Val = _STD forward<_First>(_Right.first);
        _Get_rest()._Myfirst._Val = _STD forward<_Second>(_Right.second);
        return *this;
    }

#if _HAS_CXX23
    template <class _First, class _Second, enable_if_t<_Tuple_assignable_v<const tuple, _First, _Second>, int> = 0>
    constexpr const tuple& operator=(pair<_First, _Second>&& _Right) const
        noexcept(_Tuple_nothrow_assignable_v<const tuple, _First, _Second>) /* strengthened */ {
        _Myfirst._Val = _STD forward<_First>(_Right.first);
        _Get_rest()._Myfirst._Val = _STD forward<_Second>(_Right.second);
        return *this;
    }

    template <bool _Const_assignment, class _Other, class _Indices = index_sequence_for<_Rest...>>
    static constexpr bool _Can_assign_values_from_tuple_like_v = false;

    template <_Tuple_like _Other, size_t... _Indices>
    static constexpr bool _Can_assign_values_from_tuple_like_v<false, _Other, index_sequence<_Indices...>> =
        conjunction_v<is_assignable<_This&, decltype(_STD get<0>(_STD declval<_Other>()))>,
        is_assignable<_Rest&, decltype(_STD get<_Indices + 1>(_STD declval<_Other>()))>...>;

    template <_Tuple_like _Other, size_t... _Indices>
    static constexpr bool _Can_assign_values_from_tuple_like_v<true, _Other, index_sequence<_Indices...>> =
        conjunction_v<is_assignable<const _This&, decltype(_STD get<0>(_STD declval<_Other>()))>,
        is_assignable<const _Rest&, decltype(_STD get<_Indices + 1>(_STD declval<_Other>()))>...>;

    template <_Tuple_like _Other, size_t... _Indices>
    constexpr void _Assign_tuple_like(_Other&& _Right, index_sequence<_Indices...>) {
        ((void)(_STD get<_Indices>(*this) = _STD get<_Indices>(_STD forward<_Other>(_Right))), ...);
    }

    template <_Tuple_like _Other, size_t... _Indices>
    constexpr void _Assign_tuple_like(_Other&& _Right, index_sequence<_Indices...>) const {
        ((void)(_STD get<_Indices>(*this) = _STD get<_Indices>(_STD forward<_Other>(_Right))), ...);
    }

    template <_Different_from<tuple> _Other>
        requires _Tuple_like<_Other> && (!_Is_subrange_v<remove_cvref_t<_Other>>)
    && (1 + sizeof...(_Rest) == tuple_size_v<remove_cvref_t<_Other>>)
        && _Can_assign_values_from_tuple_like_v<false, _Other>
        constexpr tuple& operator=(_Other&& _Right) {
        _Assign_tuple_like(_STD forward<_Other>(_Right), make_index_sequence<1 + sizeof...(_Rest)>{});
        return *this;
    }

    template <_Different_from<tuple> _Other>
        requires _Tuple_like<_Other> && (!_Is_subrange_v<remove_cvref_t<_Other>>)
    && (1 + sizeof...(_Rest) == tuple_size_v<remove_cvref_t<_Other>>)
        && _Can_assign_values_from_tuple_like_v<true, _Other>
        constexpr const tuple& operator=(_Other&& _Right) const {
        _Assign_tuple_like(_STD forward<_Other>(_Right), make_index_sequence<1 + sizeof...(_Rest)>{});
        return *this;
    }
#endif // _HAS_CXX23

    _CONSTEXPR20 void swap(tuple& _Right) noexcept(
        conjunction_v<_Is_nothrow_swappable<_This>, _Is_nothrow_swappable<_Rest>...>) {
        using _STD swap;
        swap(_Myfirst._Val, _Right._Myfirst._Val); // intentional ADL
        _Mybase::swap(_Right._Get_rest());
    }

#if _HAS_CXX23
    template <int = 0> // see GH-3013
    constexpr void swap(const tuple& _Right) const
        noexcept(conjunction_v<is_nothrow_swappable<const _This>, is_nothrow_swappable<const _Rest>...>) {
        using _STD swap;
        swap(_Myfirst._Val, _Right._Myfirst._Val); // intentional ADL
        _Mybase::swap(_Right._Get_rest());
    }
#endif // _HAS_CXX23

    constexpr _Mybase& _Get_rest() noexcept { // get reference to rest of elements
        return *this;
    }

    constexpr const _Mybase& _Get_rest() const noexcept { // get const reference to rest of elements
        return *this;
    }

    template <class... _Other>
    constexpr bool _Equals(const tuple<_Other...>& _Right) const {
        return _Myfirst._Val == _Right._Myfirst._Val && _Mybase::_Equals(_Right._Get_rest());
    }

#if _HAS_CXX20
    template <class _First, class... _Other>
    _NODISCARD constexpr common_comparison_category_t<_Synth_three_way_result<_This, _First>,
        _Synth_three_way_result<_Rest, _Other>...>
        _Three_way_compare(const tuple<_First, _Other...>& _Right) const {
        if (auto _Result = _Synth_three_way{}(_Myfirst._Val, _Right._Myfirst._Val); _Result != 0) {
            return _Result;
        }
        return _Mybase::_Three_way_compare(_Right._Get_rest());
    }

#if _HAS_CXX23
    template <class _Other, class _Indices = make_index_sequence<1 + sizeof...(_Rest)>>
    static constexpr bool _Can_equal_compare_with_tuple_like_v = false;

    template <class _Other, size_t... _Indices>
    static constexpr bool _Can_equal_compare_with_tuple_like_v<_Other, index_sequence<_Indices...>> =
        (requires(const tuple & _Left, const _Other & _Right) {
            { _STD get<_Indices>(_Left) == _STD get<_Indices>(_Right) } -> _Boolean_testable;
    } && ...);

    template <class _Other, size_t... _Indices>
    _NODISCARD constexpr bool _Equals_to_tuple_like(const _Other& _Right, index_sequence<_Indices...>) const {
        return ((_STD get<_Indices>(*this) == _STD get<_Indices>(_Right)) && ...);
    }

    template <_Tuple_like_non_tuple _Other>
    _NODISCARD_FRIEND constexpr bool operator==(const tuple& _Left, const _Other& _Right) {
        static_assert(1 + sizeof...(_Rest) == tuple_size_v<_Other>,
            "Cannot compare tuples of different sizes (N4950 [tuple.rel]/2).");
        static_assert(_Can_equal_compare_with_tuple_like_v<_Other>,
            "For all i, where 0 <= i < sizeof...(TTypes), get<i>(t) == get<i>(u) must be a valid expression (N4950 "
            "[tuple.rel]/2).");
        return _Left._Equals_to_tuple_like(_Right, make_index_sequence<1 + sizeof...(_Rest)>{});
    }

    template <class _Other, size_t... _Indices>
    _NODISCARD constexpr auto _Three_way_compare_with_tuple_like(
        const _Other& _Right, index_sequence<_Indices...>) const {
        _Three_way_comparison_result_with_tuple_like_t<tuple, _Other> _Result = strong_ordering::equal;
        (void)(((_Result = _Synth_three_way{}(_STD get<_Indices>(*this), _STD get<_Indices>(_Right))) == 0) && ...);
        return _Result;
    }

    template <_Tuple_like_non_tuple _Other>
    _NODISCARD_FRIEND constexpr auto operator<=>(const tuple& _Left, const _Other& _Right)
        -> _Three_way_comparison_result_with_tuple_like_t<tuple, _Other> {
        return _Left._Three_way_compare_with_tuple_like(_Right, make_index_sequence<1 + sizeof...(_Rest)>{});
    }
#endif // _HAS_CXX23
#else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
    template <class... _Other>
    _NODISCARD constexpr bool _Less(const tuple<_Other...>& _Right) const {
        return _Myfirst._Val < _Right._Myfirst._Val
            || (!(_Right._Myfirst._Val < _Myfirst._Val) && _Mybase::_Less(_Right._Get_rest()));
    }
#endif // ^^^ !_HAS_CXX20 ^^^

    template <size_t _Index, class... _Types>
    friend constexpr tuple_element_t<_Index, tuple<_Types...>>& get(tuple<_Types...>& _Tuple) noexcept;

    template <size_t _Index, class... _Types>
    friend constexpr const tuple_element_t<_Index, tuple<_Types...>>& get(const tuple<_Types...>& _Tuple) noexcept;

    template <size_t _Index, class... _Types>
    friend constexpr tuple_element_t<_Index, tuple<_Types...>>&& get(tuple<_Types...>&& _Tuple) noexcept;

    template <size_t _Index, class... _Types>
    friend constexpr const tuple_element_t<_Index, tuple<_Types...>>&& get(const tuple<_Types...>&& _Tuple) noexcept;

    template <size_t _Index, class... _Types>
    friend constexpr auto&& _Tuple_get(tuple<_Types...>&& _Tuple) noexcept;

    template <class _Ty, class... _Types>
    friend constexpr _Ty& get(tuple<_Types...>& _Tuple) noexcept;

    template <class _Ty, class... _Types>
    friend constexpr const _Ty& get(const tuple<_Types...>& _Tuple) noexcept;

    template <class _Ty, class... _Types>
    friend constexpr _Ty&& get(tuple<_Types...>&& _Tuple) noexcept;

    template <class _Ty, class... _Types>
    friend constexpr const _Ty&& get(const tuple<_Types...>&& _Tuple) noexcept;

    _Tuple_val<_This> _Myfirst; // the stored element
};

#if _HAS_CXX17
template <class... _Types>
tuple(_Types...) -> tuple<_Types...>;

template <class _Ty1, class _Ty2>
tuple(pair<_Ty1, _Ty2>) -> tuple<_Ty1, _Ty2>;

template <class _Alloc, class... _Types>
tuple(allocator_arg_t, _Alloc, _Types...) -> tuple<_Types...>;

template <class _Alloc, class _Ty1, class _Ty2>
tuple(allocator_arg_t, _Alloc, pair<_Ty1, _Ty2>) -> tuple<_Ty1, _Ty2>;

template <class _Alloc, class... _Types>
tuple(allocator_arg_t, _Alloc, tuple<_Types...>) -> tuple<_Types...>;
#endif // _HAS_CXX17

_EXPORT_STD template <class... _Types1, class... _Types2>
_NODISCARD constexpr bool operator==(const tuple<_Types1...>& _Left, const tuple<_Types2...>& _Right) {
    static_assert(
        sizeof...(_Types1) == sizeof...(_Types2), "Cannot compare tuples of different sizes (N4950 [tuple.rel]/2).");
    return _Left._Equals(_Right);
}

#if _HAS_CXX20
_EXPORT_STD template <class... _Types1, class... _Types2>
_NODISCARD constexpr common_comparison_category_t<_Synth_three_way_result<_Types1, _Types2>...> operator<=>(
    const tuple<_Types1...>& _Left, const tuple<_Types2...>& _Right) {
    return _Left._Three_way_compare(_Right);
}
#else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
template <class... _Types1, class... _Types2>
_NODISCARD constexpr bool operator!=(const tuple<_Types1...>& _Left, const tuple<_Types2...>& _Right) {
    return !(_Left == _Right);
}

template <class... _Types1, class... _Types2>
_NODISCARD constexpr bool operator<(const tuple<_Types1...>& _Left, const tuple<_Types2...>& _Right) {
    static_assert(sizeof...(_Types1) == sizeof...(_Types2), "cannot compare tuples of different sizes");
    return _Left._Less(_Right);
}

template <class... _Types1, class... _Types2>
_NODISCARD constexpr bool operator>=(const tuple<_Types1...>& _Left, const tuple<_Types2...>& _Right) {
    return !(_Left < _Right);
}

template <class... _Types1, class... _Types2>
_NODISCARD constexpr bool operator>(const tuple<_Types1...>& _Left, const tuple<_Types2...>& _Right) {
    return _Right < _Left;
}

template <class... _Types1, class... _Types2>
_NODISCARD constexpr bool operator<=(const tuple<_Types1...>& _Left, const tuple<_Types2...>& _Right) {
    return !(_Right < _Left);
}
#endif // ^^^ !_HAS_CXX20 ^^^

_EXPORT_STD template <class... _Types, enable_if_t<conjunction_v<_Is_swappable<_Types>...>, int> = 0>
_CONSTEXPR20 void swap(tuple<_Types...>& _Left, tuple<_Types...>& _Right) noexcept(noexcept(_Left.swap(_Right))) {
    _Left.swap(_Right);
}

#if _HAS_CXX23
_EXPORT_STD template <class... _Types, enable_if_t<conjunction_v<is_swappable<const _Types>...>, int> = 0>
constexpr void swap(const tuple<_Types...>& _Left, const tuple<_Types...>& _Right) noexcept(
    noexcept(_Left.swap(_Right))) {
    _Left.swap(_Right);
}
#endif // _HAS_CXX23

template <class _Ty, class _Tuple>
struct _Tuple_element {}; // backstop _Tuple_element definition

template <class _This, class... _Rest>
struct _Tuple_element<_This, tuple<_This, _Rest...>> { // select first element
    static_assert(!_Is_any_of_v<_This, _Rest...>, "duplicate type T in get<T>(tuple)");
    using _Ttype = tuple<_This, _Rest...>;
};

template <class _Ty, class _This, class... _Rest>
struct _Tuple_element<_Ty, tuple<_This, _Rest...>> { // recursive _Tuple_element definition
    using _Ttype = typename _Tuple_element<_Ty, tuple<_Rest...>>::_Ttype;
};

_EXPORT_STD template <size_t _Index, class... _Types>
_NODISCARD constexpr tuple_element_t<_Index, tuple<_Types...>>& get(tuple<_Types...>& _Tuple) noexcept {
    using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
    return static_cast<_Ttype&>(_Tuple)._Myfirst._Val;
}

_EXPORT_STD template <size_t _Index, class... _Types>
_NODISCARD constexpr const tuple_element_t<_Index, tuple<_Types...>>& get(const tuple<_Types...>& _Tuple) noexcept {
    using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
    return static_cast<const _Ttype&>(_Tuple)._Myfirst._Val;
}

_EXPORT_STD template <size_t _Index, class... _Types>
_NODISCARD constexpr tuple_element_t<_Index, tuple<_Types...>>&& get(tuple<_Types...>&& _Tuple) noexcept {
    using _Ty = tuple_element_t<_Index, tuple<_Types...>>;
    using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
    return static_cast<_Ty&&>(static_cast<_Ttype&>(_Tuple)._Myfirst._Val);
}

_EXPORT_STD template <size_t _Index, class... _Types>
_NODISCARD constexpr const tuple_element_t<_Index, tuple<_Types...>>&& get(const tuple<_Types...>&& _Tuple) noexcept {
    using _Ty = tuple_element_t<_Index, tuple<_Types...>>;
    using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
    return static_cast<const _Ty&&>(static_cast<const _Ttype&>(_Tuple)._Myfirst._Val);
}

_EXPORT_STD /* TRANSITION, VSO-1538698 */ template <size_t _Index, class... _Types>
_NODISCARD constexpr auto&& _Tuple_get(tuple<_Types...>&& _Tuple) noexcept {
    // used by pair's piecewise constructor
    using _Ty = tuple_element_t<_Index, tuple<_Types...>>;
    using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
    return static_cast<_Ty&&>(static_cast<_Ttype&>(_Tuple)._Myfirst._Val);
}

_EXPORT_STD template <class _Ty, class... _Types>
_NODISCARD constexpr _Ty& get(tuple<_Types...>& _Tuple) noexcept {
    using _Ttype = typename _Tuple_element<_Ty, tuple<_Types...>>::_Ttype;
    return static_cast<_Ttype&>(_Tuple)._Myfirst._Val;
}

_EXPORT_STD template <class _Ty, class... _Types>
_NODISCARD constexpr const _Ty& get(const tuple<_Types...>& _Tuple) noexcept {
    using _Ttype = typename _Tuple_element<_Ty, tuple<_Types...>>::_Ttype;
    return static_cast<const _Ttype&>(_Tuple)._Myfirst._Val;
}

_EXPORT_STD template <class _Ty, class... _Types>
_NODISCARD constexpr _Ty&& get(tuple<_Types...>&& _Tuple) noexcept {
    using _Ttype = typename _Tuple_element<_Ty, tuple<_Types...>>::_Ttype;
    return static_cast<_Ty&&>(static_cast<_Ttype&>(_Tuple)._Myfirst._Val);
}

_EXPORT_STD template <class _Ty, class... _Types>
_NODISCARD constexpr const _Ty&& get(const tuple<_Types...>&& _Tuple) noexcept {
    using _Ttype = typename _Tuple_element<_Ty, tuple<_Types...>>::_Ttype;
    return static_cast<const _Ty&&>(static_cast<const _Ttype&>(_Tuple)._Myfirst._Val);
}

template <class _This, class... _Rest>
template <class _Tag, class _Tpl, size_t... _Indices, enable_if_t<is_same_v<_Tag, _STD _Unpack_tuple_t>, int> /* = 0 */>
constexpr tuple<_This, _Rest...>::tuple(_Tag, _Tpl&& _Right, index_sequence<_Indices...>)
    : tuple(_Exact_args_t{}, _STD get<_Indices>(_STD forward<_Tpl>(_Right))...) {}

template <class _This, class... _Rest>
template <class _Tag, class _Alloc, class _Tpl, size_t... _Indices,
    enable_if_t<is_same_v<_Tag, _STD _Alloc_unpack_tuple_t>, int> /* = 0 */>
constexpr tuple<_This, _Rest...>::tuple(_Tag, const _Alloc& _Al, _Tpl&& _Right, index_sequence<_Indices...>)
    : tuple(_Alloc_exact_args_t{}, _Al, _STD get<_Indices>(_STD forward<_Tpl>(_Right))...) {}

_EXPORT_STD template <class... _Types>
_NODISCARD constexpr tuple<_Unrefwrap_t<_Types>...> make_tuple(_Types&&... _Args) { // make tuple from elements
    using _Ttype = tuple<_Unrefwrap_t<_Types>...>;
    return _Ttype(_STD forward<_Types>(_Args)...);
}

_EXPORT_STD template <class... _Types>
_NODISCARD constexpr tuple<_Types&...> tie(_Types&... _Args) noexcept { // make tuple from elements
    using _Ttype = tuple<_Types&...>;
    return _Ttype(_Args...);
}

_EXPORT_STD template <class... _Types>
_NODISCARD constexpr tuple<_Types&&...> forward_as_tuple(_Types&&... _Args) noexcept { // forward arguments in a tuple
    return tuple<_Types&&...>(_STD forward<_Types>(_Args)...);
}

template <class _Ty, class _Kx_arg, class _Ix_arg, size_t _Ix_next, class... _Sequences>
struct _Tuple_cat2;

template <class _Ty, size_t... _Kx, size_t... _Ix, size_t _Ix_next>
struct _Tuple_cat2<_Ty, index_sequence<_Kx...>, index_sequence<_Ix...>, _Ix_next> {
    using _Ret = tuple<tuple_element_t<_Kx, _Remove_cvref_t<tuple_element_t<_Ix, _Ty>>>...>;
    using _Kx_seq = index_sequence<_Kx...>;
    using _Ix_seq = index_sequence<_Ix...>;
};

template <class _Ty, size_t... _Kx, size_t... _Ix, size_t _Ix_next, size_t... _Kx_next, class... _Rest>
struct _Tuple_cat2<_Ty, index_sequence<_Kx...>, index_sequence<_Ix...>, _Ix_next, index_sequence<_Kx_next...>, _Rest...>
    : _Tuple_cat2<_Ty, index_sequence<_Kx..., _Kx_next...>,
    index_sequence<_Ix..., (_Ix_next + 0 * _Kx_next)...>, // repeat _Ix_next, ignoring the elements of _Kx_next
    _Ix_next + 1, _Rest...> {};

#if _HAS_CXX23
template <_Tuple_like... _Tuples>
#else // ^^^ _HAS_CXX23 / !_HAS_CXX23 vvv
template <class... _Tuples>
#endif // ^^^ !_HAS_CXX23 ^^^
using _Tuple_cat1 = _Tuple_cat2<tuple<_Tuples&&...>, index_sequence<>, index_sequence<>, 0,
    make_index_sequence<tuple_size_v<_Remove_cvref_t<_Tuples>>>...>;

template <class _Ret, size_t... _Kx, size_t... _Ix, class _Ty>
constexpr _Ret _Tuple_cat(index_sequence<_Kx...>, index_sequence<_Ix...>, _Ty _Arg) {
    return _Ret{ _STD get<_Kx>(_STD get<_Ix>(_STD move(_Arg)))... };
}

#if _HAS_CXX23
_EXPORT_STD template <_Tuple_like... _Tuples>
#else // ^^^ _HAS_CXX23 / !_HAS_CXX23 vvv
_EXPORT_STD template <class... _Tuples>
#endif // ^^^ !_HAS_CXX23 ^^^
_NODISCARD constexpr typename _Tuple_cat1<_Tuples...>::_Ret tuple_cat(_Tuples&&... _Tpls) { // concatenate tuples
    using _Cat1 = _Tuple_cat1<_Tuples...>;
    using _Ret = typename _Cat1::_Ret;
    using _Kx_seq = typename _Cat1::_Kx_seq;
    using _Ix_seq = typename _Cat1::_Ix_seq;
    return _Tuple_cat<_Ret>(_Kx_seq{}, _Ix_seq{}, _STD forward_as_tuple(_STD forward<_Tuples>(_Tpls)...));
}

#if _HAS_CXX17
#if _HAS_CXX23
template <class _Callable, _Tuple_like _Tuple, size_t... _Indices>
#else // ^^^ _HAS_CXX23 / !_HAS_CXX23 vvv
template <class _Callable, class _Tuple, size_t... _Indices>
#endif // ^^^ !_HAS_CXX23 ^^^
constexpr decltype(auto) _Apply_impl(_Callable&& _Obj, _Tuple&& _Tpl, index_sequence<_Indices...>) noexcept(
    noexcept(_STD invoke(_STD forward<_Callable>(_Obj), _STD get<_Indices>(_STD forward<_Tuple>(_Tpl))...))) {
    return _STD invoke(_STD forward<_Callable>(_Obj), _STD get<_Indices>(_STD forward<_Tuple>(_Tpl))...);
}

#if _HAS_CXX23
_EXPORT_STD template <class _Callable, _Tuple_like _Tuple>
#else // ^^^ _HAS_CXX23 / !_HAS_CXX23 vvv
_EXPORT_STD template <class _Callable, class _Tuple>
#endif // ^^^ !_HAS_CXX23 ^^^
constexpr decltype(auto) apply(_Callable&& _Obj, _Tuple&& _Tpl) noexcept(
    noexcept(_Apply_impl(_STD forward<_Callable>(_Obj), _STD forward<_Tuple>(_Tpl),
        make_index_sequence<tuple_size_v<remove_reference_t<_Tuple>>>{}))) {
    return _Apply_impl(_STD forward<_Callable>(_Obj), _STD forward<_Tuple>(_Tpl),
        make_index_sequence<tuple_size_v<remove_reference_t<_Tuple>>>{});
}

#if _HAS_CXX23
template <class _Ty, _Tuple_like _Tuple, size_t... _Indices>
#else // ^^^ _HAS_CXX23 / !_HAS_CXX23 vvv
template <class _Ty, class _Tuple, size_t... _Indices>
#endif // ^^^ !_HAS_CXX23 ^^^
constexpr _Ty _Make_from_tuple_impl(_Tuple&& _Tpl, index_sequence<_Indices...>) noexcept(
    is_nothrow_constructible_v<_Ty, decltype(_STD get<_Indices>(_STD forward<_Tuple>(_Tpl)))...>) {
    // construct _Ty from the elements of _Tpl
    static_assert(is_constructible_v<_Ty, decltype(_STD get<_Indices>(_STD forward<_Tuple>(_Tpl)))...>,
        "the target type must be constructible from the fields of the argument tuple (N4950 [tuple.apply]/4).");
    return _Ty(_STD get<_Indices>(_STD forward<_Tuple>(_Tpl))...);
}

#if _HAS_CXX23
_EXPORT_STD template <class _Ty, _Tuple_like _Tuple>
#else // ^^^ _HAS_CXX23 / !_HAS_CXX23 vvv
_EXPORT_STD template <class _Ty, class _Tuple>
#endif // ^^^ !_HAS_CXX23 ^^^
_NODISCARD constexpr _Ty make_from_tuple(_Tuple&& _Tpl) noexcept(noexcept(_Make_from_tuple_impl<_Ty>(
    _STD forward<_Tuple>(_Tpl), make_index_sequence<tuple_size_v<remove_reference_t<_Tuple>>>{}))) /* strengthened */ {
    // construct _Ty from the elements of _Tpl
    return _Make_from_tuple_impl<_Ty>(
        _STD forward<_Tuple>(_Tpl), make_index_sequence<tuple_size_v<remove_reference_t<_Tuple>>>{});
}
#endif // _HAS_CXX17

template <class... _Types, class _Alloc>
struct uses_allocator<tuple<_Types...>, _Alloc> : true_type {}; // true_type if container allocator enabled

#if _HAS_CXX23
template <_Tuple_like _TTuple, _Tuple_like _UTuple, template <class> class _TQual, template <class> class _UQual,
    class _Indices = make_index_sequence<tuple_size_v<_TTuple>>>
struct _Tuple_like_common_reference;

template <class _TTuple, class _UTuple, template <class> class _TQual, template <class> class _UQual,
    size_t... _Indices>
    requires requires {
    typename tuple<common_reference_t<_TQual<tuple_element_t<_Indices, _TTuple>>,
        _UQual<tuple_element_t<_Indices, _UTuple>>>...>;
}
struct _Tuple_like_common_reference<_TTuple, _UTuple, _TQual, _UQual, index_sequence<_Indices...>> {
    using type = tuple<
        common_reference_t<_TQual<tuple_element_t<_Indices, _TTuple>>, _UQual<tuple_element_t<_Indices, _UTuple>>>...>;
};

template <_Tuple_like _TTuple, _Tuple_like _UTuple, template <class> class _TQual, template <class> class _UQual>
    requires (_Is_specialization_v<_TTuple, tuple> || _Is_specialization_v<_UTuple, tuple>)
&& is_same_v<_TTuple, decay_t<_TTuple>>&& is_same_v<_UTuple, decay_t<_UTuple>>
&& (tuple_size_v<_TTuple> == tuple_size_v<_UTuple>) && requires {
    typename _Tuple_like_common_reference<_TTuple, _UTuple, _TQual, _UQual>::type;
}
struct basic_common_reference<_TTuple, _UTuple, _TQual, _UQual> {
    using type = _Tuple_like_common_reference<_TTuple, _UTuple, _TQual, _UQual>::type;
};

template <_Tuple_like _TTuple, _Tuple_like _UTuple, class _Indices = make_index_sequence<tuple_size_v<_TTuple>>>
struct _Tuple_like_common_type;

template <class _TTuple, class _UTuple, size_t... _Indices>
    requires requires {
    typename tuple<common_type_t<tuple_element_t<_Indices, _TTuple>, tuple_element_t<_Indices, _UTuple>>...>;
}
struct _Tuple_like_common_type<_TTuple, _UTuple, index_sequence<_Indices...>> {
    using type = tuple<common_type_t<tuple_element_t<_Indices, _TTuple>, tuple_element_t<_Indices, _UTuple>>...>;
};

template <_Tuple_like _TTuple, _Tuple_like _UTuple>
    requires (_Is_specialization_v<_TTuple, tuple> || _Is_specialization_v<_UTuple, tuple>)
&& is_same_v<_TTuple, decay_t<_TTuple>>&& is_same_v<_UTuple, decay_t<_UTuple>>
&& (tuple_size_v<_TTuple> == tuple_size_v<_UTuple>) && requires {
    typename _Tuple_like_common_type<_TTuple, _UTuple>::type;
}
struct common_type<_TTuple, _UTuple> {
    using type = _Tuple_like_common_type<_TTuple, _UTuple>::type;
};
#endif // _HAS_CXX23

#if _HAS_TR1_NAMESPACE
namespace _DEPRECATE_TR1_NAMESPACE tr1 {
    using _STD get;
    using _STD ignore;
    using _STD make_tuple;
    using _STD ref;
    using _STD tie;
    using _STD tuple;
} // namespace _DEPRECATE_TR1_NAMESPACE tr1
#endif // _HAS_TR1_NAMESPACE

_STD_END

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _TUPLE_



#ifndef _XMEMORY_
#define _XMEMORY_
#if _STL_COMPILER_PREPROCESSOR

// limits standard header (core)

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#ifndef _LIMITS_
#define _LIMITS_
#if _STL_COMPILER_PREPROCESSOR
// cfloat standard header (core)

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#ifndef _CFLOAT_
#define _CFLOAT_

//
// float.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Implementation-defined values commonly used by sophisticated numerical
// (floating point) programs.
//
#pragma once
#ifndef _INC_FLOAT // include guard for 3rd party interop
#define _INC_FLOAT

#pragma warning(push)
#pragma warning(disable: _UCRT_DISABLED_WARNINGS)
_UCRT_DISABLE_CLANG_WARNINGS

_CRT_BEGIN_C_HEADER



#ifndef _CRT_MANAGED_FP_DEPRECATE
#ifdef _CRT_MANAGED_FP_NO_DEPRECATE
#define _CRT_MANAGED_FP_DEPRECATE
#else
#ifdef _M_CEE
#define _CRT_MANAGED_FP_DEPRECATE _CRT_DEPRECATE_TEXT("Direct floating point control is not supported or reliable from within managed code. ")
#else
#define _CRT_MANAGED_FP_DEPRECATE
#endif
#endif
#endif

#define FLT_EVAL_METHOD 0

//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Constants
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#define DBL_DECIMAL_DIG  17                      // # of decimal digits of rounding precision
#define DBL_DIG          15                      // # of decimal digits of precision
#define DBL_EPSILON      2.2204460492503131e-016 // smallest such that 1.0+DBL_EPSILON != 1.0
#define DBL_HAS_SUBNORM  1                       // type does support subnormal numbers
#define DBL_MANT_DIG     53                      // # of bits in mantissa
#define DBL_MAX          1.7976931348623158e+308 // max value
#define DBL_MAX_10_EXP   308                     // max decimal exponent
#define DBL_MAX_EXP      1024                    // max binary exponent
#define DBL_MIN          2.2250738585072014e-308 // min positive value
#define DBL_MIN_10_EXP   (-307)                  // min decimal exponent
#define DBL_MIN_EXP      (-1021)                 // min binary exponent
#define _DBL_RADIX       2                       // exponent radix
#define DBL_TRUE_MIN     4.9406564584124654e-324 // min positive value

#define FLT_DECIMAL_DIG  9                       // # of decimal digits of rounding precision
#define FLT_DIG          6                       // # of decimal digits of precision
#define FLT_EPSILON      1.192092896e-07F        // smallest such that 1.0+FLT_EPSILON != 1.0
#define FLT_HAS_SUBNORM  1                       // type does support subnormal numbers
#define FLT_GUARD        0
#define FLT_MANT_DIG     24                      // # of bits in mantissa
#define FLT_MAX          3.402823466e+38F        // max value
#define FLT_MAX_10_EXP   38                      // max decimal exponent
#define FLT_MAX_EXP      128                     // max binary exponent
#define FLT_MIN          1.175494351e-38F        // min normalized positive value
#define FLT_MIN_10_EXP   (-37)                   // min decimal exponent
#define FLT_MIN_EXP      (-125)                  // min binary exponent
#define FLT_NORMALIZE    0
#define FLT_RADIX        2                       // exponent radix
#define FLT_TRUE_MIN     1.401298464e-45F        // min positive value

#define LDBL_DIG         DBL_DIG                 // # of decimal digits of precision
#define LDBL_EPSILON     DBL_EPSILON             // smallest such that 1.0+LDBL_EPSILON != 1.0
#define LDBL_HAS_SUBNORM DBL_HAS_SUBNORM         // type does support subnormal numbers
#define LDBL_MANT_DIG    DBL_MANT_DIG            // # of bits in mantissa
#define LDBL_MAX         DBL_MAX                 // max value
#define LDBL_MAX_10_EXP  DBL_MAX_10_EXP          // max decimal exponent
#define LDBL_MAX_EXP     DBL_MAX_EXP             // max binary exponent
#define LDBL_MIN         DBL_MIN                 // min normalized positive value
#define LDBL_MIN_10_EXP  DBL_MIN_10_EXP          // min decimal exponent
#define LDBL_MIN_EXP     DBL_MIN_EXP             // min binary exponent
#define _LDBL_RADIX      _DBL_RADIX              // exponent radix
#define LDBL_TRUE_MIN    DBL_TRUE_MIN            // min positive value

#define DECIMAL_DIG      DBL_DECIMAL_DIG



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Flags
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#define _SW_INEXACT     0x00000001              // Inexact (precision)
#define _SW_UNDERFLOW   0x00000002              // Underflow
#define _SW_OVERFLOW    0x00000004              // Overflow
#define _SW_ZERODIVIDE  0x00000008              // Divide by zero
#define _SW_INVALID     0x00000010              // Invalid
#define _SW_DENORMAL    0x00080000              // Denormal status bit

// New Control Bit that specifies the ambiguity in control word.
#define _EM_AMBIGUIOUS  0x80000000 // For backwards compatibility
#define _EM_AMBIGUOUS   0x80000000

// Abstract User Control Word Mask and bit definitions
#define _MCW_EM         0x0008001f              // Interrupt Exception Masks
#define _EM_INEXACT     0x00000001              //     inexact (precision)
#define _EM_UNDERFLOW   0x00000002              //     underflow
#define _EM_OVERFLOW    0x00000004              //     overflow
#define _EM_ZERODIVIDE  0x00000008              //     zero divide
#define _EM_INVALID     0x00000010              //     invalid
#define _EM_DENORMAL    0x00080000              // Denormal exception mask (_control87 only)

#define _MCW_RC         0x00000300              // Rounding Control
#define _RC_NEAR        0x00000000              //     near
#define _RC_DOWN        0x00000100              //     down
#define _RC_UP          0x00000200              //     up
#define _RC_CHOP        0x00000300              //     chop

// i386 specific definitions
#define _MCW_PC         0x00030000              // Precision Control
#define _PC_64          0x00000000              //     64 bits
#define _PC_53          0x00010000              //     53 bits
#define _PC_24          0x00020000              //     24 bits

#define _MCW_IC         0x00040000              // Infinity Control
#define _IC_AFFINE      0x00040000              //     affine
#define _IC_PROJECTIVE  0x00000000              //     projective

// RISC specific definitions
#define _MCW_DN         0x03000000              // Denormal Control
#define _DN_SAVE        0x00000000              //   save denormal results and operands
#define _DN_FLUSH       0x01000000              //   flush denormal results and operands to zero
#define _DN_FLUSH_OPERANDS_SAVE_RESULTS 0x02000000  // flush operands to zero and save results
#define _DN_SAVE_OPERANDS_FLUSH_RESULTS 0x03000000  // save operands and flush results to zero



// Invalid subconditions (_SW_INVALID also set)
#define _SW_UNEMULATED          0x0040  // Unemulated instruction
#define _SW_SQRTNEG             0x0080  // Square root of a negative number
#define _SW_STACKOVERFLOW       0x0200  // FP stack overflow
#define _SW_STACKUNDERFLOW      0x0400  // FP stack underflow



// Floating point error signals and return codes
#define _FPE_INVALID            0x81
#define _FPE_DENORMAL           0x82
#define _FPE_ZERODIVIDE         0x83
#define _FPE_OVERFLOW           0x84
#define _FPE_UNDERFLOW          0x85
#define _FPE_INEXACT            0x86

#define _FPE_UNEMULATED         0x87
#define _FPE_SQRTNEG            0x88
#define _FPE_STACKOVERFLOW      0x8a
#define _FPE_STACKUNDERFLOW     0x8b

#define _FPE_EXPLICITGEN        0x8c // raise(SIGFPE);

// On x86 with arch:SSE2, the OS returns these exceptions
#define _FPE_MULTIPLE_TRAPS     0x8d
#define _FPE_MULTIPLE_FAULTS    0x8e



#define _FPCLASS_SNAN  0x0001  // signaling NaN
#define _FPCLASS_QNAN  0x0002  // quiet NaN
#define _FPCLASS_NINF  0x0004  // negative infinity
#define _FPCLASS_NN    0x0008  // negative normal
#define _FPCLASS_ND    0x0010  // negative denormal
#define _FPCLASS_NZ    0x0020  // -0
#define _FPCLASS_PZ    0x0040  // +0
#define _FPCLASS_PD    0x0080  // positive denormal
#define _FPCLASS_PN    0x0100  // positive normal
#define _FPCLASS_PINF  0x0200  // positive infinity



// Initial Control Word value
#if defined _M_IX86

#define _CW_DEFAULT (_RC_NEAR + _PC_53 + _EM_INVALID + _EM_ZERODIVIDE + _EM_OVERFLOW + _EM_UNDERFLOW + _EM_INEXACT + _EM_DENORMAL)

#elif defined _M_X64 || defined _M_ARM || defined _M_ARM64

#define _CW_DEFAULT (_RC_NEAR + _EM_INVALID + _EM_ZERODIVIDE + _EM_OVERFLOW + _EM_UNDERFLOW + _EM_INEXACT + _EM_DENORMAL)

#endif



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// State Manipulation
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// Note that reading or writing the floating point control or status words is
// not supported in managed code.
_CRT_MANAGED_FP_DEPRECATE
_ACRTIMP unsigned int __cdecl _clearfp(void);

#pragma warning(push)
#pragma warning(disable: 4141) // Double deprecation

_CRT_MANAGED_FP_DEPRECATE _CRT_INSECURE_DEPRECATE(_controlfp_s)
_ACRTIMP unsigned int __cdecl _controlfp(
    _In_ unsigned int _NewValue,
    _In_ unsigned int _Mask
);

#pragma warning(pop)

_CRT_MANAGED_FP_DEPRECATE
_ACRTIMP void __cdecl _set_controlfp(
    _In_ unsigned int _NewValue,
    _In_ unsigned int _Mask
);

_CRT_MANAGED_FP_DEPRECATE
_ACRTIMP errno_t __cdecl _controlfp_s(
    _Out_opt_ unsigned int* _CurrentState,
    _In_      unsigned int  _NewValue,
    _In_      unsigned int  _Mask
);

_CRT_MANAGED_FP_DEPRECATE
_ACRTIMP unsigned int __cdecl _statusfp(void);

_CRT_MANAGED_FP_DEPRECATE
_ACRTIMP void __cdecl _fpreset(void);

#ifdef _M_IX86

_CRT_MANAGED_FP_DEPRECATE
_ACRTIMP void __cdecl _statusfp2(
    _Out_opt_ unsigned int* _X86Status,
    _Out_opt_ unsigned int* _SSE2Status
);

#endif

#define _clear87        _clearfp
#define _status87       _statusfp

_CRT_MANAGED_FP_DEPRECATE
_ACRTIMP unsigned int __cdecl _control87(
    _In_ unsigned int _NewValue,
    _In_ unsigned int _Mask
);

#ifdef _M_IX86
_CRT_MANAGED_FP_DEPRECATE
_ACRTIMP int __cdecl __control87_2(
    _In_      unsigned int  _NewValue,
    _In_      unsigned int  _Mask,
    _Out_opt_ unsigned int* _X86ControlWord,
    _Out_opt_ unsigned int* _Sse2ControlWord
);
#endif

// Global variable holding floating point error code
_Check_return_
_ACRTIMP int* __cdecl __fpecode(void);

#define _fpecode (*__fpecode())

_Check_return_
_ACRTIMP int __cdecl __fpe_flt_rounds(void);

#define FLT_ROUNDS   (__fpe_flt_rounds())
#define _DBL_ROUNDS  FLT_ROUNDS
#define _LDBL_ROUNDS _DBL_ROUNDS



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// IEEE Recommended Functions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
_Check_return_ _ACRTIMP double __cdecl _copysign(_In_ double _Number, _In_ double _Sign);
_Check_return_ _ACRTIMP double __cdecl _chgsign(_In_ double _X);
_Check_return_ _ACRTIMP double __cdecl _scalb(_In_ double _X, _In_ long _Y);
_Check_return_ _ACRTIMP double __cdecl _logb(_In_ double _X);
_Check_return_ _ACRTIMP double __cdecl _nextafter(_In_ double _X, _In_ double _Y);
_Check_return_ _ACRTIMP int    __cdecl _finite(_In_ double _X);
_Check_return_ _ACRTIMP int    __cdecl _isnan(_In_ double _X);
_Check_return_ _ACRTIMP int    __cdecl _fpclass(_In_ double _X);

#ifdef _M_X64
_Check_return_ _ACRTIMP float __cdecl _scalbf(_In_ float _X, _In_ long _Y);
#endif



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Nonstandard Names for Compatibility
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#if defined(_CRT_INTERNAL_NONSTDC_NAMES) && _CRT_INTERNAL_NONSTDC_NAMES

#define clear87   _clear87
#define status87  _status87
#define control87 _control87

_CRT_MANAGED_FP_DEPRECATE
_ACRTIMP void __cdecl fpreset(void);

#define DBL_RADIX          _DBL_RADIX
#define DBL_ROUNDS         _DBL_ROUNDS

#define LDBL_RADIX         _LDBL_RADIX
#define LDBL_ROUNDS        _LDBL_ROUNDS

// For backwards compatibility with the old spelling
#define EM_AMBIGUIOUS      _EM_AMBIGUOUS
#define EM_AMBIGUOUS       _EM_AMBIGUOUS

#define MCW_EM             _MCW_EM
#define EM_INVALID         _EM_INVALID
#define EM_DENORMAL        _EM_DENORMAL
#define EM_ZERODIVIDE      _EM_ZERODIVIDE
#define EM_OVERFLOW        _EM_OVERFLOW
#define EM_UNDERFLOW       _EM_UNDERFLOW
#define EM_INEXACT         _EM_INEXACT

#define MCW_IC             _MCW_IC
#define IC_AFFINE          _IC_AFFINE
#define IC_PROJECTIVE      _IC_PROJECTIVE

#define MCW_RC             _MCW_RC
#define RC_CHOP            _RC_CHOP
#define RC_UP              _RC_UP
#define RC_DOWN            _RC_DOWN
#define RC_NEAR            _RC_NEAR

#define MCW_PC             _MCW_PC
#define PC_24              _PC_24
#define PC_53              _PC_53
#define PC_64              _PC_64

#define CW_DEFAULT         _CW_DEFAULT

#define SW_INVALID         _SW_INVALID
#define SW_DENORMAL        _SW_DENORMAL
#define SW_ZERODIVIDE      _SW_ZERODIVIDE
#define SW_OVERFLOW        _SW_OVERFLOW
#define SW_UNDERFLOW       _SW_UNDERFLOW
#define SW_INEXACT         _SW_INEXACT

#define SW_UNEMULATED      _SW_UNEMULATED
#define SW_SQRTNEG         _SW_SQRTNEG
#define SW_STACKOVERFLOW   _SW_STACKOVERFLOW
#define SW_STACKUNDERFLOW  _SW_STACKUNDERFLOW

#define FPE_INVALID        _FPE_INVALID
#define FPE_DENORMAL       _FPE_DENORMAL
#define FPE_ZERODIVIDE     _FPE_ZERODIVIDE
#define FPE_OVERFLOW       _FPE_OVERFLOW
#define FPE_UNDERFLOW      _FPE_UNDERFLOW
#define FPE_INEXACT        _FPE_INEXACT

#define FPE_UNEMULATED     _FPE_UNEMULATED
#define FPE_SQRTNEG        _FPE_SQRTNEG
#define FPE_STACKOVERFLOW  _FPE_STACKOVERFLOW
#define FPE_STACKUNDERFLOW _FPE_STACKUNDERFLOW

#define FPE_EXPLICITGEN    _FPE_EXPLICITGEN

#endif // _CRT_INTERNAL_NONSTDC_NAMES



_CRT_END_C_HEADER
_UCRT_RESTORE_CLANG_WARNINGS
#pragma warning(pop) // _UCRT_DISABLED_WARNINGS
#endif // _INC_FLOAT

#endif // _CFLOAT_


#include _STL_INTRIN_HEADER

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_STD_BEGIN
// constants for different IEEE float denormalization styles
_EXPORT_STD enum _CXX23_DEPRECATE_DENORM float_denorm_style {
    denorm_indeterminate = -1,
    denorm_absent = 0,
    denorm_present = 1
};

_EXPORT_STD enum float_round_style { // constants for different IEEE rounding styles
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
};

struct _Num_base { // base for all types, with common defaults
    _STL_DISABLE_DEPRECATED_WARNING
        _CXX23_DEPRECATE_DENORM static constexpr float_denorm_style has_denorm = denorm_absent;
    _CXX23_DEPRECATE_DENORM static constexpr bool has_denorm_loss = false;
    _STL_RESTORE_DEPRECATED_WARNING

        static constexpr bool has_infinity = false;
    static constexpr bool has_quiet_NaN = false;
    static constexpr bool has_signaling_NaN = false;
    static constexpr bool is_bounded = false;
    static constexpr bool is_exact = false;
    static constexpr bool is_iec559 = false;
    static constexpr bool is_integer = false;
    static constexpr bool is_modulo = false;
    static constexpr bool is_signed = false;
    static constexpr bool is_specialized = false;
    static constexpr bool tinyness_before = false;
    static constexpr bool traps = false;
    static constexpr float_round_style round_style = round_toward_zero;
    static constexpr int digits = 0;
    static constexpr int digits10 = 0;
    static constexpr int max_digits10 = 0;
    static constexpr int max_exponent = 0;
    static constexpr int max_exponent10 = 0;
    static constexpr int min_exponent = 0;
    static constexpr int min_exponent10 = 0;
    static constexpr int radix = 0;
};

_EXPORT_STD template <class _Ty>
class numeric_limits : public _Num_base { // numeric limits for arbitrary type _Ty (say little or nothing)
public:
    _NODISCARD static constexpr _Ty(min)() noexcept {
        return _Ty();
    }

    _NODISCARD static constexpr _Ty(max)() noexcept {
        return _Ty();
    }

    _NODISCARD static constexpr _Ty lowest() noexcept {
        return _Ty();
    }

    _NODISCARD static constexpr _Ty epsilon() noexcept {
        return _Ty();
    }

    _NODISCARD static constexpr _Ty round_error() noexcept {
        return _Ty();
    }

    _NODISCARD static constexpr _Ty denorm_min() noexcept {
        return _Ty();
    }

    _NODISCARD static constexpr _Ty infinity() noexcept {
        return _Ty();
    }

    _NODISCARD static constexpr _Ty quiet_NaN() noexcept {
        return _Ty();
    }

    _NODISCARD static constexpr _Ty signaling_NaN() noexcept {
        return _Ty();
    }
};

template <class _Ty>
class numeric_limits<const _Ty> : public numeric_limits<_Ty> {}; // numeric limits for const types

template <class _Ty>
class numeric_limits<volatile _Ty> : public numeric_limits<_Ty> {}; // numeric limits for volatile types

template <class _Ty>
class numeric_limits<const volatile _Ty> : public numeric_limits<_Ty> {}; // numeric limits for const volatile types

struct _Num_int_base : _Num_base { // base for integer types
    static constexpr bool is_bounded = true;
    static constexpr bool is_exact = true;
    static constexpr bool is_integer = true;
    static constexpr bool is_specialized = true;
    static constexpr int radix = 2;
};

struct _Num_float_base : _Num_base { // base for floating-point types
    _STL_DISABLE_DEPRECATED_WARNING
        _CXX23_DEPRECATE_DENORM static constexpr float_denorm_style has_denorm = denorm_present;
    _STL_RESTORE_DEPRECATED_WARNING

        static constexpr bool has_infinity = true;
    static constexpr bool has_quiet_NaN = true;
    static constexpr bool has_signaling_NaN = true;
    static constexpr bool is_bounded = true;
    static constexpr bool is_iec559 = true;
    static constexpr bool is_signed = true;
    static constexpr bool is_specialized = true;
    static constexpr float_round_style round_style = round_to_nearest;
    static constexpr int radix = FLT_RADIX;
};

template <>
class numeric_limits<bool> : public _Num_int_base {
public:
    _NODISCARD static constexpr bool(min)() noexcept {
        return false;
    }

    _NODISCARD static constexpr bool(max)() noexcept {
        return true;
    }

    _NODISCARD static constexpr bool lowest() noexcept {
        return (min)();
    }

    _NODISCARD static constexpr bool epsilon() noexcept {
        return 0;
    }

    _NODISCARD static constexpr bool round_error() noexcept {
        return 0;
    }

    _NODISCARD static constexpr bool denorm_min() noexcept {
        return 0;
    }

    _NODISCARD static constexpr bool infinity() noexcept {
        return 0;
    }

    _NODISCARD static constexpr bool quiet_NaN() noexcept {
        return 0;
    }

    _NODISCARD static constexpr bool signaling_NaN() noexcept {
        return 0;
    }

    static constexpr int digits = 1;
};

template <>
class numeric_limits<char> : public _Num_int_base {
public:
    _NODISCARD static constexpr char(min)() noexcept {
        return CHAR_MIN;
    }

    _NODISCARD static constexpr char(max)() noexcept {
        return CHAR_MAX;
    }

    _NODISCARD static constexpr char lowest() noexcept {
        return (min)();
    }

    _NODISCARD static constexpr char epsilon() noexcept {
        return 0;
    }

    _NODISCARD static constexpr char round_error() noexcept {
        return 0;
    }

    _NODISCARD static constexpr char denorm_min() noexcept {
        return 0;
    }

    _NODISCARD static constexpr char infinity() noexcept {
        return 0;
    }

    _NODISCARD static constexpr char quiet_NaN() noexcept {
        return 0;
    }

    _NODISCARD static constexpr char signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_signed = CHAR_MIN != 0;
    static constexpr bool is_modulo = CHAR_MIN == 0;
    static constexpr int digits = 8 - (CHAR_MIN != 0);
    static constexpr int digits10 = 2;
};

template <>
class numeric_limits<signed char> : public _Num_int_base {
public:
    _NODISCARD static constexpr signed char(min)() noexcept {
        return SCHAR_MIN;
    }

    _NODISCARD static constexpr signed char(max)() noexcept {
        return SCHAR_MAX;
    }

    _NODISCARD static constexpr signed char lowest() noexcept {
        return (min)();
    }

    _NODISCARD static constexpr signed char epsilon() noexcept {
        return 0;
    }

    _NODISCARD static constexpr signed char round_error() noexcept {
        return 0;
    }

    _NODISCARD static constexpr signed char denorm_min() noexcept {
        return 0;
    }

    _NODISCARD static constexpr signed char infinity() noexcept {
        return 0;
    }

    _NODISCARD static constexpr signed char quiet_NaN() noexcept {
        return 0;
    }

    _NODISCARD static constexpr signed char signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_signed = true;
    static constexpr int digits = 7;
    static constexpr int digits10 = 2;
};

template <>
class numeric_limits<unsigned char> : public _Num_int_base {
public:
    _NODISCARD static constexpr unsigned char(min)() noexcept {
        return 0;
    }

    _NODISCARD static constexpr unsigned char(max)() noexcept {
        return UCHAR_MAX;
    }

    _NODISCARD static constexpr unsigned char lowest() noexcept {
        return (min)();
    }

    _NODISCARD static constexpr unsigned char epsilon() noexcept {
        return 0;
    }

    _NODISCARD static constexpr unsigned char round_error() noexcept {
        return 0;
    }

    _NODISCARD static constexpr unsigned char denorm_min() noexcept {
        return 0;
    }

    _NODISCARD static constexpr unsigned char infinity() noexcept {
        return 0;
    }

    _NODISCARD static constexpr unsigned char quiet_NaN() noexcept {
        return 0;
    }

    _NODISCARD static constexpr unsigned char signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits = 8;
    static constexpr int digits10 = 2;
};

#ifdef __cpp_char8_t
template <>
class numeric_limits<char8_t> : public _Num_int_base {
public:
    _NODISCARD static constexpr char8_t(min)() noexcept {
        return 0;
    }

    _NODISCARD static constexpr char8_t(max)() noexcept {
        return UCHAR_MAX;
    }

    _NODISCARD static constexpr char8_t lowest() noexcept {
        return 0;
    }

    _NODISCARD static constexpr char8_t epsilon() noexcept {
        return 0;
    }

    _NODISCARD static constexpr char8_t round_error() noexcept {
        return 0;
    }

    _NODISCARD static constexpr char8_t denorm_min() noexcept {
        return 0;
    }

    _NODISCARD static constexpr char8_t infinity() noexcept {
        return 0;
    }

    _NODISCARD static constexpr char8_t quiet_NaN() noexcept {
        return 0;
    }

    _NODISCARD static constexpr char8_t signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits = 8;
    static constexpr int digits10 = 2;
};
#endif // defined(__cpp_char8_t)

template <>
class numeric_limits<char16_t> : public _Num_int_base {
public:
    _NODISCARD static constexpr char16_t(min)() noexcept {
        return 0;
    }

    _NODISCARD static constexpr char16_t(max)() noexcept {
        return USHRT_MAX;
    }

    _NODISCARD static constexpr char16_t lowest() noexcept {
        return (min)();
    }

    _NODISCARD static constexpr char16_t epsilon() noexcept {
        return 0;
    }

    _NODISCARD static constexpr char16_t round_error() noexcept {
        return 0;
    }

    _NODISCARD static constexpr char16_t denorm_min() noexcept {
        return 0;
    }

    _NODISCARD static constexpr char16_t infinity() noexcept {
        return 0;
    }

    _NODISCARD static constexpr char16_t quiet_NaN() noexcept {
        return 0;
    }

    _NODISCARD static constexpr char16_t signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits = 16;
    static constexpr int digits10 = 4;
};

template <>
class numeric_limits<char32_t> : public _Num_int_base {
public:
    _NODISCARD static constexpr char32_t(min)() noexcept {
        return 0;
    }

    _NODISCARD static constexpr char32_t(max)() noexcept {
        return UINT_MAX;
    }

    _NODISCARD static constexpr char32_t lowest() noexcept {
        return (min)();
    }

    _NODISCARD static constexpr char32_t epsilon() noexcept {
        return 0;
    }

    _NODISCARD static constexpr char32_t round_error() noexcept {
        return 0;
    }

    _NODISCARD static constexpr char32_t denorm_min() noexcept {
        return 0;
    }

    _NODISCARD static constexpr char32_t infinity() noexcept {
        return 0;
    }

    _NODISCARD static constexpr char32_t quiet_NaN() noexcept {
        return 0;
    }

    _NODISCARD static constexpr char32_t signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits = 32;
    static constexpr int digits10 = 9;
};

template <>
class numeric_limits<wchar_t> : public _Num_int_base {
public:
    _NODISCARD static constexpr wchar_t(min)() noexcept {
        return WCHAR_MIN;
    }

    _NODISCARD static constexpr wchar_t(max)() noexcept {
        return WCHAR_MAX;
    }

    _NODISCARD static constexpr wchar_t lowest() noexcept {
        return (min)();
    }

    _NODISCARD static constexpr wchar_t epsilon() noexcept {
        return 0;
    }

    _NODISCARD static constexpr wchar_t round_error() noexcept {
        return 0;
    }

    _NODISCARD static constexpr wchar_t denorm_min() noexcept {
        return 0;
    }

    _NODISCARD static constexpr wchar_t infinity() noexcept {
        return 0;
    }

    _NODISCARD static constexpr wchar_t quiet_NaN() noexcept {
        return 0;
    }

    _NODISCARD static constexpr wchar_t signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits = 16;
    static constexpr int digits10 = 4;
};

template <>
class numeric_limits<short> : public _Num_int_base {
public:
    _NODISCARD static constexpr short(min)() noexcept {
        return SHRT_MIN;
    }

    _NODISCARD static constexpr short(max)() noexcept {
        return SHRT_MAX;
    }

    _NODISCARD static constexpr short lowest() noexcept {
        return (min)();
    }

    _NODISCARD static constexpr short epsilon() noexcept {
        return 0;
    }

    _NODISCARD static constexpr short round_error() noexcept {
        return 0;
    }

    _NODISCARD static constexpr short denorm_min() noexcept {
        return 0;
    }

    _NODISCARD static constexpr short infinity() noexcept {
        return 0;
    }

    _NODISCARD static constexpr short quiet_NaN() noexcept {
        return 0;
    }

    _NODISCARD static constexpr short signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_signed = true;
    static constexpr int digits = 15;
    static constexpr int digits10 = 4;
};

template <>
class numeric_limits<int> : public _Num_int_base {
public:
    _NODISCARD static constexpr int(min)() noexcept {
        return INT_MIN;
    }

    _NODISCARD static constexpr int(max)() noexcept {
        return INT_MAX;
    }

    _NODISCARD static constexpr int lowest() noexcept {
        return (min)();
    }

    _NODISCARD static constexpr int epsilon() noexcept {
        return 0;
    }

    _NODISCARD static constexpr int round_error() noexcept {
        return 0;
    }

    _NODISCARD static constexpr int denorm_min() noexcept {
        return 0;
    }

    _NODISCARD static constexpr int infinity() noexcept {
        return 0;
    }

    _NODISCARD static constexpr int quiet_NaN() noexcept {
        return 0;
    }

    _NODISCARD static constexpr int signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_signed = true;
    static constexpr int digits = 31;
    static constexpr int digits10 = 9;
};

template <>
class numeric_limits<long> : public _Num_int_base {
public:
    _NODISCARD static constexpr long(min)() noexcept {
        return LONG_MIN;
    }

    _NODISCARD static constexpr long(max)() noexcept {
        return LONG_MAX;
    }

    _NODISCARD static constexpr long lowest() noexcept {
        return (min)();
    }

    _NODISCARD static constexpr long epsilon() noexcept {
        return 0;
    }

    _NODISCARD static constexpr long round_error() noexcept {
        return 0;
    }

    _NODISCARD static constexpr long denorm_min() noexcept {
        return 0;
    }

    _NODISCARD static constexpr long infinity() noexcept {
        return 0;
    }

    _NODISCARD static constexpr long quiet_NaN() noexcept {
        return 0;
    }

    _NODISCARD static constexpr long signaling_NaN() noexcept {
        return 0;
    }

    static_assert(sizeof(int) == sizeof(long), "LLP64 assumption");
    static constexpr bool is_signed = true;
    static constexpr int digits = 31;
    static constexpr int digits10 = 9;
};

template <>
class numeric_limits<long long> : public _Num_int_base {
public:
    _NODISCARD static constexpr long long(min)() noexcept {
        return LLONG_MIN;
    }

    _NODISCARD static constexpr long long(max)() noexcept {
        return LLONG_MAX;
    }

    _NODISCARD static constexpr long long lowest() noexcept {
        return (min)();
    }

    _NODISCARD static constexpr long long epsilon() noexcept {
        return 0;
    }

    _NODISCARD static constexpr long long round_error() noexcept {
        return 0;
    }

    _NODISCARD static constexpr long long denorm_min() noexcept {
        return 0;
    }

    _NODISCARD static constexpr long long infinity() noexcept {
        return 0;
    }

    _NODISCARD static constexpr long long quiet_NaN() noexcept {
        return 0;
    }

    _NODISCARD static constexpr long long signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_signed = true;
    static constexpr int digits = 63;
    static constexpr int digits10 = 18;
};

#ifdef _NATIVE_WCHAR_T_DEFINED
template <>
class numeric_limits<unsigned short> : public _Num_int_base {
public:
    _NODISCARD static constexpr unsigned short(min)() noexcept {
        return 0;
    }

    _NODISCARD static constexpr unsigned short(max)() noexcept {
        return USHRT_MAX;
    }

    _NODISCARD static constexpr unsigned short lowest() noexcept {
        return (min)();
    }

    _NODISCARD static constexpr unsigned short epsilon() noexcept {
        return 0;
    }

    _NODISCARD static constexpr unsigned short round_error() noexcept {
        return 0;
    }

    _NODISCARD static constexpr unsigned short denorm_min() noexcept {
        return 0;
    }

    _NODISCARD static constexpr unsigned short infinity() noexcept {
        return 0;
    }

    _NODISCARD static constexpr unsigned short quiet_NaN() noexcept {
        return 0;
    }

    _NODISCARD static constexpr unsigned short signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits = 16;
    static constexpr int digits10 = 4;
};
#endif // _NATIVE_WCHAR_T_DEFINED

template <>
class numeric_limits<unsigned int> : public _Num_int_base {
public:
    _NODISCARD static constexpr unsigned int(min)() noexcept {
        return 0;
    }

    _NODISCARD static constexpr unsigned int(max)() noexcept {
        return UINT_MAX;
    }

    _NODISCARD static constexpr unsigned int lowest() noexcept {
        return (min)();
    }

    _NODISCARD static constexpr unsigned int epsilon() noexcept {
        return 0;
    }

    _NODISCARD static constexpr unsigned int round_error() noexcept {
        return 0;
    }

    _NODISCARD static constexpr unsigned int denorm_min() noexcept {
        return 0;
    }

    _NODISCARD static constexpr unsigned int infinity() noexcept {
        return 0;
    }

    _NODISCARD static constexpr unsigned int quiet_NaN() noexcept {
        return 0;
    }

    _NODISCARD static constexpr unsigned int signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits = 32;
    static constexpr int digits10 = 9;
};

template <>
class numeric_limits<unsigned long> : public _Num_int_base {
public:
    _NODISCARD static constexpr unsigned long(min)() noexcept {
        return 0;
    }

    _NODISCARD static constexpr unsigned long(max)() noexcept {
        return ULONG_MAX;
    }

    _NODISCARD static constexpr unsigned long lowest() noexcept {
        return (min)();
    }

    _NODISCARD static constexpr unsigned long epsilon() noexcept {
        return 0;
    }

    _NODISCARD static constexpr unsigned long round_error() noexcept {
        return 0;
    }

    _NODISCARD static constexpr unsigned long denorm_min() noexcept {
        return 0;
    }

    _NODISCARD static constexpr unsigned long infinity() noexcept {
        return 0;
    }

    _NODISCARD static constexpr unsigned long quiet_NaN() noexcept {
        return 0;
    }

    _NODISCARD static constexpr unsigned long signaling_NaN() noexcept {
        return 0;
    }

    static_assert(sizeof(unsigned int) == sizeof(unsigned long), "LLP64 assumption");
    static constexpr bool is_modulo = true;
    static constexpr int digits = 32;
    static constexpr int digits10 = 9;
};

template <>
class numeric_limits<unsigned long long> : public _Num_int_base {
public:
    _NODISCARD static constexpr unsigned long long(min)() noexcept {
        return 0;
    }

    _NODISCARD static constexpr unsigned long long(max)() noexcept {
        return ULLONG_MAX;
    }

    _NODISCARD static constexpr unsigned long long lowest() noexcept {
        return (min)();
    }

    _NODISCARD static constexpr unsigned long long epsilon() noexcept {
        return 0;
    }

    _NODISCARD static constexpr unsigned long long round_error() noexcept {
        return 0;
    }

    _NODISCARD static constexpr unsigned long long denorm_min() noexcept {
        return 0;
    }

    _NODISCARD static constexpr unsigned long long infinity() noexcept {
        return 0;
    }

    _NODISCARD static constexpr unsigned long long quiet_NaN() noexcept {
        return 0;
    }

    _NODISCARD static constexpr unsigned long long signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits = 64;
    static constexpr int digits10 = 19;
};

template <>
class numeric_limits<float> : public _Num_float_base {
public:
    _NODISCARD static constexpr float(min)() noexcept {
        return FLT_MIN;
    }

    _NODISCARD static constexpr float(max)() noexcept {
        return FLT_MAX;
    }

    _NODISCARD static constexpr float lowest() noexcept {
        return -(max)();
    }

    _NODISCARD static constexpr float epsilon() noexcept {
        return FLT_EPSILON;
    }

    _NODISCARD static constexpr float round_error() noexcept {
        return 0.5F;
    }

    _NODISCARD static constexpr float denorm_min() noexcept {
        return FLT_TRUE_MIN;
    }

    _NODISCARD static constexpr float infinity() noexcept {
        return __builtin_huge_valf();
    }

    _NODISCARD static constexpr float quiet_NaN() noexcept {
        return __builtin_nanf("0");
    }

    _NODISCARD static constexpr float signaling_NaN() noexcept {
        return __builtin_nansf("1");
    }

    static constexpr int digits = FLT_MANT_DIG;
    static constexpr int digits10 = FLT_DIG;
    static constexpr int max_digits10 = 9;
    static constexpr int max_exponent = FLT_MAX_EXP;
    static constexpr int max_exponent10 = FLT_MAX_10_EXP;
    static constexpr int min_exponent = FLT_MIN_EXP;
    static constexpr int min_exponent10 = FLT_MIN_10_EXP;
};

template <>
class numeric_limits<double> : public _Num_float_base {
public:
    _NODISCARD static constexpr double(min)() noexcept {
        return DBL_MIN;
    }

    _NODISCARD static constexpr double(max)() noexcept {
        return DBL_MAX;
    }

    _NODISCARD static constexpr double lowest() noexcept {
        return -(max)();
    }

    _NODISCARD static constexpr double epsilon() noexcept {
        return DBL_EPSILON;
    }

    _NODISCARD static constexpr double round_error() noexcept {
        return 0.5;
    }

    _NODISCARD static constexpr double denorm_min() noexcept {
        return DBL_TRUE_MIN;
    }

    _NODISCARD static constexpr double infinity() noexcept {
        return __builtin_huge_val();
    }

    _NODISCARD static constexpr double quiet_NaN() noexcept {
        return __builtin_nan("0");
    }

    _NODISCARD static constexpr double signaling_NaN() noexcept {
        return __builtin_nans("1");
    }

    static constexpr int digits = DBL_MANT_DIG;
    static constexpr int digits10 = DBL_DIG;
    static constexpr int max_digits10 = 17;
    static constexpr int max_exponent = DBL_MAX_EXP;
    static constexpr int max_exponent10 = DBL_MAX_10_EXP;
    static constexpr int min_exponent = DBL_MIN_EXP;
    static constexpr int min_exponent10 = DBL_MIN_10_EXP;
};

template <>
class numeric_limits<long double> : public _Num_float_base {
public:
    _NODISCARD static constexpr long double(min)() noexcept {
        return LDBL_MIN;
    }

    _NODISCARD static constexpr long double(max)() noexcept {
        return LDBL_MAX;
    }

    _NODISCARD static constexpr long double lowest() noexcept {
        return -(max)();
    }

    _NODISCARD static constexpr long double epsilon() noexcept {
        return LDBL_EPSILON;
    }

    _NODISCARD static constexpr long double round_error() noexcept {
        return 0.5L;
    }

    _NODISCARD static constexpr long double denorm_min() noexcept {
        return LDBL_TRUE_MIN;
    }

    _NODISCARD static constexpr long double infinity() noexcept {
        return __builtin_huge_val();
    }

    _NODISCARD static constexpr long double quiet_NaN() noexcept {
        return __builtin_nan("0");
    }

    _NODISCARD static constexpr long double signaling_NaN() noexcept {
        return __builtin_nans("1");
    }

    static constexpr int digits = LDBL_MANT_DIG;
    static constexpr int digits10 = LDBL_DIG;
    static constexpr int max_digits10 = 2 + LDBL_MANT_DIG * 301L / 1000;
    static constexpr int max_exponent = LDBL_MAX_EXP;
    static constexpr int max_exponent10 = LDBL_MAX_10_EXP;
    static constexpr int min_exponent = LDBL_MIN_EXP;
    static constexpr int min_exponent10 = LDBL_MIN_10_EXP;
};

_STD_END
#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _LIMITS_

// new standard header

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#ifndef _NEW_
#define _NEW_
#if _STL_COMPILER_PREPROCESSOR
#ifndef _EXCEPTION_
#define _EXCEPTION_
#if _STL_COMPILER_PREPROCESSOR
#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_STD_BEGIN

#if _HAS_DEPRECATED_UNCAUGHT_EXCEPTION
_EXPORT_STD extern "C++" _CXX17_DEPRECATE_UNCAUGHT_EXCEPTION _NODISCARD _CRTIMP2_PURE bool __CLRCALL_PURE_OR_CDECL
uncaught_exception() noexcept;
#endif // _HAS_DEPRECATED_UNCAUGHT_EXCEPTION
_EXPORT_STD extern "C++" _NODISCARD _CRTIMP2_PURE int __CLRCALL_PURE_OR_CDECL uncaught_exceptions() noexcept;

_STD_END

#if _HAS_EXCEPTIONS

#pragma once

#pragma once
#define _INC_EH
#pragma push_macro("terminate_function")
#undef terminate_function
//
// corecrt_terminate.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The terminate handler
//
#pragma once

#pragma warning(push)
#pragma warning(disable: _UCRT_DISABLED_WARNINGS)
_UCRT_DISABLE_CLANG_WARNINGS

#ifndef RC_INVOKED

_CRT_BEGIN_C_HEADER

// terminate_handler is the standard name; terminate_function is defined for
// source compatibility.
typedef void (__CRTDECL* terminate_handler)(void);
typedef void (__CRTDECL* terminate_function)(void);

#ifdef _M_CEE
typedef void(__clrcall* __terminate_function_m)();
typedef void(__clrcall* __terminate_handler_m)();
#endif

#ifdef __cplusplus

_ACRTIMP __declspec(noreturn) void __cdecl abort();
_ACRTIMP __declspec(noreturn) void __cdecl terminate() throw();

#ifndef _M_CEE_PURE

_ACRTIMP terminate_handler __cdecl set_terminate(
    _In_opt_ terminate_handler _NewTerminateHandler
) throw();

_ACRTIMP terminate_handler __cdecl _get_terminate();

#endif

#endif // __cplusplus

_CRT_END_C_HEADER

#endif // RC_INVOKED
_UCRT_RESTORE_CLANG_WARNINGS
#pragma warning(pop) // _UCRT_DISABLED_WARNINGS

#pragma pop_macro("terminate_function")

#if _VCRT_COMPILER_PREPROCESSOR

#pragma warning(push)
#pragma warning(disable: _VCRUNTIME_DISABLED_WARNINGS)

_CRT_BEGIN_C_HEADER

#if defined(_VCRT_BUILD) || !_HAS_CXX23 // C++98 unexpected() is incompatible with C++23 unexpected<E>.
typedef void (__CRTDECL* unexpected_handler)(void);

#ifdef _M_CEE
typedef void(__clrcall* __unexpected_function_m)();
typedef void(__clrcall* __unexpected_handler_m)();
#endif // _M_CEE

#ifdef __cplusplus
_VCRTIMP __declspec(noreturn) void __cdecl unexpected() noexcept(false);

#ifndef _M_CEE_PURE
_VCRTIMP unexpected_handler __cdecl set_unexpected(
    _In_opt_ unexpected_handler _NewUnexpectedHandler
) noexcept;
_VCRTIMP unexpected_handler __cdecl _get_unexpected() noexcept;
#endif // _M_CEE_PURE
#endif // __cplusplus
#endif // defined(_VCRT_BUILD) || !_HAS_CXX23

struct _EXCEPTION_POINTERS;

#ifdef __cplusplus
#ifndef _M_CEE_PURE
typedef void(__cdecl* _se_translator_function)(unsigned int, struct _EXCEPTION_POINTERS*);

_VCRTIMP _se_translator_function __cdecl _set_se_translator(
    _In_opt_ _se_translator_function _NewSETranslator
);
#endif // _M_CEE_PURE

extern "C++" { // attach declarations to the global module, see N4910 [module.unit]/7
    class type_info;
} // extern "C++"

_VCRTIMP int __cdecl _is_exception_typeof(
    _In_ type_info const& _Type,
    _In_ _EXCEPTION_POINTERS* _ExceptionPtr
);

_VCRTIMP bool __cdecl __uncaught_exception();
_VCRTIMP int  __cdecl __uncaught_exceptions();
#endif // __cplusplus

_CRT_END_C_HEADER

#pragma warning(pop) // _VCRUNTIME_DISABLED_WARNINGS

#endif // _VCRT_COMPILER_PREPROCESSOR

#if _VCRT_COMPILER_PREPROCESSOR && _HAS_EXCEPTIONS

#pragma warning(push)
#pragma warning(disable: _VCRUNTIME_DISABLED_WARNINGS)
#pragma warning(disable: 4577) // 'noexcept' used with no exception handling mode specified
#pragma warning(disable: 4643) // Forward declaring 'meow' in namespace std is not permitted by the C++ Standard.

#pragma pack(push, _CRT_PACKING)

_CRT_BEGIN_C_HEADER

struct __std_exception_data
{
    char const* _What;
    bool        _DoFree;
};

_VCRTIMP void __cdecl __std_exception_copy(
    _In_    __std_exception_data const* _From,
    _Inout_ __std_exception_data* _To
);

_VCRTIMP void __cdecl __std_exception_destroy(
    _Inout_ __std_exception_data* _Data
);

_CRT_END_C_HEADER


extern "C++" {

    namespace std {

        _VCRT_EXPORT_STD class exception
        {
        public:

            exception() noexcept
                : _Data()
            {
            }

            explicit exception(char const* const _Message) noexcept
                : _Data()
            {
                __std_exception_data _InitData = { _Message, true };
                __std_exception_copy(&_InitData, &_Data);
            }

            exception(char const* const _Message, int) noexcept
                : _Data()
            {
                _Data._What = _Message;
            }

            exception(exception const& _Other) noexcept
                : _Data()
            {
                __std_exception_copy(&_Other._Data, &_Data);
            }

            exception& operator=(exception const& _Other) noexcept
            {
                if (this == &_Other)
                {
                    return *this;
                }

                __std_exception_destroy(&_Data);
                __std_exception_copy(&_Other._Data, &_Data);
                return *this;
            }

            virtual ~exception() noexcept
            {
                __std_exception_destroy(&_Data);
            }

            _NODISCARD virtual char const* what() const
            {
                return _Data._What ? _Data._What : "Unknown exception";
            }

        private:

            __std_exception_data _Data;
        };

        _VCRT_EXPORT_STD class bad_exception
            : public exception
        {
        public:

            bad_exception() noexcept
                : exception("bad exception", 1)
            {
            }
        };

        _VCRT_EXPORT_STD class bad_array_new_length;

        _VCRT_EXPORT_STD class bad_alloc
            : public exception
        {
        public:

            bad_alloc() noexcept
                : exception("bad allocation", 1)
            {
            }

        private:

            friend bad_array_new_length;

            bad_alloc(char const* const _Message) noexcept
                : exception(_Message, 1)
            {
            }
        };

        _VCRT_EXPORT_STD class bad_array_new_length
            : public bad_alloc
        {
        public:

            bad_array_new_length() noexcept
                : bad_alloc("bad array new length")
            {
            }
        };

    } // namespace std

} // extern "C++"

#pragma pack(pop)

#pragma warning(pop) // _VCRUNTIME_DISABLED_WARNINGS
#endif // _VCRT_COMPILER_PREPROCESSOR && _HAS_EXCEPTIONS

_STD_BEGIN

#ifndef _VCRT_EXPORT_STD // TRANSITION, VCRuntime update expected in 17.10 Preview 3
// Follow N4971 [module.interface]/6 by exporting aliases (a type alias is not an entity, N4971 [basic.pre]/3):
_EXPORT_STD using exception = exception;
_EXPORT_STD using bad_exception = bad_exception;
#endif // ^^^ workaround ^^^

_EXPORT_STD using ::terminate;

#ifndef _M_CEE_PURE
_EXPORT_STD using ::set_terminate;
_EXPORT_STD using ::terminate_handler;

_EXPORT_STD _NODISCARD inline terminate_handler __CRTDECL get_terminate() noexcept {
    // get current terminate handler
    return _get_terminate();
}
#endif // !defined(_M_CEE_PURE)


_STD_END

#else // ^^^ _HAS_EXCEPTIONS / !_HAS_EXCEPTIONS vvv

#pragma push_macro("stdext")
#undef stdext

_STDEXT_BEGIN
class exception;
_STDEXT_END

_STD_BEGIN

_EXPORT_STD using _STDEXT exception;

using _Prhand = void(__cdecl*)(const exception&);

extern _CRTIMP2_PURE_IMPORT _Prhand _Raise_handler; // pointer to raise handler

_STD_END

_STDEXT_BEGIN
class exception { // base of all library exceptions
public:
    static _STD _Prhand _Set_raise_handler(_STD _Prhand _Pnew) { // register a handler for _Raise calls
        const _STD _Prhand _Pold = _STD _Raise_handler;
        _STD _Raise_handler = _Pnew;
        return _Pold;
    }

    // this constructor is necessary to compile
    // successfully header new for _HAS_EXCEPTIONS==0 scenario
    explicit __CLR_OR_THIS_CALL exception(const char* _Message = "unknown", int = 1) noexcept : _Ptr(_Message) {}

    __CLR_OR_THIS_CALL exception(const exception& _Right) noexcept : _Ptr(_Right._Ptr) {}

    exception& __CLR_OR_THIS_CALL operator=(const exception& _Right) noexcept {
        _Ptr = _Right._Ptr;
        return *this;
    }

    virtual __CLR_OR_THIS_CALL ~exception() noexcept {}

    _NODISCARD virtual const char* __CLR_OR_THIS_CALL what() const noexcept { // return pointer to message string
        return _Ptr ? _Ptr : "unknown exception";
    }

    [[noreturn]] void __CLR_OR_THIS_CALL _Raise() const { // raise the exception
        if (_STD _Raise_handler) {
            (*_STD _Raise_handler)(*this); // call raise handler if present
        }

        _Doraise(); // call the protected virtual
        _RAISE(*this); // raise this exception
    }

protected:
    virtual void __CLR_OR_THIS_CALL _Doraise() const {} // perform class-specific exception handling

    const char* _Ptr; // the message pointer
};

class bad_exception : public exception { // base of all bad exceptions
public:
    __CLR_OR_THIS_CALL bad_exception(const char* _Message = "bad exception") noexcept : exception(_Message) {}

    __CLR_OR_THIS_CALL ~bad_exception() noexcept override {}

protected:
    void __CLR_OR_THIS_CALL _Doraise() const override { // raise this exception
        _RAISE(*this);
    }
};

class bad_array_new_length;

class bad_alloc : public exception { // base of all bad allocation exceptions
public:
    __CLR_OR_THIS_CALL bad_alloc() noexcept
        : exception("bad allocation", 1) {} // construct from message string with no memory allocation

    __CLR_OR_THIS_CALL ~bad_alloc() noexcept override {}

private:
    friend bad_array_new_length;

    __CLR_OR_THIS_CALL bad_alloc(const char* _Message) noexcept
        : exception(_Message, 1) {} // construct from message string with no memory allocation

protected:
    void __CLR_OR_THIS_CALL _Doraise() const override { // perform class-specific exception handling
        _RAISE(*this);
    }
};

class bad_array_new_length : public bad_alloc {
public:
    bad_array_new_length() noexcept : bad_alloc("bad array new length") {}
};

_STDEXT_END

_STD_BEGIN
_EXPORT_STD using terminate_handler = void(__cdecl*)();

_EXPORT_STD inline terminate_handler __CRTDECL set_terminate(terminate_handler) noexcept {
    // register a terminate handler
    return nullptr;
}

_EXPORT_STD [[noreturn]] inline void __CRTDECL terminate() noexcept {
    // handle exception termination
    _CSTD abort();
}

_EXPORT_STD _NODISCARD inline terminate_handler __CRTDECL get_terminate() noexcept {
    // get current terminate handler
    return nullptr;
}

#if _HAS_UNEXPECTED
using unexpected_handler = void(__cdecl*)();

inline unexpected_handler __CRTDECL set_unexpected(unexpected_handler) noexcept {
    // register an unexpected handler
    return nullptr;
}

inline void __CRTDECL unexpected() {} // handle unexpected exception

_NODISCARD inline unexpected_handler __CRTDECL get_unexpected() noexcept {
    // get current unexpected handler
    return nullptr;
}
#endif // _HAS_UNEXPECTED

_EXPORT_STD using _STDEXT bad_alloc;
_EXPORT_STD using _STDEXT bad_array_new_length;
_EXPORT_STD using _STDEXT bad_exception;

_STD_END

#pragma pop_macro("stdext")

#endif // ^^^ !_HAS_EXCEPTIONS ^^^

extern "C++" _CRTIMP2_PURE void __CLRCALL_PURE_OR_CDECL __ExceptionPtrCreate(_Out_ void*) noexcept;
extern "C++" _CRTIMP2_PURE void __CLRCALL_PURE_OR_CDECL __ExceptionPtrDestroy(_Inout_ void*) noexcept;
extern "C++" _CRTIMP2_PURE void __CLRCALL_PURE_OR_CDECL __ExceptionPtrCopy(_Out_ void*, _In_ const void*) noexcept;
extern "C++" _CRTIMP2_PURE void __CLRCALL_PURE_OR_CDECL __ExceptionPtrAssign(_Inout_ void*, _In_ const void*) noexcept;
extern "C++" _CRTIMP2_PURE bool __CLRCALL_PURE_OR_CDECL __ExceptionPtrCompare(
    _In_ const void*, _In_ const void*) noexcept;
extern "C++" _CRTIMP2_PURE bool __CLRCALL_PURE_OR_CDECL __ExceptionPtrToBool(_In_ const void*) noexcept;
extern "C++" _CRTIMP2_PURE void __CLRCALL_PURE_OR_CDECL __ExceptionPtrSwap(_Inout_ void*, _Inout_ void*) noexcept;
extern "C++" _CRTIMP2_PURE void __CLRCALL_PURE_OR_CDECL __ExceptionPtrCurrentException(void*) noexcept;
extern "C++" [[noreturn]] _CRTIMP2_PURE void __CLRCALL_PURE_OR_CDECL __ExceptionPtrRethrow(_In_ const void*);
extern "C++" _CRTIMP2_PURE void __CLRCALL_PURE_OR_CDECL __ExceptionPtrCopyException(
    _Inout_ void*, _In_ const void*, _In_ const void*) noexcept;

_STD_BEGIN

_EXPORT_STD class exception_ptr {
public:
    exception_ptr() noexcept {
        __ExceptionPtrCreate(this);
    }

    exception_ptr(nullptr_t) noexcept {
        __ExceptionPtrCreate(this);
    }

    ~exception_ptr() noexcept {
        __ExceptionPtrDestroy(this);
    }

    exception_ptr(const exception_ptr& _Rhs) noexcept {
        __ExceptionPtrCopy(this, &_Rhs);
    }

    exception_ptr& operator=(const exception_ptr& _Rhs) noexcept {
        __ExceptionPtrAssign(this, &_Rhs);
        return *this;
    }

    exception_ptr& operator=(nullptr_t) noexcept {
        exception_ptr _Ptr;
        __ExceptionPtrAssign(this, &_Ptr);
        return *this;
    }

    explicit operator bool() const noexcept {
        return __ExceptionPtrToBool(this);
    }

    static exception_ptr _Copy_exception(_In_ void* _Except, _In_ const void* _Ptr) {
        exception_ptr _Retval;
        if (!_Ptr) {
            // unsupported exceptions
            return _Retval;
        }
        __ExceptionPtrCopyException(&_Retval, _Except, _Ptr);
        return _Retval;
    }

    friend void swap(exception_ptr& _Lhs, exception_ptr& _Rhs) noexcept {
        __ExceptionPtrSwap(&_Lhs, &_Rhs);
    }

    _NODISCARD_FRIEND bool operator==(const exception_ptr& _Lhs, const exception_ptr& _Rhs) noexcept {
        return __ExceptionPtrCompare(&_Lhs, &_Rhs);
    }

    _NODISCARD_FRIEND bool operator==(const exception_ptr& _Lhs, nullptr_t) noexcept {
        return !_Lhs;
    }

#if !_HAS_CXX20
    _NODISCARD_FRIEND bool operator==(nullptr_t, const exception_ptr& _Rhs) noexcept {
        return !_Rhs;
    }

    _NODISCARD_FRIEND bool operator!=(const exception_ptr& _Lhs, const exception_ptr& _Rhs) noexcept {
        return !(_Lhs == _Rhs);
    }

    _NODISCARD_FRIEND bool operator!=(const exception_ptr& _Lhs, nullptr_t) noexcept {
        return !(_Lhs == nullptr);
    }

    _NODISCARD_FRIEND bool operator!=(nullptr_t, const exception_ptr& _Rhs) noexcept {
        return !(nullptr == _Rhs);
    }
#endif // !_HAS_CXX20

private:
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif // defined(__clang__)
    void* _Data1{};
    void* _Data2{};
#ifdef __clang__
#pragma clang diagnostic pop
#endif // defined(__clang__)
};

_EXPORT_STD _NODISCARD inline exception_ptr current_exception() noexcept {
    exception_ptr _Retval;
    __ExceptionPtrCurrentException(&_Retval);
    return _Retval;
}

_EXPORT_STD [[noreturn]] inline void rethrow_exception(_In_ exception_ptr _Ptr) {
    __ExceptionPtrRethrow(&_Ptr);
}

template <class _Ex>
void* __GetExceptionInfo(_Ex);

_EXPORT_STD template <class _Ex>
_NODISCARD_SMART_PTR_ALLOC exception_ptr make_exception_ptr(_Ex _Except) noexcept {
    return exception_ptr::_Copy_exception(_STD addressof(_Except), __GetExceptionInfo(_Except));
}

_EXPORT_STD class nested_exception { // wrap an exception_ptr
public:
    nested_exception() noexcept : _Exc(_STD current_exception()) {}

    nested_exception(const nested_exception&) noexcept = default;
    nested_exception& operator=(const nested_exception&) noexcept = default;
    virtual ~nested_exception() noexcept {}

    [[noreturn]] void rethrow_nested() const { // throw wrapped exception_ptr
        if (_Exc) {
            _STD rethrow_exception(_Exc);
        }
        else {
            _STD terminate(); // per N4950 [except.nested]/4
        }
    }

    _NODISCARD exception_ptr nested_ptr() const noexcept { // return wrapped exception_ptr
        return _Exc;
    }

private:
    exception_ptr _Exc;
};

template <class _Uty>
struct _With_nested_v2 : _Uty, nested_exception { // glue user exception to nested_exception
    template <class _Ty>
    explicit _With_nested_v2(_Ty&& _Arg)
        : _Uty(_STD forward<_Ty>(_Arg)), nested_exception() {} // store user exception and current_exception()
};

_EXPORT_STD template <class _Ty>
[[noreturn]] void throw_with_nested(_Ty&& _Arg) {
    // throw user exception, glued to nested_exception if possible
    using _Uty = decay_t<_Ty>;

    if constexpr (is_class_v<_Uty> && !is_base_of_v<nested_exception, _Uty> && !is_final_v<_Uty>) {
        // throw user exception glued to nested_exception
        _THROW(_With_nested_v2<_Uty>(_STD forward<_Ty>(_Arg)));
    }
    else {
        // throw user exception by itself
        _THROW(_STD forward<_Ty>(_Arg));
    }
}

#ifdef _CPPRTTI
_EXPORT_STD template <class _Ty>
void rethrow_if_nested(const _Ty& _Arg) {
    // detect nested_exception inheritance
    constexpr bool _Can_use_dynamic_cast =
        is_polymorphic_v<_Ty> && (!is_base_of_v<nested_exception, _Ty> || is_convertible_v<_Ty*, nested_exception*>);

    if constexpr (_Can_use_dynamic_cast) {
        const auto _Nested = dynamic_cast<const nested_exception*>(_STD addressof(_Arg));

        if (_Nested) {
            _Nested->rethrow_nested();
        }
    }
}
#else // ^^^ defined(_CPPRTTI) / !defined(_CPPRTTI) vvv
_EXPORT_STD template <class _Ty>
void rethrow_if_nested(const _Ty&) = delete; // requires /GR option
#endif // ^^^ !defined(_CPPRTTI) ^^^

_EXPORT_STD class bad_variant_access
    : public exception { // exception for visit of a valueless variant or get<I> on a variant with index() != I
public:
    bad_variant_access() noexcept = default;

    _NODISCARD const char* __CLR_OR_THIS_CALL what() const noexcept override {
        return "bad variant access";
    }

#if !_HAS_EXCEPTIONS
protected:
    void _Doraise() const override { // perform class-specific exception handling
        _RAISE(*this);
    }
#endif // ^^^ !_HAS_EXCEPTIONS ^^^
};

[[noreturn]] inline void _Throw_bad_variant_access() {
    _THROW(bad_variant_access{});
}

_STD_END

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)

#endif // _STL_COMPILER_PREPROCESSOR
#endif // _EXCEPTION_

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_STD_BEGIN
#ifndef _VCRT_EXPORT_STD // TRANSITION, VCRuntime update expected in 17.10 Preview 3
#if _HAS_EXCEPTIONS
// Follow N4971 [module.interface]/6 by exporting aliases (a type alias is not an entity, N4971 [basic.pre]/3):
_EXPORT_STD using bad_alloc = bad_alloc;
_EXPORT_STD using bad_array_new_length = bad_array_new_length;
#else // ^^^ _HAS_EXCEPTIONS / !_HAS_EXCEPTIONS vvv
// <exception> exports bad_alloc and bad_array_new_length.
#endif // ^^^ !_HAS_EXCEPTIONS ^^^
#endif // ^^^ workaround ^^^

#if _HAS_CXX20
_EXPORT_STD struct destroying_delete_t {
    explicit destroying_delete_t() = default;
};
_EXPORT_STD inline constexpr destroying_delete_t destroying_delete{};
#endif // _HAS_CXX20

#if _HAS_CXX17
_EXPORT_STD template <class _Ty>
_NODISCARD_LAUNDER constexpr _Ty* launder(_Ty* _Ptr) noexcept {
    static_assert(!is_function_v<_Ty> && !is_void_v<_Ty>,
        "N4950 [ptr.launder]/1: Mandates: !is_function_v<T> && !is_void_v<T> is true.");
#if defined(__clang__) || defined(__EDG__) // TRANSITION, DevCom-10456452
    return __builtin_launder(_Ptr);
#else // ^^^ no workaround / workaround vvv
    return ::__builtin_launder(_Ptr);
#endif // ^^^ workaround ^^^
}

#if defined(_M_IX86) || defined(_M_X64) || defined(_M_ARM) || defined(_M_ARM64)
_EXPORT_STD inline constexpr size_t hardware_constructive_interference_size = 64;
_EXPORT_STD inline constexpr size_t hardware_destructive_interference_size = 64;
#else // ^^^ supported hardware / unsupported hardware vvv
#error Unsupported architecture
#endif // ^^^ unsupported hardware ^^^

#endif // _HAS_CXX17

_EXPORT_STD using new_handler = void(__CLRCALL_PURE_OR_CDECL*)();

_EXPORT_STD extern "C++" _CRTIMP2 new_handler __cdecl set_new_handler(_In_opt_ new_handler) noexcept;
_EXPORT_STD extern "C++" _NODISCARD _CRTIMP2 new_handler __cdecl get_new_handler() noexcept;
_STD_END

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)

#endif // _STL_COMPILER_PREPROCESSOR
#endif // _NEW_

// xatomic.h internal header (core)

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#ifndef _XATOMIC_H
#define _XATOMIC_H
#if _STL_COMPILER_PREPROCESSOR

#include _STL_INTRIN_HEADER

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

#define _CONCATX(x, y) x##y
#define _CONCAT(x, y)  _CONCATX(x, y)

// Interlocked intrinsic mapping for _nf/_acq/_rel
#if defined(_M_CEE_PURE) || (defined(_M_IX86) && !defined(_M_HYBRID_X86_ARM64)) \
    || (defined(_M_X64) && !defined(_M_ARM64EC))
#define _INTRIN_RELAXED(x) x
#define _INTRIN_ACQUIRE(x) x
#define _INTRIN_RELEASE(x) x
#define _INTRIN_ACQ_REL(x) x
#ifdef _M_CEE_PURE
#define _YIELD_PROCESSOR()
#else // ^^^ defined(_M_CEE_PURE) / !defined(_M_CEE_PURE) vvv
#define _YIELD_PROCESSOR() _mm_pause()
#endif // ^^^ !defined(_M_CEE_PURE) ^^^

#elif defined(_M_ARM) || defined(_M_ARM64) || defined(_M_ARM64EC) || defined(_M_HYBRID_X86_ARM64)
#define _INTRIN_RELAXED(x) _CONCAT(x, _nf)
#define _INTRIN_ACQUIRE(x) _CONCAT(x, _acq)
#define _INTRIN_RELEASE(x) _CONCAT(x, _rel)
// We don't have interlocked intrinsics for acquire-release ordering, even on
// ARM32/ARM64, so fall back to sequentially consistent.
#define _INTRIN_ACQ_REL(x) x
#define _YIELD_PROCESSOR() __yield()

#else // ^^^ ARM32/ARM64/ARM64EC/HYBRID_X86_ARM64 / unsupported hardware vvv
#error Unsupported hardware
#endif // hardware

#define _MT_INCR(x) _INTRIN_RELAXED(_InterlockedIncrement)(reinterpret_cast<volatile long*>(&x))
#define _MT_DECR(x) _INTRIN_ACQ_REL(_InterlockedDecrement)(reinterpret_cast<volatile long*>(&x))

// The following macros are SHARED with vcruntime and any updates should be mirrored.
// Also: if any macros are added they should be #undefed in vcruntime as well.
#define _Compiler_barrier() _STL_DISABLE_DEPRECATED_WARNING _ReadWriteBarrier() _STL_RESTORE_DEPRECATED_WARNING

#if defined(_M_ARM) || defined(_M_ARM64) || defined(_M_ARM64EC) || defined(_M_HYBRID_X86_ARM64)
#define _Memory_barrier()             __dmb(0xB) // inner shared data memory barrier
#define _Compiler_or_memory_barrier() _Memory_barrier()
#elif defined(_M_IX86) || defined(_M_X64)
// x86/x64 hardware only emits memory barriers inside _Interlocked intrinsics
#define _Compiler_or_memory_barrier() _Compiler_barrier()
#else // ^^^ x86/x64 / unsupported hardware vvv
#error Unsupported hardware
#endif // hardware

_STD_BEGIN

#if _HAS_CXX20
_EXPORT_STD enum class memory_order : int {
    relaxed,
    consume,
    acquire,
    release,
    acq_rel,
    seq_cst,

    // LWG-3268
    memory_order_relaxed = relaxed,
    memory_order_consume = consume,
    memory_order_acquire = acquire,
    memory_order_release = release,
    memory_order_acq_rel = acq_rel,
    memory_order_seq_cst = seq_cst
};
_EXPORT_STD inline constexpr memory_order memory_order_relaxed = memory_order::relaxed;
_EXPORT_STD inline constexpr memory_order memory_order_consume = memory_order::consume;
_EXPORT_STD inline constexpr memory_order memory_order_acquire = memory_order::acquire;
_EXPORT_STD inline constexpr memory_order memory_order_release = memory_order::release;
_EXPORT_STD inline constexpr memory_order memory_order_acq_rel = memory_order::acq_rel;
_EXPORT_STD inline constexpr memory_order memory_order_seq_cst = memory_order::seq_cst;
#else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
enum memory_order {
    memory_order_relaxed,
    memory_order_consume,
    memory_order_acquire,
    memory_order_release,
    memory_order_acq_rel,
    memory_order_seq_cst
};
#endif // ^^^ !_HAS_CXX20 ^^^

using _Atomic_counter_t = unsigned long;

template <class _Integral, class _Ty>
_NODISCARD volatile _Integral* _Atomic_address_as(_Ty& _Source) noexcept {
    // gets a pointer to the argument as an integral type (to pass to intrinsics)
    static_assert(is_integral_v<_Integral>, "Tried to reinterpret memory as non-integral");
    return &reinterpret_cast<volatile _Integral&>(_Source);
}

template <class _Integral, class _Ty>
_NODISCARD const volatile _Integral* _Atomic_address_as(const _Ty& _Source) noexcept {
    // gets a pointer to the argument as an integral type (to pass to intrinsics)
    static_assert(is_integral_v<_Integral>, "Tried to reinterpret memory as non-integral");
    return &reinterpret_cast<const volatile _Integral&>(_Source);
}

_STD_END

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _XATOMIC_H



#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_STD_BEGIN
template <class _Ptrty>
_NODISCARD constexpr auto _Unfancy(_Ptrty _Ptr) noexcept { // converts from a fancy pointer to a plain pointer
    return _STD addressof(*_Ptr);
}

template <class _Ty>
_NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers
    return _Ptr;
}

template <class _Ptrty>
constexpr auto _Unfancy_maybe_null(_Ptrty _Ptr) noexcept {
    // converts from a (potentially null) fancy pointer to a plain pointer
    return _Ptr ? _STD addressof(*_Ptr) : nullptr;
}

template <class _Ty>
constexpr _Ty* _Unfancy_maybe_null(_Ty* _Ptr) noexcept { // do nothing for plain pointers
    return _Ptr;
}

template <class _Ty>
struct _NODISCARD _Tidy_guard { // class with destructor that calls _Tidy
    _Ty* _Target;
    _CONSTEXPR20 ~_Tidy_guard() {
        if (_Target) {
            _Target->_Tidy();
        }
    }
};

template <class _Ty>
struct _NODISCARD _Tidy_deallocate_guard { // class with destructor that calls _Tidy_deallocate
    _Ty* _Target;
    _CONSTEXPR20 ~_Tidy_deallocate_guard() {
        if (_Target) {
            _Target->_Tidy_deallocate();
        }
    }
};

template <class _Keycmp, class _Lhs, class _Rhs>
_INLINE_VAR constexpr bool _Nothrow_compare = noexcept(
    static_cast<bool>(_STD declval<const _Keycmp&>()(_STD declval<const _Lhs&>(), _STD declval<const _Rhs&>())));

[[noreturn]] inline void _Throw_bad_array_new_length() {
    _THROW(bad_array_new_length{});
}

template <size_t _Ty_size>
_NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {
    constexpr bool _Overflow_is_possible = _Ty_size > 1;

    if constexpr (_Overflow_is_possible) {
        constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
        if (_Count > _Max_possible) {
            _Throw_bad_array_new_length(); // multiply overflow
        }
    }

    return _Count * _Ty_size;
}

template <class _Ty>
_INLINE_VAR constexpr size_t _New_alignof = (_STD max)(alignof(_Ty), __STDCPP_DEFAULT_NEW_ALIGNMENT__);

struct _Default_allocate_traits {
    __declspec(allocator) static
#ifdef __clang__ // Clang and MSVC implement P0784R7 differently; see GH-1532
        _CONSTEXPR20
#endif // defined(__clang__)
        void* _Allocate(const size_t _Bytes) {
        return ::operator new(_Bytes);
    }

#ifdef __cpp_aligned_new
    __declspec(allocator) static
#ifdef __clang__ // Clang and MSVC implement P0784R7 differently; see GH-1532
        _CONSTEXPR20
#endif // defined(__clang__)
        void* _Allocate_aligned(const size_t _Bytes, const size_t _Align) {
#ifdef __clang__ // Clang and MSVC implement P0784R7 differently; see GH-1532
#if _HAS_CXX20
        if (_STD is_constant_evaluated()) {
            return ::operator new(_Bytes);
        }
        else
#endif // _HAS_CXX20
#endif // defined(__clang__)
        {
            return ::operator new(_Bytes, align_val_t{ _Align });
        }
    }
#endif // defined(__cpp_aligned_new)
};

constexpr bool _Is_pow_2(const size_t _Value) noexcept {
    return _Value != 0 && (_Value & (_Value - 1)) == 0;
}

#if defined(_M_IX86) || defined(_M_X64)
_INLINE_VAR constexpr size_t _Big_allocation_threshold = 4096;
_INLINE_VAR constexpr size_t _Big_allocation_alignment = 32;

// Big allocation alignment should at least match vector register alignment
_STL_INTERNAL_STATIC_ASSERT(2 * sizeof(void*) <= _Big_allocation_alignment);

// Big allocation alignment must be a power of two
_STL_INTERNAL_STATIC_ASSERT(_Is_pow_2(_Big_allocation_alignment));

#ifdef _DEBUG
_INLINE_VAR constexpr size_t _Non_user_size = 2 * sizeof(void*) + _Big_allocation_alignment - 1;
#else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
_INLINE_VAR constexpr size_t _Non_user_size = sizeof(void*) + _Big_allocation_alignment - 1;
#endif // ^^^ !defined(_DEBUG) ^^^

#ifdef _WIN64
_INLINE_VAR constexpr size_t _Big_allocation_sentinel = 0xFAFAFAFAFAFAFAFAULL;
#else // ^^^ defined(_WIN64) / !defined(_WIN64) vvv
_INLINE_VAR constexpr size_t _Big_allocation_sentinel = 0xFAFAFAFAUL;
#endif // ^^^ !defined(_WIN64) ^^^

template <class _Traits>
__declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {
    // allocate _Bytes manually aligned to at least _Big_allocation_alignment
    const size_t _Block_size = _Non_user_size + _Bytes;
    if (_Block_size <= _Bytes) {
        _Throw_bad_array_new_length(); // add overflow
    }

    const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
    _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]
    void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));
    static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

#ifdef _DEBUG
    static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
#endif // defined(_DEBUG)
    return _Ptr;
}

inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {
    // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
    _Bytes += _Non_user_size;

    const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
    const uintptr_t _Ptr_container = _Ptr_user[-1];

    // If the following asserts, it likely means that we are performing
    // an aligned delete on memory coming from an unaligned allocation.
    _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");

    // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
    // in range [_Min_back_shift, _Non_user_size]
#ifdef _DEBUG
    constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
#else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
    constexpr uintptr_t _Min_back_shift = sizeof(void*);
#endif // ^^^ !defined(_DEBUG) ^^^
    const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
    _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");
    _Ptr = reinterpret_cast<void*>(_Ptr_container);
}
#endif // defined(_M_IX86) || defined(_M_X64)

template <size_t _Align, class _Traits = _Default_allocate_traits>
__declspec(allocator) _CONSTEXPR20 void* _Allocate(const size_t _Bytes) {
    // allocate _Bytes
    if (_Bytes == 0) {
        return nullptr;
    }

#if _HAS_CXX20 // TRANSITION, GH-1532
    if (_STD is_constant_evaluated()) {
        return _Traits::_Allocate(_Bytes);
    }
#endif // _HAS_CXX20

#ifdef __cpp_aligned_new
    if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
        size_t _Passed_align = _Align;
#if defined(_M_IX86) || defined(_M_X64)
        if (_Bytes >= _Big_allocation_threshold) {
            // boost the alignment of big allocations to help autovectorization
            _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
        }
#endif // defined(_M_IX86) || defined(_M_X64)
        return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
    }
    else
#endif // defined(__cpp_aligned_new)
    {
#if defined(_M_IX86) || defined(_M_X64)
        if (_Bytes >= _Big_allocation_threshold) {
            // boost the alignment of big allocations to help autovectorization
            return _Allocate_manually_vector_aligned<_Traits>(_Bytes);
        }
#endif // defined(_M_IX86) || defined(_M_X64)
        return _Traits::_Allocate(_Bytes);
    }
}

template <size_t _Align>
_CONSTEXPR20 void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {
    // deallocate storage allocated by _Allocate
#if _HAS_CXX20 // TRANSITION, GH-1532
    if (_STD is_constant_evaluated()) {
        ::operator delete(_Ptr);
        return;
    }
#endif // _HAS_CXX20

#ifdef __cpp_aligned_new
    if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
        size_t _Passed_align = _Align;
#if defined(_M_IX86) || defined(_M_X64)
        if (_Bytes >= _Big_allocation_threshold) {
            // boost the alignment of big allocations to help autovectorization
            _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
        }
#endif // defined(_M_IX86) || defined(_M_X64)
        ::operator delete(_Ptr, _Bytes, align_val_t{ _Passed_align });
    }
    else
#endif // defined(__cpp_aligned_new)
    {
#if defined(_M_IX86) || defined(_M_X64)
        if (_Bytes >= _Big_allocation_threshold) {
            // boost the alignment of big allocations to help autovectorization
            _Adjust_manually_vector_aligned(_Ptr, _Bytes);
        }
#endif // defined(_M_IX86) || defined(_M_X64)
        ::operator delete(_Ptr, _Bytes);
    }
}

template <class _Ptr, class _Ty>
using _Rebind_pointer_t = typename pointer_traits<_Ptr>::template rebind<_Ty>;

template <class _Pointer, enable_if_t<!is_pointer_v<_Pointer>, int> = 0>
_CONSTEXPR20 _Pointer _Refancy(typename pointer_traits<_Pointer>::element_type* _Ptr) noexcept {
    return pointer_traits<_Pointer>::pointer_to(*_Ptr);
}

template <class _Pointer, enable_if_t<is_pointer_v<_Pointer>, int> = 0>
_CONSTEXPR20 _Pointer _Refancy(_Pointer _Ptr) noexcept {
    return _Ptr;
}

template <class _Pointer, enable_if_t<!is_pointer_v<_Pointer>, int> = 0>
_CONSTEXPR20 _Pointer _Refancy_maybe_null(typename pointer_traits<_Pointer>::element_type* _Ptr) noexcept {
    return _Ptr == nullptr ? _Pointer() : pointer_traits<_Pointer>::pointer_to(*_Ptr);
}

template <class _Pointer, enable_if_t<is_pointer_v<_Pointer>, int> = 0>
_CONSTEXPR20 _Pointer _Refancy_maybe_null(_Pointer _Ptr) noexcept {
    return _Ptr;
}

template <class _NoThrowFwdIt, class _NoThrowSentinel>
_CONSTEXPR20 void _Destroy_range(_NoThrowFwdIt _First, _NoThrowSentinel _Last) noexcept;

template <class _Ty>
_CONSTEXPR20 void _Destroy_in_place(_Ty& _Obj) noexcept {
    if constexpr (is_array_v<_Ty>) {
        _STD _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
    }
    else {
        _Obj.~_Ty();
    }
}

#if _HAS_CXX17
_EXPORT_STD template <class _Ty>
_CONSTEXPR20 void destroy_at(_Ty* const _Location) noexcept /* strengthened */ {
#if _HAS_CXX20
    if constexpr (is_array_v<_Ty>) {
        _STD _Destroy_range(_STD begin(*_Location), _STD end(*_Location));
    }
    else
#endif // _HAS_CXX20
    {
        _Location->~_Ty();
    }
}
#endif // _HAS_CXX17

template <class _Ptrty>
auto _Const_cast(_Ptrty _Ptr) noexcept { // remove constness from a fancy pointer
    using _Elem = typename pointer_traits<_Ptrty>::element_type;
    using _Modifiable = remove_const_t<_Elem>;
    using _Dest = typename pointer_traits<_Ptrty>::template rebind<_Modifiable>;

    return pointer_traits<_Dest>::pointer_to(const_cast<_Modifiable&>(*_Ptr));
}

template <class _Ty>
auto _Const_cast(_Ty* _Ptr) noexcept {
    return const_cast<remove_const_t<_Ty>*>(_Ptr);
}

template <class _Ty, class = void>
struct _Get_pointer_type {
    using type = typename _Ty::value_type*;
};

_STL_DISABLE_DEPRECATED_WARNING
template <class _Ty>
struct _Get_pointer_type<_Ty, void_t<typename _Ty::pointer>> {
    using type = typename _Ty::pointer;
};
_STL_RESTORE_DEPRECATED_WARNING

template <class _Ty, class = void>
struct _Get_const_pointer_type {
    using _Ptrty = typename _Get_pointer_type<_Ty>::type;
    using _Valty = typename _Ty::value_type;
    using type = typename pointer_traits<_Ptrty>::template rebind<const _Valty>;
};

_STL_DISABLE_DEPRECATED_WARNING
template <class _Ty>
struct _Get_const_pointer_type<_Ty, void_t<typename _Ty::const_pointer>> {
    using type = typename _Ty::const_pointer;
};
_STL_RESTORE_DEPRECATED_WARNING

template <class _Ty, class = void>
struct _Get_void_pointer_type {
    using _Ptrty = typename _Get_pointer_type<_Ty>::type;
    using type = typename pointer_traits<_Ptrty>::template rebind<void>;
};

template <class _Ty>
struct _Get_void_pointer_type<_Ty, void_t<typename _Ty::void_pointer>> {
    using type = typename _Ty::void_pointer;
};

template <class _Ty, class = void>
struct _Get_const_void_pointer_type {
    using _Ptrty = typename _Get_pointer_type<_Ty>::type;
    using type = typename pointer_traits<_Ptrty>::template rebind<const void>;
};

template <class _Ty>
struct _Get_const_void_pointer_type<_Ty, void_t<typename _Ty::const_void_pointer>> {
    using type = typename _Ty::const_void_pointer;
};

template <class _Ty, class = void>
struct _Get_difference_type {
    using _Ptrty = typename _Get_pointer_type<_Ty>::type;
    using type = typename pointer_traits<_Ptrty>::difference_type;
};

template <class _Ty>
struct _Get_difference_type<_Ty, void_t<typename _Ty::difference_type>> {
    using type = typename _Ty::difference_type;
};

template <class _Ty, class = void>
struct _Get_size_type {
    using type = make_unsigned_t<typename _Get_difference_type<_Ty>::type>;
};

template <class _Ty>
struct _Get_size_type<_Ty, void_t<typename _Ty::size_type>> {
    using type = typename _Ty::size_type;
};

template <class _Ty, class = void>
struct _Get_propagate_on_container_copy {
    using type = false_type;
};

template <class _Ty>
struct _Get_propagate_on_container_copy<_Ty, void_t<typename _Ty::propagate_on_container_copy_assignment>> {
    using type = typename _Ty::propagate_on_container_copy_assignment;
};

template <class _Ty, class = void>
struct _Get_propagate_on_container_move {
    using type = false_type;
};

template <class _Ty>
struct _Get_propagate_on_container_move<_Ty, void_t<typename _Ty::propagate_on_container_move_assignment>> {
    using type = typename _Ty::propagate_on_container_move_assignment;
};

template <class _Ty, class = void>
struct _Get_propagate_on_container_swap {
    using type = false_type;
};

template <class _Ty>
struct _Get_propagate_on_container_swap<_Ty, void_t<typename _Ty::propagate_on_container_swap>> {
    using type = typename _Ty::propagate_on_container_swap;
};

template <class _Ty, class = void>
struct _Get_is_always_equal {
    using type = bool_constant<is_empty_v<_Ty>>;
};

_STL_DISABLE_DEPRECATED_WARNING
template <class _Ty>
struct _Get_is_always_equal<_Ty, void_t<typename _Ty::is_always_equal>> {
    using type = typename _Ty::is_always_equal;
};
_STL_RESTORE_DEPRECATED_WARNING

template <class _Ty, class _Other, class = void>
struct _Get_rebind_type {
    using type = typename _Replace_first_parameter<_Other, _Ty>::type;
};

_STL_DISABLE_DEPRECATED_WARNING
template <class _Ty, class _Other>
struct _Get_rebind_type<_Ty, _Other, void_t<typename _Ty::template rebind<_Other>::other>> {
    using type = typename _Ty::template rebind<_Other>::other;
};
_STL_RESTORE_DEPRECATED_WARNING

_EXPORT_STD template <class _Ty>
class allocator;

template <class _Alloc, class = void>
struct _Is_default_allocator : false_type {};

template <class _Ty>
struct _Is_default_allocator<allocator<_Ty>, void_t<typename allocator<_Ty>::_From_primary>>
    : is_same<typename allocator<_Ty>::_From_primary, allocator<_Ty>>::type {};

#if _HAS_CXX23
template <class _Alloc, class _SizeTy>
concept _Has_member_allocate_at_least = requires(_Alloc & _Al, const _SizeTy & _Count) { _Al.allocate_at_least(_Count); };
#endif // _HAS_CXX23

template <class _Void, class... _Types>
struct _Has_no_allocator_construct : true_type {};

_STL_DISABLE_DEPRECATED_WARNING
template <class _Alloc, class _Ptr, class... _Args>
struct _Has_no_allocator_construct<
    void_t<decltype(_STD declval<_Alloc&>().construct(_STD declval<_Ptr>(), _STD declval<_Args>()...))>, _Alloc, _Ptr,
    _Args...> : false_type {};
_STL_RESTORE_DEPRECATED_WARNING

template <class _Alloc, class _Ptr, class... _Args>
using _Uses_default_construct =
disjunction<_Is_default_allocator<_Alloc>, _Has_no_allocator_construct<void, _Alloc, _Ptr, _Args...>>;

template <class _Alloc, class _Ptr, class = void>
struct _Has_no_alloc_destroy : true_type {};

_STL_DISABLE_DEPRECATED_WARNING
template <class _Alloc, class _Ptr>
struct _Has_no_alloc_destroy<_Alloc, _Ptr, void_t<decltype(_STD declval<_Alloc&>().destroy(_STD declval<_Ptr>()))>>
    : false_type {};
_STL_RESTORE_DEPRECATED_WARNING

template <class _Alloc, class _Ptr>
using _Uses_default_destroy = disjunction<_Is_default_allocator<_Alloc>, _Has_no_alloc_destroy<_Alloc, _Ptr>>;

template <class _Alloc, class _Size_type, class _Const_void_pointer, class = void>
struct _Has_allocate_hint : false_type {};

_STL_DISABLE_DEPRECATED_WARNING
template <class _Alloc, class _Size_type, class _Const_void_pointer>
struct _Has_allocate_hint<_Alloc, _Size_type, _Const_void_pointer,
    void_t<decltype(_STD declval<_Alloc&>().allocate(
        _STD declval<const _Size_type&>(), _STD declval<const _Const_void_pointer&>()))>> : true_type {};
_STL_RESTORE_DEPRECATED_WARNING

template <class _Alloc, class = void>
struct _Has_max_size : false_type {};

_STL_DISABLE_DEPRECATED_WARNING
template <class _Alloc>
struct _Has_max_size<_Alloc, void_t<decltype(_STD declval<const _Alloc&>().max_size())>> : true_type {};
_STL_RESTORE_DEPRECATED_WARNING

template <class _Alloc, class = void>
struct _Has_select_on_container_copy_construction : false_type {};

template <class _Alloc>
struct _Has_select_on_container_copy_construction<_Alloc,
    void_t<decltype(_STD declval<const _Alloc&>().select_on_container_copy_construction())>> : true_type {};

#if _HAS_CXX23
_EXPORT_STD template <class _Ptr, class _SizeTy = size_t>
struct allocation_result {
    _Ptr ptr;
    _SizeTy count;
};
#endif // _HAS_CXX23

_EXPORT_STD template <class _Alloc>
struct allocator_traits;

_STL_DISABLE_DEPRECATED_WARNING
template <class _Alloc>
struct _Normal_allocator_traits { // defines traits for allocators
    using allocator_type = _Alloc;
    using value_type = typename _Alloc::value_type;

    using pointer = typename _Get_pointer_type<_Alloc>::type;
    using const_pointer = typename _Get_const_pointer_type<_Alloc>::type;
    using void_pointer = typename _Get_void_pointer_type<_Alloc>::type;
    using const_void_pointer = typename _Get_const_void_pointer_type<_Alloc>::type;

    using size_type = typename _Get_size_type<_Alloc>::type;
    using difference_type = typename _Get_difference_type<_Alloc>::type;

    using propagate_on_container_copy_assignment = typename _Get_propagate_on_container_copy<_Alloc>::type;
    using propagate_on_container_move_assignment = typename _Get_propagate_on_container_move<_Alloc>::type;
    using propagate_on_container_swap = typename _Get_propagate_on_container_swap<_Alloc>::type;
    using is_always_equal = typename _Get_is_always_equal<_Alloc>::type;

    template <class _Other>
    using rebind_alloc = typename _Get_rebind_type<_Alloc, _Other>::type;

    template <class _Other>
    using rebind_traits = allocator_traits<rebind_alloc<_Other>>;

    _NODISCARD_RAW_PTR_ALLOC static _CONSTEXPR20 __declspec(allocator) pointer
        allocate(_Alloc& _Al, _CRT_GUARDOVERFLOW const size_type _Count) {
        return _Al.allocate(_Count);
    }

    _NODISCARD_RAW_PTR_ALLOC static _CONSTEXPR20 __declspec(allocator) pointer
        allocate(_Alloc& _Al, _CRT_GUARDOVERFLOW const size_type _Count, const const_void_pointer _Hint) {
        if constexpr (_Has_allocate_hint<_Alloc, size_type, const_void_pointer>::value) {
            return _Al.allocate(_Count, _Hint);
        }
        else {
            return _Al.allocate(_Count);
        }
    }

#if _HAS_CXX23
    _NODISCARD_RAW_PTR_ALLOC static constexpr allocation_result<pointer, size_type> allocate_at_least(
        _Alloc& _Al, _CRT_GUARDOVERFLOW const size_type _Count) {
        if constexpr (_Has_member_allocate_at_least<_Alloc, size_type>) {
            return _Al.allocate_at_least(_Count);
        }
        else {
            return { _Al.allocate(_Count), _Count };
        }
    }
#endif // _HAS_CXX23

    static _CONSTEXPR20 void deallocate(_Alloc& _Al, pointer _Ptr, size_type _Count) {
        _Al.deallocate(_Ptr, _Count);
    }

    template <class _Ty, class... _Types>
    static _CONSTEXPR20 void construct(_Alloc& _Al, _Ty* _Ptr, _Types&&... _Args) {
        if constexpr (_Uses_default_construct<_Alloc, _Ty*, _Types...>::value) {
#if _HAS_CXX20
            _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
#else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
            ::new (static_cast<void*>(_Ptr)) _Ty(_STD forward<_Types>(_Args)...);
#endif // ^^^ !_HAS_CXX20 ^^^
        }
        else {
            _Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
        }
    }

    template <class _Ty>
    static _CONSTEXPR20 void destroy(_Alloc& _Al, _Ty* _Ptr) {
        if constexpr (_Uses_default_destroy<_Alloc, _Ty*>::value) {
#if _HAS_CXX20
            _STD destroy_at(_Ptr);
#else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
            _Ptr->~_Ty();
#endif // ^^^ !_HAS_CXX20 ^^^
        }
        else {
            _Al.destroy(_Ptr);
        }
    }

    _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc& _Al) noexcept {
        if constexpr (_Has_max_size<_Alloc>::value) {
            return _Al.max_size();
        }
        else {
            return (numeric_limits<size_type>::max)() / sizeof(value_type);
        }
    }

    _NODISCARD static _CONSTEXPR20 _Alloc select_on_container_copy_construction(const _Alloc& _Al) {
        if constexpr (_Has_select_on_container_copy_construction<_Alloc>::value) {
            return _Al.select_on_container_copy_construction();
        }
        else {
            return _Al;
        }
    }
};
_STL_RESTORE_DEPRECATED_WARNING

template <class _Alloc>
struct _Default_allocator_traits { // traits for std::allocator
    using allocator_type = _Alloc;
    using value_type = typename _Alloc::value_type;

    using pointer = value_type*;
    using const_pointer = const value_type*;
    using void_pointer = void*;
    using const_void_pointer = const void*;

    using size_type = size_t;
    using difference_type = ptrdiff_t;

    using propagate_on_container_copy_assignment = false_type;
    using propagate_on_container_move_assignment = true_type;
    using propagate_on_container_swap = false_type;
    using is_always_equal = true_type;

    template <class _Other>
    using rebind_alloc = allocator<_Other>;

    template <class _Other>
    using rebind_traits = allocator_traits<allocator<_Other>>;

    _NODISCARD_RAW_PTR_ALLOC static _CONSTEXPR20 __declspec(allocator) pointer
        allocate(_Alloc& _Al, _CRT_GUARDOVERFLOW const size_type _Count) {
#if _HAS_CXX20 // TRANSITION, GH-1532
        if (_STD is_constant_evaluated()) {
            return _Al.allocate(_Count);
        }
        else
#endif // _HAS_CXX20
        {
            (void)_Al;
            return static_cast<pointer>(
                _Allocate<_New_alignof<value_type>>(_Get_size_of_n<sizeof(value_type)>(_Count)));
        }
    }

    _NODISCARD_RAW_PTR_ALLOC static _CONSTEXPR20 __declspec(allocator) pointer
        allocate(_Alloc& _Al, _CRT_GUARDOVERFLOW const size_type _Count, const_void_pointer) {
#if _HAS_CXX20 // TRANSITION, GH-1532
        if (_STD is_constant_evaluated()) {
            return _Al.allocate(_Count);
        }
        else
#endif // _HAS_CXX20
        {
            (void)_Al;
            return static_cast<pointer>(
                _Allocate<_New_alignof<value_type>>(_Get_size_of_n<sizeof(value_type)>(_Count)));
        }
    }

#if _HAS_CXX23
    _NODISCARD_RAW_PTR_ALLOC static constexpr allocation_result<pointer, size_type> allocate_at_least(
        _Alloc& _Al, _CRT_GUARDOVERFLOW const size_type _Count) {
        return { _Al.allocate(_Count), _Count };
    }
#endif // _HAS_CXX23

    static _CONSTEXPR20 void deallocate(_Alloc& _Al, const pointer _Ptr, const size_type _Count) {
        // no overflow check on the following multiply; we assume _Allocate did that check
#if _HAS_CXX20 // TRANSITION, GH-1532
        if (_STD is_constant_evaluated()) {
            _Al.deallocate(_Ptr, _Count);
        }
        else
#endif // _HAS_CXX20
        {
            (void)_Al;
            _STD _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);
        }
    }

    template <class _Objty, class... _Types>
    static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {
#if _HAS_CXX20
        _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
#else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
        ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);
#endif // ^^^ !_HAS_CXX20 ^^^
    }

    template <class _Uty>
    static _CONSTEXPR20 void destroy(_Alloc&, _Uty* const _Ptr) {
#if _HAS_CXX20
        _STD destroy_at(_Ptr);
#else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
        _Ptr->~_Uty();
#endif // ^^^ !_HAS_CXX20 ^^^
    }

    _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {
        return static_cast<size_t>(-1) / sizeof(value_type);
    }

    _NODISCARD static _CONSTEXPR20 _Alloc select_on_container_copy_construction(const _Alloc& _Al) {
        return _Al;
    }
};

_EXPORT_STD template <class _Alloc>
struct allocator_traits : conditional_t<_Is_default_allocator<_Alloc>::value, _Default_allocator_traits<_Alloc>,
    _Normal_allocator_traits<_Alloc>> {};

// _Choose_pocca_v returns whether an attempt to propagate allocators is necessary in copy assignment operations.
// Note that even when false_type, callers should call _Pocca as we want to assign allocators even when equal.
template <class _Alloc>
_INLINE_VAR constexpr bool _Choose_pocca_v = allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value
&& !allocator_traits<_Alloc>::is_always_equal::value;

enum class _Pocma_values {
    _Equal_allocators, // usually allows contents to be stolen (e.g. with swap)
    _Propagate_allocators, // usually allows the allocator to be propagated, and then contents stolen
    _No_propagate_allocators, // usually turns moves into copies
};

template <class _Alloc>
_INLINE_VAR constexpr _Pocma_values _Choose_pocma_v =
allocator_traits<_Alloc>::is_always_equal::value
? _Pocma_values::_Equal_allocators
    : (allocator_traits<_Alloc>::propagate_on_container_move_assignment::value
        ? _Pocma_values::_Propagate_allocators
        : _Pocma_values::_No_propagate_allocators);

template <class _Alloc, class _Value_type>
using _Rebind_alloc_t = typename allocator_traits<_Alloc>::template rebind_alloc<_Value_type>;

// If _Alloc is already rebound appropriately, binds an lvalue reference to it, avoiding a copy. Otherwise, creates a
// rebound copy.
template <class _Alloc, class _Value_type>
using _Maybe_rebind_alloc_t =
typename _Select<is_same_v<typename _Alloc::value_type, _Value_type>>::template _Apply<_Alloc&,
    _Rebind_alloc_t<_Alloc, _Value_type>>;

template <class _Alloc> // tests if allocator has simple addressing
_INLINE_VAR constexpr bool _Is_simple_alloc_v =
is_same_v<typename allocator_traits<_Alloc>::size_type, size_t>
&& is_same_v<typename allocator_traits<_Alloc>::difference_type, ptrdiff_t>
&& is_same_v<typename allocator_traits<_Alloc>::pointer, typename _Alloc::value_type*>
&& is_same_v<typename allocator_traits<_Alloc>::const_pointer, const typename _Alloc::value_type*>;

template <class _Value_type>
struct _Simple_types { // wraps types from allocators with simple addressing for use in iterators
    // and other SCARY machinery
    using value_type = _Value_type;
    using size_type = size_t;
    using difference_type = ptrdiff_t;
    using pointer = value_type*;
    using const_pointer = const value_type*;
};

// The number of user bytes a single byte of ASAN shadow memory can track.
_INLINE_VAR constexpr size_t _Asan_granularity = 8;
_INLINE_VAR constexpr size_t _Asan_granularity_mask = _Asan_granularity - 1;

struct _Asan_aligned_pointers {
    const void* _First;
    const void* _End;

    _NODISCARD constexpr const void* _Clamp_to_end(const void* _Mid) const noexcept {
        _STL_INTERNAL_CHECK(_Mid >= _First);
        if (_Mid > _End) {
            return _End;
        }
        else {
            return _Mid;
        }
    }
};

// The way that ASan shadow memory works, each eight byte block of memory ("shadow memory section")
// has a single byte to mark it as either poison or valid.
// Each section has 0 to 8 "valid" bytes followed by poison bytes, so:
// ```
//   [ v v v p p p p p ]
// ```
// or
// ```
//   [ v v v v v v v v ]
// ```
// are okay, but
// ```
//   [ p p p p v v v v ]
// ```
// is not.
//
// This function exists to fix up `first` and `end` pointers so that one can call
// `__sanitizer_annotate_contiguous_container`:
//
//   - `__sanitizer_annotate_contiguous_container` checks that `first` is aligned to an 8-byte boundary
//   - if `end` is not aligned to an 8-byte boundary, `__sanitizer_annotate_contiguous_container` still poisons the
//     remaining bytes in the shadow memory section.
//
// Because of the second property, we can only mark poison up to the final aligned address before the true `last`.
// Otherwise, we'd poison the memory _after_ `last` as well.
// For the first property, we can assume that everything before `first` in the shadow memory section is valid
// (since otherwise we couldn't mark `first` valid), and so we just return back the first address in
// `first`'s shadow memory section.
//
// ### Example
//
// ```cpp
// struct alignas(8) cat {
//     int meow; // bytes [0, 4)
//     char buffer[16]; // bytes [4, 20)
//     int purr; // bytes [20, 24)
// };
// ```
//
// First, `meow` and `purr` are just regular data members, not container buffers, so they _must_ be valid.
// Then, assume we want to poison all of `buffer`.
// This would mean that, in a perfect world, we want something like:
//
// ```
//    |  meow |               buffer                | purr  |
//   [ v v v v p p p p ][ p p p p p p p p ][ p p p p v v v v ]
//           sm1                sm2                sm3
// ```
//
// However, note that by the rules above, `sm3` is not a valid shadow memory section; we always need
// the valid bytes to come before the poison bytes. Thus, the closest we can actually get to it is:
//
// ```
//    |  meow |               buffer                | purr  |
//   [ v v v v p p p p ][ p p p p p p p p ][ v v v v v v v v ]
//           sm1                sm2                sm3
// ```
//
// We call `aligned = _Get_asan_aligned_first_end(cat.buffer, cat.buffer + 16);`, and we get back
//
// ```cpp
// aligned = {
//     ._First = &cat.meow,
//     ._End = cat.buffer + 12,
// };
// ```
//
// Then, we poison as much of buffer as we can via
//
// ```cpp
// __sanitizer_annotate_contiguous_container(
//     aligned._First,
//     aligned._End,
//     cat.buffer,
//     aligned._Clamp_to_end(cat.buffer + 16));
// ```
//
// We are allowed to assume that `&cat.meow` is valid, since otherwise `cat.buffer + [0, 4)` could not be valid.
// We cannot poison up to `cat.buffer + 16`, since then `&purr` could not be valid.
// Thus, this results in the shadow memory state from the second example.
_NODISCARD inline _Asan_aligned_pointers _Get_asan_aligned_first_end(
    const void* const _First, const void* const _End) noexcept {
    return {
        reinterpret_cast<const void*>(reinterpret_cast<uintptr_t>(_First) & ~_Asan_granularity_mask),
        reinterpret_cast<const void*>(reinterpret_cast<uintptr_t>(_End) & ~_Asan_granularity_mask),
    };
}

// When we can assume that the allocator we are using will always align allocations to the 8-byte,
// we can simply push the `_End` pointer to the end of the shadow memory section.
// This is _not_ safe in general (see _Get_asan_aligned_first_end's comment for why).
_NODISCARD inline const void* _Get_asan_aligned_after(const void* const _End) noexcept {
    return reinterpret_cast<const void*>(
        (reinterpret_cast<uintptr_t>(_End) + _Asan_granularity_mask) & ~_Asan_granularity_mask);
}

template <class _Container, class = void>
_INLINE_VAR constexpr size_t _Container_allocation_minimum_asan_alignment = alignof(typename _Container::value_type);

template <class _Container>
_INLINE_VAR constexpr size_t _Container_allocation_minimum_asan_alignment<_Container,
    void_t<decltype(_Container::allocator_type::_Minimum_asan_allocation_alignment)>> =
    (_STD max)(
        alignof(typename _Container::value_type), _Container::allocator_type::_Minimum_asan_allocation_alignment);

_EXPORT_STD template <class _Ty>
class allocator {
public:
    static_assert(!is_const_v<_Ty>, "The C++ Standard forbids containers of const elements "
        "because allocator<const T> is ill-formed.");
    static_assert(!is_function_v<_Ty>, "The C++ Standard forbids allocators for function elements "
        "because of [allocator.requirements].");
    static_assert(!is_reference_v<_Ty>, "The C++ Standard forbids allocators for reference elements "
        "because of [allocator.requirements].");

    using _From_primary = allocator;

    using value_type = _Ty;

#if _HAS_DEPRECATED_ALLOCATOR_MEMBERS
    using pointer _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS = _Ty*;
    using const_pointer _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS = const _Ty*;

    using reference _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS = _Ty&;
    using const_reference _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS = const _Ty&;
#endif // _HAS_DEPRECATED_ALLOCATOR_MEMBERS

    using size_type = size_t;
    using difference_type = ptrdiff_t;

    using propagate_on_container_move_assignment = true_type;
    using is_always_equal _CXX20_DEPRECATE_IS_ALWAYS_EQUAL = true_type;

#if _HAS_DEPRECATED_ALLOCATOR_MEMBERS
    template <class _Other>
    struct _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS rebind {
        using other = allocator<_Other>;
    };

    _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS _NODISCARD _Ty* address(_Ty& _Val) const noexcept {
        return _STD addressof(_Val);
    }

    _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS _NODISCARD const _Ty* address(const _Ty& _Val) const noexcept {
        return _STD addressof(_Val);
    }
#endif // _HAS_DEPRECATED_ALLOCATOR_MEMBERS

    constexpr allocator() noexcept {}

    constexpr allocator(const allocator&) noexcept = default;
    template <class _Other>
    constexpr allocator(const allocator<_Other>&) noexcept {}
    _CONSTEXPR20 ~allocator() = default;
    _CONSTEXPR20 allocator& operator=(const allocator&) = default;

    _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {
        _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
        // no overflow check on the following multiply; we assume _Allocate did that check
        _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);
    }

    _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {
        static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
        return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
    }

#if _HAS_CXX23
    _NODISCARD_RAW_PTR_ALLOC constexpr allocation_result<_Ty*> allocate_at_least(
        _CRT_GUARDOVERFLOW const size_t _Count) {
        return { allocate(_Count), _Count };
    }
#endif // _HAS_CXX23

#if _HAS_DEPRECATED_ALLOCATOR_MEMBERS
    _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS _NODISCARD_RAW_PTR_ALLOC __declspec(allocator) _Ty* allocate(
        _CRT_GUARDOVERFLOW const size_t _Count, const void*) {
        return allocate(_Count);
    }

    template <class _Objty, class... _Types>
    _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS void construct(_Objty* const _Ptr, _Types&&... _Args) {
        ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);
    }

    template <class _Uty>
    _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS void destroy(_Uty* const _Ptr) {
        _Ptr->~_Uty();
    }

    _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS _NODISCARD size_t max_size() const noexcept {
        return static_cast<size_t>(-1) / sizeof(_Ty);
    }
#endif // _HAS_DEPRECATED_ALLOCATOR_MEMBERS

    static constexpr size_t _Minimum_asan_allocation_alignment = _Asan_granularity;
};

#if _HAS_DEPRECATED_ALLOCATOR_VOID || _HAS_DEPRECATED_ALLOCATOR_MEMBERS
template <>
class allocator<void> {
public:
    using value_type = void;
#if _HAS_DEPRECATED_ALLOCATOR_MEMBERS
    using pointer _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS = void*;
    using const_pointer _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS = const void*;

    template <class _Other>
    struct _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS rebind {
        using other = allocator<_Other>;
    };
#endif // _HAS_DEPRECATED_ALLOCATOR_MEMBERS

#if _HAS_CXX20
    using size_type = size_t;
    using difference_type = ptrdiff_t;

    using propagate_on_container_move_assignment = true_type;
    using is_always_equal _CXX20_DEPRECATE_IS_ALWAYS_EQUAL = true_type;
#endif // _HAS_CXX20
};
#endif // _HAS_DEPRECATED_ALLOCATOR_VOID || _HAS_DEPRECATED_ALLOCATOR_MEMBERS

_EXPORT_STD template <class _Ty, class _Other>
_NODISCARD _CONSTEXPR20 bool operator==(const allocator<_Ty>&, const allocator<_Other>&) noexcept {
    return true;
}

#if !_HAS_CXX20
template <class _Ty, class _Other>
_NODISCARD bool operator!=(const allocator<_Ty>&, const allocator<_Other>&) noexcept {
    return false;
}
#endif // !_HAS_CXX20

#if _HAS_CXX17
// See N4950 [unord.map.overview]/4
template <class _Alloc>
using _Guide_size_type_t =
typename allocator_traits<conditional_t<_Is_allocator<_Alloc>::value, _Alloc, allocator<int>>>::size_type;
#endif // _HAS_CXX17

template <class _Alloc>
using _Alloc_ptr_t = typename allocator_traits<_Alloc>::pointer;

template <class _Alloc>
using _Alloc_size_t = typename allocator_traits<_Alloc>::size_type;

template <class _Alloc>
_CONSTEXPR20 void _Pocca(_Alloc& _Left, const _Alloc& _Right) noexcept {
    if constexpr (allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value) {
        _Left = _Right;
    }
}

template <class _Alloc>
_CONSTEXPR20 void _Pocma(_Alloc& _Left, _Alloc& _Right) noexcept { // (maybe) propagate on container move assignment
    if constexpr (allocator_traits<_Alloc>::propagate_on_container_move_assignment::value) {
        _Left = _STD move(_Right);
    }
}

template <class _Alloc>
_CONSTEXPR20 void _Pocs(_Alloc& _Left, _Alloc& _Right) noexcept {
    if constexpr (allocator_traits<_Alloc>::propagate_on_container_swap::value) {
        swap(_Left, _Right); // intentional ADL
    }
    else {
        _STL_ASSERT(_Left == _Right, "containers incompatible for swap");
    }
}

template <class _Alloc>
_CONSTEXPR20 void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {
    // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
    using _Ty = typename _Alloc::value_type;
    if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
        for (; _First != _Last; ++_First) {
            allocator_traits<_Alloc>::destroy(_Al, _STD _Unfancy(_First));
        }
    }
}

template <class _NoThrowFwdIt, class _NoThrowSentinel>
_CONSTEXPR20 void _Destroy_range(_NoThrowFwdIt _First, const _NoThrowSentinel _Last) noexcept {
    // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
    if constexpr (!is_trivially_destructible_v<_Iter_value_t<_NoThrowFwdIt>>) {
        for (; _First != _Last; ++_First) {
            _STD _Destroy_in_place(*_First);
        }
    }
}

template <class _Size_type, class _Unsigned_type>
_NODISCARD constexpr _Size_type _Convert_size(const _Unsigned_type _Len) noexcept(
    sizeof(_Unsigned_type) <= sizeof(_Size_type)) {
    // convert _Unsigned_type to _Size_type, avoiding truncation
    _STL_INTERNAL_STATIC_ASSERT(_Unsigned_type(-1) > 0);
    _STL_INTERNAL_STATIC_ASSERT(_Size_type(-1) > 0);

    if constexpr (sizeof(_Unsigned_type) > sizeof(_Size_type)) {
        if (_Len > (numeric_limits<_Size_type>::max)()) {
            _Xlength_error("size is too long for _Size_type");
        }
    }

    return static_cast<_Size_type>(_Len);
}

template <class _Alloc>
_CONSTEXPR20 void _Deallocate_plain(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {
    // deallocate a plain pointer using an allocator
    using _Alloc_traits = allocator_traits<_Alloc>;
    if constexpr (is_same_v<_Alloc_ptr_t<_Alloc>, typename _Alloc::value_type*>) {
        _Alloc_traits::deallocate(_Al, _Ptr, 1);
    }
    else {
        using _Ptr_traits = pointer_traits<_Alloc_ptr_t<_Alloc>>;
        _Alloc_traits::deallocate(_Al, _Ptr_traits::pointer_to(*_Ptr), 1);
    }
}

template <class _Alloc>
_CONSTEXPR20 void _Delete_plain_internal(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {
    // destroy *_Ptr in place, then deallocate _Ptr using _Al; used for internal container types the user didn't name
    using _Ty = typename _Alloc::value_type;
    _Ptr->~_Ty();
    _STD _Deallocate_plain(_Al, _Ptr);
}

template <class _Alloc>
struct _Alloc_construct_ptr { // pointer used to help construct 1 _Alloc::value_type without EH
    using pointer = _Alloc_ptr_t<_Alloc>;
    _Alloc& _Al;
    pointer _Ptr;

    _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

    _NODISCARD _CONSTEXPR20 pointer _Release() noexcept { // disengage *this and return contained pointer
        return _STD exchange(_Ptr, nullptr);
    }

    _CONSTEXPR20 void _Allocate() { // disengage *this, then allocate a new memory block
        _Ptr = nullptr; // if allocate throws, prevents double-free
        _Ptr = _Al.allocate(1);
    }

    _CONSTEXPR20 ~_Alloc_construct_ptr() { // if this instance is engaged, deallocate storage
        if (_Ptr) {
            _Al.deallocate(_Ptr, 1);
        }
    }

    _Alloc_construct_ptr(const _Alloc_construct_ptr&) = delete;
    _Alloc_construct_ptr& operator=(const _Alloc_construct_ptr&) = delete;
};

struct _Fake_allocator {};

struct _Container_base0 {
    _CONSTEXPR20 void _Orphan_all() noexcept {}
    _CONSTEXPR20 void _Swap_proxy_and_iterators(_Container_base0&) noexcept {}
    _CONSTEXPR20 void _Alloc_proxy(const _Fake_allocator&) noexcept {}
    _CONSTEXPR20 void _Reload_proxy(const _Fake_allocator&, const _Fake_allocator&) noexcept {}
};

struct _Iterator_base0 {
    _CONSTEXPR20 void _Adopt(const void*) noexcept {}
    _CONSTEXPR20 const _Container_base0* _Getcont() const noexcept {
        return nullptr;
    }

    static constexpr bool _Unwrap_when_unverified = true;
};

struct _Container_base12;
struct _Container_proxy { // store head of iterator chain and back pointer
    _CONSTEXPR20 _Container_proxy() noexcept = default;
    _CONSTEXPR20 _Container_proxy(_Container_base12* _Mycont_) noexcept : _Mycont(_Mycont_) {}

    const _Container_base12* _Mycont = nullptr;
    mutable _Iterator_base12* _Myfirstiter = nullptr;
};

struct _Container_base12 {
public:
    _CONSTEXPR20 _Container_base12() noexcept = default;

    _Container_base12(const _Container_base12&) = delete;
    _Container_base12& operator=(const _Container_base12&) = delete;

    _CONSTEXPR20 void _Orphan_all() noexcept;
    _CONSTEXPR20 void _Swap_proxy_and_iterators(_Container_base12&) noexcept;

    template <class _Alloc>
    _CONSTEXPR20 void _Alloc_proxy(_Alloc&& _Al) {
        _Container_proxy* const _New_proxy = _Unfancy(_Al.allocate(1));
        _Construct_in_place(*_New_proxy, this);
        _Myproxy = _New_proxy;
        _New_proxy->_Mycont = this;
    }

    template <class _Alloc>
    _CONSTEXPR20 void _Reload_proxy(_Alloc&& _Old_alloc, _Alloc&& _New_alloc) {
        // pre: no iterators refer to the existing proxy
        _Container_proxy* const _New_proxy = _Unfancy(_New_alloc.allocate(1));
        _Construct_in_place(*_New_proxy, this);
        _New_proxy->_Mycont = this;
        _Delete_plain_internal(_Old_alloc, _STD exchange(_Myproxy, _New_proxy));
    }

    _Container_proxy* _Myproxy = nullptr;

private:
    _CONSTEXPR20 void _Orphan_all_unlocked_v3() noexcept;
    _CONSTEXPR20 void _Swap_proxy_and_iterators_unlocked(_Container_base12&) noexcept;

    void _Orphan_all_locked_v3() noexcept {
        _Lockit _Lock(_LOCK_DEBUG);
        _Orphan_all_unlocked_v3();
    }

    void _Swap_proxy_and_iterators_locked(_Container_base12& _Right) noexcept {
        _Lockit _Lock(_LOCK_DEBUG);
        _Swap_proxy_and_iterators_unlocked(_Right);
    }
};

struct _Iterator_base12 { // store links to container proxy, next iterator
public:
    _CONSTEXPR20 _Iterator_base12() noexcept = default; // construct orphaned iterator

    _CONSTEXPR20 _Iterator_base12(const _Iterator_base12& _Right) noexcept {
        *this = _Right;
    }

    _CONSTEXPR20 _Iterator_base12& operator=(const _Iterator_base12& _Right) noexcept {
#if _ITERATOR_DEBUG_LEVEL == 2
#if _HAS_CXX20
        if (_STD is_constant_evaluated()) {
            _Assign_unlocked(_Right);
        }
        else
#endif // _HAS_CXX20
        {
            _Assign_locked(_Right);
        }
#else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 / _ITERATOR_DEBUG_LEVEL != 2 vvv
        _Myproxy = _Right._Myproxy;
#endif // ^^^ _ITERATOR_DEBUG_LEVEL != 2 ^^^
        return *this;
    }

#if _ITERATOR_DEBUG_LEVEL == 2
    _CONSTEXPR20 ~_Iterator_base12() noexcept {
#if _HAS_CXX20
        if (_STD is_constant_evaluated()) {
            _Orphan_me_unlocked_v3();
        }
        else
#endif // _HAS_CXX20
        {
            _Orphan_me_locked_v3();
        }
    }

    _CONSTEXPR20 void _Adopt(const _Container_base12* _Parent) noexcept {
#if _HAS_CXX20
        if (_STD is_constant_evaluated()) {
            _Adopt_unlocked(_Parent);
        }
        else
#endif // _HAS_CXX20
        {
            _Adopt_locked(_Parent);
        }
    }
#else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 / _ITERATOR_DEBUG_LEVEL != 2 vvv
    _CONSTEXPR20 void _Adopt(const _Container_base12* _Parent) noexcept {
        if (_Parent) { // have a parent, do adoption
            _Myproxy = _Parent->_Myproxy;
        }
        else { // no future parent, just disown current parent
            _Myproxy = nullptr;
        }
    }
#endif // ^^^ _ITERATOR_DEBUG_LEVEL != 2 ^^^

    _CONSTEXPR20 const _Container_base12* _Getcont() const noexcept {
        return _Myproxy ? _Myproxy->_Mycont : nullptr;
    }

    static constexpr bool _Unwrap_when_unverified = _ITERATOR_DEBUG_LEVEL == 0;

    mutable _Container_proxy* _Myproxy = nullptr;
    mutable _Iterator_base12* _Mynextiter = nullptr;

#if _ITERATOR_DEBUG_LEVEL == 2
private:
    _CONSTEXPR20 void _Assign_unlocked(const _Iterator_base12& _Right) noexcept {
        if (_Myproxy == _Right._Myproxy) {
            return;
        }

        if (_Right._Myproxy) {
            _Adopt_unlocked(_Right._Myproxy->_Mycont);
        }
        else { // becoming invalid, disown current parent
            _Orphan_me_unlocked_v3();
        }
    }

    void _Assign_locked(const _Iterator_base12& _Right) noexcept {
        _Lockit _Lock(_LOCK_DEBUG);
        _Assign_unlocked(_Right);
    }

    _CONSTEXPR20 void _Adopt_unlocked(const _Container_base12* _Parent) noexcept {
        if (!_Parent) {
            _Orphan_me_unlocked_v3();
            return;
        }

        _Container_proxy* _Parent_proxy = _Parent->_Myproxy;
        if (_Myproxy != _Parent_proxy) { // change parentage
            if (_Myproxy) { // adopted, remove self from list
                _Orphan_me_unlocked_v3();
            }
            _Mynextiter = _Parent_proxy->_Myfirstiter;
            _Parent_proxy->_Myfirstiter = this;
            _Myproxy = _Parent_proxy;
        }
    }

    void _Adopt_locked(const _Container_base12* _Parent) noexcept {
        _Lockit _Lock(_LOCK_DEBUG);
        _Adopt_unlocked(_Parent);
    }

    _CONSTEXPR20 void _Orphan_me_unlocked_v3() noexcept {
        if (!_Myproxy) { // already orphaned
            return;
        }

        // adopted, remove self from list
        _Iterator_base12** _Pnext = &_Myproxy->_Myfirstiter;
        while (*_Pnext && *_Pnext != this) {
            _Pnext = &(*_Pnext)->_Mynextiter;
        }

        _STL_VERIFY(*_Pnext, "ITERATOR LIST CORRUPTED!");
        *_Pnext = _Mynextiter;
        _Myproxy = nullptr;
    }

    void _Orphan_me_locked_v3() noexcept {
        _Lockit _Lock(_LOCK_DEBUG);
        _Orphan_me_unlocked_v3();
    }
#endif // _ITERATOR_DEBUG_LEVEL == 2
};

_CONSTEXPR20 void _Container_base12::_Orphan_all_unlocked_v3() noexcept {
    if (!_Myproxy) { // no proxy, already done
        return;
    }

    // proxy allocated, drain it
    for (auto _Pnext = _STD exchange(_Myproxy->_Myfirstiter, nullptr); _Pnext; _Pnext = _Pnext->_Mynextiter) {
        _Pnext->_Myproxy = nullptr;
    }
}

_CONSTEXPR20 void _Container_base12::_Orphan_all() noexcept {
#if _ITERATOR_DEBUG_LEVEL == 2
#if _HAS_CXX20
    if (_STD is_constant_evaluated()) {
        _Orphan_all_unlocked_v3();
    }
    else
#endif // _HAS_CXX20
    {
        _Orphan_all_locked_v3();
    }
#endif // _ITERATOR_DEBUG_LEVEL == 2
}

_CONSTEXPR20 void _Container_base12::_Swap_proxy_and_iterators_unlocked(_Container_base12& _Right) noexcept {
    _Container_proxy* _Temp = _Myproxy;
    _Myproxy = _Right._Myproxy;
    _Right._Myproxy = _Temp;

    if (_Myproxy) {
        _Myproxy->_Mycont = this;
    }

    if (_Right._Myproxy) {
        _Right._Myproxy->_Mycont = &_Right;
    }
}

_CONSTEXPR20 void _Container_base12::_Swap_proxy_and_iterators(_Container_base12& _Right) noexcept {
#if _ITERATOR_DEBUG_LEVEL == 2
#if _HAS_CXX20
    if (_STD is_constant_evaluated()) {
        _Swap_proxy_and_iterators_unlocked(_Right);
    }
    else
#endif // _HAS_CXX20
    {
        _Swap_proxy_and_iterators_locked(_Right);
    }
#else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 / _ITERATOR_DEBUG_LEVEL != 2 vvv
    _Swap_proxy_and_iterators_unlocked(_Right);
#endif // ^^^ _ITERATOR_DEBUG_LEVEL != 2 ^^^
}

#if _ITERATOR_DEBUG_LEVEL == 0
using _Container_base = _Container_base0;
using _Iterator_base = _Iterator_base0;
#else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 / _ITERATOR_DEBUG_LEVEL > 0 vvv
using _Container_base = _Container_base12;
using _Iterator_base = _Iterator_base12;
#endif // ^^^ _ITERATOR_DEBUG_LEVEL > 0 ^^^

struct _Leave_proxy_unbound {
    explicit _Leave_proxy_unbound() = default;
}; // tag to indicate that a proxy is being allocated before it is safe to bind to a _Container_base12

struct _Fake_proxy_ptr_impl { // fake replacement for a container proxy smart pointer when no container proxy is in use
    _Fake_proxy_ptr_impl(const _Fake_proxy_ptr_impl&) = delete;
    _Fake_proxy_ptr_impl& operator=(const _Fake_proxy_ptr_impl&) = delete;
    _CONSTEXPR20 _Fake_proxy_ptr_impl(const _Fake_allocator&, _Leave_proxy_unbound) noexcept {}
    _CONSTEXPR20 _Fake_proxy_ptr_impl(const _Fake_allocator&, const _Container_base0&) noexcept {}

    _CONSTEXPR20 void _Bind(const _Fake_allocator&, _Container_base0*) noexcept {}
    _CONSTEXPR20 void _Release() noexcept {}
};

struct _Basic_container_proxy_ptr12 {
    // smart pointer components for a _Container_proxy * that don't depend on the allocator
    _Container_proxy* _Ptr = nullptr;

    constexpr void _Release() noexcept { // disengage this _Basic_container_proxy_ptr12
        _Ptr = nullptr;
    }

protected:
    _CONSTEXPR20 _Basic_container_proxy_ptr12() = default;
    _Basic_container_proxy_ptr12(const _Basic_container_proxy_ptr12&) = delete;
    _Basic_container_proxy_ptr12(_Basic_container_proxy_ptr12&&) = delete;
};

template <class _Alloc>
struct _Container_proxy_ptr12 : _Basic_container_proxy_ptr12 {
    // smart pointer components for a _Container_proxy * for an allocator family
    _Alloc& _Al;

    _CONSTEXPR20 _Container_proxy_ptr12(_Alloc& _Al_, _Leave_proxy_unbound) : _Al(_Al_) {
        // create a new unbound _Container_proxy
        _Ptr = _Unfancy(_Al_.allocate(1));
        _Construct_in_place(*_Ptr);
    }

    _CONSTEXPR20 _Container_proxy_ptr12(_Alloc& _Al_, _Container_base12& _Mycont) : _Al(_Al_) {
        // create a new _Container_proxy pointing at _Mycont
        _Ptr = _Unfancy(_Al_.allocate(1));
        _Construct_in_place(*_Ptr, _STD addressof(_Mycont));
        _Mycont._Myproxy = _Ptr;
    }

    _CONSTEXPR20 void _Bind(_Alloc& _Old_alloc, _Container_base12* _Mycont) noexcept {
        // Attach the proxy stored in *this to _Mycont, and destroy _Mycont's existing proxy
        // with _Old_alloc. Requires that no iterators are alive referring to _Mycont.
        _Ptr->_Mycont = _Mycont;
        _Delete_plain_internal(_Old_alloc, _STD exchange(_Mycont->_Myproxy, _STD exchange(_Ptr, nullptr)));
    }

    _CONSTEXPR20 ~_Container_proxy_ptr12() {
        if (_Ptr) {
            _Delete_plain_internal(_Al, _Ptr);
        }
    }
};

#if _ITERATOR_DEBUG_LEVEL == 0
_INLINE_VAR constexpr _Fake_allocator _Fake_alloc{};
#define _GET_PROXY_ALLOCATOR(_Alty, _Al) _Fake_alloc // TRANSITION, VSO-1284799, should be _Fake_allocator{}
template <class _Alloc>
using _Container_proxy_ptr = _Fake_proxy_ptr_impl;
#else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 / _ITERATOR_DEBUG_LEVEL > 0 vvv
#define _GET_PROXY_ALLOCATOR(_Alty, _Al) static_cast<_Rebind_alloc_t<_Alty, _Container_proxy>>(_Al)
template <class _Alloc>
using _Container_proxy_ptr = _Container_proxy_ptr12<_Rebind_alloc_t<_Alloc, _Container_proxy>>;
#endif // ^^^ _ITERATOR_DEBUG_LEVEL > 0 ^^^

struct _Zero_then_variadic_args_t {
    explicit _Zero_then_variadic_args_t() = default;
}; // tag type for value-initializing first, constructing second from remaining args

struct _One_then_variadic_args_t {
    explicit _One_then_variadic_args_t() = default;
}; // tag type for constructing first from one arg, constructing second from remaining args

template <class _Ty1, class _Ty2, bool = is_empty_v<_Ty1> && !is_final_v<_Ty1>>
class _Compressed_pair final : private _Ty1 { // store a pair of values, deriving from empty first
public:
    _Ty2 _Myval2;

    using _Mybase = _Ty1; // for visualization

    template <class... _Other2>
    constexpr explicit _Compressed_pair(_Zero_then_variadic_args_t, _Other2&&... _Val2) noexcept(
        conjunction_v<is_nothrow_default_constructible<_Ty1>, is_nothrow_constructible<_Ty2, _Other2...>>)
        : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

    template <class _Other1, class... _Other2>
    constexpr _Compressed_pair(_One_then_variadic_args_t, _Other1&& _Val1, _Other2&&... _Val2) noexcept(
        conjunction_v<is_nothrow_constructible<_Ty1, _Other1>, is_nothrow_constructible<_Ty2, _Other2...>>)
        : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

    constexpr _Ty1& _Get_first() noexcept {
        return *this;
    }

    constexpr const _Ty1& _Get_first() const noexcept {
        return *this;
    }
};

template <class _Ty1, class _Ty2>
class _Compressed_pair<_Ty1, _Ty2, false> final { // store a pair of values, not deriving from first
public:
    _Ty1 _Myval1;
    _Ty2 _Myval2;

    template <class... _Other2>
    constexpr explicit _Compressed_pair(_Zero_then_variadic_args_t, _Other2&&... _Val2) noexcept(
        conjunction_v<is_nothrow_default_constructible<_Ty1>, is_nothrow_constructible<_Ty2, _Other2...>>)
        : _Myval1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

    template <class _Other1, class... _Other2>
    constexpr _Compressed_pair(_One_then_variadic_args_t, _Other1&& _Val1, _Other2&&... _Val2) noexcept(
        conjunction_v<is_nothrow_constructible<_Ty1, _Other1>, is_nothrow_constructible<_Ty2, _Other2...>>)
        : _Myval1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

    constexpr _Ty1& _Get_first() noexcept {
        return _Myval1;
    }

    constexpr const _Ty1& _Get_first() const noexcept {
        return _Myval1;
    }
};

struct _Move_allocator_tag {
    explicit _Move_allocator_tag() = default;
};

template <class _Ty>
pair<_Ty*, ptrdiff_t> _Get_temporary_buffer(ptrdiff_t _Count) noexcept {
    if (static_cast<size_t>(_Count) <= static_cast<size_t>(-1) / sizeof(_Ty)) {
        for (; 0 < _Count; _Count /= 2) {
            const auto _Size = static_cast<size_t>(_Count) * sizeof(_Ty);
            void* _Pbuf;
#ifdef __cpp_aligned_new
            if constexpr (alignof(_Ty) > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
                _Pbuf = ::operator new(_Size, align_val_t{ alignof(_Ty) }, nothrow);
            }
            else
#endif // defined(__cpp_aligned_new)
            {
                _Pbuf = ::operator new(_Size, nothrow);
            }

            if (_Pbuf) {
                return { static_cast<_Ty*>(_Pbuf), _Count };
            }
        }
    }

    return { nullptr, 0 };
}

template <class _Ty>
void _Return_temporary_buffer(_Ty* const _Pbuf) noexcept {
#ifdef __cpp_aligned_new
    if constexpr (alignof(_Ty) > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
        ::operator delete(_Pbuf, align_val_t{ alignof(_Ty) });
    }
    else
#endif // defined(__cpp_aligned_new)
    {
        ::operator delete(_Pbuf);
    }
}

template <class _NoThrowFwdIt>
struct _NODISCARD _Uninitialized_backout {
    // struct to undo partially constructed ranges in _Uninitialized_xxx algorithms
    _NoThrowFwdIt _First;
    _NoThrowFwdIt _Last;

    constexpr explicit _Uninitialized_backout(_NoThrowFwdIt _Dest) : _First(_Dest), _Last(_Dest) {}

    constexpr _Uninitialized_backout(_NoThrowFwdIt _First_, _NoThrowFwdIt _Last_) : _First(_First_), _Last(_Last_) {}

    _Uninitialized_backout(const _Uninitialized_backout&) = delete;
    _Uninitialized_backout& operator=(const _Uninitialized_backout&) = delete;

    _CONSTEXPR20 ~_Uninitialized_backout() {
        _STD _Destroy_range(_First, _Last);
    }

    template <class... _Types>
    _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) {
        // construct a new element at *_Last and increment
        _STD _Construct_in_place(*_Last, _STD forward<_Types>(_Vals)...);
        ++_Last;
    }

    constexpr _NoThrowFwdIt _Release() { // suppress any exception handling backout and return _Last
        _First = _Last;
        return _Last;
    }
};

template <class _InIt, class _NoThrowFwdIt>
_CONSTEXPR20 _NoThrowFwdIt _Uninitialized_move_unchecked(_InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest) {
    // move [_First, _Last) to raw [_Dest, ...)
    if constexpr (_Iter_move_cat<_InIt, _NoThrowFwdIt>::_Bitcopy_constructible) {
#if _HAS_CXX20
        if (!_STD is_constant_evaluated())
#endif // _HAS_CXX20
        {
            return _STD _Copy_memmove(_First, _Last, _Dest);
        }
    }
    _Uninitialized_backout<_NoThrowFwdIt> _Backout{ _Dest };
    for (; _First != _Last; ++_First) {
        _Backout._Emplace_back(_STD move(*_First));
    }

    return _Backout._Release();
}

#if _HAS_CXX20
namespace ranges {
    template <class _It>
    concept _No_throw_input_iterator =
        input_iterator<_It> && is_lvalue_reference_v<iter_reference_t<_It>>
        && same_as<remove_cvref_t<iter_reference_t<_It>>, remove_reference_t<iter_reference_t<_It>>> // per LWG-3888
        && same_as<remove_cvref_t<iter_reference_t<_It>>, iter_value_t<_It>>;

    template <class _Se, class _It>
    concept _No_throw_sentinel_for = sentinel_for<_Se, _It>;

    template <class _It>
    concept _No_throw_forward_iterator =
        _No_throw_input_iterator<_It> && forward_iterator<_It> && _No_throw_sentinel_for<_It, _It>;

    template <class _Rng>
    concept _No_throw_input_range = range<_Rng> && _No_throw_input_iterator<iterator_t<_Rng>>
        && _No_throw_sentinel_for<sentinel_t<_Rng>, iterator_t<_Rng>>;

    template <class _Rng>
    concept _No_throw_forward_range = _No_throw_input_range<_Rng> && _No_throw_forward_iterator<iterator_t<_Rng>>;

    template <class _InIt, class _OutIt>
    in_out_result<_InIt, _OutIt> _Copy_memcpy_count(_InIt _IFirst, _OutIt _OFirst, const size_t _Count) noexcept {
        const auto _IFirstPtr = _STD _To_address(_IFirst);
        const auto _OFirstPtr = _STD _To_address(_OFirst);
        const auto _IFirst_ch = const_cast<char*>(reinterpret_cast<const volatile char*>(_IFirstPtr));
        const auto _OFirst_ch = const_cast<char*>(reinterpret_cast<const volatile char*>(_OFirstPtr));
        const size_t _Count_bytes = _Count * sizeof(iter_value_t<_InIt>);
        _CSTD memcpy(_OFirst_ch, _IFirst_ch, _Count_bytes);
        if constexpr (is_pointer_v<_InIt>) {
            _IFirst = reinterpret_cast<_InIt>(_IFirst_ch + _Count_bytes);
        }
        else {
            _IFirst += static_cast<iter_difference_t<_InIt>>(_Count);
        }

        if constexpr (is_pointer_v<_OutIt>) {
            _OFirst = reinterpret_cast<_OutIt>(_OFirst_ch + _Count_bytes);
        }
        else {
            _OFirst += static_cast<iter_difference_t<_OutIt>>(_Count);
        }
        return { _STD move(_IFirst), _STD move(_OFirst) };
    }

    template <class _InIt, class _OutIt, class _DistIt>
    in_out_result<_InIt, _OutIt> _Copy_memcpy_distance(
        _InIt _IFirst, _OutIt _OFirst, const _DistIt _DFirst, const _DistIt _DLast) noexcept {
        // equivalent to _Copy_memcpy_count(_IFirst, _OFirst, _DLast - _DFirst) but computes distance more efficiently
        const auto _IFirstPtr = _STD _To_address(_IFirst);
        const auto _OFirstPtr = _STD _To_address(_OFirst);
        const auto _DFirstPtr = _STD _To_address(_DFirst);
        const auto _DLastPtr = _STD _To_address(_DLast);
        const auto _IFirst_ch = const_cast<char*>(reinterpret_cast<const volatile char*>(_IFirstPtr));
        const auto _OFirst_ch = const_cast<char*>(reinterpret_cast<const volatile char*>(_OFirstPtr));
        const auto _DFirst_ch = const_cast<char*>(reinterpret_cast<const volatile char*>(_DFirstPtr));
        const auto _DLast_ch = const_cast<char*>(reinterpret_cast<const volatile char*>(_DLastPtr));
        const auto _Count_bytes = static_cast<size_t>(_DLast_ch - _DFirst_ch);
        _CSTD memcpy(_OFirst_ch, _IFirst_ch, _Count_bytes);
        if constexpr (is_pointer_v<_InIt>) {
            _IFirst = reinterpret_cast<_InIt>(_IFirst_ch + _Count_bytes);
        }
        else {
            _IFirst += _Count_bytes / sizeof(iter_value_t<_InIt>);
        }

        if constexpr (is_pointer_v<_OutIt>) {
            _OFirst = reinterpret_cast<_OutIt>(_OFirst_ch + _Count_bytes);
        }
        else {
            _OFirst += _Count_bytes / sizeof(iter_value_t<_OutIt>);
        }
        return { _STD move(_IFirst), _STD move(_OFirst) };
    }

    template <class _InIt, class _OutIt>
    in_out_result<_InIt, _OutIt> _Copy_memcpy_common(
        _InIt _IFirst, _InIt _ILast, _OutIt _OFirst, _OutIt _OLast) noexcept {
        const auto _IFirstPtr = _STD _To_address(_IFirst);
        const auto _ILastPtr = _STD _To_address(_ILast);
        const auto _OFirstPtr = _STD _To_address(_OFirst);
        const auto _OLastPtr = _STD _To_address(_OLast);
        const auto _IFirst_ch = const_cast<char*>(reinterpret_cast<const volatile char*>(_IFirstPtr));
        const auto _ILast_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_ILastPtr));
        const auto _OFirst_ch = const_cast<char*>(reinterpret_cast<const volatile char*>(_OFirstPtr));
        const auto _OLast_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_OLastPtr));
        const auto _Count_bytes = static_cast<size_t>((_STD min)(_ILast_ch - _IFirst_ch, _OLast_ch - _OFirst_ch));
        _CSTD memcpy(_OFirst_ch, _IFirst_ch, _Count_bytes);
        if constexpr (is_pointer_v<_InIt>) {
            _IFirst = reinterpret_cast<_InIt>(_IFirst_ch + _Count_bytes);
        }
        else {
            _IFirst += static_cast<iter_difference_t<_InIt>>(_Count_bytes / sizeof(iter_value_t<_InIt>));
        }

        if constexpr (is_pointer_v<_OutIt>) {
            _OFirst = reinterpret_cast<_OutIt>(_OFirst_ch + _Count_bytes);
        }
        else {
            _OFirst += static_cast<iter_difference_t<_OutIt>>(_Count_bytes / sizeof(iter_value_t<_OutIt>));
        }
        return { _STD move(_IFirst), _STD move(_OFirst) };
    }

    _EXPORT_STD template <class _In, class _Out>
        using uninitialized_move_result = in_out_result<_In, _Out>;

    template <input_iterator _It, sentinel_for<_It> _Se, _No_throw_forward_iterator _Out,
        _No_throw_sentinel_for<_Out> _OSe>
        requires (constructible_from<iter_value_t<_Out>, iter_rvalue_reference_t<_It>>)
    uninitialized_move_result<_It, _Out> _Uninitialized_move_unchecked(
        _It _IFirst, _Se _ILast, _Out _OFirst, _OSe _OLast) {
        constexpr bool _Is_sized1 = sized_sentinel_for<_Se, _It>;
        constexpr bool _Is_sized2 = sized_sentinel_for<_OSe, _Out>;
        if constexpr (_Iter_move_cat<_It, _Out>::_Bitcopy_constructible && _Sized_or_unreachable_sentinel_for<_Se, _It>
            && _Sized_or_unreachable_sentinel_for<_OSe, _Out>) {
            if constexpr (_Is_sized1 && _Is_sized2) {
                return _RANGES _Copy_memcpy_common(_IFirst, _RANGES next(_IFirst, _STD move(_ILast)), _OFirst,
                    _RANGES next(_OFirst, _STD move(_OLast)));
            }
            else if constexpr (_Is_sized1) {
                return _RANGES _Copy_memcpy_distance(
                    _IFirst, _OFirst, _IFirst, _RANGES next(_IFirst, _STD move(_ILast)));
            }
            else if constexpr (_Is_sized2) {
                return _RANGES _Copy_memcpy_distance(
                    _IFirst, _OFirst, _OFirst, _RANGES next(_OFirst, _STD move(_OLast)));
            }
            else {
                _STL_ASSERT(false, "Tried to uninitialized_move two ranges with unreachable sentinels");
            }
        }
        else {
            _Uninitialized_backout _Backout{ _STD move(_OFirst) };

            for (; _IFirst != _ILast && _Backout._Last != _OLast; ++_IFirst) {
                _Backout._Emplace_back(_RANGES iter_move(_IFirst));
            }

            return { _STD move(_IFirst), _Backout._Release() };
        }
    }
} // namespace ranges
#endif // _HAS_CXX20

template <class _Alloc>
class _NODISCARD _Uninitialized_backout_al {
    // struct to undo partially constructed ranges in _Uninitialized_xxx_al algorithms
private:
    using pointer = _Alloc_ptr_t<_Alloc>;

public:
    _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

    _Uninitialized_backout_al(const _Uninitialized_backout_al&) = delete;
    _Uninitialized_backout_al& operator=(const _Uninitialized_backout_al&) = delete;

    _CONSTEXPR20 ~_Uninitialized_backout_al() {
        _STD _Destroy_range(_First, _Last, _Al);
    }

    template <class... _Types>
    _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment
        allocator_traits<_Alloc>::construct(_Al, _STD _Unfancy(_Last), _STD forward<_Types>(_Vals)...);
        ++_Last;
    }

    constexpr pointer _Release() { // suppress any exception handling backout and return _Last
        _First = _Last;
        return _Last;
    }

private:
    pointer _First;
    pointer _Last;
    _Alloc& _Al;
};

template <class _InIt, class _Se, class _Alloc>
_CONSTEXPR20 _Alloc_ptr_t<_Alloc> _Uninitialized_copy(
    _InIt _First, _Se _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {
    // copy [_First, _Last) to raw _Dest, using _Al
    // note: only called internally from elsewhere in the STL
    using _Ptrval = typename _Alloc::value_type*;

#if _HAS_CXX20
    auto _UFirst = _RANGES _Unwrap_iter<_Se>(_STD move(_First));
    auto _ULast = _RANGES _Unwrap_sent<_InIt>(_STD move(_Last));
#else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
    // In pre-concepts world, _Uninitialized_copy should only ever be called with an iterator
    // and sentinel of the same type, so `_Get_unwrapped` is fine to call.
    auto _UFirst = _STD _Get_unwrapped(_STD move(_First));
    auto _ULast = _STD _Get_unwrapped(_STD move(_Last));
#endif // ^^^ !_HAS_CXX20 ^^^

    constexpr bool _Can_memmove = _Sent_copy_cat<decltype(_UFirst), decltype(_ULast), _Ptrval>::_Bitcopy_constructible
        && _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>::value;

    if constexpr (_Can_memmove) {
#if _HAS_CXX20
        if (!_STD is_constant_evaluated())
#endif // _HAS_CXX20
        {
            if constexpr (is_same_v<decltype(_UFirst), decltype(_ULast)>) {
                _STD _Copy_memmove(_STD _To_address(_UFirst), _STD _To_address(_ULast), _STD _Unfancy(_Dest));
                _Dest += _ULast - _UFirst;
            }
            else {
                const auto _Count = static_cast<size_t>(_ULast - _UFirst);
                _STD _Copy_memmove_n(_STD _To_address(_UFirst), _Count, _STD _Unfancy(_Dest));
                _Dest += _Count;
            }
            return _Dest;
        }
    }

    _Uninitialized_backout_al<_Alloc> _Backout{ _Dest, _Al };
    for (; _UFirst != _ULast; ++_UFirst) {
        _Backout._Emplace_back(*_UFirst);
    }

    return _Backout._Release();
}

template <class _InIt, class _Alloc>
_CONSTEXPR20 _Alloc_ptr_t<_Alloc> _Uninitialized_copy_n(
    _InIt _First, size_t _Count, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {
    // copy _First + [0, _Count) to raw _Dest, using _Al
    // note: only called internally from elsewhere in the STL
    using _Ptrval = typename _Alloc::value_type*;

    auto _UFirst = _STD _Get_unwrapped(_STD move(_First));

    constexpr bool _Can_memmove =
        conjunction_v<bool_constant<_Iter_copy_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
        _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>;

    if constexpr (_Can_memmove) {
#if _HAS_CXX20
        if (!_STD is_constant_evaluated())
#endif // _HAS_CXX20
        {
            _STD _Copy_memmove_n(_UFirst, _Count, _STD _Unfancy(_Dest));
            _Dest += _Count;
            return _Dest;
        }
    }

    _Uninitialized_backout_al<_Alloc> _Backout{ _Dest, _Al };
    for (; _Count != 0; ++_UFirst, (void) --_Count) {
        _Backout._Emplace_back(*_UFirst);
    }

    return _Backout._Release();
}

template <class _InIt, class _NoThrowFwdIt>
_CONSTEXPR20 _NoThrowFwdIt _Uninitialized_copy_unchecked(_InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest) {
    // copy [_First, _Last) to raw [_Dest, ...)
    if constexpr (_Iter_copy_cat<_InIt, _NoThrowFwdIt>::_Bitcopy_constructible) {
#if _HAS_CXX20
        if (!_STD is_constant_evaluated())
#endif // _HAS_CXX20
        {
            return _STD _Copy_memmove(_First, _Last, _Dest);
        }
    }

    _Uninitialized_backout<_NoThrowFwdIt> _Backout{ _Dest };
    for (; _First != _Last; ++_First) {
        _Backout._Emplace_back(*_First);
    }

    return _Backout._Release();
}

_EXPORT_STD template <class _InIt, class _NoThrowFwdIt>
_NoThrowFwdIt uninitialized_copy(const _InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest) {
    // copy [_First, _Last) to raw [_Dest, ...)
    _STD _Adl_verify_range(_First, _Last);
    auto _UFirst = _STD _Get_unwrapped(_First);
    const auto _ULast = _STD _Get_unwrapped(_Last);
    auto _UDest = _STD _Get_unwrapped_n(_Dest, _STD _Idl_distance<_InIt>(_UFirst, _ULast));
    _STD _Seek_wrapped(_Dest, _STD _Uninitialized_copy_unchecked(_UFirst, _ULast, _UDest));
    return _Dest;
}

template <class _InIt, class _Alloc>
_CONSTEXPR20 _Alloc_ptr_t<_Alloc> _Uninitialized_move(
    const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {
    // move [_First, _Last) to raw _Dest, using _Al
    // note: only called internally from elsewhere in the STL
    using _Ptrval = typename _Alloc::value_type*;
    auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
        _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
#if _HAS_CXX20
        if (!_STD is_constant_evaluated())
#endif // _HAS_CXX20
        {
            _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
            return _Dest + (_ULast - _UFirst);
        }
    }

    _Uninitialized_backout_al<_Alloc> _Backout{ _Dest, _Al };
    for (; _UFirst != _ULast; ++_UFirst) {
        _Backout._Emplace_back(_STD move(*_UFirst));
    }

    return _Backout._Release();
}

template <class _Alloc>
_CONSTEXPR20 _Alloc_ptr_t<_Alloc> _Uninitialized_fill_n(
    _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, const typename _Alloc::value_type& _Val, _Alloc& _Al) {
    // copy _Count copies of _Val to raw _First, using _Al
    using _Ty = typename _Alloc::value_type;
    if constexpr (_Fill_memset_is_safe<_Ty*, _Ty> && _Uses_default_construct<_Alloc, _Ty*, _Ty>::value) {
#if _HAS_CXX20
        if (!_STD is_constant_evaluated())
#endif // _HAS_CXX20
        {
            _Fill_memset(_Unfancy(_First), _Val, static_cast<size_t>(_Count));
            return _First + _Count;
        }
    }
    else if constexpr (_Fill_zero_memset_is_safe<_Ty*, _Ty> && _Uses_default_construct<_Alloc, _Ty*, _Ty>::value) {
#if _HAS_CXX20
        if (!_STD is_constant_evaluated())
#endif // _HAS_CXX20
        {
            if (_Is_all_bits_zero(_Val)) {
                _Fill_zero_memset(_Unfancy(_First), static_cast<size_t>(_Count));
                return _First + _Count;
            }
        }
    }

    _Uninitialized_backout_al<_Alloc> _Backout{ _First, _Al };
    for (; 0 < _Count; --_Count) {
        _Backout._Emplace_back(_Val);
    }

    return _Backout._Release();
}

_EXPORT_STD template <class _NoThrowFwdIt, class _Tval>
void uninitialized_fill(const _NoThrowFwdIt _First, const _NoThrowFwdIt _Last, const _Tval& _Val) {
    // copy _Val throughout raw [_First, _Last)
    _STD _Adl_verify_range(_First, _Last);
    auto _UFirst = _STD _Get_unwrapped(_First);
    const auto _ULast = _STD _Get_unwrapped(_Last);
    if constexpr (_Fill_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
        _STD _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
    }
    else {
        if constexpr (_Fill_zero_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
            if (_STD _Is_all_bits_zero(_Val)) {
                _STD _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
                return;
            }
        }

        _Uninitialized_backout<_Unwrapped_t<const _NoThrowFwdIt&>> _Backout{ _UFirst };
        while (_Backout._Last != _ULast) {
            _Backout._Emplace_back(_Val);
        }

        _Backout._Release();
    }
}

template <class _NoThrowFwdIt>
_INLINE_VAR constexpr bool _Use_memset_value_construct_v =
conjunction_v<bool_constant<_Iterator_is_contiguous<_NoThrowFwdIt>>, is_scalar<_Iter_value_t<_NoThrowFwdIt>>,
    negation<is_volatile<remove_reference_t<_Iter_ref_t<_NoThrowFwdIt>>>>,
    negation<is_member_pointer<_Iter_value_t<_NoThrowFwdIt>>>>;

template <class _Ptr>
_Ptr _Zero_range(const _Ptr _First, const _Ptr _Last) { // fill [_First, _Last) with zeroes
    char* const _First_ch = reinterpret_cast<char*>(_STD _To_address(_First));
    char* const _Last_ch = reinterpret_cast<char*>(_STD _To_address(_Last));
    _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));
    return _Last;
}

template <class _Alloc>
_CONSTEXPR20 _Alloc_ptr_t<_Alloc> _Uninitialized_value_construct_n(
    _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {
    // value-initialize _Count objects to raw _First, using _Al
    using _Ptrty = typename _Alloc::value_type*;
    if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
#if _HAS_CXX20
        if (!_STD is_constant_evaluated())
#endif // _HAS_CXX20
        {
            auto _PFirst = _Unfancy(_First);
            _Zero_range(_PFirst, _PFirst + _Count);
            return _First + _Count;
        }
    }

    _Uninitialized_backout_al<_Alloc> _Backout{ _First, _Al };
    for (; 0 < _Count; --_Count) {
        _Backout._Emplace_back();
    }

    return _Backout._Release();
}

template <class _NoThrowFwdIt, class _Diff>
_NoThrowFwdIt _Uninitialized_value_construct_n_unchecked1(_NoThrowFwdIt _UFirst, _Diff _Count) {
    // value-initialize all elements in [_UFirst, _UFirst + _Count)
    _STL_INTERNAL_CHECK(_Count >= 0);
    if constexpr (_Use_memset_value_construct_v<_NoThrowFwdIt>) {
        return _STD _Zero_range(_UFirst, _UFirst + _Count);
    }
    else {
        _Uninitialized_backout<_NoThrowFwdIt> _Backout{ _UFirst };
        for (; 0 < _Count; --_Count) {
            _Backout._Emplace_back();
        }

        return _Backout._Release();
    }
}

#if _HAS_DEPRECATED_TEMPORARY_BUFFER
_EXPORT_STD template <class _Ty>
_CXX17_DEPRECATE_TEMPORARY_BUFFER _NODISCARD pair<_Ty*, ptrdiff_t> get_temporary_buffer(ptrdiff_t _Count) noexcept {
    return _Get_temporary_buffer<_Ty>(_Count);
}

_EXPORT_STD template <class _Ty>
_CXX17_DEPRECATE_TEMPORARY_BUFFER void return_temporary_buffer(_Ty* _Pbuf) {
    _Return_temporary_buffer(_Pbuf);
}
#endif // _HAS_DEPRECATED_TEMPORARY_BUFFER

// assumes _Args have already been _Remove_cvref_t'd
template <class _Key, class... _Args>
struct _In_place_key_extract_set {
    // by default we can't extract the key in the emplace family and must construct a node we might not use
    static constexpr bool _Extractable = false;
};

template <class _Key>
struct _In_place_key_extract_set<_Key, _Key> {
    // we can extract the key in emplace if the emplaced type is identical to the key type
    static constexpr bool _Extractable = true;
    static const _Key& _Extract(const _Key& _Val) noexcept {
        return _Val;
    }
};

// assumes _Args have already been _Remove_cvref_t'd
template <class _Key, class... _Args>
struct _In_place_key_extract_map {
    // by default we can't extract the key in the emplace family and must construct a node we might not use
    static constexpr bool _Extractable = false;
};

template <class _Key, class _Second>
struct _In_place_key_extract_map<_Key, _Key, _Second> {
    // if we would call the pair(key, value) constructor family, we can use the first parameter as the key
    static constexpr bool _Extractable = true;
    static const _Key& _Extract(const _Key& _Val, const _Second&) noexcept {
        return _Val;
    }
};

template <class _Key, class _First, class _Second>
struct _In_place_key_extract_map<_Key, pair<_First, _Second>> {
    // if we would call the pair(pair<other, other>) constructor family, we can use the pair.first member as the key
    static constexpr bool _Extractable = is_same_v<_Key, _Remove_cvref_t<_First>>;
    static const _Key& _Extract(const pair<_First, _Second>& _Val) {
        return _Val.first;
    }
};

#pragma warning(push)
#pragma warning(disable : 4624) // '%s': destructor was implicitly defined as deleted
template <class _Ty>
struct _Wrap {
    _Ty _Value; // workaround for VSO-586813 "T^ is not allowed in a union"
};
#pragma warning(pop)

template <class _Alloc>
struct _Alloc_temporary2 {
    using value_type = typename _Alloc::value_type;
    using _Traits = allocator_traits<_Alloc>;

    _Alloc& _Al;

#ifdef __cplusplus_winrt
    union {
        _Wrap<value_type> _Storage;
    };

    _NODISCARD _CONSTEXPR20 value_type& _Get_value() noexcept {
        return _Storage._Value;
    }

    _NODISCARD _CONSTEXPR20 const value_type& _Get_value() const noexcept {
        return _Storage._Value;
    }
#else // ^^^ workaround for VSO-586813 "T^ is not allowed in a union" / no workaround vvv
    union {
        value_type _Value;
    };

    _NODISCARD _CONSTEXPR20 value_type& _Get_value() noexcept {
        return _Value;
    }

    _NODISCARD _CONSTEXPR20 const value_type& _Get_value() const noexcept {
        return _Value;
    }
#endif // ^^^ no workaround ^^^

    template <class... _Args>
    _CONSTEXPR20 explicit _Alloc_temporary2(_Alloc& _Al_, _Args&&... _Vals) noexcept(
        noexcept(_Traits::construct(_Al_, _STD addressof(_Get_value()), _STD forward<_Args>(_Vals)...)))
        : _Al(_Al_) {
        _Traits::construct(_Al, _STD addressof(_Get_value()), _STD forward<_Args>(_Vals)...);
    }

    _Alloc_temporary2(const _Alloc_temporary2&) = delete;
    _Alloc_temporary2& operator=(const _Alloc_temporary2&) = delete;

    _CONSTEXPR20 ~_Alloc_temporary2() {
        _Traits::destroy(_Al, _STD addressof(_Get_value()));
    }
};

template <class _Alloc>
_NODISCARD constexpr bool _Allocators_equal(const _Alloc& _Lhs, const _Alloc& _Rhs) noexcept {
    if constexpr (allocator_traits<_Alloc>::is_always_equal::value) {
        return true;
    }
    else {
        return _Lhs == _Rhs;
    }
}

#if _HAS_CXX23
template <class _Ty, class = void>
inline constexpr bool _Has_member_from_primary = false;
template <class _Ty>
inline constexpr bool _Has_member_from_primary<_Ty, void_t<typename _Ty::_From_primary>> = true;

// Avoid using allocate_at_least when the allocator publicly derives from std::allocator:
// "old" allocators might hide allocate and deallocate but fail to hide allocate_at_least.
// Also avoid using allocate_at_least from std::allocator itself because it currently doesn't do anything useful.
template <class _Alloc>
inline constexpr bool _Should_allocate_at_least =
!_Has_member_from_primary<_Alloc>
&& _Has_member_allocate_at_least<_Alloc, typename allocator_traits<_Alloc>::size_type>;
#endif // _HAS_CXX23

template <class _Alloc>
_NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 typename allocator_traits<_Alloc>::pointer _Allocate_at_least_helper(
    _Alloc& _Al, _CRT_GUARDOVERFLOW typename allocator_traits<_Alloc>::size_type& _Count) {
#if _HAS_CXX23
    if constexpr (_Should_allocate_at_least<_Alloc>) {
        auto [_Ptr, _Allocated] = _Al.allocate_at_least(_Count);
        _Count = _Allocated;
        return _Ptr;
    }
    else
#endif // _HAS_CXX23
    {
        return _Al.allocate(_Count);
    }
}

_EXPORT_STD template <class _FwdIt, class _Ty>
_NODISCARD_REMOVE_ALG _CONSTEXPR20 _FwdIt remove(_FwdIt _First, const _FwdIt _Last, const _Ty& _Val) {
    // remove each matching _Val
    _STD _Adl_verify_range(_First, _Last);
    auto _UFirst = _STD _Get_unwrapped(_First);
    const auto _ULast = _STD _Get_unwrapped(_Last);
    _UFirst = _STD _Find_unchecked(_UFirst, _ULast, _Val);
    auto _UNext = _UFirst;
    if (_UFirst != _ULast) {
        while (++_UFirst != _ULast) {
            if (!(*_UFirst == _Val)) {
                *_UNext = _STD move(*_UFirst);
                ++_UNext;
            }
        }
    }

    _STD _Seek_wrapped(_First, _UNext);
    return _First;
}

_EXPORT_STD template <class _FwdIt, class _Pr>
_NODISCARD_REMOVE_ALG _CONSTEXPR20 _FwdIt remove_if(_FwdIt _First, const _FwdIt _Last, _Pr _Pred) {
    // remove each satisfying _Pred
    _STD _Adl_verify_range(_First, _Last);
    auto _UFirst = _STD _Get_unwrapped(_First);
    const auto _ULast = _STD _Get_unwrapped(_Last);
    _UFirst = _STD find_if(_UFirst, _ULast, _STD _Pass_fn(_Pred));
    auto _UNext = _UFirst;
    if (_UFirst != _ULast) {
        while (++_UFirst != _ULast) {
            if (!_Pred(*_UFirst)) {
                *_UNext = _STD move(*_UFirst);
                ++_UNext;
            }
        }
    }

    _STD _Seek_wrapped(_First, _UNext);
    return _First;
}

template <class _Container, class _Uty>
_CONSTEXPR20 typename _Container::size_type _Erase_remove(_Container& _Cont, const _Uty& _Val) {
    // erase each element matching _Val
    auto _First = _Cont.begin();
    const auto _Last = _Cont.end();
    const auto _Old_size = _Cont.size();
    _STD _Seek_wrapped(_First, _STD remove(_STD _Get_unwrapped(_First), _STD _Get_unwrapped(_Last), _Val));
    _Cont.erase(_First, _Last);
    return _Old_size - _Cont.size();
}

template <class _Container, class _Pr>
_CONSTEXPR20 typename _Container::size_type _Erase_remove_if(_Container& _Cont, _Pr _Pred) {
    // erase each element satisfying _Pred
    auto _First = _Cont.begin();
    const auto _Last = _Cont.end();
    const auto _Old_size = _Cont.size();
    _STD _Seek_wrapped(_First, _STD remove_if(_STD _Get_unwrapped(_First), _STD _Get_unwrapped(_Last), _Pred));
    _Cont.erase(_First, _Last);
    return _Old_size - _Cont.size();
}

template <class _Container, class _Pr>
typename _Container::size_type _Erase_nodes_if(_Container& _Cont, _Pr _Pred) {
    // erase each element satisfying _Pred
    auto _First = _Cont.begin();
    const auto _Last = _Cont.end();
    const auto _Old_size = _Cont.size();
    while (_First != _Last) {
        if (_Pred(*_First)) {
            _First = _Cont.erase(_First);
        }
        else {
            ++_First;
        }
    }
    return _Old_size - _Cont.size();
}

template <class _Ty1, class _Ty2>
void _Deduce_as_pair(const pair<_Ty1, _Ty2>&); // not defined

template <class _Ty, class = void>
_INLINE_VAR constexpr bool _Is_deducible_as_pair = false;

template <class _Ty>
_INLINE_VAR constexpr bool _Is_deducible_as_pair<_Ty, decltype(_STD _Deduce_as_pair(_STD declval<_Ty>()))> = true;

template <class _Ty>
_INLINE_VAR constexpr bool _Is_cv_pair = _Is_specialization_v<remove_cv_t<_Ty>, pair>;

template <class _Ty>
const _Ty& _Normally_bind(_Identity_t<const _Ty&>); // not defined

template <class _Ty>
_Ty&& _Normally_bind(_Identity_t<_Ty&&>); // not defined

template <class _Ty, class _Uty>
using _Normally_bound_ref = decltype(_STD _Normally_bind<_Ty>(_STD declval<_Uty>()));

template <class _Ty, class _Uty, class = void>
_INLINE_VAR constexpr bool _Is_normally_bindable = false;

template <class _Ty, class _Uty>
_INLINE_VAR constexpr bool _Is_normally_bindable<_Ty, _Uty, void_t<_Normally_bound_ref<_Ty, _Uty>>> = true;

#if _HAS_CXX20
_EXPORT_STD template <class _Ty, class _Alloc, class... _Types, enable_if_t<!_Is_cv_pair<_Ty>, int> = 0>
_NODISCARD constexpr auto uses_allocator_construction_args(const _Alloc& _Al, _Types&&... _Args) noexcept {
    if constexpr (!uses_allocator_v<remove_cv_t<_Ty>, _Alloc>) {
        static_assert(is_constructible_v<_Ty, _Types...>,
            "If uses_allocator_v<remove_cv_t<T>, Alloc> does not hold, T must be constructible from Types...");
        (void)_Al;
        return _STD forward_as_tuple(_STD forward<_Types>(_Args)...);
    }
    else if constexpr (is_constructible_v<_Ty, allocator_arg_t, const _Alloc&, _Types...>) {
        using _ReturnType = tuple<allocator_arg_t, const _Alloc&, _Types&&...>;
        return _ReturnType{ allocator_arg, _Al, _STD forward<_Types>(_Args)... };
    }
    else if constexpr (is_constructible_v<_Ty, _Types..., const _Alloc&>) {
        return _STD forward_as_tuple(_STD forward<_Types>(_Args)..., _Al);
    }
    else {
        static_assert(_Always_false<_Ty>,
            "T must be constructible from either (allocator_arg_t, const Alloc&, Types...) "
            "or (Types..., const Alloc&) if uses_allocator_v<remove_cv_t<T>, Alloc> is true");
    }
}

_EXPORT_STD template <class _Ty, class _Alloc, enable_if_t<_Is_cv_pair<_Ty>, int> = 0>
_NODISCARD constexpr auto uses_allocator_construction_args(const _Alloc& _Al) noexcept;

_EXPORT_STD template <class _Ty, class _Alloc, class _Uty1, class _Uty2, enable_if_t<_Is_cv_pair<_Ty>, int> = 0>
_NODISCARD constexpr auto uses_allocator_construction_args(const _Alloc& _Al, _Uty1&& _Val1, _Uty2&& _Val2) noexcept;

#if _HAS_CXX23
_EXPORT_STD template <class _Ty, class _Alloc, class _Uty1, class _Uty2, enable_if_t<_Is_cv_pair<_Ty>, int> = 0>
_NODISCARD constexpr auto uses_allocator_construction_args(const _Alloc& _Al, pair<_Uty1, _Uty2>& _Pair) noexcept;
#endif // _HAS_CXX23

_EXPORT_STD template <class _Ty, class _Alloc, class _Uty1, class _Uty2, enable_if_t<_Is_cv_pair<_Ty>, int> = 0>
_NODISCARD constexpr auto uses_allocator_construction_args(const _Alloc& _Al, const pair<_Uty1, _Uty2>& _Pair) noexcept;

_EXPORT_STD template <class _Ty, class _Alloc, class _Uty1, class _Uty2, enable_if_t<_Is_cv_pair<_Ty>, int> = 0>
_NODISCARD constexpr auto uses_allocator_construction_args(const _Alloc& _Al, pair<_Uty1, _Uty2>&& _Pair) noexcept;

#if _HAS_CXX23
_EXPORT_STD template <class _Ty, class _Alloc, class _Uty1, class _Uty2, enable_if_t<_Is_cv_pair<_Ty>, int> = 0>
_NODISCARD constexpr auto uses_allocator_construction_args(
    const _Alloc& _Al, const pair<_Uty1, _Uty2>&& _Pair) noexcept;
#endif // _HAS_CXX23

#if _HAS_CXX23
_EXPORT_STD template <class _Ty, class _Alloc, class _Uty>
    requires _Is_cv_pair<_Ty> && (_Pair_like<_Uty> || !_Is_deducible_as_pair<_Uty&>)
#else // ^^^ _HAS_CXX23 / !_HAS_CXX23 vvv
_EXPORT_STD template <class _Ty, class _Alloc, class _Uty,
    enable_if_t<_Is_cv_pair<_Ty> && !_Is_deducible_as_pair<_Uty&>, int> = 0>
#endif // ^^^ !_HAS_CXX23 ^^^
    _NODISCARD constexpr auto uses_allocator_construction_args(const _Alloc& _Al, _Uty&& _Ux) noexcept;

_EXPORT_STD template <class _Ty, class _Alloc, class _Tuple1, class _Tuple2, enable_if_t<_Is_cv_pair<_Ty>, int> = 0>
_NODISCARD constexpr auto uses_allocator_construction_args(
    const _Alloc& _Al, piecewise_construct_t, _Tuple1&& _Tup1, _Tuple2&& _Tup2) noexcept {
    return _STD make_tuple(piecewise_construct,
        _STD apply(
            [&_Al](auto&&... _Tuple_args) {
                return _STD uses_allocator_construction_args<typename _Ty::first_type>(
                    _Al, _STD forward<decltype(_Tuple_args)>(_Tuple_args)...);
            },
            _STD forward<_Tuple1>(_Tup1)),
        _STD apply(
            [&_Al](auto&&... _Tuple_args) {
                return _STD uses_allocator_construction_args<typename _Ty::second_type>(
                    _Al, _STD forward<decltype(_Tuple_args)>(_Tuple_args)...);
            },
            _STD forward<_Tuple2>(_Tup2)));
}

_EXPORT_STD template <class _Ty, class _Alloc, enable_if_t<_Is_cv_pair<_Ty>, int> /* = 0 */>
_NODISCARD constexpr auto uses_allocator_construction_args(const _Alloc& _Al) noexcept {
    // equivalent to
    // return _STD uses_allocator_construction_args<_Ty>(_Al, piecewise_construct, tuple<>{}, tuple<>{});
    return _STD make_tuple(piecewise_construct, _STD uses_allocator_construction_args<typename _Ty::first_type>(_Al),
        _STD uses_allocator_construction_args<typename _Ty::second_type>(_Al));
}

_EXPORT_STD template <class _Ty, class _Alloc, class _Uty1, class _Uty2, enable_if_t<_Is_cv_pair<_Ty>, int> /* = 0 */>
_NODISCARD constexpr auto uses_allocator_construction_args(const _Alloc& _Al, _Uty1&& _Val1, _Uty2&& _Val2) noexcept {
    // equivalent to
    // return _STD uses_allocator_construction_args<_Ty>(_Al, piecewise_construct,
    //     _STD forward_as_tuple(_STD forward<_Uty1>(_Val1)), _STD forward_as_tuple(_STD forward<_Uty2>(_Val2)));
    return _STD make_tuple(piecewise_construct,
        _STD uses_allocator_construction_args<typename _Ty::first_type>(_Al, _STD forward<_Uty1>(_Val1)),
        _STD uses_allocator_construction_args<typename _Ty::second_type>(_Al, _STD forward<_Uty2>(_Val2)));
}

#if _HAS_CXX23
_EXPORT_STD template <class _Ty, class _Alloc, class _Uty1, class _Uty2, enable_if_t<_Is_cv_pair<_Ty>, int> /* = 0 */>
_NODISCARD constexpr auto uses_allocator_construction_args(const _Alloc& _Al, pair<_Uty1, _Uty2>& _Pair) noexcept {
    // equivalent to
    // return _STD uses_allocator_construction_args<_Ty>(_Al, piecewise_construct,
    //     _STD forward_as_tuple(_Pair.first), _STD forward_as_tuple(_Pair.second));
    return _STD make_tuple(piecewise_construct,
        _STD uses_allocator_construction_args<typename _Ty::first_type>(_Al, _Pair.first),
        _STD uses_allocator_construction_args<typename _Ty::second_type>(_Al, _Pair.second));
}
#endif // _HAS_CXX23

_EXPORT_STD template <class _Ty, class _Alloc, class _Uty1, class _Uty2, enable_if_t<_Is_cv_pair<_Ty>, int> /* = 0 */>
_NODISCARD constexpr auto uses_allocator_construction_args(
    const _Alloc& _Al, const pair<_Uty1, _Uty2>& _Pair) noexcept {
    // equivalent to
    // return _STD uses_allocator_construction_args<_Ty>(_Al, piecewise_construct,
    //     _STD forward_as_tuple(_Pair.first), _STD forward_as_tuple(_Pair.second));
    return _STD make_tuple(piecewise_construct,
        _STD uses_allocator_construction_args<typename _Ty::first_type>(_Al, _Pair.first),
        _STD uses_allocator_construction_args<typename _Ty::second_type>(_Al, _Pair.second));
}

_EXPORT_STD template <class _Ty, class _Alloc, class _Uty1, class _Uty2, enable_if_t<_Is_cv_pair<_Ty>, int> /* = 0 */>
_NODISCARD constexpr auto uses_allocator_construction_args(const _Alloc& _Al, pair<_Uty1, _Uty2>&& _Pair) noexcept {
    // equivalent to
    // return _STD uses_allocator_construction_args<_Ty>(_Al, piecewise_construct,
    //     _STD forward_as_tuple(_STD get<0>(_STD move(_Pair)), _STD forward_as_tuple(_STD get<1>(_STD move(_Pair)));
    return _STD make_tuple(piecewise_construct,
        _STD uses_allocator_construction_args<typename _Ty::first_type>(_Al, _STD get<0>(_STD move(_Pair))),
        _STD uses_allocator_construction_args<typename _Ty::second_type>(_Al, _STD get<1>(_STD move(_Pair))));
}

#if _HAS_CXX23
_EXPORT_STD template <class _Ty, class _Alloc, class _Uty1, class _Uty2, enable_if_t<_Is_cv_pair<_Ty>, int> /* = 0 */>
_NODISCARD constexpr auto uses_allocator_construction_args(
    const _Alloc& _Al, const pair<_Uty1, _Uty2>&& _Pair) noexcept {
    // equivalent to
    // return _STD uses_allocator_construction_args<_Ty>(_Al, piecewise_construct,
    //     _STD forward_as_tuple(_STD get<0>(_STD move(_Pair)), _STD forward_as_tuple(_STD get<1>(_STD move(_Pair)));
    return _STD make_tuple(piecewise_construct,
        _STD uses_allocator_construction_args<typename _Ty::first_type>(_Al, _STD get<0>(_STD move(_Pair))),
        _STD uses_allocator_construction_args<typename _Ty::second_type>(_Al, _STD get<1>(_STD move(_Pair))));
}
#endif // _HAS_CXX23

#if _HAS_CXX23
_EXPORT_STD template <class _Ty, class _Alloc, class _Uty>
    requires _Is_cv_pair<_Ty> && (_Pair_like<_Uty> || !_Is_deducible_as_pair<_Uty&>)
#else // ^^^ _HAS_CXX23 / !_HAS_CXX23 vvv
_EXPORT_STD template <class _Ty, class _Alloc, class _Uty,
    enable_if_t<_Is_cv_pair<_Ty> && !_Is_deducible_as_pair<_Uty&>, int> /* = 0 */>
#endif // ^^^ !_HAS_CXX23 ^^^
    _NODISCARD constexpr auto uses_allocator_construction_args(const _Alloc& _Al, _Uty&& _Ux) noexcept {
#if _HAS_CXX23
    if constexpr (_Pair_like<_Uty> && !_Is_subrange_v<remove_cvref_t<_Uty>>) {
        // equivalent to
        // return _STD uses_allocator_construction_args<_Ty>(_Al, piecewise_construct,
        //     _STD forward_as_tuple(_STD get<0>(_STD forward<_Uty>(_Ux)),
        //     _STD forward_as_tuple(_STD get<1>(_STD forward<_Uty>(_Ux)));
        return _STD make_tuple(piecewise_construct,
            _STD uses_allocator_construction_args<typename _Ty::first_type>(_Al, _STD get<0>(_STD forward<_Uty>(_Ux))),
            _STD uses_allocator_construction_args<typename _Ty::second_type>(
                _Al, _STD get<1>(_STD forward<_Uty>(_Ux))));
    }
    else
#endif // _HAS_CXX23
    {
        struct _Pair_remaker {
            const _Alloc& _Al;
            _Uty& _Ux;

            constexpr operator remove_cv_t<_Ty>() const {
                using _Pair_t = remove_cv_t<_Ty>;
                static_assert(_Is_normally_bindable<_Pair_t, _Uty>,
                    "The argument must be bindable to a reference to the std::pair type.");

                using _Pair_first_t = _Pair_t::first_type;
                using _Pair_second_t = _Pair_t::second_type;
                using _Pair_ref_t = _Normally_bound_ref<_Pair_t, _Uty>;
                _Pair_ref_t _Pair_ref = _STD forward<_Uty>(_Ux);
                if constexpr (is_same_v<_Pair_ref_t, const _Pair_t&>) {
                    // equivalent to
                    // return _STD make_obj_using_allocator<_Pair_t>(_Al, _Pair_ref);
                    return _Pair_t{ piecewise_construct,
                        _STD uses_allocator_construction_args<_Pair_first_t>(_Al, _Pair_ref.first),
                        _STD uses_allocator_construction_args<_Pair_second_t>(_Al, _Pair_ref.second) };
                }
                else {
                    // equivalent to
                    // return _STD make_obj_using_allocator<_Pair_t>(_Al, _STD move(_Pair_ref));
                    return _Pair_t{ piecewise_construct,
                        _STD uses_allocator_construction_args<_Pair_first_t>(_Al, _STD get<0>(_STD move(_Pair_ref))),
                        _STD uses_allocator_construction_args<_Pair_second_t>(_Al, _STD get<1>(_STD move(_Pair_ref))) };
                }
            }
        };

        // equivalent to
        // return _STD make_tuple(_Pair_remaker{_Al, _Ux});
        return tuple<_Pair_remaker>({ _Al, _Ux });
    }
}

_EXPORT_STD template <class _Ty, class _Alloc, class... _Types>
_NODISCARD constexpr _Ty make_obj_using_allocator(const _Alloc& _Al, _Types&&... _Args) {
    return _STD make_from_tuple<_Ty>(_STD uses_allocator_construction_args<_Ty>(_Al, _STD forward<_Types>(_Args)...));
}

_EXPORT_STD template <class _Ty, class _Alloc, class... _Types>
constexpr _Ty* uninitialized_construct_using_allocator(_Ty* _Ptr, const _Alloc& _Al, _Types&&... _Args) {
    return _STD apply(
        [&](auto&&... _Construct_args) {
            return _STD construct_at(_Ptr, _STD forward<decltype(_Construct_args)>(_Construct_args)...);
        },
        _STD uses_allocator_construction_args<_Ty>(_Al, _STD forward<_Types>(_Args)...));
}
#endif // _HAS_CXX20

#if _HAS_CXX23
_EXPORT_STD struct from_range_t {
    explicit from_range_t() = default;
};
_EXPORT_STD inline constexpr from_range_t from_range;

template <class _Rng, class _Elem>
concept _Container_compatible_range =
(_RANGES input_range<_Rng>) && convertible_to<_RANGES range_reference_t<_Rng>, _Elem>;

template <_RANGES input_range _Rng>
using _Range_key_type = remove_const_t<typename _RANGES range_value_t<_Rng>::first_type>;

template <_RANGES input_range _Rng>
using _Range_mapped_type = _RANGES range_value_t<_Rng>::second_type;

template <_RANGES input_range _Rng>
using _Range_to_alloc_type =
pair<const typename _RANGES range_value_t<_Rng>::first_type, typename _RANGES range_value_t<_Rng>::second_type>;
#endif // _HAS_CXX23

template <class _Ty,
    bool = is_empty_v<_Ty> && !is_final_v<_Ty>>
    class _Ebco_base : private _Ty { // Empty Base Class Optimization, active
    private:
        using _Mybase = _Ty; // for visualization

    protected:
        template <class _Other, enable_if_t<!is_same_v<_Remove_cvref_t<_Other>, _Ebco_base>, int> = 0>
        constexpr explicit _Ebco_base(_Other&& _Val) noexcept(is_nothrow_constructible_v<_Ty, _Other>)
            : _Ty(_STD forward<_Other>(_Val)) {}

        constexpr _Ty& _Get_val() noexcept {
            return *this;
        }

        constexpr const _Ty& _Get_val() const noexcept {
            return *this;
        }
};

template <class _Ty>
class _Ebco_base<_Ty, false> { // Empty Base Class Optimization, inactive
private:
    _Ty _Myval;

protected:
    template <class _Other, enable_if_t<!is_same_v<_Remove_cvref_t<_Other>, _Ebco_base>, int> = 0>
    constexpr explicit _Ebco_base(_Other&& _Val) noexcept(is_nothrow_constructible_v<_Ty, _Other>)
        : _Myval(_STD forward<_Other>(_Val)) {}

    constexpr _Ty& _Get_val() noexcept {
        return _Myval;
    }

    constexpr const _Ty& _Get_val() const noexcept {
        return _Myval;
    }
};

_EXPORT_STD inline void* align(size_t _Bound, size_t _Size, void*& _Ptr, size_t& _Space) noexcept /* strengthened */ {
    // try to carve out _Size bytes on boundary _Bound
    size_t _Off = static_cast<size_t>(reinterpret_cast<uintptr_t>(_Ptr) & (_Bound - 1));
    if (_Off != 0) {
        _Off = _Bound - _Off; // number of bytes to skip
    }

    if (_Space < _Off || _Space - _Off < _Size) {
        return nullptr;
    }

    // enough room, update
    _Ptr = static_cast<char*>(_Ptr) + _Off;
    _Space -= _Off;
    return _Ptr;
}

template <class _Ty, class = void>
_INLINE_VAR constexpr bool _Is_transparent_v = false;

template <class _Ty>
_INLINE_VAR constexpr bool _Is_transparent_v<_Ty, void_t<typename _Ty::is_transparent>> = true;

template <class _Ty>
struct _Is_transparent : bool_constant<_Is_transparent_v<_Ty>> {};

#if _HAS_CXX20
template <class _Ty>
concept _Transparent = _Is_transparent_v<_Ty>;
#endif // _HAS_CXX20

template <class _Elem, class _UTy>
_NODISCARD _Elem* _UIntegral_to_buff(_Elem* _RNext, _UTy _UVal) { // used by both to_string and thread::id output
    // format _UVal into buffer *ending at* _RNext
    static_assert(is_unsigned_v<_UTy>, "_UTy must be unsigned");

#ifdef _WIN64
    auto _UVal_trunc = _UVal;
#else // ^^^ defined(_WIN64) / !defined(_WIN64) vvv

    constexpr bool _Big_uty = sizeof(_UTy) > 4;
    if constexpr (_Big_uty) { // For 64-bit numbers, work in chunks to avoid 64-bit divisions.
        while (_UVal > 0xFFFFFFFFU) {
            auto _UVal_chunk = static_cast<unsigned long>(_UVal % 1000000000);
            _UVal /= 1000000000;

            for (int _Idx = 0; _Idx != 9; ++_Idx) {
                *--_RNext = static_cast<_Elem>('0' + _UVal_chunk % 10);
                _UVal_chunk /= 10;
            }
        }
    }

    auto _UVal_trunc = static_cast<unsigned long>(_UVal);
#endif // ^^^ !defined(_WIN64) ^^^

    do {
        *--_RNext = static_cast<_Elem>('0' + _UVal_trunc % 10);
        _UVal_trunc /= 10;
    } while (_UVal_trunc != 0);
    return _RNext;
}
_STD_END

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _XMEMORY_


#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_STD_BEGIN

#if !_HAS_CXX20
template <class _Ty, class _Outer_alloc, class _Inner_alloc, class... _Types>
void _Uses_alloc_construct_non_pair(_Ty* const _Ptr, _Outer_alloc& _Outer, _Inner_alloc& _Inner, _Types&&... _Args) {
    // uses-allocator construction of *_Ptr by alloc _Outer propagating alloc _Inner, non-pair case
    if constexpr (uses_allocator_v<remove_cv_t<_Ty>, _Inner_alloc>) {
        if constexpr (is_constructible_v<_Ty, allocator_arg_t, _Inner_alloc&, _Types...>) {
            allocator_traits<_Outer_alloc>::construct(
                _Outer, _Ptr, allocator_arg, _Inner, _STD forward<_Types>(_Args)...);
        }
        else {
            static_assert(is_constructible_v<_Ty, _Types..., _Inner_alloc&>,
                "N4950 [allocator.uses.trait]/1 requires "
                "is_constructible_v<T, Args..., Alloc&> when uses_allocator_v<remove_cv_t<T>, Alloc> is true and "
                "is_constructible_v<T, allocator_arg_t, Alloc&, Args...> is false");
            allocator_traits<_Outer_alloc>::construct(_Outer, _Ptr, _STD forward<_Types>(_Args)..., _Inner);
        }
    }
    else {
        static_assert(is_constructible_v<_Ty, _Types...>,
            "N4950 [allocator.uses.trait]/1 requires "
            "is_constructible_v<T, Args...> when uses_allocator_v<remove_cv_t<T>, Alloc> is false");
        allocator_traits<_Outer_alloc>::construct(_Outer, _Ptr, _STD forward<_Types>(_Args)...);
    }
}

template <class _Ty, class _Alloc, class... _Types>
decltype(auto) _Uses_alloc_piecewise(_Alloc& _Al, tuple<_Types...>&& _Tuple) {
    if constexpr (uses_allocator_v<remove_cv_t<_Ty>, _Alloc>) {
        if constexpr (is_constructible_v<_Ty, allocator_arg_t, _Alloc&, _Types...>) {
            return _STD tuple_cat(tuple<allocator_arg_t, _Alloc&>(allocator_arg, _Al), _STD move(_Tuple));
        }
        else {
            return _STD tuple_cat(_STD move(_Tuple), tuple<_Alloc&>(_Al));
        }
    }
    else {
        return _STD move(_Tuple);
    }
}

template <class _CvPair, class _Outer_alloc, class _Inner_alloc, class... _Types1, class... _Types2>
void _Uses_alloc_construct_pair_piecewise(_CvPair* const _Ptr, _Outer_alloc& _Outer, _Inner_alloc& _Inner,
    tuple<_Types1...>&& _Val1, tuple<_Types2...>&& _Val2) {
    // uses-allocator construction of pair from _Val1 and _Val2 by alloc _Outer propagating alloc _Inner
    allocator_traits<_Outer_alloc>::construct(_Outer, _Ptr, piecewise_construct,
        _STD _Uses_alloc_piecewise<typename _CvPair::first_type>(_Inner, _STD move(_Val1)),
        _STD _Uses_alloc_piecewise<typename _CvPair::second_type>(_Inner, _STD move(_Val2)));
}

template <class _CvPair, class _Outer_alloc, class _Inner_alloc, class... _Types1, class... _Types2>
void _Uses_alloc_construct_pair(_CvPair* const _Ptr, _Outer_alloc& _Outer, _Inner_alloc& _Inner, piecewise_construct_t,
    tuple<_Types1...> _Val1, tuple<_Types2...> _Val2) {
    // uses-allocator construction of pair by alloc _Outer propagating alloc _Inner, piecewise case
    _STD _Uses_alloc_construct_pair_piecewise(_Ptr, _Outer, _Inner, _STD move(_Val1), _STD move(_Val2));
}

template <class _CvPair, class _Outer_alloc, class _Inner_alloc>
void _Uses_alloc_construct_pair(_CvPair* const _Ptr, _Outer_alloc& _Outer, _Inner_alloc& _Inner) {
    // uses-allocator construction of pair by alloc _Outer propagating alloc _Inner, zero-argument case
    _STD _Uses_alloc_construct_pair_piecewise(_Ptr, _Outer, _Inner, tuple<>{}, tuple<>{});
}

template <class _CvPair, class _Outer_alloc, class _Inner_alloc, class _Uty, class _Vty>
void _Uses_alloc_construct_pair(
    _CvPair* const _Ptr, _Outer_alloc& _Outer, _Inner_alloc& _Inner, _Uty&& _Arg1, _Vty&& _Arg2) {
    // uses-allocator construction of pair by alloc _Outer propagating alloc _Inner, two-argument case
    _STD _Uses_alloc_construct_pair_piecewise(_Ptr, _Outer, _Inner, _STD forward_as_tuple(_STD forward<_Uty>(_Arg1)),
        _STD forward_as_tuple(_STD forward<_Vty>(_Arg2)));
}

template <class _CvPair, class _Outer_alloc, class _Inner_alloc, class _Uty, class _Vty>
void _Uses_alloc_construct_pair(
    _CvPair* const _Ptr, _Outer_alloc& _Outer, _Inner_alloc& _Inner, const pair<_Uty, _Vty>& _Pair) {
    // uses-allocator construction of pair by alloc _Outer propagating alloc _Inner, lvalue pair argument
    _STD _Uses_alloc_construct_pair_piecewise(
        _Ptr, _Outer, _Inner, _STD forward_as_tuple(_Pair.first), _STD forward_as_tuple(_Pair.second));
}

template <class _CvPair, class _Outer_alloc, class _Inner_alloc, class _Uty, class _Vty>
void _Uses_alloc_construct_pair(
    _CvPair* const _Ptr, _Outer_alloc& _Outer, _Inner_alloc& _Inner, pair<_Uty, _Vty>&& _Pair) {
    // uses-allocator construction of pair by alloc _Outer propagating alloc _Inner, rvalue pair argument
    _STD _Uses_alloc_construct_pair_piecewise(_Ptr, _Outer, _Inner,
        _STD forward_as_tuple(_STD forward<_Uty>(_Pair.first)),
        _STD forward_as_tuple(_STD forward<_Vty>(_Pair.second)));
}

template <class _CvPair, class _Outer_alloc, class _Inner_alloc, class _Uty,
    enable_if_t<!_Is_deducible_as_pair<_Uty>, int> = 0>
void _Uses_alloc_construct_pair(_CvPair* const _Ptr, _Outer_alloc& _Outer, _Inner_alloc& _Inner, _Uty&& _Ux) {
    // uses-allocator construction of pair by alloc _Outer propagating alloc _Inner, non-pair argument
    static_assert(_Is_normally_bindable<remove_cv_t<_CvPair>, _Uty>,
        "The argument must be bindable to a reference to the std::pair type.");

    using _Pair_ref_t = _Normally_bound_ref<remove_cv_t<_CvPair>, _Uty>;
    _Pair_ref_t _Pair_ref = _STD forward<_Uty>(_Ux);
    if constexpr (is_lvalue_reference_v<_Pair_ref_t>) {
        _STD _Uses_alloc_construct_pair_piecewise(
            _Ptr, _Outer, _Inner, _STD forward_as_tuple(_Pair_ref.first), _STD forward_as_tuple(_Pair_ref.second));
    }
    else {
        _STD _Uses_alloc_construct_pair_piecewise(_Ptr, _Outer, _Inner,
            _STD forward_as_tuple(_STD forward<typename _CvPair::first_type>(_Pair_ref.first)),
            _STD forward_as_tuple(_STD forward<typename _CvPair::second_type>(_Pair_ref.second)));
    }
}
#endif // !_HAS_CXX20

#if _HAS_CXX17
namespace pmr {
    _EXPORT_STD class __declspec(novtable) memory_resource {
    public:
        virtual ~memory_resource() noexcept = default;

        _NODISCARD_RAW_PTR_ALLOC __declspec(allocator) void* allocate(_CRT_GUARDOVERFLOW const size_t _Bytes,
            const size_t _Align = alignof(max_align_t)) { // allocate _Bytes bytes of memory with alignment _Align
            _STL_ASSERT(_STD _Is_pow_2(_Align), "memory_resource::allocate(): Alignment must be a power of two.");
            void* _Ptr = do_allocate(_Bytes, _Align);
            return ::operator new(_Bytes, _Ptr);
        }

        void deallocate(void* const _Ptr, const size_t _Bytes, const size_t _Align = alignof(max_align_t)) {
            // deallocate _Ptr, which was returned from allocate(_Bytes, _Align)
            _STL_ASSERT(_STD _Is_pow_2(_Align), "memory_resource::deallocate(): Alignment must be a power of two.");
            return do_deallocate(_Ptr, _Bytes, _Align);
        }

        _NODISCARD bool is_equal(const memory_resource& _That) const noexcept {
            // determine if *this and _That can both deallocate memory allocated by either
            return do_is_equal(_That);
        }

    private:
        virtual void* do_allocate(size_t _Bytes, size_t _Align) = 0;
        virtual void do_deallocate(void* _Ptr, size_t _Bytes, size_t _Align) = 0;
        virtual bool do_is_equal(const memory_resource& _That) const noexcept = 0;
    };

    _EXPORT_STD _NODISCARD inline bool operator==(
        const memory_resource& _Left, const memory_resource& _Right) noexcept {
        return &_Left == &_Right || _Left.is_equal(_Right);
    }

#if !_HAS_CXX20
    _NODISCARD inline bool operator!=(const memory_resource& _Left, const memory_resource& _Right) noexcept {
        return !(_Left == _Right);
    }
#endif // !_HAS_CXX20

    extern "C" _CRT_SATELLITE_1 memory_resource* __cdecl _Aligned_get_default_resource() noexcept;
    extern "C" _CRT_SATELLITE_1 memory_resource* __cdecl _Unaligned_get_default_resource() noexcept;

    _EXPORT_STD _NODISCARD inline memory_resource* get_default_resource() noexcept {
#ifdef __cpp_aligned_new
        return _STD pmr::_Aligned_get_default_resource();
#else // ^^^ defined(__cpp_aligned_new) / !defined(__cpp_aligned_new) vvv
        return _STD pmr::_Unaligned_get_default_resource();
#endif // ^^^ !defined(__cpp_aligned_new) ^^^
    }

#if _HAS_CXX20
    template <class _Uty>
    struct _NODISCARD _Deallocate_bytes_guard {
        ~_Deallocate_bytes_guard() noexcept {
            if (_Mem_res) {
                _Mem_res->deallocate(_Pobj, sizeof(_Uty), alignof(_Uty));
            }
        }

        _Deallocate_bytes_guard& operator=(const _Deallocate_bytes_guard&) = delete;
        _Deallocate_bytes_guard& operator=(_Deallocate_bytes_guard&&) = delete;

        memory_resource* _Mem_res;
        void* _Pobj;
    };
#endif // _HAS_CXX20

#if _HAS_CXX20 && defined(__cpp_lib_byte)
    _EXPORT_STD template <class _Ty = byte>
#else // ^^^ _HAS_CXX20 && defined(__cpp_lib_byte) / !_HAS_CXX20 || !defined(__cpp_lib_byte) vvv
    _EXPORT_STD template <class _Ty>
#endif // ^^^ !_HAS_CXX20 || !defined(__cpp_lib_byte) ^^^
        class polymorphic_allocator {
        public:
            template <class>
            friend class polymorphic_allocator;

            using value_type = _Ty;

            polymorphic_allocator() noexcept = default;

            /* implicit */ polymorphic_allocator(memory_resource* const _Resource_) noexcept // strengthened
                : _Resource{ _Resource_ } { // initialize with _Resource_
                _STL_ASSERT(_Resource,
                    "Cannot initialize polymorphic_allocator with null resource (N4950 [mem.poly.allocator.ctor]/2)");
            }

            polymorphic_allocator(const polymorphic_allocator&) = default;

            template <class _Uty>
            polymorphic_allocator(const polymorphic_allocator<_Uty>& _That) noexcept
                : _Resource{ _That._Resource } {} // initialize with _That's resource

            polymorphic_allocator& operator=(const polymorphic_allocator&) = delete;

            _NODISCARD_RAW_PTR_ALLOC __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {
                // get space for _Count objects of type _Ty from _Resource
                void* const _Vp = _Resource->allocate(_Get_size_of_n<sizeof(_Ty)>(_Count), alignof(_Ty));
                return static_cast<_Ty*>(_Vp);
            }

            void deallocate(_Ty* const _Ptr, const size_t _Count) noexcept /* strengthened */ {
                // return space for _Count objects of type _Ty to _Resource
                // No need to verify that size_t can represent the size of _Ty[_Count].
                _Resource->deallocate(_Ptr, _Count * sizeof(_Ty), alignof(_Ty));
            }

#if _HAS_CXX20
            _NODISCARD_RAW_PTR_ALLOC __declspec(allocator) void* allocate_bytes(
                const size_t _Bytes, const size_t _Align = alignof(max_align_t)) {
                return _Resource->allocate(_Bytes, _Align);
            }

            void deallocate_bytes(void* const _Ptr, const size_t _Bytes,
                const size_t _Align = alignof(max_align_t)) noexcept /* strengthened */ {
                _Resource->deallocate(_Ptr, _Bytes, _Align);
            }

            template <class _Uty>
            _NODISCARD_RAW_PTR_ALLOC __declspec(allocator) _Uty* allocate_object(
                _CRT_GUARDOVERFLOW const size_t _Count = 1) {
                void* const _Vp = allocate_bytes(_Get_size_of_n<sizeof(_Uty)>(_Count), alignof(_Uty));
                return static_cast<_Uty*>(_Vp);
            }

            template <class _Uty>
            void deallocate_object(_Uty* const _Ptr, const size_t _Count = 1) noexcept /* strengthened */ {
                deallocate_bytes(_Ptr, _Count * sizeof(_Uty), alignof(_Uty));
            }

            template <class _Uty, class... _Types>
            _NODISCARD_RAW_PTR_ALLOC __declspec(allocator) _Uty* new_object(_Types&&... _Args) {
                _Uty* const _Ptr = allocate_object<_Uty>();

                _Deallocate_bytes_guard<_Uty> _Guard{ _Resource, _Ptr };
                construct(_Ptr, _STD forward<_Types>(_Args)...);
                _Guard._Mem_res = nullptr;

                return _Ptr;
            }

            template <class _Uty>
            void delete_object(_Uty* const _Ptr) noexcept /* strengthened */ {
                _STD _Destroy_in_place(*_Ptr);
                deallocate_object(_Ptr);
            }
#endif // _HAS_CXX20

            template <class _Uty, class... _Types>
            void construct(_Uty* const _Ptr, _Types&&... _Args) {
                // propagate allocator *this if uses_allocator_v<remove_cv_t<_Uty>, polymorphic_allocator>
#if _HAS_CXX20
            // equivalent to calling uninitialized_construct_using_allocator except for handling of cv-qualification
                _STD apply(
                    [_Ptr](auto&&... _Construct_args) {
                        return ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr)))
                            _Uty(_STD forward<decltype(_Construct_args)>(_Construct_args)...);
                    },
                    _STD uses_allocator_construction_args<_Uty>(*this, _STD forward<_Types>(_Args)...));
#else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
                allocator<char> _Al{};
                if constexpr (_Is_cv_pair<_Uty>) {
                    _STD _Uses_alloc_construct_pair(_Ptr, _Al, *this, _STD forward<_Types>(_Args)...);
                }
                else {
                    _STD _Uses_alloc_construct_non_pair(_Ptr, _Al, *this, _STD forward<_Types>(_Args)...);
                }
#endif // ^^^ !_HAS_CXX20 ^^^
            }

            template <class _Uty>
            _CXX17_DEPRECATE_POLYMORPHIC_ALLOCATOR_DESTROY void destroy(_Uty* const _Ptr) noexcept /* strengthened */ {
                _STD _Destroy_in_place(*_Ptr);
            }

            _NODISCARD polymorphic_allocator select_on_container_copy_construction() const noexcept /* strengthened */ {
                // don't propagate on copy
                return {};
            }

            _NODISCARD memory_resource* resource() const noexcept /* strengthened */ {
                // retrieve this allocator's memory_resource
                return _Resource;
            }

            _NODISCARD_FRIEND bool operator==(
                const polymorphic_allocator& _Lhs, const polymorphic_allocator& _Rhs) noexcept {
                return *_Lhs._Resource == *_Rhs._Resource;
            }

#if !_HAS_CXX20
            _NODISCARD_FRIEND bool operator!=(
                const polymorphic_allocator& _Lhs, const polymorphic_allocator& _Rhs) noexcept {
                return *_Lhs._Resource != *_Rhs._Resource;
            }
#endif // !_HAS_CXX20

        private:
            memory_resource* _Resource = _STD pmr::get_default_resource();
    };

    _EXPORT_STD template <class _Ty1, class _Ty2>
        _NODISCARD bool operator==(
            const polymorphic_allocator<_Ty1>& _Left, const polymorphic_allocator<_Ty2>& _Right) noexcept {
        // polymorphic_allocators with the same resource are compatible
        return *_Left.resource() == *_Right.resource();
    }

#if !_HAS_CXX20
    template <class _Ty1, class _Ty2>
    _NODISCARD bool operator!=(
        const polymorphic_allocator<_Ty1>& _Left, const polymorphic_allocator<_Ty2>& _Right) noexcept {
        return !(_Left == _Right);
    }
#endif // !_HAS_CXX20

} // namespace pmr

template <class _Ty, class _Ptr>
struct _Has_no_alloc_destroy<pmr::polymorphic_allocator<_Ty>, _Ptr, void> : true_type {
    // polymorphic_allocator technically _does_ have a destroy member, but it's equivalent to the
    // default implementation in allocator_traits so we can optimize it away.
};

#endif // _HAS_CXX17

_STD_END

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _XPOLYMORPHIC_ALLOCATOR_H

#endif // _HAS_CXX17

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

#ifdef __clang__
#define _HAS_MEMCPY_MEMMOVE_INTRINSICS 1
#else // ^^^ use __builtin_memcpy and __builtin_memmove / use workaround vvv
#define _HAS_MEMCPY_MEMMOVE_INTRINSICS 0 // TRANSITION, DevCom-1046483 (MSVC) and VSO-1129974 (EDG)
#endif // ^^^ use workaround ^^^

_STD_BEGIN
template <class _Elem, class _Int_type>
struct _Char_traits { // properties of a string or stream element
    using char_type = _Elem;
    using int_type = _Int_type;
    using pos_type = streampos;
    using off_type = streamoff;
    using state_type = _Mbstatet;
#if _HAS_CXX20
    using comparison_category = strong_ordering;
#endif // _HAS_CXX20

    // For copy/move, we can uniformly call memcpy/memmove (or their builtin versions) for all element types.

    static _CONSTEXPR20 _Elem* copy(_Out_writes_all_(_Count) _Elem* const _First1,
        _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {
        // copy [_First2, _First2 + _Count) to [_First1, ...)
#if _HAS_MEMCPY_MEMMOVE_INTRINSICS
        __builtin_memcpy(_First1, _First2, _Count * sizeof(_Elem));
#else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS / !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
#if _HAS_CXX20
        if (_STD is_constant_evaluated()) {
            // pre: [_First1, _First1 + _Count) and [_First2, _First2 + _Count) do not overlap
            for (size_t _Idx = 0; _Idx != _Count; ++_Idx) {
                _First1[_Idx] = _First2[_Idx];
            }

            return _First1;
        }
#endif // _HAS_CXX20

        _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));
#endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^

        return _First1;
    }

    _Pre_satisfies_(_Dest_size >= _Count) static _CONSTEXPR20 _Elem* _Copy_s(_Out_writes_all_(_Dest_size)
        _Elem* const _First1,
        const size_t _Dest_size, _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept {
        // copy [_First2, _First2 + _Count) to [_First1, _First1 + _Dest_size)
        _STL_VERIFY(_Count <= _Dest_size, "invalid argument");
        return copy(_First1, _First2, _Count);
    }

    static _CONSTEXPR20 _Elem* move(_Out_writes_all_(_Count) _Elem* const _First1,
        _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {
        // copy [_First2, _First2 + _Count) to [_First1, ...), allowing overlap
#if _HAS_MEMCPY_MEMMOVE_INTRINSICS
        __builtin_memmove(_First1, _First2, _Count * sizeof(_Elem));
#else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS / !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
#if _HAS_CXX20
        if (_STD is_constant_evaluated()) {
            // dest: [_First1, _First1 + _Count)
            // src: [_First2, _First2 + _Count)
            // We need to handle overlapping ranges.
            // If _First1 is in the src range, we need a backward loop.
            // Otherwise, the forward loop works (even if the back of dest overlaps the front of src).

            // Usually, we would compare pointers with less-than, even though they could belong to different arrays.
            // However, we're not allowed to do that during constant evaluation, so we need a linear scan for equality.
            bool _Loop_forward = true;

            for (const _Elem* _Src = _First2; _Src != _First2 + _Count; ++_Src) {
                if (_First1 == _Src) {
                    _Loop_forward = false;
                    break;
                }
            }

            if (_Loop_forward) {
                for (size_t _Idx = 0; _Idx != _Count; ++_Idx) {
                    _First1[_Idx] = _First2[_Idx];
                }
            }
            else {
                for (size_t _Idx = _Count; _Idx != 0; --_Idx) {
                    _First1[_Idx - 1] = _First2[_Idx - 1];
                }
            }

            return _First1;
        }
#endif // _HAS_CXX20

        _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));
#endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^

        return _First1;
    }

    // For compare/length/find/assign, we can't uniformly call CRT functions (or their builtin versions).
    // 8-bit: memcmp/strlen/memchr/memset; 16-bit: wmemcmp/wcslen/wmemchr/wmemset; 32-bit: nonexistent

    _NODISCARD static _CONSTEXPR17 int compare(_In_reads_(_Count) const _Elem* _First1,
        _In_reads_(_Count) const _Elem* _First2, size_t _Count) noexcept /* strengthened */ {
        // compare [_First1, _First1 + _Count) with [_First2, ...)
        for (; 0 < _Count; --_Count, ++_First1, ++_First2) {
            if (*_First1 != *_First2) {
                return *_First1 < *_First2 ? -1 : +1;
            }
        }

        return 0;
    }

    _NODISCARD static _CONSTEXPR17 size_t length(_In_z_ const _Elem* _First) noexcept /* strengthened */ {
        // find length of null-terminated sequence
        size_t _Count = 0;
        while (*_First != _Elem()) {
            ++_Count;
            ++_First;
        }

        return _Count;
    }

    _NODISCARD static _CONSTEXPR17 const _Elem* find(
        _In_reads_(_Count) const _Elem* _First, size_t _Count, const _Elem& _Ch) noexcept /* strengthened */ {
        // look for _Ch in [_First, _First + _Count)
        for (; 0 < _Count; --_Count, ++_First) {
            if (*_First == _Ch) {
                return _First;
            }
        }

        return nullptr;
    }

    static _CONSTEXPR20 _Elem* assign(
        _Out_writes_all_(_Count) _Elem* const _First, size_t _Count, const _Elem _Ch) noexcept /* strengthened */ {
        // assign _Count * _Ch to [_First, ...)
#if _HAS_CXX20
        if (_STD is_constant_evaluated()) {
            for (_Elem* _Next = _First; _Count > 0; --_Count, ++_Next) {
                _STD construct_at(_Next, _Ch);
            }
        }
        else
#endif // _HAS_CXX20
        {
            for (_Elem* _Next = _First; _Count > 0; --_Count, ++_Next) {
                *_Next = _Ch;
            }
        }

        return _First;
    }

    static _CONSTEXPR17 void assign(_Elem& _Left, const _Elem& _Right) noexcept {
#if _HAS_CXX20
        if (_STD is_constant_evaluated()) {
            _STD construct_at(_STD addressof(_Left), _Right);
        }
        else
#endif // _HAS_CXX20
        {
            _Left = _Right;
        }
    }

    _NODISCARD static constexpr bool eq(const _Elem _Left, const _Elem _Right) noexcept {
        return _Left == _Right;
    }

    _NODISCARD static constexpr bool lt(const _Elem _Left, const _Elem _Right) noexcept {
        return _Left < _Right;
    }

    _NODISCARD static constexpr _Elem to_char_type(const int_type _Meta) noexcept {
        return static_cast<_Elem>(_Meta);
    }

    _NODISCARD static constexpr int_type to_int_type(const _Elem _Ch) noexcept {
        return static_cast<int_type>(_Ch);
    }

    _NODISCARD static constexpr bool eq_int_type(const int_type _Left, const int_type _Right) noexcept {
        return _Left == _Right;
    }

    _NODISCARD static constexpr int_type not_eof(const int_type _Meta) noexcept {
        return _Meta != eof() ? _Meta : !eof();
    }

    _NODISCARD static constexpr int_type eof() noexcept {
        return static_cast<int_type>(EOF);
    }
};

template <class _Elem>
struct _WChar_traits : private _Char_traits<_Elem, unsigned short> {
    // char_traits for the char16_t-likes: char16_t, wchar_t, unsigned short
private:
    using _Primary_char_traits = _Char_traits<_Elem, unsigned short>;

public:
    using char_type = _Elem;
    using int_type = unsigned short;
    using pos_type = streampos;
    using off_type = streamoff;
    using state_type = mbstate_t;
#if _HAS_CXX20
    using comparison_category = strong_ordering;
#endif // _HAS_CXX20

    using _Primary_char_traits::_Copy_s;
    using _Primary_char_traits::copy;
    using _Primary_char_traits::move;

    _NODISCARD static _CONSTEXPR17 int compare(_In_reads_(_Count) const _Elem* const _First1,
        _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {
        // compare [_First1, _First1 + _Count) with [_First2, ...)
#if _HAS_CXX17
        if constexpr (is_same_v<_Elem, wchar_t>) {
            return __builtin_wmemcmp(_First1, _First2, _Count);
        }
        else {
            return _Primary_char_traits::compare(_First1, _First2, _Count);
        }
#else // ^^^ _HAS_CXX17 / !_HAS_CXX17 vvv
        return _CSTD wmemcmp(
            reinterpret_cast<const wchar_t*>(_First1), reinterpret_cast<const wchar_t*>(_First2), _Count);
#endif // ^^^ !_HAS_CXX17 ^^^
    }

    _NODISCARD static _CONSTEXPR17 size_t length(_In_z_ const _Elem* _First) noexcept /* strengthened */ {
        // find length of null-terminated sequence
#if _HAS_CXX17
        if constexpr (is_same_v<_Elem, wchar_t>) {
            return __builtin_wcslen(_First);
        }
        else {
            return _Primary_char_traits::length(_First);
        }
#else // ^^^ _HAS_CXX17 / !_HAS_CXX17 vvv
        return _CSTD wcslen(reinterpret_cast<const wchar_t*>(_First));
#endif // ^^^ !_HAS_CXX17 ^^^
    }

    _NODISCARD static _CONSTEXPR17 const _Elem* find(
        _In_reads_(_Count) const _Elem* _First, const size_t _Count, const _Elem& _Ch) noexcept /* strengthened */ {
        // look for _Ch in [_First, _First + _Count)
#if _HAS_CXX17
        if constexpr (is_same_v<_Elem, wchar_t>) {
            return __builtin_wmemchr(_First, _Ch, _Count);
        }
        else {
            return _Primary_char_traits::find(_First, _Count, _Ch);
        }
#else // ^^^ _HAS_CXX17 / !_HAS_CXX17 vvv
        return reinterpret_cast<const _Elem*>(_CSTD wmemchr(reinterpret_cast<const wchar_t*>(_First), _Ch, _Count));
#endif // ^^^ !_HAS_CXX17 ^^^
    }

    static _CONSTEXPR20 _Elem* assign(
        _Out_writes_all_(_Count) _Elem* const _First, size_t _Count, const _Elem _Ch) noexcept /* strengthened */ {
        // assign _Count * _Ch to [_First, ...)
#if _HAS_CXX20
        if (_STD is_constant_evaluated()) {
            return _Primary_char_traits::assign(_First, _Count, _Ch);
        }
#endif // _HAS_CXX20

        return reinterpret_cast<_Elem*>(_CSTD wmemset(reinterpret_cast<wchar_t*>(_First), _Ch, _Count));
    }

    static _CONSTEXPR17 void assign(_Elem& _Left, const _Elem& _Right) noexcept {
#if _HAS_CXX20
        if (_STD is_constant_evaluated()) {
            return _Primary_char_traits::assign(_Left, _Right);
        }
#endif // _HAS_CXX20
        _Left = _Right;
    }

    _NODISCARD static constexpr bool eq(const _Elem _Left, const _Elem _Right) noexcept {
        return _Left == _Right;
    }

    _NODISCARD static constexpr bool lt(const _Elem _Left, const _Elem _Right) noexcept {
        return _Left < _Right;
    }

    _NODISCARD static constexpr _Elem to_char_type(const int_type _Meta) noexcept {
        return _Meta;
    }

    _NODISCARD static constexpr int_type to_int_type(const _Elem _Ch) noexcept {
        return _Ch;
    }

    _NODISCARD static constexpr bool eq_int_type(const int_type _Left, const int_type _Right) noexcept {
        return _Left == _Right;
    }

    _NODISCARD static constexpr int_type not_eof(const int_type _Meta) noexcept {
        return _Meta != eof() ? _Meta : static_cast<int_type>(!eof());
    }

    _NODISCARD static constexpr int_type eof() noexcept {
        return WEOF;
    }
};

_EXPORT_STD template <class _Elem>
struct char_traits : _Char_traits<_Elem, long> {}; // properties of a string or stream unknown element

template <>
struct char_traits<char16_t> : _WChar_traits<char16_t> {};

template <>
struct char_traits<char32_t> : _Char_traits<char32_t, unsigned int> {};

template <>
struct char_traits<wchar_t> : _WChar_traits<wchar_t> {};

#ifdef _CRTBLD
template <>
struct char_traits<unsigned short> : _WChar_traits<unsigned short> {};
#endif // defined(_CRTBLD)

#if defined(__cpp_char8_t) && !defined(__clang__) && !defined(__EDG__)
#define _HAS_U8_INTRINSICS 1
#else // ^^^ Use intrinsics for char8_t / don't use said intrinsics vvv
#define _HAS_U8_INTRINSICS 0
#endif // Detect u8 intrinsics

template <class _Elem, class _Int_type>
struct _Narrow_char_traits : private _Char_traits<_Elem, _Int_type> {
    // Implement char_traits for narrow character types char and char8_t
private:
    using _Primary_char_traits = _Char_traits<_Elem, _Int_type>;

public:
    using char_type = _Elem;
    using int_type = _Int_type;
    using pos_type = streampos;
    using off_type = streamoff;
    using state_type = mbstate_t;
#if _HAS_CXX20
    using comparison_category = strong_ordering;
#endif // _HAS_CXX20

    using _Primary_char_traits::_Copy_s;
    using _Primary_char_traits::copy;
    using _Primary_char_traits::move;

    _NODISCARD static _CONSTEXPR17 int compare(_In_reads_(_Count) const _Elem* const _First1,
        _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {
        // compare [_First1, _First1 + _Count) with [_First2, ...)
#if _HAS_CXX17
        return __builtin_memcmp(_First1, _First2, _Count);
#else // ^^^ _HAS_CXX17 / !_HAS_CXX17 vvv
        return _CSTD memcmp(_First1, _First2, _Count);
#endif // ^^^ !_HAS_CXX17 ^^^
    }

    _NODISCARD static _CONSTEXPR17 size_t length(_In_z_ const _Elem* const _First) noexcept /* strengthened */ {
        // find length of null-terminated string
#if _HAS_CXX17
#ifdef __cpp_char8_t
        if constexpr (is_same_v<_Elem, char8_t>) {
#if _HAS_U8_INTRINSICS
            return __builtin_u8strlen(_First);
#else // ^^^ use u8 intrinsics / no u8 intrinsics vvv
            return _Primary_char_traits::length(_First);
#endif // ^^^ no u8 intrinsics ^^^
        }
        else
#endif // defined(__cpp_char8_t)
        {
            return __builtin_strlen(_First);
        }
#else // ^^^ _HAS_CXX17 / !_HAS_CXX17 vvv
        return _CSTD strlen(reinterpret_cast<const char*>(_First));
#endif // ^^^ !_HAS_CXX17 ^^^
    }

    _NODISCARD static _CONSTEXPR17 const _Elem* find(_In_reads_(_Count) const _Elem* const _First, const size_t _Count,
        const _Elem& _Ch) noexcept /* strengthened */ {
        // look for _Ch in [_First, _First + _Count)
#if _HAS_CXX17
#ifdef __cpp_char8_t
        if constexpr (is_same_v<_Elem, char8_t>) {
#if _HAS_U8_INTRINSICS
            return __builtin_u8memchr(_First, _Ch, _Count);
#else // ^^^ use u8 intrinsics / no u8 intrinsics vvv
            return _Primary_char_traits::find(_First, _Count, _Ch);
#endif // ^^^ no u8 intrinsics ^^^
        }
        else
#endif // defined(__cpp_char8_t)
        {
            return __builtin_char_memchr(_First, _Ch, _Count);
        }
#else // ^^^ _HAS_CXX17 / !_HAS_CXX17 vvv
        return static_cast<const _Elem*>(_CSTD memchr(_First, _Ch, _Count));
#endif // ^^^ !_HAS_CXX17 ^^^
    }

    static _CONSTEXPR20 _Elem* assign(
        _Out_writes_all_(_Count) _Elem* const _First, size_t _Count, const _Elem _Ch) noexcept /* strengthened */ {
        // assign _Count * _Ch to [_First, ...)
#if _HAS_CXX20
        if (_STD is_constant_evaluated()) {
            return _Primary_char_traits::assign(_First, _Count, _Ch);
        }
#endif // _HAS_CXX20

        return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));
    }

    static _CONSTEXPR17 void assign(_Elem& _Left, const _Elem& _Right) noexcept {
#if _HAS_CXX20
        if (_STD is_constant_evaluated()) {
            return _Primary_char_traits::assign(_Left, _Right);
        }
#endif // _HAS_CXX20
        _Left = _Right;
    }

    _NODISCARD static constexpr bool eq(const _Elem _Left, const _Elem _Right) noexcept {
        return _Left == _Right;
    }

    _NODISCARD static constexpr bool lt(const _Elem _Left, const _Elem _Right) noexcept {
        return static_cast<unsigned char>(_Left) < static_cast<unsigned char>(_Right);
    }

    _NODISCARD static constexpr _Elem to_char_type(const int_type _Meta) noexcept {
        return static_cast<_Elem>(_Meta);
    }

    _NODISCARD static constexpr int_type to_int_type(const _Elem _Ch) noexcept {
        return static_cast<unsigned char>(_Ch);
    }

    _NODISCARD static constexpr bool eq_int_type(const int_type _Left, const int_type _Right) noexcept {
        return _Left == _Right;
    }

    _NODISCARD static constexpr int_type not_eof(const int_type _Meta) noexcept {
        return _Meta != eof() ? _Meta : !eof();
    }

    _NODISCARD static constexpr int_type eof() noexcept {
        return static_cast<int_type>(EOF);
    }
};

#undef _HAS_U8_INTRINSICS
#undef _HAS_MEMCPY_MEMMOVE_INTRINSICS

template <>
struct char_traits<char> : _Narrow_char_traits<char, int> {}; // properties of a string or stream char element

#ifdef __cpp_char8_t
template <>
struct char_traits<char8_t> : _Narrow_char_traits<char8_t, unsigned int> {};
#endif // defined(__cpp_char8_t)

template <class _Elem, class _Traits, class _SizeT>
basic_ostream<_Elem, _Traits>& _Insert_string(
    basic_ostream<_Elem, _Traits>& _Ostr, const _Elem* const _Data, const _SizeT _Size) {
    // insert a character-type sequence into _Ostr as if through a basic_string copy
    using _Ostr_t = basic_ostream<_Elem, _Traits>;
    typename _Ostr_t::iostate _State = _Ostr_t::goodbit;

    _SizeT _Pad;
    if (_Ostr.width() <= 0 || static_cast<_SizeT>(_Ostr.width()) <= _Size) {
        _Pad = 0;
    }
    else {
        _Pad = static_cast<_SizeT>(_Ostr.width()) - _Size;
    }

    const typename _Ostr_t::sentry _Ok(_Ostr);

    if (!_Ok) {
        _State |= _Ostr_t::badbit;
    }
    else { // state okay, insert characters
        _TRY_IO_BEGIN
            if ((_Ostr.flags() & _Ostr_t::adjustfield) != _Ostr_t::left) {
                for (; 0 < _Pad; --_Pad) { // pad on left
                    if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                        _State |= _Ostr_t::badbit; // insertion failed, quit
                        break;
                    }
                }
            }

        if (_State == _Ostr_t::goodbit
            && _Ostr.rdbuf()->sputn(_Data, static_cast<streamsize>(_Size)) != static_cast<streamsize>(_Size)) {
            _State |= _Ostr_t::badbit;
        }
        else {
            for (; 0 < _Pad; --_Pad) { // pad on right
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= _Ostr_t::badbit; // insertion failed, quit
                    break;
                }
            }
        }

        _Ostr.width(0);
        _CATCH_IO_(_Ostr_t, _Ostr)
    }

    _Ostr.setstate(_State);
    return _Ostr;
}

template <class _Traits>
using _Traits_ch_t = typename _Traits::char_type;

template <class _Traits>
using _Traits_ptr_t = const typename _Traits::char_type*;

template <class _Traits>
constexpr bool _Traits_equal(_In_reads_(_Left_size) const _Traits_ptr_t<_Traits> _Left, const size_t _Left_size,
    _In_reads_(_Right_size) const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) noexcept {
    // compare [_Left, _Left + _Left_size) to [_Right, _Right + _Right_size) for equality using _Traits
    return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;
}

template <class _Traits>
constexpr int _Traits_compare(_In_reads_(_Left_size) const _Traits_ptr_t<_Traits> _Left, const size_t _Left_size,
    _In_reads_(_Right_size) const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) noexcept {
    // compare [_Left, _Left + _Left_size) to [_Right, _Right + _Right_size) using _Traits
    const int _Ans = _Traits::compare(_Left, _Right, (_STD min)(_Left_size, _Right_size));

    if (_Ans != 0) {
        return _Ans;
    }

    if (_Left_size < _Right_size) {
        return -1;
    }

    if (_Left_size > _Right_size) {
        return 1;
    }

    return 0;
}

template <class _Traits>
constexpr size_t _Traits_find(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size,
    const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size) noexcept {
    // search [_Haystack, _Haystack + _Hay_size) for [_Needle, _Needle + _Needle_size), at/after _Start_at
    if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size) {
        // xpos cannot exist, report failure
        // N4950 [string.view.find]/3 says:
        // 1. _Start_at <= xpos
        // 2. xpos + _Needle_size <= _Hay_size;
        // therefore:
        // 3. _Needle_size <= _Hay_size (by 2) (checked above)
        // 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
        // 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
        return static_cast<size_t>(-1);
    }

    if (_Needle_size == 0) { // empty string always matches if xpos is possible
        return _Start_at;
    }

    const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;
    for (auto _Match_try = _Haystack + _Start_at;; ++_Match_try) {
        _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);
        if (!_Match_try) { // didn't find first character; report failure
            return static_cast<size_t>(-1);
        }

        if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0) { // found match
            return static_cast<size_t>(_Match_try - _Haystack);
        }
    }
}

template <class _Traits>
constexpr size_t _Traits_find_ch(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size,
    const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept {
    // search [_Haystack, _Haystack + _Hay_size) for _Ch, at/after _Start_at
    if (_Start_at < _Hay_size) {
        const auto _Found_at = _Traits::find(_Haystack + _Start_at, _Hay_size - _Start_at, _Ch);
        if (_Found_at) {
            return static_cast<size_t>(_Found_at - _Haystack);
        }
    }

    return static_cast<size_t>(-1); // (npos) no match
}

template <class _Traits>
constexpr size_t _Traits_rfind(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size,
    const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size) noexcept {
    // search [_Haystack, _Haystack + _Hay_size) for [_Needle, _Needle + _Needle_size) beginning before _Start_at
    if (_Needle_size == 0) {
        return (_STD min)(_Start_at, _Hay_size); // empty string always matches
    }

    if (_Needle_size <= _Hay_size) { // room for match, look for it
        for (auto _Match_try = _Haystack + (_STD min)(_Start_at, _Hay_size - _Needle_size);; --_Match_try) {
            if (_Traits::eq(*_Match_try, *_Needle) && _Traits::compare(_Match_try, _Needle, _Needle_size) == 0) {
                return static_cast<size_t>(_Match_try - _Haystack); // found a match
            }

            if (_Match_try == _Haystack) {
                break; // at beginning, no more chance for match
            }
        }
    }

    return static_cast<size_t>(-1); // no match
}

template <class _Traits>
constexpr size_t _Traits_rfind_ch(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size,
    const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept {
    // search [_Haystack, _Haystack + _Hay_size) for _Ch before _Start_at
    if (_Hay_size != 0) { // room for match, look for it
        for (auto _Match_try = _Haystack + (_STD min)(_Start_at, _Hay_size - 1);; --_Match_try) {
            if (_Traits::eq(*_Match_try, _Ch)) {
                return static_cast<size_t>(_Match_try - _Haystack); // found a match
            }

            if (_Match_try == _Haystack) {
                break; // at beginning, no more chance for match
            }
        }
    }

    return static_cast<size_t>(-1); // no match
}

template <class _Elem, bool = _Is_character<_Elem>::value>
class _String_bitmap { // _String_bitmap for character types
public:
    constexpr bool _Mark(const _Elem* _First, const _Elem* const _Last) noexcept {
        // mark this bitmap such that the characters in [_First, _Last) are intended to match
        // returns whether all inputs can be placed in the bitmap
        for (; _First != _Last; ++_First) {
            _Matches[static_cast<unsigned char>(*_First)] = true;
        }

        return true;
    }

    constexpr bool _Match(const _Elem _Ch) const noexcept { // test if _Ch is in the bitmap
        return _Matches[static_cast<unsigned char>(_Ch)];
    }

private:
    bool _Matches[256] = {};
};

template <class _Elem>
class _String_bitmap<_Elem, false> { // _String_bitmap for wchar_t/unsigned short/char16_t/char32_t/etc. types
public:
    static_assert(is_unsigned_v<_Elem>,
        "Standard char_traits is only provided for char, wchar_t, char16_t, and char32_t. See N4950 [char.traits]. "
        "Visual C++ accepts other unsigned integral types as an extension.");

    constexpr bool _Mark(const _Elem* _First, const _Elem* const _Last) noexcept {
        // mark this bitmap such that the characters in [_First, _Last) are intended to match
        // returns whether all inputs can be placed in the bitmap
        for (; _First != _Last; ++_First) {
            const auto _Ch = *_First;
            if (_Ch >= 256U) {
                return false;
            }

            _Matches[static_cast<unsigned char>(_Ch)] = true;
        }

        return true;
    }

    constexpr bool _Match(const _Elem _Ch) const noexcept { // test if _Ch is in the bitmap
        return _Ch < 256U && _Matches[_Ch];
    }

private:
    bool _Matches[256] = {};
};

template <class _Traits, bool _Special = _Is_specialization_v<_Traits, char_traits>>
constexpr size_t _Traits_find_first_of(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size) noexcept {
    // in [_Haystack, _Haystack + _Hay_size), look for one of [_Needle, _Needle + _Needle_size), at/after _Start_at
    if (_Needle_size != 0 && _Start_at < _Hay_size) { // room for match, look for it
        if constexpr (_Special) {
            _String_bitmap<typename _Traits::char_type> _Matches;
            if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { // couldn't put one of the characters into the
                // bitmap, fall back to the serial algorithm
                return _Traits_find_first_of<_Traits, false>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size);
            }

            const auto _End = _Haystack + _Hay_size;
            for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
                if (_Matches._Match(*_Match_try)) {
                    return static_cast<size_t>(_Match_try - _Haystack); // found a match
                }
            }
        }
        else {
            const auto _End = _Haystack + _Hay_size;
            for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
                if (_Traits::find(_Needle, _Needle_size, *_Match_try)) {
                    return static_cast<size_t>(_Match_try - _Haystack); // found a match
                }
            }
        }
    }

    return static_cast<size_t>(-1); // no match
}

template <class _Traits, bool _Special = _Is_specialization_v<_Traits, char_traits>>
constexpr size_t _Traits_find_last_of(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size) noexcept {
    // in [_Haystack, _Haystack + _Hay_size), look for last of [_Needle, _Needle + _Needle_size), before _Start_at
    if (_Needle_size != 0 && _Hay_size != 0) { // worth searching, do it
        if constexpr (_Special) {
            _String_bitmap<typename _Traits::char_type> _Matches;
            if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { // couldn't put one of the characters into the
                // bitmap, fall back to the serial algorithm
                return _Traits_find_last_of<_Traits, false>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size);
            }

            for (auto _Match_try = _Haystack + (_STD min)(_Start_at, _Hay_size - 1);; --_Match_try) {
                if (_Matches._Match(*_Match_try)) {
                    return static_cast<size_t>(_Match_try - _Haystack); // found a match
                }

                if (_Match_try == _Haystack) {
                    break; // at beginning, no more chance for match
                }
            }
        }
        else {
            for (auto _Match_try = _Haystack + (_STD min)(_Start_at, _Hay_size - 1);; --_Match_try) {
                if (_Traits::find(_Needle, _Needle_size, *_Match_try)) {
                    return static_cast<size_t>(_Match_try - _Haystack); // found a match
                }

                if (_Match_try == _Haystack) {
                    break; // at beginning, no more chance for match
                }
            }
        }
    }

    return static_cast<size_t>(-1); // no match
}

template <class _Traits, bool _Special = _Is_specialization_v<_Traits, char_traits>>
constexpr size_t _Traits_find_first_not_of(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size) noexcept {
    // in [_Haystack, _Haystack + _Hay_size), look for none of [_Needle, _Needle + _Needle_size), at/after _Start_at
    if (_Start_at < _Hay_size) { // room for match, look for it
        if constexpr (_Special) {
            _String_bitmap<typename _Traits::char_type> _Matches;
            if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { // couldn't put one of the characters into the
                // bitmap, fall back to the serial algorithm
                return _Traits_find_first_not_of<_Traits, false>(
                    _Haystack, _Hay_size, _Start_at, _Needle, _Needle_size);
            }

            const auto _End = _Haystack + _Hay_size;
            for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
                if (!_Matches._Match(*_Match_try)) {
                    return static_cast<size_t>(_Match_try - _Haystack); // found a match
                }
            }
        }
        else {
            const auto _End = _Haystack + _Hay_size;
            for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
                if (!_Traits::find(_Needle, _Needle_size, *_Match_try)) {
                    return static_cast<size_t>(_Match_try - _Haystack); // found a match
                }
            }
        }
    }

    return static_cast<size_t>(-1); // no match
}

template <class _Traits>
constexpr size_t _Traits_find_not_ch(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept {
    // search [_Haystack, _Haystack + _Hay_size) for any value other than _Ch, at/after _Start_at
    if (_Start_at < _Hay_size) { // room for match, look for it
        const auto _End = _Haystack + _Hay_size;
        for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
            if (!_Traits::eq(*_Match_try, _Ch)) {
                return static_cast<size_t>(_Match_try - _Haystack); // found a match
            }
        }
    }

    return static_cast<size_t>(-1); // no match
}

template <class _Traits, bool _Special = _Is_specialization_v<_Traits, char_traits>>
constexpr size_t _Traits_find_last_not_of(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size) noexcept {
    // in [_Haystack, _Haystack + _Hay_size), look for none of [_Needle, _Needle + _Needle_size), before _Start_at
    if (_Hay_size != 0) { // worth searching, do it
        if constexpr (_Special) {
            _String_bitmap<typename _Traits::char_type> _Matches;
            if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { // couldn't put one of the characters into the
                // bitmap, fall back to the serial algorithm
                return _Traits_find_last_not_of<_Traits, false>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size);
            }

            for (auto _Match_try = _Haystack + (_STD min)(_Start_at, _Hay_size - 1);; --_Match_try) {
                if (!_Matches._Match(*_Match_try)) {
                    return static_cast<size_t>(_Match_try - _Haystack); // found a match
                }

                if (_Match_try == _Haystack) {
                    break; // at beginning, no more chance for match
                }
            }
        }
        else {
            for (auto _Match_try = _Haystack + (_STD min)(_Start_at, _Hay_size - 1);; --_Match_try) {
                if (!_Traits::find(_Needle, _Needle_size, *_Match_try)) {
                    return static_cast<size_t>(_Match_try - _Haystack); // found a match
                }

                if (_Match_try == _Haystack) {
                    break; // at beginning, no more chance for match
                }
            }
        }
    }

    return static_cast<size_t>(-1); // no match
}

template <class _Traits>
constexpr size_t _Traits_rfind_not_ch(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept {
    // search [_Haystack, _Haystack + _Hay_size) for any value other than _Ch before _Start_at
    if (_Hay_size != 0) { // room for match, look for it
        for (auto _Match_try = _Haystack + (_STD min)(_Start_at, _Hay_size - 1);; --_Match_try) {
            if (!_Traits::eq(*_Match_try, _Ch)) {
                return static_cast<size_t>(_Match_try - _Haystack); // found a match
            }

            if (_Match_try == _Haystack) {
                break; // at beginning, no more chance for match
            }
        }
    }

    return static_cast<size_t>(-1); // no match
}

template <class _Ty>
_INLINE_VAR constexpr bool _Is_EcharT = _Is_any_of_v<_Ty, char, wchar_t,
#ifdef __cpp_char8_t
    char8_t,
#endif // defined(__cpp_char8_t)
    char16_t, char32_t>;

#if _HAS_CXX17
_EXPORT_STD template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_string_view;

template <class _Traits>
class _String_view_iterator {
public:
#if _HAS_CXX20
    using iterator_concept = contiguous_iterator_tag;
#endif // _HAS_CXX20
    using iterator_category = random_access_iterator_tag;
    using value_type = typename _Traits::char_type;
    using difference_type = ptrdiff_t;
    using pointer = const value_type*;
    using reference = const value_type&;

    constexpr _String_view_iterator() noexcept = default;

private:
    friend basic_string_view<value_type, _Traits>;

#if _ITERATOR_DEBUG_LEVEL >= 1
    constexpr _String_view_iterator(const pointer _Data, const size_t _Size, const size_t _Off) noexcept
        : _Mydata(_Data), _Mysize(_Size), _Myoff(_Off) {}
#else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 / _ITERATOR_DEBUG_LEVEL == 0 vvv
    constexpr explicit _String_view_iterator(const pointer _Ptr) noexcept : _Myptr(_Ptr) {}
#endif // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^

public:
    _NODISCARD constexpr reference operator*() const noexcept {
#if _ITERATOR_DEBUG_LEVEL >= 1
        _STL_VERIFY(_Mydata, "cannot dereference value-initialized string_view iterator");
        _STL_VERIFY(_Myoff < _Mysize, "cannot dereference end string_view iterator");
        return _Mydata[_Myoff];
#else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 / _ITERATOR_DEBUG_LEVEL == 0 vvv
        return *_Myptr;
#endif // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^
    }

    _NODISCARD constexpr pointer operator->() const noexcept {
#if _ITERATOR_DEBUG_LEVEL >= 1
        _STL_VERIFY(_Mydata, "cannot dereference value-initialized string_view iterator");
        _STL_VERIFY(_Myoff < _Mysize, "cannot dereference end string_view iterator");
        return _Mydata + _Myoff;
#else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 / _ITERATOR_DEBUG_LEVEL == 0 vvv
        return _Myptr;
#endif // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^
    }

    constexpr _String_view_iterator& operator++() noexcept {
#if _ITERATOR_DEBUG_LEVEL >= 1
        _STL_VERIFY(_Mydata, "cannot increment value-initialized string_view iterator");
        _STL_VERIFY(_Myoff < _Mysize, "cannot increment string_view iterator past end");
        ++_Myoff;
#else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 / _ITERATOR_DEBUG_LEVEL == 0 vvv
        ++_Myptr;
#endif // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^
        return *this;
    }

    constexpr _String_view_iterator operator++(int) noexcept {
        _String_view_iterator _Tmp{ *this };
        ++*this;
        return _Tmp;
    }

    constexpr _String_view_iterator& operator--() noexcept {
#if _ITERATOR_DEBUG_LEVEL >= 1
        _STL_VERIFY(_Mydata, "cannot decrement value-initialized string_view iterator");
        _STL_VERIFY(_Myoff != 0, "cannot decrement string_view iterator before begin");
        --_Myoff;
#else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 / _ITERATOR_DEBUG_LEVEL == 0 vvv
        --_Myptr;
#endif // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^
        return *this;
    }

    constexpr _String_view_iterator operator--(int) noexcept {
        _String_view_iterator _Tmp{ *this };
        --*this;
        return _Tmp;
    }

    constexpr void _Verify_offset(const difference_type _Off) const noexcept {
#if _ITERATOR_DEBUG_LEVEL >= 1
        if (_Off != 0) {
            _STL_VERIFY(_Mydata, "cannot seek value-initialized string_view iterator");
        }

        if (_Off < 0) {
            _STL_VERIFY(
                _Myoff >= size_t{ 0 } - static_cast<size_t>(_Off), "cannot seek string_view iterator before begin");
        }

        if (_Off > 0) {
            _STL_VERIFY(_Mysize - _Myoff >= static_cast<size_t>(_Off), "cannot seek string_view iterator after end");
        }
#else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 / _ITERATOR_DEBUG_LEVEL == 0 vvv
        (void)_Off;
#endif // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^
    }

    constexpr _String_view_iterator& operator+=(const difference_type _Off) noexcept {
#if _ITERATOR_DEBUG_LEVEL >= 1
        _Verify_offset(_Off);
        _Myoff += static_cast<size_t>(_Off);
#else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 / _ITERATOR_DEBUG_LEVEL == 0 vvv
        _Myptr += _Off;
#endif // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^

        return *this;
    }

    _NODISCARD constexpr _String_view_iterator operator+(const difference_type _Off) const noexcept {
        _String_view_iterator _Tmp{ *this };
        _Tmp += _Off;
        return _Tmp;
    }

    _NODISCARD_FRIEND constexpr _String_view_iterator operator+(
        const difference_type _Off, _String_view_iterator _Right) noexcept {
        _Right += _Off;
        return _Right;
    }

    constexpr _String_view_iterator& operator-=(const difference_type _Off) noexcept {
#if _ITERATOR_DEBUG_LEVEL >= 1
        if (_Off != 0) {
            _STL_VERIFY(_Mydata, "cannot seek value-initialized string_view iterator");
        }

        if (_Off > 0) {
            _STL_VERIFY(_Myoff >= static_cast<size_t>(_Off), "cannot seek string_view iterator before begin");
        }

        if (_Off < 0) {
            _STL_VERIFY(_Mysize - _Myoff >= size_t{ 0 } - static_cast<size_t>(_Off),
                "cannot seek string_view iterator after end");
        }

        _Myoff -= static_cast<size_t>(_Off);
#else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 / _ITERATOR_DEBUG_LEVEL == 0 vvv
        _Myptr -= _Off;
#endif // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^

        return *this;
    }

    _NODISCARD constexpr _String_view_iterator operator-(const difference_type _Off) const noexcept {
        _String_view_iterator _Tmp{ *this };
        _Tmp -= _Off;
        return _Tmp;
    }

    _NODISCARD constexpr difference_type operator-(const _String_view_iterator& _Right) const noexcept {
#if _ITERATOR_DEBUG_LEVEL >= 1
        _STL_VERIFY(_Mydata == _Right._Mydata && _Mysize == _Right._Mysize,
            "cannot subtract incompatible string_view iterators");
        return static_cast<difference_type>(_Myoff - _Right._Myoff);
#else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 / _ITERATOR_DEBUG_LEVEL == 0 vvv
        return _Myptr - _Right._Myptr;
#endif // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^
    }

    _NODISCARD constexpr reference operator[](const difference_type _Off) const noexcept {
        return *(*this + _Off);
    }

    _NODISCARD constexpr bool operator==(const _String_view_iterator& _Right) const noexcept {
#if _ITERATOR_DEBUG_LEVEL >= 1
        _STL_VERIFY(_Mydata == _Right._Mydata && _Mysize == _Right._Mysize,
            "cannot compare incompatible string_view iterators for equality");
        return _Myoff == _Right._Myoff;
#else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 / _ITERATOR_DEBUG_LEVEL == 0 vvv
        return _Myptr == _Right._Myptr;
#endif // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^
    }

#if _HAS_CXX20
    _NODISCARD constexpr strong_ordering operator<=>(const _String_view_iterator& _Right) const noexcept {
#if _ITERATOR_DEBUG_LEVEL >= 1
        _STL_VERIFY(_Mydata == _Right._Mydata && _Mysize == _Right._Mysize,
            "cannot compare incompatible string_view iterators");
        return _Myoff <=> _Right._Myoff;
#else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 / _ITERATOR_DEBUG_LEVEL == 0 vvv
        return _Myptr <=> _Right._Myptr;
#endif // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^
    }
#else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
    _NODISCARD constexpr bool operator!=(const _String_view_iterator& _Right) const noexcept {
        return !(*this == _Right);
    }

    _NODISCARD constexpr bool operator<(const _String_view_iterator& _Right) const noexcept {
#if _ITERATOR_DEBUG_LEVEL >= 1
        _STL_VERIFY(_Mydata == _Right._Mydata && _Mysize == _Right._Mysize,
            "cannot compare incompatible string_view iterators");
        return _Myoff < _Right._Myoff;
#else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 / _ITERATOR_DEBUG_LEVEL == 0 vvv
        return _Myptr < _Right._Myptr;
#endif // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^
    }

    _NODISCARD constexpr bool operator>(const _String_view_iterator& _Right) const noexcept {
        return _Right < *this;
    }

    _NODISCARD constexpr bool operator<=(const _String_view_iterator& _Right) const noexcept {
        return !(_Right < *this);
    }

    _NODISCARD constexpr bool operator>=(const _String_view_iterator& _Right) const noexcept {
        return !(*this < _Right);
    }
#endif // !_HAS_CXX20

#if _ITERATOR_DEBUG_LEVEL >= 1
    friend constexpr void _Verify_range(const _String_view_iterator& _First, const _String_view_iterator& _Last) {
        _STL_VERIFY(_First._Mydata == _Last._Mydata && _First._Mysize == _Last._Mysize,
            "string_view iterators in range are from different views");
        _STL_VERIFY(_First._Myoff <= _Last._Myoff, "string_view iterator range transposed");
    }
#endif // _ITERATOR_DEBUG_LEVEL >= 1

    using _Prevent_inheriting_unwrap = _String_view_iterator;

    _NODISCARD constexpr pointer _Unwrapped() const noexcept {
#if _ITERATOR_DEBUG_LEVEL >= 1
        return _Mydata + _Myoff;
#else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 / _ITERATOR_DEBUG_LEVEL == 0 vvv
        return _Myptr;
#endif // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^
    }

    static constexpr bool _Unwrap_when_unverified = _ITERATOR_DEBUG_LEVEL == 0;

    constexpr void _Seek_to(pointer _It) noexcept {
#if _ITERATOR_DEBUG_LEVEL >= 1
        _Myoff = static_cast<size_t>(_It - _Mydata);
#else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 / _ITERATOR_DEBUG_LEVEL == 0 vvv
        _Myptr = _It;
#endif // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^
    }

private:
#if _ITERATOR_DEBUG_LEVEL >= 1
    pointer _Mydata = nullptr;
    size_t _Mysize = 0;
    size_t _Myoff = 0;
#else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 / _ITERATOR_DEBUG_LEVEL == 0 vvv
    pointer _Myptr = nullptr;
#endif // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^
};

#if _HAS_CXX20
template <class _Traits>
struct pointer_traits<_String_view_iterator<_Traits>> {
    using pointer = _String_view_iterator<_Traits>;
    using element_type = const pointer::value_type;
    using difference_type = pointer::difference_type;

    _NODISCARD static constexpr element_type* to_address(const pointer& _Iter) noexcept {
        return _Iter._Unwrapped();
    }
};
#endif // _HAS_CXX20

#pragma warning(push)
// Invalid annotation: 'NullTerminated' property may only be used on buffers whose elements are of integral or pointer
// type
#pragma warning(disable : 6510)

_EXPORT_STD template <class _Elem, class _Traits>
class basic_string_view { // wrapper for any kind of contiguous character buffer
public:
    static_assert(is_same_v<_Elem, typename _Traits::char_type>,
        "Bad char_traits for basic_string_view; N4950 [string.view.template.general]/1 "
        "\"The program is ill-formed if traits::char_type is not the same type as charT.\"");

    static_assert(!is_array_v<_Elem>&& is_trivial_v<_Elem>&& is_standard_layout_v<_Elem>,
        "The character type of basic_string_view must be a non-array trivial standard-layout type. See N4950 "
        "[strings.general]/1.");

    using traits_type = _Traits;
    using value_type = _Elem;
    using pointer = _Elem*;
    using const_pointer = const _Elem*;
    using reference = _Elem&;
    using const_reference = const _Elem&;
    using const_iterator = _String_view_iterator<_Traits>;
    using iterator = const_iterator;
    using const_reverse_iterator = _STD reverse_iterator<const_iterator>;
    using reverse_iterator = const_reverse_iterator;
    using size_type = size_t;
    using difference_type = ptrdiff_t;

    static constexpr auto npos{ static_cast<size_type>(-1) };

    constexpr basic_string_view() noexcept : _Mydata(), _Mysize(0) {}

    constexpr basic_string_view(const basic_string_view&) noexcept = default;
    constexpr basic_string_view& operator=(const basic_string_view&) noexcept = default;

    /* implicit */ constexpr basic_string_view(_In_z_ const const_pointer _Ntcts) noexcept // strengthened
        : _Mydata(_Ntcts), _Mysize(_Traits::length(_Ntcts)) {}

#if _HAS_CXX23
    basic_string_view(nullptr_t) = delete;
#endif // _HAS_CXX23

    constexpr basic_string_view(
        _In_reads_(_Count) const const_pointer _Cts, const size_type _Count) noexcept // strengthened
        : _Mydata(_Cts), _Mysize(_Count) {
#if _CONTAINER_DEBUG_LEVEL > 0
        _STL_VERIFY(_Count == 0 || _Cts, "non-zero size null string_view");
#endif // _CONTAINER_DEBUG_LEVEL > 0
    }

#if _HAS_CXX20
    template <contiguous_iterator _Iter, sized_sentinel_for<_Iter> _Sent>
        requires (is_same_v<iter_value_t<_Iter>, _Elem> && !is_convertible_v<_Sent, size_type>)
    constexpr basic_string_view(_Iter _First, _Sent _Last) noexcept(noexcept(_Last - _First)) // strengthened
        : _Mydata(_STD to_address(_First)), _Mysize(static_cast<size_type>(_Last - _First)) {}

#if _HAS_CXX23
    // clang-format off
    template <class _Range>
        requires (!same_as<remove_cvref_t<_Range>, basic_string_view>
    && _RANGES contiguous_range<_Range>
        && _RANGES sized_range<_Range>
        && same_as<_RANGES range_value_t<_Range>, _Elem>
        && !is_convertible_v<_Range, const _Elem*>
        && !requires(remove_cvref_t<_Range>& _Rng) {
        _Rng.operator _STD basic_string_view<_Elem, _Traits>();
    })
        constexpr explicit basic_string_view(_Range&& _Rng) noexcept(
            noexcept(_RANGES data(_Rng)) && noexcept(_RANGES size(_Rng))) // strengthened
        : _Mydata(_RANGES data(_Rng)), _Mysize(static_cast<size_t>(_RANGES size(_Rng))) {}
    // clang-format on
#endif // _HAS_CXX23
#endif // _HAS_CXX20

    _NODISCARD constexpr const_iterator begin() const noexcept {
#if _ITERATOR_DEBUG_LEVEL >= 1
        return const_iterator(_Mydata, _Mysize, 0);
#else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 / _ITERATOR_DEBUG_LEVEL == 0 vvv
        return const_iterator(_Mydata);
#endif // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^
    }

    _NODISCARD constexpr const_iterator end() const noexcept {
#if _ITERATOR_DEBUG_LEVEL >= 1
        return const_iterator(_Mydata, _Mysize, _Mysize);
#else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 / _ITERATOR_DEBUG_LEVEL == 0 vvv
        return const_iterator(_Mydata + _Mysize);
#endif // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^
    }

    _NODISCARD constexpr const_iterator cbegin() const noexcept {
        return begin();
    }

    _NODISCARD constexpr const_iterator cend() const noexcept {
        return end();
    }

    _NODISCARD constexpr const_reverse_iterator rbegin() const noexcept {
        return const_reverse_iterator{ end() };
    }

    _NODISCARD constexpr const_reverse_iterator rend() const noexcept {
        return const_reverse_iterator{ begin() };
    }

    _NODISCARD constexpr const_reverse_iterator crbegin() const noexcept {
        return rbegin();
    }

    _NODISCARD constexpr const_reverse_iterator crend() const noexcept {
        return rend();
    }

    constexpr const_pointer _Unchecked_begin() const noexcept {
        return _Mydata;
    }

    constexpr const_pointer _Unchecked_end() const noexcept {
        return _Mydata + _Mysize;
    }

    _NODISCARD constexpr size_type size() const noexcept {
        return _Mysize;
    }

    _NODISCARD constexpr size_type length() const noexcept {
        return _Mysize;
    }

    _NODISCARD constexpr bool empty() const noexcept {
        return _Mysize == 0;
    }

    _NODISCARD constexpr const_pointer data() const noexcept {
        return _Mydata;
    }

    _NODISCARD constexpr size_type max_size() const noexcept {
        // bound to PTRDIFF_MAX to make end() - begin() well defined (also makes room for npos)
        // bound to static_cast<size_t>(-1) / sizeof(_Elem) by address space limits
        return (_STD min)(static_cast<size_t>(PTRDIFF_MAX), static_cast<size_t>(-1) / sizeof(_Elem));
    }

    _NODISCARD constexpr const_reference operator[](const size_type _Off) const noexcept /* strengthened */ {
#if _CONTAINER_DEBUG_LEVEL > 0
        _STL_VERIFY(_Off < _Mysize, "string_view subscript out of range");
#endif // _CONTAINER_DEBUG_LEVEL > 0
        return _Mydata[_Off];
    }

    _NODISCARD constexpr const_reference at(const size_type _Off) const {
        // get the character at _Off or throw if that is out of range
        _Check_offset_exclusive(_Off);
        return _Mydata[_Off];
    }

    _NODISCARD constexpr const_reference front() const noexcept /* strengthened */ {
#if _CONTAINER_DEBUG_LEVEL > 0
        _STL_VERIFY(_Mysize != 0, "cannot call front on empty string_view");
#endif // _CONTAINER_DEBUG_LEVEL > 0
        return _Mydata[0];
    }

    _NODISCARD constexpr const_reference back() const noexcept /* strengthened */ {
#if _CONTAINER_DEBUG_LEVEL > 0
        _STL_VERIFY(_Mysize != 0, "cannot call back on empty string_view");
#endif // _CONTAINER_DEBUG_LEVEL > 0
        return _Mydata[_Mysize - 1];
    }

    constexpr void remove_prefix(const size_type _Count) noexcept /* strengthened */ {
#if _CONTAINER_DEBUG_LEVEL > 0
        _STL_VERIFY(_Mysize >= _Count, "cannot remove prefix longer than total size");
#endif // _CONTAINER_DEBUG_LEVEL > 0
        _Mydata += _Count;
        _Mysize -= _Count;
    }

    constexpr void remove_suffix(const size_type _Count) noexcept /* strengthened */ {
#if _CONTAINER_DEBUG_LEVEL > 0
        _STL_VERIFY(_Mysize >= _Count, "cannot remove suffix longer than total size");
#endif // _CONTAINER_DEBUG_LEVEL > 0
        _Mysize -= _Count;
    }

    constexpr void swap(basic_string_view& _Other) noexcept {
        const basic_string_view _Tmp{ _Other }; // note: std::swap is not constexpr before C++20
        _Other = *this;
        *this = _Tmp;
    }

    _CONSTEXPR20 size_type copy(
        _Out_writes_(_Count) _Elem* const _Ptr, size_type _Count, const size_type _Off = 0) const {
        // copy [_Off, _Off + Count) to [_Ptr, _Ptr + _Count)
        _Check_offset(_Off);
        _Count = _Clamp_suffix_size(_Off, _Count);
        _Traits::copy(_Ptr, _Mydata + _Off, _Count);
        return _Count;
    }

    _Pre_satisfies_(_Dest_size >= _Count) _CONSTEXPR20 size_type
        _Copy_s(_Out_writes_all_(_Dest_size) _Elem* const _Dest, const size_type _Dest_size, size_type _Count,
            const size_type _Off = 0) const {
        // copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
        _Check_offset(_Off);
        _Count = _Clamp_suffix_size(_Off, _Count);
        _Traits::_Copy_s(_Dest, _Dest_size, _Mydata + _Off, _Count);
        return _Count;
    }

    _NODISCARD constexpr basic_string_view substr(const size_type _Off = 0, size_type _Count = npos) const {
        // return a new basic_string_view moved forward by _Off and trimmed to _Count elements
        _Check_offset(_Off);
        _Count = _Clamp_suffix_size(_Off, _Count);
        return basic_string_view(_Mydata + _Off, _Count);
    }

    constexpr bool _Equal(const basic_string_view _Right) const noexcept {
        return _Traits_equal<_Traits>(_Mydata, _Mysize, _Right._Mydata, _Right._Mysize);
    }

    _NODISCARD constexpr int compare(const basic_string_view _Right) const noexcept {
        return _Traits_compare<_Traits>(_Mydata, _Mysize, _Right._Mydata, _Right._Mysize);
    }

    _NODISCARD constexpr int compare(const size_type _Off, const size_type _Nx, const basic_string_view _Right) const {
        // compare [_Off, _Off + _Nx) with _Right
        return substr(_Off, _Nx).compare(_Right);
    }

    _NODISCARD constexpr int compare(const size_type _Off, const size_type _Nx, const basic_string_view _Right,
        const size_type _Roff, const size_type _Count) const {
        // compare [_Off, _Off + _Nx) with _Right [_Roff, _Roff + _Count)
        return substr(_Off, _Nx).compare(_Right.substr(_Roff, _Count));
    }

    _NODISCARD constexpr int compare(_In_z_ const _Elem* const _Ptr) const noexcept /* strengthened */ {
        // compare [0, _Mysize) with [_Ptr, <null>)
        return compare(basic_string_view(_Ptr));
    }

    _NODISCARD constexpr int compare(const size_type _Off, const size_type _Nx, _In_z_ const _Elem* const _Ptr) const {
        // compare [_Off, _Off + _Nx) with [_Ptr, <null>)
        return substr(_Off, _Nx).compare(basic_string_view(_Ptr));
    }

    _NODISCARD constexpr int compare(const size_type _Off, const size_type _Nx,
        _In_reads_(_Count) const _Elem* const _Ptr, const size_type _Count) const {
        // compare [_Off, _Off + _Nx) with [_Ptr, _Ptr + _Count)
        return substr(_Off, _Nx).compare(basic_string_view(_Ptr, _Count));
    }

#if _HAS_CXX20
    _NODISCARD constexpr bool starts_with(const basic_string_view _Right) const noexcept {
        const auto _Rightsize = _Right._Mysize;
        if (_Mysize < _Rightsize) {
            return false;
        }
        return _Traits::compare(_Mydata, _Right._Mydata, _Rightsize) == 0;
    }

    _NODISCARD constexpr bool starts_with(const _Elem _Right) const noexcept {
        return !empty() && _Traits::eq(front(), _Right);
    }

    _NODISCARD constexpr bool starts_with(const _Elem* const _Right) const noexcept /* strengthened */ {
        return starts_with(basic_string_view(_Right));
    }

    _NODISCARD constexpr bool ends_with(const basic_string_view _Right) const noexcept {
        const auto _Rightsize = _Right._Mysize;
        if (_Mysize < _Rightsize) {
            return false;
        }
        return _Traits::compare(_Mydata + (_Mysize - _Rightsize), _Right._Mydata, _Rightsize) == 0;
    }

    _NODISCARD constexpr bool ends_with(const _Elem _Right) const noexcept {
        return !empty() && _Traits::eq(back(), _Right);
    }

    _NODISCARD constexpr bool ends_with(const _Elem* const _Right) const noexcept /* strengthened */ {
        return ends_with(basic_string_view(_Right));
    }
#endif // _HAS_CXX20

#if _HAS_CXX23
    _NODISCARD constexpr bool contains(const basic_string_view _Right) const noexcept {
        return find(_Right) != npos;
    }

    _NODISCARD constexpr bool contains(const _Elem _Right) const noexcept {
        return find(_Right) != npos;
    }

    _NODISCARD constexpr bool contains(const _Elem* const _Right) const noexcept /* strengthened */ {
        return find(_Right) != npos;
    }
#endif // _HAS_CXX23

    _NODISCARD constexpr size_type find(const basic_string_view _Right, const size_type _Off = 0) const noexcept {
        // look for _Right beginning at or after _Off
        return _Traits_find<_Traits>(_Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize);
    }

    _NODISCARD constexpr size_type find(const _Elem _Ch, const size_type _Off = 0) const noexcept {
        // look for _Ch at or after _Off
        return _Traits_find_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch);
    }

    _NODISCARD constexpr size_type find(_In_reads_(_Count) const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept /* strengthened */ {
        // look for [_Ptr, _Ptr + _Count) beginning at or after _Off
        return _Traits_find<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Count);
    }

    _NODISCARD constexpr size_type find(_In_z_ const _Elem* const _Ptr, const size_type _Off = 0) const noexcept
        /* strengthened */ {
        // look for [_Ptr, <null>) beginning at or after _Off
        return _Traits_find<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr));
    }

    _NODISCARD constexpr size_type rfind(const basic_string_view _Right, const size_type _Off = npos) const noexcept {
        // look for _Right beginning before _Off
        return _Traits_rfind<_Traits>(_Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize);
    }

    _NODISCARD constexpr size_type rfind(const _Elem _Ch, const size_type _Off = npos) const noexcept {
        // look for _Ch before _Off
        return _Traits_rfind_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch);
    }

    _NODISCARD constexpr size_type rfind(_In_reads_(_Count) const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept /* strengthened */ {
        // look for [_Ptr, _Ptr + _Count) beginning before _Off
        return _Traits_rfind<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Count);
    }

    _NODISCARD constexpr size_type rfind(_In_z_ const _Elem* const _Ptr, const size_type _Off = npos) const noexcept
        /* strengthened */ {
        // look for [_Ptr, <null>) beginning before _Off
        return _Traits_rfind<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr));
    }

    _NODISCARD constexpr size_type find_first_of(const basic_string_view _Right,
        const size_type _Off = 0) const noexcept { // look for one of _Right at or after _Off
        return _Traits_find_first_of<_Traits>(_Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize);
    }

    _NODISCARD constexpr size_type find_first_of(const _Elem _Ch, const size_type _Off = 0) const noexcept {
        // look for _Ch at or after _Off
        return _Traits_find_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch);
    }

    _NODISCARD constexpr size_type find_first_of(_In_reads_(_Count) const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept /* strengthened */ {
        // look for one of [_Ptr, _Ptr + _Count) at or after _Off
        return _Traits_find_first_of<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Count);
    }

    _NODISCARD constexpr size_type find_first_of(
        _In_z_ const _Elem* const _Ptr, const size_type _Off = 0) const noexcept /* strengthened */ {
        // look for one of [_Ptr, <null>) at or after _Off
        return _Traits_find_first_of<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr));
    }

    _NODISCARD constexpr size_type find_last_of(const basic_string_view _Right,
        const size_type _Off = npos) const noexcept { // look for one of _Right before _Off
        return _Traits_find_last_of<_Traits>(_Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize);
    }

    _NODISCARD constexpr size_type find_last_of(const _Elem _Ch, const size_type _Off = npos) const noexcept {
        // look for _Ch before _Off
        return _Traits_rfind_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch);
    }

    _NODISCARD constexpr size_type find_last_of(_In_reads_(_Count) const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept /* strengthened */ {
        // look for one of [_Ptr, _Ptr + _Count) before _Off
        return _Traits_find_last_of<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Count);
    }

    _NODISCARD constexpr size_type find_last_of(
        _In_z_ const _Elem* const _Ptr, const size_type _Off = npos) const noexcept /* strengthened */ {
        // look for one of [_Ptr, <null>) before _Off
        return _Traits_find_last_of<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr));
    }

    _NODISCARD constexpr size_type find_first_not_of(const basic_string_view _Right,
        const size_type _Off = 0) const noexcept { // look for none of _Right at or after _Off
        return _Traits_find_first_not_of<_Traits>(_Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize);
    }

    _NODISCARD constexpr size_type find_first_not_of(const _Elem _Ch, const size_type _Off = 0) const noexcept {
        // look for any value other than _Ch at or after _Off
        return _Traits_find_not_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch);
    }

    _NODISCARD constexpr size_type find_first_not_of(_In_reads_(_Count) const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept /* strengthened */ {
        // look for none of [_Ptr, _Ptr + _Count) at or after _Off
        return _Traits_find_first_not_of<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Count);
    }

    _NODISCARD constexpr size_type find_first_not_of(
        _In_z_ const _Elem* const _Ptr, const size_type _Off = 0) const noexcept /* strengthened */ {
        // look for none of [_Ptr, <null>) at or after _Off
        return _Traits_find_first_not_of<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr));
    }

    _NODISCARD constexpr size_type find_last_not_of(const basic_string_view _Right,
        const size_type _Off = npos) const noexcept { // look for none of _Right before _Off
        return _Traits_find_last_not_of<_Traits>(_Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize);
    }

    _NODISCARD constexpr size_type find_last_not_of(const _Elem _Ch, const size_type _Off = npos) const noexcept {
        // look for any value other than _Ch before _Off
        return _Traits_rfind_not_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch);
    }

    _NODISCARD constexpr size_type find_last_not_of(_In_reads_(_Count) const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept /* strengthened */ {
        // look for none of [_Ptr, _Ptr + _Count) before _Off
        return _Traits_find_last_not_of<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Count);
    }

    _NODISCARD constexpr size_type find_last_not_of(
        _In_z_ const _Elem* const _Ptr, const size_type _Off = npos) const noexcept /* strengthened */ {
        // look for none of [_Ptr, <null>) before _Off
        return _Traits_find_last_not_of<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr));
    }

    _NODISCARD constexpr bool _Starts_with(const basic_string_view _View) const noexcept {
        return _Mysize >= _View._Mysize && _Traits::compare(_Mydata, _View._Mydata, _View._Mysize) == 0;
    }

private:
    constexpr void _Check_offset(const size_type _Off) const { // checks whether _Off is in the bounds of [0, size()]
        if (_Mysize < _Off) {
            _Xran();
        }
    }

    constexpr void _Check_offset_exclusive(const size_type _Off) const {
        // checks whether _Off is in the bounds of [0, size())
        if (_Mysize <= _Off) {
            _Xran();
        }
    }

    constexpr size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {
        // trims _Size to the longest it can be assuming a string at/after _Off
        return (_STD min)(_Size, _Mysize - _Off);
    }

    [[noreturn]] static void _Xran() {
        _Xout_of_range("invalid string_view position");
    }

    const_pointer _Mydata;
    size_type _Mysize;
};

#pragma warning(pop)

#if _HAS_CXX20
template <contiguous_iterator _Iter, sized_sentinel_for<_Iter> _Sent>
basic_string_view(_Iter, _Sent) -> basic_string_view<iter_value_t<_Iter>>;

#if _HAS_CXX23
template <_RANGES contiguous_range _Range>
basic_string_view(_Range&&) -> basic_string_view<_RANGES range_value_t<_Range>>;
#endif // _HAS_CXX23

namespace ranges {
    template <class _Elem, class _Traits>
    inline constexpr bool enable_view<basic_string_view<_Elem, _Traits>> = true;
    template <class _Elem, class _Traits>
    inline constexpr bool enable_borrowed_range<basic_string_view<_Elem, _Traits>> = true;
} // namespace ranges
#endif // _HAS_CXX20

_EXPORT_STD template <class _Elem, class _Traits>
_NODISCARD constexpr bool operator==(
    const basic_string_view<_Elem, _Traits> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
    return _Lhs._Equal(_Rhs);
}

#if !_HAS_CXX20
template <class _Elem, class _Traits, int = 1> // TRANSITION, VSO-409326
_NODISCARD constexpr bool operator==(
    const _Identity_t<basic_string_view<_Elem, _Traits>> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
    return _Lhs._Equal(_Rhs);
}
#endif // !_HAS_CXX20

_EXPORT_STD template <class _Elem, class _Traits, int = 2> // TRANSITION, VSO-409326
_NODISCARD constexpr bool operator==(
    const basic_string_view<_Elem, _Traits> _Lhs, const _Identity_t<basic_string_view<_Elem, _Traits>> _Rhs) noexcept {
    return _Lhs._Equal(_Rhs);
}

#if !_HAS_CXX20
template <class _Elem, class _Traits>
_NODISCARD constexpr bool operator!=(
    const basic_string_view<_Elem, _Traits> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
    return !_Lhs._Equal(_Rhs);
}

template <class _Elem, class _Traits, int = 1> // TRANSITION, VSO-409326
_NODISCARD constexpr bool operator!=(
    const _Identity_t<basic_string_view<_Elem, _Traits>> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
    return !_Lhs._Equal(_Rhs);
}

template <class _Elem, class _Traits, int = 2> // TRANSITION, VSO-409326
_NODISCARD constexpr bool operator!=(
    const basic_string_view<_Elem, _Traits> _Lhs, const _Identity_t<basic_string_view<_Elem, _Traits>> _Rhs) noexcept {
    return !_Lhs._Equal(_Rhs);
}

template <class _Elem, class _Traits>
_NODISCARD constexpr bool operator<(
    const basic_string_view<_Elem, _Traits> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
    return _Lhs.compare(_Rhs) < 0;
}

template <class _Elem, class _Traits, int = 1> // TRANSITION, VSO-409326
_NODISCARD constexpr bool operator<(
    const _Identity_t<basic_string_view<_Elem, _Traits>> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
    return _Lhs.compare(_Rhs) < 0;
}

template <class _Elem, class _Traits, int = 2> // TRANSITION, VSO-409326
_NODISCARD constexpr bool operator<(
    const basic_string_view<_Elem, _Traits> _Lhs, const _Identity_t<basic_string_view<_Elem, _Traits>> _Rhs) noexcept {
    return _Lhs.compare(_Rhs) < 0;
}

template <class _Elem, class _Traits>
_NODISCARD constexpr bool operator>(
    const basic_string_view<_Elem, _Traits> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
    return _Lhs.compare(_Rhs) > 0;
}

template <class _Elem, class _Traits, int = 1> // TRANSITION, VSO-409326
_NODISCARD constexpr bool operator>(
    const _Identity_t<basic_string_view<_Elem, _Traits>> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
    return _Lhs.compare(_Rhs) > 0;
}

template <class _Elem, class _Traits, int = 2> // TRANSITION, VSO-409326
_NODISCARD constexpr bool operator>(
    const basic_string_view<_Elem, _Traits> _Lhs, const _Identity_t<basic_string_view<_Elem, _Traits>> _Rhs) noexcept {
    return _Lhs.compare(_Rhs) > 0;
}

template <class _Elem, class _Traits>
_NODISCARD constexpr bool operator<=(
    const basic_string_view<_Elem, _Traits> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
    return _Lhs.compare(_Rhs) <= 0;
}

template <class _Elem, class _Traits, int = 1> // TRANSITION, VSO-409326
_NODISCARD constexpr bool operator<=(
    const _Identity_t<basic_string_view<_Elem, _Traits>> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
    return _Lhs.compare(_Rhs) <= 0;
}

template <class _Elem, class _Traits, int = 2> // TRANSITION, VSO-409326
_NODISCARD constexpr bool operator<=(
    const basic_string_view<_Elem, _Traits> _Lhs, const _Identity_t<basic_string_view<_Elem, _Traits>> _Rhs) noexcept {
    return _Lhs.compare(_Rhs) <= 0;
}

template <class _Elem, class _Traits>
_NODISCARD constexpr bool operator>=(
    const basic_string_view<_Elem, _Traits> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
    return _Lhs.compare(_Rhs) >= 0;
}

template <class _Elem, class _Traits, int = 1> // TRANSITION, VSO-409326
_NODISCARD constexpr bool operator>=(
    const _Identity_t<basic_string_view<_Elem, _Traits>> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
    return _Lhs.compare(_Rhs) >= 0;
}

template <class _Elem, class _Traits, int = 2> // TRANSITION, VSO-409326
_NODISCARD constexpr bool operator>=(
    const basic_string_view<_Elem, _Traits> _Lhs, const _Identity_t<basic_string_view<_Elem, _Traits>> _Rhs) noexcept {
    return _Lhs.compare(_Rhs) >= 0;
}
#endif // !_HAS_CXX20

#if _HAS_CXX20
template <class _Traits, class = void>
struct _Get_comparison_category {
    using type = weak_ordering;
};

template <class _Traits>
struct _Get_comparison_category<_Traits, void_t<typename _Traits::comparison_category>> {
    using type = _Traits::comparison_category;

    static_assert(_Is_any_of_v<type, partial_ordering, weak_ordering, strong_ordering>,
        "N4950 [string.view.comparison]/4: Mandates: R denotes a comparison category type.");
};

template <class _Traits>
using _Get_comparison_category_t = _Get_comparison_category<_Traits>::type;

_EXPORT_STD template <class _Elem, class _Traits>
_NODISCARD constexpr _Get_comparison_category_t<_Traits> operator<=>(
    const basic_string_view<_Elem, _Traits> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
    return static_cast<_Get_comparison_category_t<_Traits>>(_Lhs.compare(_Rhs) <=> 0);
}

_EXPORT_STD template <class _Elem, class _Traits, int = 2> // TRANSITION, VSO-409326
_NODISCARD constexpr _Get_comparison_category_t<_Traits> operator<=>(
    const basic_string_view<_Elem, _Traits> _Lhs, const _Identity_t<basic_string_view<_Elem, _Traits>> _Rhs) noexcept {
    return static_cast<_Get_comparison_category_t<_Traits>>(_Lhs.compare(_Rhs) <=> 0);
}
#endif // _HAS_CXX20

_EXPORT_STD using string_view = basic_string_view<char>;
#ifdef __cpp_lib_char8_t
_EXPORT_STD using u8string_view = basic_string_view<char8_t>;
#endif // defined(__cpp_lib_char8_t)
_EXPORT_STD using u16string_view = basic_string_view<char16_t>;
_EXPORT_STD using u32string_view = basic_string_view<char32_t>;
_EXPORT_STD using wstring_view = basic_string_view<wchar_t>;

template <class _Elem>
struct hash<basic_string_view<_Elem>> : _Conditionally_enabled_hash<basic_string_view<_Elem>, _Is_EcharT<_Elem>> {
    _NODISCARD static size_t _Do_hash(const basic_string_view<_Elem> _Keyval) noexcept {
        return _Hash_array_representation(_Keyval.data(), _Keyval.size());
    }
};

_EXPORT_STD template <class _Elem, class _Traits>
basic_ostream<_Elem, _Traits>& operator<<(
    basic_ostream<_Elem, _Traits>& _Ostr, const basic_string_view<_Elem, _Traits> _Str) {
    return _Insert_string(_Ostr, _Str.data(), _Str.size());
}

inline namespace literals {
    inline namespace string_view_literals {
        _EXPORT_STD _NODISCARD constexpr string_view operator""sv(const char* _Str, size_t _Len) noexcept {
            return string_view(_Str, _Len);
        }

        _EXPORT_STD _NODISCARD constexpr wstring_view operator""sv(const wchar_t* _Str, size_t _Len) noexcept {
            return wstring_view(_Str, _Len);
        }

#ifdef __cpp_char8_t
        _EXPORT_STD _NODISCARD constexpr basic_string_view<char8_t> operator""sv(
            const char8_t* _Str, size_t _Len) noexcept {
            return basic_string_view<char8_t>(_Str, _Len);
        }
#endif // defined(__cpp_char8_t)

        _EXPORT_STD _NODISCARD constexpr u16string_view operator""sv(const char16_t* _Str, size_t _Len) noexcept {
            return u16string_view(_Str, _Len);
        }

        _EXPORT_STD _NODISCARD constexpr u32string_view operator""sv(const char32_t* _Str, size_t _Len) noexcept {
            return u32string_view(_Str, _Len);
        }
    } // namespace string_view_literals
} // namespace literals
#endif // _HAS_CXX17

template <class _Mystr>
class _String_const_iterator : public _Iterator_base {
public:
#if _HAS_CXX20
    using iterator_concept = contiguous_iterator_tag;
#endif // _HAS_CXX20
    using iterator_category = random_access_iterator_tag;
    using value_type = typename _Mystr::value_type;
    using difference_type = typename _Mystr::difference_type;
    using pointer = typename _Mystr::const_pointer;
    using reference = const value_type&;

    _CONSTEXPR20 _String_const_iterator() noexcept : _Ptr() {}

    _CONSTEXPR20 _String_const_iterator(pointer _Parg, const _Container_base* _Pstring) noexcept : _Ptr(_Parg) {
        this->_Adopt(_Pstring);
    }

    _NODISCARD _CONSTEXPR20 reference operator*() const noexcept {
#if _ITERATOR_DEBUG_LEVEL >= 1
        _STL_VERIFY(_Ptr, "cannot dereference value-initialized string iterator");
        const auto _Mycont = static_cast<const _Mystr*>(this->_Getcont());
        _STL_VERIFY(_Mycont, "cannot dereference string iterator because the iterator was "
            "invalidated (e.g. reallocation occurred, or the string was destroyed)");
        const auto _Contptr = _Mycont->_Myptr();
        const auto _Rawptr = _Unfancy(_Ptr);
        _STL_VERIFY(_Contptr <= _Rawptr && _Rawptr < _Contptr + _Mycont->_Mysize,
            "cannot dereference string iterator because it is out of range (e.g. an end iterator)");
#endif // _ITERATOR_DEBUG_LEVEL >= 1

        _Analysis_assume_(_Ptr);
        return *_Ptr;
    }

    _NODISCARD _CONSTEXPR20 pointer operator->() const noexcept {
        return pointer_traits<pointer>::pointer_to(**this);
    }

    _CONSTEXPR20 _String_const_iterator& operator++() noexcept {
#if _ITERATOR_DEBUG_LEVEL >= 1
        _STL_VERIFY(_Ptr, "cannot increment value-initialized string iterator");
        const auto _Mycont = static_cast<const _Mystr*>(this->_Getcont());
        _STL_VERIFY(_Mycont, "cannot increment string iterator because the iterator was "
            "invalidated (e.g. reallocation occurred, or the string was destroyed)");
        _STL_VERIFY(_Unfancy(_Ptr) < _Mycont->_Myptr() + _Mycont->_Mysize, "cannot increment string iterator past end");
#endif // _ITERATOR_DEBUG_LEVEL >= 1

        ++_Ptr;
        return *this;
    }

    _CONSTEXPR20 _String_const_iterator operator++(int) noexcept {
        _String_const_iterator _Tmp = *this;
        ++*this;
        return _Tmp;
    }

    _CONSTEXPR20 _String_const_iterator& operator--() noexcept {
#if _ITERATOR_DEBUG_LEVEL >= 1
        _STL_VERIFY(_Ptr, "cannot decrement value-initialized string iterator");
        const auto _Mycont = static_cast<const _Mystr*>(this->_Getcont());
        _STL_VERIFY(_Mycont, "cannot decrement string iterator because the iterator was "
            "invalidated (e.g. reallocation occurred, or the string was destroyed)");
        _STL_VERIFY(_Mycont->_Myptr() < _Unfancy(_Ptr), "cannot decrement string iterator before begin");
#endif // _ITERATOR_DEBUG_LEVEL >= 1

        --_Ptr;
        return *this;
    }

    _CONSTEXPR20 _String_const_iterator operator--(int) noexcept {
        _String_const_iterator _Tmp = *this;
        --*this;
        return _Tmp;
    }

    _CONSTEXPR20 void _Verify_offset(const difference_type _Off) const noexcept {
#if _ITERATOR_DEBUG_LEVEL >= 1
        if (_Off == 0) {
            return;
        }

        _STL_ASSERT(_Ptr, "cannot seek value-initialized string iterator");
        const auto _Mycont = static_cast<const _Mystr*>(this->_Getcont());
        _STL_ASSERT(_Mycont, "cannot seek string iterator because the iterator was "
            "invalidated (e.g. reallocation occurred, or the string was destroyed)");
        const auto _Contptr = _Mycont->_Myptr();
        const auto _Rawptr = _Unfancy(_Ptr);

        if (_Off < 0) {
            _STL_VERIFY(_Contptr - _Rawptr <= _Off, "cannot seek string iterator before begin");
        }

        if (_Off > 0) {
            using _Size_type = typename _Mystr::size_type;
            const auto _Left = _Mycont->_Mysize - static_cast<_Size_type>(_Rawptr - _Contptr);
            _STL_VERIFY(static_cast<_Size_type>(_Off) <= _Left, "cannot seek string iterator after end");
        }
#else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 / _ITERATOR_DEBUG_LEVEL == 0 vvv
        (void)_Off;
#endif // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^
    }

    _CONSTEXPR20 _String_const_iterator& operator+=(const difference_type _Off) noexcept {
#if _ITERATOR_DEBUG_LEVEL >= 1
        _Verify_offset(_Off);
#endif // _ITERATOR_DEBUG_LEVEL >= 1
        _Ptr += _Off;
        return *this;
    }

    _NODISCARD _CONSTEXPR20 _String_const_iterator operator+(const difference_type _Off) const noexcept {
        _String_const_iterator _Tmp = *this;
        _Tmp += _Off;
        return _Tmp;
    }

    _NODISCARD_FRIEND _CONSTEXPR20 _String_const_iterator operator+(
        const difference_type _Off, _String_const_iterator _Next) noexcept {
        _Next += _Off;
        return _Next;
    }

    _CONSTEXPR20 _String_const_iterator& operator-=(const difference_type _Off) noexcept {
        return *this += -_Off;
    }

    _NODISCARD _CONSTEXPR20 _String_const_iterator operator-(const difference_type _Off) const noexcept {
        _String_const_iterator _Tmp = *this;
        _Tmp -= _Off;
        return _Tmp;
    }

    _NODISCARD _CONSTEXPR20 difference_type operator-(const _String_const_iterator& _Right) const noexcept {
        _Compat(_Right);
        return static_cast<difference_type>(_Ptr - _Right._Ptr);
    }

    _NODISCARD _CONSTEXPR20 reference operator[](const difference_type _Off) const noexcept {
        return *(*this + _Off);
    }

    _NODISCARD _CONSTEXPR20 bool operator==(const _String_const_iterator& _Right) const noexcept {
        _Compat(_Right);
        return _Ptr == _Right._Ptr;
    }

#if _HAS_CXX20
    _NODISCARD constexpr strong_ordering operator<=>(const _String_const_iterator& _Right) const noexcept {
        _Compat(_Right);
        return _STD _Unfancy_maybe_null(_Ptr) <=> _STD _Unfancy_maybe_null(_Right._Ptr);
    }
#else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
    _NODISCARD bool operator!=(const _String_const_iterator& _Right) const noexcept {
        return !(*this == _Right);
    }

    _NODISCARD bool operator<(const _String_const_iterator& _Right) const noexcept {
        _Compat(_Right);
        return _Ptr < _Right._Ptr;
    }

    _NODISCARD bool operator>(const _String_const_iterator& _Right) const noexcept {
        return _Right < *this;
    }

    _NODISCARD bool operator<=(const _String_const_iterator& _Right) const noexcept {
        return !(_Right < *this);
    }

    _NODISCARD bool operator>=(const _String_const_iterator& _Right) const noexcept {
        return !(*this < _Right);
    }
#endif // !_HAS_CXX20

    _CONSTEXPR20 void _Compat(const _String_const_iterator& _Right) const noexcept {
        // test for compatible iterator pair
#if _ITERATOR_DEBUG_LEVEL >= 1
        _STL_VERIFY(this->_Getcont() == _Right._Getcont(),
            "string iterators incompatible (e.g. point to different string instances)");
#else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 / _ITERATOR_DEBUG_LEVEL == 0 vvv
        (void)_Right;
#endif // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^
    }

#if _ITERATOR_DEBUG_LEVEL >= 1
    friend _CONSTEXPR20 void _Verify_range(
        const _String_const_iterator& _First, const _String_const_iterator& _Last) noexcept {
        _STL_VERIFY(_First._Getcont() == _Last._Getcont(), "string iterators in range are from different containers");
        _STL_VERIFY(_First._Ptr <= _Last._Ptr, "string iterator range transposed");
    }
#endif // _ITERATOR_DEBUG_LEVEL >= 1

    using _Prevent_inheriting_unwrap = _String_const_iterator;

    _NODISCARD _CONSTEXPR20 const value_type* _Unwrapped() const noexcept {
        return _STD _Unfancy_maybe_null(_Ptr);
    }

    _CONSTEXPR20 void _Seek_to(const value_type* _It) noexcept {
        _Ptr = _STD _Refancy_maybe_null<pointer>(const_cast<value_type*>(_It));
    }

    pointer _Ptr; // pointer to element in string
};

#if _HAS_CXX20
template <class _Mystr>
struct pointer_traits<_String_const_iterator<_Mystr>> {
    using pointer = _String_const_iterator<_Mystr>;
    using element_type = const pointer::value_type;
    using difference_type = pointer::difference_type;

    _NODISCARD static constexpr element_type* to_address(const pointer _Iter) noexcept {
#if _ITERATOR_DEBUG_LEVEL >= 1
        const auto _Mycont = static_cast<const _Mystr*>(_Iter._Getcont());
        if (!_Mycont) {
            _STL_VERIFY(!_Iter._Ptr, "cannot convert string iterator to pointer because the iterator was invalidated "
                "(e.g. reallocation occurred, or the string was destroyed)");
        }
#endif // _ITERATOR_DEBUG_LEVEL >= 1

        const auto _Rawptr = _STD to_address(_Iter._Ptr);

#if _ITERATOR_DEBUG_LEVEL >= 1
        if (_Mycont) {
            const auto _Contptr = _Mycont->_Myptr();
            _STL_VERIFY(_Contptr <= _Rawptr && _Rawptr <= _Contptr + _Mycont->_Mysize,
                "cannot convert string iterator to pointer because it is out of range");
        }
#endif // _ITERATOR_DEBUG_LEVEL >= 1

        return _Rawptr;
    }
};
#endif // _HAS_CXX20

template <class _Mystr>
class _String_iterator : public _String_const_iterator<_Mystr> {
public:
    using _Mybase = _String_const_iterator<_Mystr>;

#if _HAS_CXX20
    using iterator_concept = contiguous_iterator_tag;
#endif // _HAS_CXX20
    using iterator_category = random_access_iterator_tag;
    using value_type = typename _Mystr::value_type;
    using difference_type = typename _Mystr::difference_type;
    using pointer = typename _Mystr::pointer;
    using reference = value_type&;

    using _Mybase::_Mybase;

    _NODISCARD _CONSTEXPR20 reference operator*() const noexcept {
        return const_cast<reference>(_Mybase::operator*());
    }

    _NODISCARD _CONSTEXPR20 pointer operator->() const noexcept {
        return pointer_traits<pointer>::pointer_to(**this);
    }

    _CONSTEXPR20 _String_iterator& operator++() noexcept {
        _Mybase::operator++();
        return *this;
    }

    _CONSTEXPR20 _String_iterator operator++(int) noexcept {
        _String_iterator _Tmp = *this;
        _Mybase::operator++();
        return _Tmp;
    }

    _CONSTEXPR20 _String_iterator& operator--() noexcept {
        _Mybase::operator--();
        return *this;
    }

    _CONSTEXPR20 _String_iterator operator--(int) noexcept {
        _String_iterator _Tmp = *this;
        _Mybase::operator--();
        return _Tmp;
    }

    _CONSTEXPR20 _String_iterator& operator+=(const difference_type _Off) noexcept {
        _Mybase::operator+=(_Off);
        return *this;
    }

    _NODISCARD _CONSTEXPR20 _String_iterator operator+(const difference_type _Off) const noexcept {
        _String_iterator _Tmp = *this;
        _Tmp += _Off;
        return _Tmp;
    }

    _NODISCARD_FRIEND _CONSTEXPR20 _String_iterator operator+(
        const difference_type _Off, _String_iterator _Next) noexcept {
        _Next += _Off;
        return _Next;
    }

    _CONSTEXPR20 _String_iterator& operator-=(const difference_type _Off) noexcept {
        _Mybase::operator-=(_Off);
        return *this;
    }

    using _Mybase::operator-;

    _NODISCARD _CONSTEXPR20 _String_iterator operator-(const difference_type _Off) const noexcept {
        _String_iterator _Tmp = *this;
        _Tmp -= _Off;
        return _Tmp;
    }

    _NODISCARD _CONSTEXPR20 reference operator[](const difference_type _Off) const noexcept {
        return const_cast<reference>(_Mybase::operator[](_Off));
    }

    using _Prevent_inheriting_unwrap = _String_iterator;

    _NODISCARD _CONSTEXPR20 value_type* _Unwrapped() const noexcept {
        return const_cast<value_type*>(_STD _Unfancy_maybe_null(this->_Ptr));
    }
};

#if _HAS_CXX20
template <class _Mystr>
struct pointer_traits<_String_iterator<_Mystr>> {
    using pointer = _String_iterator<_Mystr>;
    using element_type = pointer::value_type;
    using difference_type = pointer::difference_type;

    _NODISCARD static constexpr element_type* to_address(const pointer _Iter) noexcept {
#if _ITERATOR_DEBUG_LEVEL >= 1
        const auto _Mycont = static_cast<const _Mystr*>(_Iter._Getcont());
        if (!_Mycont) {
            _STL_VERIFY(!_Iter._Ptr, "cannot convert string iterator to pointer because the iterator was invalidated "
                "(e.g. reallocation occurred, or the string was destroyed)");
        }
#endif // _ITERATOR_DEBUG_LEVEL >= 1

        const auto _Rawptr = _STD to_address(_Iter._Ptr);

#if _ITERATOR_DEBUG_LEVEL >= 1
        if (_Mycont) {
            const auto _Contptr = _Mycont->_Myptr();
            _STL_VERIFY(_Contptr <= _Rawptr && _Rawptr <= _Contptr + _Mycont->_Mysize,
                "cannot convert string iterator to pointer because it is out of range");
        }
#endif // _ITERATOR_DEBUG_LEVEL >= 1

        return const_cast<element_type*>(_Rawptr);
    }
};
#endif // _HAS_CXX20

template <class _Value_type, class _Size_type, class _Difference_type, class _Pointer, class _Const_pointer>
struct _String_iter_types {
    using value_type = _Value_type;
    using size_type = _Size_type;
    using difference_type = _Difference_type;
    using pointer = _Pointer;
    using const_pointer = _Const_pointer;
};

template <class _Val_types>
class _String_val : public _Container_base {
public:
    using value_type = typename _Val_types::value_type;
    using size_type = typename _Val_types::size_type;
    using difference_type = typename _Val_types::difference_type;
    using pointer = typename _Val_types::pointer;
    using const_pointer = typename _Val_types::const_pointer;
    using reference = value_type&;
    using const_reference = const value_type&;

    _CONSTEXPR20 _String_val() noexcept : _Bx() {}

    // length of internal buffer, [1, 16] (NB: used by the debugger visualizer)
    static constexpr size_type _BUF_SIZE = 16 / sizeof(value_type) < 1 ? 1 : 16 / sizeof(value_type);
    // roundup mask for allocated buffers, [0, 15]
    static constexpr size_type _Alloc_mask = sizeof(value_type) <= 1 ? 15
        : sizeof(value_type) <= 2 ? 7
        : sizeof(value_type) <= 4 ? 3
        : sizeof(value_type) <= 8 ? 1
        : 0;
    // capacity in small mode
    static constexpr size_type _Small_string_capacity = _BUF_SIZE - 1;

    _NODISCARD _CONSTEXPR20 value_type* _Myptr() noexcept {
        value_type* _Result = _Bx._Buf;
        if (_Large_mode_engaged()) {
            _Result = _Unfancy(_Bx._Ptr);
        }

        return _Result;
    }

    _NODISCARD _CONSTEXPR20 const value_type* _Myptr() const noexcept {
        const value_type* _Result = _Bx._Buf;
        if (_Large_mode_engaged()) {
            _Result = _Unfancy(_Bx._Ptr);
        }

        return _Result;
    }

    _NODISCARD _CONSTEXPR20 bool _Large_mode_engaged() const noexcept {
        return _Myres > _Small_string_capacity;
    }

    _CONSTEXPR20 void _Activate_SSO_buffer() noexcept {
        // start the lifetime of the array elements
#if _HAS_CXX20
        if (_STD is_constant_evaluated()) {
            for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
                _Bx._Buf[_Idx] = value_type();
            }
        }
#endif // _HAS_CXX20
    }

    _CONSTEXPR20 void _Check_offset(const size_type _Off) const {
        // checks whether _Off is in the bounds of [0, size()]
        if (_Mysize < _Off) {
            _Xran();
        }
    }

    _CONSTEXPR20 void _Check_offset_exclusive(const size_type _Off) const {
        // checks whether _Off is in the bounds of [0, size())
        if (_Mysize <= _Off) {
            _Xran();
        }
    }

    [[noreturn]] static void _Xran() {
        _Xout_of_range("invalid string position");
    }

    _NODISCARD _CONSTEXPR20 size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {
        // trims _Size to the longest it can be assuming a string at/after _Off
        return (_STD min)(_Size, _Mysize - _Off);
    }

    union _Bxty { // storage for small buffer or pointer to larger one
        // This constructor previously initialized _Ptr. Don't rely on the new behavior without
        // renaming `_String_val` (and fixing the visualizer).
        _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers
        _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers

        value_type _Buf[_BUF_SIZE];
        pointer _Ptr;
        char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)

        _CONSTEXPR20 void _Switch_to_buf() noexcept {
            _STD _Destroy_in_place(_Ptr);

#if _HAS_CXX20
            // start the lifetime of the array elements
            if (_STD is_constant_evaluated()) {
                for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
                    _Buf[_Idx] = value_type();
                }
            }
#endif // _HAS_CXX20
        }
    };
    _Bxty _Bx;

    // invariant: _Myres >= _Mysize, and _Myres >= _Small_string_capacity (after string's construction)
    // neither _Mysize nor _Myres takes account of the extra null terminator
    size_type _Mysize = 0; // current length of string (size)
    size_type _Myres = 0; // current storage reserved for string (capacity)
};

// get _Ty's size after being EBCO'd
template <class _Ty>
_INLINE_VAR constexpr size_t _Size_after_ebco_v = is_empty_v<_Ty> ? 0 : sizeof(_Ty);

struct _String_constructor_concat_tag {
    // tag to select constructors used by basic_string's concatenation operators (operator+)
    explicit _String_constructor_concat_tag() = default;
};

struct _String_constructor_rvalue_allocator_tag {
    // tag to select constructors used by basic_stringbuf's rvalue str()
    explicit _String_constructor_rvalue_allocator_tag() = default;
};

[[noreturn]] inline void _Xlen_string() {
    _Xlength_error("string too long");
}

#if _HAS_CXX23
template <class _Rng, class _Ty>
concept _Contiguous_range_of =
(_RANGES contiguous_range<_Rng>) && same_as<remove_cvref_t<_RANGES range_reference_t<_Rng>>, _Ty>;
#endif // _HAS_CXX23

_EXPORT_STD template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
class basic_string { // null-terminated transparent array of elements
private:
    friend _Tidy_deallocate_guard<basic_string>;
    friend basic_stringbuf<_Elem, _Traits, _Alloc>;

    using _Alty = _Rebind_alloc_t<_Alloc, _Elem>;
    using _Alty_traits = allocator_traits<_Alty>;

    using _Scary_val = _String_val<conditional_t<_Is_simple_alloc_v<_Alty>, _Simple_types<_Elem>,
        _String_iter_types<_Elem, typename _Alty_traits::size_type, typename _Alty_traits::difference_type,
        typename _Alty_traits::pointer, typename _Alty_traits::const_pointer>>>;

    static_assert(!_ENFORCE_MATCHING_ALLOCATORS || is_same_v<_Elem, typename _Alloc::value_type>,
        _MISMATCHED_ALLOCATOR_MESSAGE("basic_string<T, Traits, Allocator>", "T"));

    static_assert(is_same_v<_Elem, typename _Traits::char_type>,
        "N4950 [string.require]/3 requires that the supplied "
        "char_traits character type match the string's character type.");

    static_assert(!is_array_v<_Elem>&& is_trivial_v<_Elem>&& is_standard_layout_v<_Elem>,
        "The character type of basic_string must be a non-array trivial standard-layout type. See N4950 "
        "[strings.general]/1.");

public:
    using traits_type = _Traits;
    using allocator_type = _Alloc;

    using value_type = _Elem;
    using size_type = typename _Alty_traits::size_type;
    using difference_type = typename _Alty_traits::difference_type;
    using pointer = typename _Alty_traits::pointer;
    using const_pointer = typename _Alty_traits::const_pointer;
    using reference = value_type&;
    using const_reference = const value_type&;

    using iterator = _String_iterator<_Scary_val>;
    using const_iterator = _String_const_iterator<_Scary_val>;

    using reverse_iterator = _STD reverse_iterator<iterator>;
    using const_reverse_iterator = _STD reverse_iterator<const_iterator>;

private:
    static constexpr size_type _BUF_SIZE = _Scary_val::_BUF_SIZE;
    static constexpr size_type _Alloc_mask = _Scary_val::_Alloc_mask;
    static constexpr size_type _Small_string_capacity = _Scary_val::_Small_string_capacity;

    // least real allocation size, including space reserved for terminating null
    static constexpr size_type _Least_allocation_size = _Small_string_capacity + 1 + 1;

    // When doing _String_val operations by memcpy, we are touching:
    //   _String_val::_Bx::_Buf (type is array of _Elem)
    //   _String_val::_Bx::_Ptr (type is pointer)
    //   _String_val::_Mysize   (type is size_type)
    //   _String_val::_Myres    (type is size_type)
    // N4950 [strings.general]/1 says _Elem must be trivial standard-layout, so memcpy is safe.
    // We need to ask if pointer is safe to memcpy.
    // size_type must be an unsigned integral type so memcpy is safe.
    // We also need to disable memcpy if the user has supplied _Traits, since
    //   they can observe traits::assign and similar.
    static constexpr bool _Can_memcpy_val = _Is_specialization_v<_Traits, char_traits>&& is_trivial_v<pointer>;
    // This offset skips over the _Container_base members, if any
    static constexpr size_t _Memcpy_val_offset = _Size_after_ebco_v<_Container_base>;
    static constexpr size_t _Memcpy_val_size = sizeof(_Scary_val) - _Memcpy_val_offset;

    template <class _Iter>
    // TRANSITION, /clr:pure is incompatible with templated static constexpr data members
    // static constexpr bool _Is_elem_cptr =_Is_any_of_v<_Iter, const _Elem* const, _Elem* const, const _Elem*, _Elem*>;
    using _Is_elem_cptr = bool_constant<_Is_any_of_v<_Iter, const _Elem* const, _Elem* const, const _Elem*, _Elem*>>;

#if _HAS_CXX17
    template <class _StringViewIsh>
    using _Is_string_view_ish =
        enable_if_t<conjunction_v<is_convertible<const _StringViewIsh&, basic_string_view<_Elem, _Traits>>,
        negation<is_convertible<const _StringViewIsh&, const _Elem*>>>,
        int>;
#endif // _HAS_CXX17

#ifdef _INSERT_STRING_ANNOTATION
    _CONSTEXPR20 void _Create_annotation() const noexcept {
        // Annotates the valid range with shadow memory
        auto& _My_data = _Mypair._Myval2;
        _Apply_annotation(_My_data._Myptr(), _My_data._Myres, _My_data._Myres, _My_data._Mysize);
    }

    _CONSTEXPR20 void _Remove_annotation() const noexcept {
        // Removes annotation of the range with shadow memory
        auto& _My_data = _Mypair._Myval2;
        _Apply_annotation(_My_data._Myptr(), _My_data._Myres, _My_data._Mysize, _My_data._Myres);
    }

    _CONSTEXPR20 void _Modify_annotation(const size_type _Old_size, const size_type _New_size) const noexcept {
        if (_Old_size == _New_size) {
            return;
        }

        auto& _My_data = _Mypair._Myval2;
        _Apply_annotation(_My_data._Myptr(), _My_data._Myres, _Old_size, _New_size);
    }

    static _CONSTEXPR20 void _Apply_annotation(const value_type* const _First, const size_type _Capacity,
        const size_type _Old_size, const size_type _New_size) noexcept {
#if _HAS_CXX20
        if (_STD is_constant_evaluated()) {
            return;
        }
#endif // _HAS_CXX20
        // Don't annotate small strings; only annotate on the heap.
        if (_Capacity <= _Small_string_capacity || !_Asan_string_should_annotate) {
            return;
        }

        // Note that `_Capacity`, `_Old_size`, and `_New_size` do not include the null terminator
        const void* const _End = _First + _Capacity + 1;
        const void* const _Old_last = _First + _Old_size + 1;
        const void* const _New_last = _First + _New_size + 1;

        constexpr bool _Large_string_always_asan_aligned =
            (_Container_allocation_minimum_asan_alignment<basic_string>) >= _Asan_granularity;

        // for the non-aligned buffer options, the buffer must always have size >= 9 bytes,
        // so it will always end at least one shadow memory section.

        _Asan_aligned_pointers _Aligned;
        if constexpr (_Large_string_always_asan_aligned) {
            _Aligned = { _First, _STD _Get_asan_aligned_after(_End) };
        }
        else {
            _Aligned = _STD _Get_asan_aligned_first_end(_First, _End);
        }
        const void* const _Old_fixed = _Aligned._Clamp_to_end(_Old_last);
        const void* const _New_fixed = _Aligned._Clamp_to_end(_New_last);

        // --- always aligned case ---
        // old state:
        //   [_First, _Old_last) valid
        //   [_Old_last, asan_aligned_after(_End)) poison
        // new state:
        //   [_First, _New_last) valid
        //   [_New_last, asan_aligned_after(_End)) poison

        // --- sometimes non-aligned case ---
        // old state:
        //   [_Aligned._First, _Old_fixed) valid
        //   [_Old_fixed, _Aligned._End) poison
        //   [_Aligned._End, _End) valid
        // new state:
        //   [_Aligned._First, _New_fixed) valid
        //   [_New_fixed, _Aligned._End) poison
        //   [_Aligned._End, _End) valid
        _CSTD __sanitizer_annotate_contiguous_container(_Aligned._First, _Aligned._End, _Old_fixed, _New_fixed);
    }

#define _ASAN_STRING_REMOVE(_Str)                       (_Str)._Remove_annotation()
#define _ASAN_STRING_CREATE(_Str)                       (_Str)._Create_annotation()
#define _ASAN_STRING_MODIFY(_Str, _Old_size, _New_size) (_Str)._Modify_annotation(_Old_size, _New_size)
#else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
#define _ASAN_STRING_REMOVE(_Str)
#define _ASAN_STRING_CREATE(_Str)
#define _ASAN_STRING_MODIFY(_Str, _Old_size, _New_size)
#endif // ^^^ !_INSERT_STRING_ANNOTATION ^^^

public:
    _CONSTEXPR20
        basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {
        _Construct_empty();
    }

    _CONSTEXPR20 explicit basic_string(const _Alloc& _Al) noexcept : _Mypair(_One_then_variadic_args_t{}, _Al) {
        _Construct_empty();
    }

    _CONSTEXPR20 basic_string(const basic_string& _Right)
        : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {
        _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    }

    _CONSTEXPR20 basic_string(const basic_string& _Right, const _Alloc& _Al)
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    }

    _CONSTEXPR20 basic_string(const basic_string& _Right, const size_type _Roff, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t{}, _Al) { // construct from _Right [_Roff, <end>)
        _Right._Mypair._Myval2._Check_offset(_Roff);
        _Construct<_Construct_strategy::_From_ptr>(
            _Right._Mypair._Myval2._Myptr() + _Roff, _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, npos));
    }

    _CONSTEXPR20 basic_string(
        const basic_string& _Right, const size_type _Roff, const size_type _Count, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t{}, _Al) { // construct from _Right [_Roff, _Roff + _Count)
        _Right._Mypair._Myval2._Check_offset(_Roff);
        _Construct<_Construct_strategy::_From_ptr>(
            _Right._Mypair._Myval2._Myptr() + _Roff, _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count));
    }

#if _HAS_CXX23
    constexpr basic_string(basic_string&& _Right, const size_type _Roff, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t{}, _Al) { // construct from _Right [_Roff, <end>), potentially move
        _Move_construct_from_substr(_Right, _Roff, npos);
    }

    constexpr basic_string(
        basic_string&& _Right, const size_type _Roff, const size_type _Count, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t{}, _Al) { // construct from _Right [_Roff, _Roff + _Count), potentially move
        _Move_construct_from_substr(_Right, _Roff, _Count);
    }
#endif // _HAS_CXX23

    _CONSTEXPR20 basic_string(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count)
        : _Mypair(_Zero_then_variadic_args_t{}) {
        _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Count);
    }

#if _HAS_CXX17
    template <class _Alloc2 = _Alloc, enable_if_t<_Is_allocator<_Alloc2>::value, int> = 0>
#endif // _HAS_CXX17
    _CONSTEXPR20 basic_string(
        _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count, const _Alloc& _Al)
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Count);
    }

    _CONSTEXPR20 basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {
        _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
    }

#if _HAS_CXX17
    template <class _Alloc2 = _Alloc, enable_if_t<_Is_allocator<_Alloc2>::value, int> = 0>
#endif // _HAS_CXX17
    _CONSTEXPR20 basic_string(_In_z_ const _Elem* const _Ptr, const _Alloc& _Al)
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
    }

#if _HAS_CXX23
    basic_string(nullptr_t) = delete;
#endif // _HAS_CXX23

    _CONSTEXPR20 basic_string(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch)
        : _Mypair(_Zero_then_variadic_args_t{}) { // construct from _Count * _Ch
        _Construct<_Construct_strategy::_From_char>(_Ch, _Count);
    }

#if _HAS_CXX17
    template <class _Alloc2 = _Alloc, enable_if_t<_Is_allocator<_Alloc2>::value, int> = 0>
#endif // _HAS_CXX17
    _CONSTEXPR20 basic_string(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch, const _Alloc& _Al)
        : _Mypair(_One_then_variadic_args_t{}, _Al) { // construct from _Count * _Ch with allocator
        _Construct<_Construct_strategy::_From_char>(_Ch, _Count);
    }

    template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    _CONSTEXPR20 basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        _STD _Adl_verify_range(_First, _Last);
        auto _UFirst = _STD _Get_unwrapped(_First);
        auto _ULast = _STD _Get_unwrapped(_Last);
        if (_UFirst == _ULast) {
            _Construct_empty();
        }
        else {
            if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
                _Construct<_Construct_strategy::_From_ptr>(
                    _UFirst, _STD _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
            }
            else if constexpr (_Is_cpp17_fwd_iter_v<decltype(_UFirst)>) {
                const auto _Length = static_cast<size_t>(_STD distance(_UFirst, _ULast));
                const auto _Count = _STD _Convert_size<size_type>(_Length);
                _Construct_from_iter(_STD move(_UFirst), _STD move(_ULast), _Count);
            }
            else {
                _Construct_from_iter(_STD move(_UFirst), _STD move(_ULast));
            }
        }
    }

private:
    enum class _Allocation_policy { _At_least, _Exactly };

    template <_Allocation_policy _Policy = _Allocation_policy::_At_least>
    _NODISCARD static _CONSTEXPR20 pointer _Allocate_for_capacity(_Alty& _Al, size_type& _Capacity) {
        _STL_INTERNAL_CHECK(_Capacity > _Small_string_capacity);
        ++_Capacity; // Take null terminator into consideration

        pointer _Fancy_ptr;
        if constexpr (_Policy == _Allocation_policy::_At_least) {
            _Fancy_ptr = _Allocate_at_least_helper(_Al, _Capacity);
        }
        else {
            _STL_INTERNAL_STATIC_ASSERT(_Policy == _Allocation_policy::_Exactly);
            _Fancy_ptr = _Al.allocate(_Capacity);
        }

#if _HAS_CXX20
        // Start element lifetimes to avoid UB. This is a more general mechanism than _String_val::_Activate_SSO_buffer,
        // but likely more impactful to throughput.
        if (_STD is_constant_evaluated()) {
            _Elem* const _Ptr = _Unfancy(_Fancy_ptr);
            for (size_type _Idx = 0; _Idx < _Capacity; ++_Idx) {
                _STD construct_at(_Ptr + _Idx);
            }
        }
#endif // _HAS_CXX20
        --_Capacity;
        return _Fancy_ptr;
    }

    static _CONSTEXPR20 void _Deallocate_for_capacity(
        _Alty& _Al, const pointer _Old_ptr, const size_type _Capacity) noexcept {
        _STL_INTERNAL_CHECK(_Capacity > _Small_string_capacity);
        _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator
    }

    _CONSTEXPR20 void _Construct_empty() {
        auto& _My_data = _Mypair._Myval2;
        _My_data._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

        // initialize basic_string data members
        _My_data._Mysize = 0;
        _My_data._Myres = _Small_string_capacity;
        _My_data._Activate_SSO_buffer();

        // the _Traits::assign is last so the codegen doesn't think the char write can alias this
        _Traits::assign(_My_data._Bx._Buf[0], _Elem());
    }

    enum class _Construct_strategy : uint8_t { _From_char, _From_ptr, _From_string };

    template <_Construct_strategy _Strat, class _Char_or_ptr>
    _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {
        auto& _My_data = _Mypair._Myval2;
        _STL_INTERNAL_CHECK(!_My_data._Large_mode_engaged());

        if constexpr (_Strat == _Construct_strategy::_From_char) {
            _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
        }
        else {
            _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
        }

        if (_Count > max_size()) {
            _Xlen_string(); // result too long
        }

        auto& _Al = _Getal();
        auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

        if (_Count <= _Small_string_capacity) {
            _My_data._Mysize = _Count;
            _My_data._Myres = _Small_string_capacity;

            if constexpr (_Strat == _Construct_strategy::_From_char) {
                _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
                _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
            }
            else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
                _Traits::copy(_My_data._Bx._Buf, _Arg, _Count);
                _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
            }
            else { // _Strat == _Construct_strategy::_From_string
#ifdef _INSERT_STRING_ANNOTATION
                _Traits::copy(_My_data._Bx._Buf, _Arg, _Count + 1);
#else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
                _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);
#endif // ^^^ !_INSERT_STRING_ANNOTATION ^^^
            }

            _Proxy._Release();
            return;
        }

        size_type _New_capacity = _Calculate_growth(_Count, _Small_string_capacity, max_size());
        const pointer _New_ptr = _Allocate_for_capacity(_Al, _New_capacity); // throws
        _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

        _My_data._Mysize = _Count;
        _My_data._Myres = _New_capacity;
        if constexpr (_Strat == _Construct_strategy::_From_char) {
            _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
            _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
        }
        else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
            _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
            _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
        }
        else { // _Strat == _Construct_strategy::_From_string
            _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);
        }

        _ASAN_STRING_CREATE(*this);
        _Proxy._Release();
    }

    template <class _Iter, class _Sent, class _Size = nullptr_t>
    _CONSTEXPR20 void _Construct_from_iter(_Iter _First, const _Sent _Last, _Size _Count = {}) {
        // Pre: _Iter models input_iterator or meets the Cpp17InputIterator requirements.
        // Pre: [_First, _Last) is a valid range.
        // Pre: if _Iter models forward_iterator or meets the Cpp17ForwardIterator requirements,
        //      then is_same_v<_Size, size_type> holds.
        // Pre: if is_same_v<_Size, size_type>, _Count is the length of [_First, _Last).
        // Pre: *this is in small mode; the lifetime of the SSO elements has already begun.

        auto& _My_data = _Mypair._Myval2;
        auto& _Al = _Getal();
        auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

        _My_data._Mysize = 0;
        _My_data._Myres = _Small_string_capacity;

        if constexpr (is_same_v<_Size, size_type>) {
            if (_Count > max_size()) {
                _Xlen_string(); // result too long
            }

            if (_Count > _Small_string_capacity) {
                size_type _New_capacity = _Calculate_growth(_Count);
                const pointer _New_ptr = _Allocate_for_capacity(_Al, _New_capacity); // throws
                _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);
                _My_data._Myres = _New_capacity;
            }
        }

        _Tidy_deallocate_guard<basic_string> _Guard{ this };

        constexpr bool _Can_construct_by_copy =
            _Is_specialization_v<_Traits, char_traits>&& _Is_EcharT<_Elem>&& is_same_v<_Size, size_type>;

        if constexpr (_Can_construct_by_copy) {
            const auto _Data = _My_data._Myptr();
            _STD _Copy_n_unchecked4(_STD move(_First), _Count, _Data);
            _My_data._Mysize = _Count;
            _Data[_Count] = _Elem();
        }
        else {
            for (; _First != _Last; ++_First) {
                if constexpr (!is_same_v<_Size, size_type>) {
                    if (_My_data._Mysize == _My_data._Myres) { // Need to grow
                        if (_My_data._Mysize == max_size()) {
                            _Xlen_string(); // result too long
                        }

                        _Elem* const _Old_ptr = _My_data._Myptr();
                        size_type _New_capacity = _Calculate_growth(_My_data._Mysize + 1);
                        const pointer _New_ptr = _Allocate_for_capacity(_Al, _New_capacity); // throws

                        _Traits::copy(_Unfancy(_New_ptr), _Old_ptr, _My_data._Mysize);
                        if (_My_data._Large_mode_engaged()) { // Need to deallocate old storage
                            _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);
                            _My_data._Bx._Ptr = _New_ptr;
                        }
                        else {
                            _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);
                        }
                        _My_data._Myres = _New_capacity;
                    }
                }

                _Elem* const _Ptr = _My_data._Myptr();
                _Traits::assign(_Ptr[_My_data._Mysize], *_First);
                ++_My_data._Mysize;
            }

            _Elem* const _Ptr = _My_data._Myptr();
            _Traits::assign(_Ptr[_My_data._Mysize], _Elem());
        }

        _ASAN_STRING_CREATE(*this);
        _Guard._Target = nullptr;
        _Proxy._Release();
    }

public:
#if _HAS_CXX23
    template <_Container_compatible_range<_Elem> _Rng>
    constexpr basic_string(from_range_t, _Rng&& _Range, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        if constexpr (_RANGES sized_range<_Rng> || _RANGES forward_range<_Rng>) {
            const auto _Length = _To_unsigned_like(_RANGES distance(_Range));
            const auto _Count = _Convert_size<size_type>(_Length);
            if constexpr (_Contiguous_range_of<_Rng, _Elem>) {
                _Construct<_Construct_strategy::_From_ptr>(_RANGES data(_Range), _Count);
            }
            else {
                _Construct_from_iter(_RANGES _Ubegin(_Range), _RANGES _Uend(_Range), _Count);
            }
        }
        else {
            _Construct_from_iter(_RANGES _Ubegin(_Range), _RANGES _Uend(_Range));
        }
    }
#endif // _HAS_CXX23

    _CONSTEXPR20 basic_string(basic_string&& _Right) noexcept
        : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal())) {
        _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
        _Take_contents(_Right);
    }

    _CONSTEXPR20 basic_string(basic_string&& _Right, const _Alloc& _Al) noexcept(
        _Alty_traits::is_always_equal::value) // strengthened
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        if constexpr (!_Alty_traits::is_always_equal::value) {
            if (_Getal() != _Right._Getal()) {
                _Construct<_Construct_strategy::_From_string>(
                    _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
                return;
            }
        }

        _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
        _Take_contents(_Right);
    }

    _CONSTEXPR20 basic_string(_String_constructor_concat_tag, const basic_string& _Source_of_al,
        const _Elem* const _Left_ptr, const size_type _Left_size, const _Elem* const _Right_ptr,
        const size_type _Right_size)
        : _Mypair(
            _One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Source_of_al._Getal())) {
        _STL_INTERNAL_CHECK(_Left_size <= max_size());
        _STL_INTERNAL_CHECK(_Right_size <= max_size());
        _STL_INTERNAL_CHECK(_Right_size <= max_size() - _Left_size);
        const auto _New_size = static_cast<size_type>(_Left_size + _Right_size);
        size_type _New_capacity = _Small_string_capacity;
        auto& _My_data = _Mypair._Myval2;
        _Elem* _Ptr = _My_data._Bx._Buf;
        auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data); // throws

        if (_New_capacity < _New_size) {
            _New_capacity = _Calculate_growth(_New_size, _Small_string_capacity, max_size());
            const pointer _Fancyptr = _Allocate_for_capacity(_Getal(), _New_capacity); // throws
            _Ptr = _Unfancy(_Fancyptr);
            _Construct_in_place(_My_data._Bx._Ptr, _Fancyptr);
        }

        _My_data._Mysize = _New_size;
        _My_data._Myres = _New_capacity;
        _Traits::copy(_Ptr, _Left_ptr, _Left_size);
        _Traits::copy(_Ptr + static_cast<ptrdiff_t>(_Left_size), _Right_ptr, _Right_size);
        _Traits::assign(_Ptr[_New_size], _Elem());
        _ASAN_STRING_CREATE(*this);
        _Proxy._Release();
    }

    _CONSTEXPR20 basic_string(_String_constructor_concat_tag, basic_string& _Left, basic_string& _Right)
        : _Mypair(_One_then_variadic_args_t{}, _Left._Getal()) {
        auto& _My_data = _Mypair._Myval2;
        auto& _Left_data = _Left._Mypair._Myval2;
        auto& _Right_data = _Right._Mypair._Myval2;
        _Left_data._Orphan_all();
        _Right_data._Orphan_all();
        const auto _Left_size = _Left_data._Mysize;
        const auto _Right_size = _Right_data._Mysize;

        const auto _Left_capacity = _Left_data._Myres;
        const auto _Right_capacity = _Right_data._Myres;
        // overflow is OK due to max_size() checks:
        const auto _New_size = static_cast<size_type>(_Left_size + _Right_size);
        const bool _Fits_in_left = _Right_size <= _Left_capacity - _Left_size;
        if (_Fits_in_left && _Right_capacity <= _Left_capacity) {
            // take _Left's buffer, max_size() is OK because _Fits_in_left
            _My_data._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal())); // throws, hereafter nothrow in this block
            _Take_contents(_Left);
            const auto _Ptr = _My_data._Myptr();
            _ASAN_STRING_MODIFY(*this, _Left_size, _New_size);
            _Traits::copy(_Ptr + _Left_size, _Right_data._Myptr(), _Right_size + 1);
            _My_data._Mysize = _New_size;
            return;
        }

        const bool _Fits_in_right = _Left_size <= _Right_capacity - _Right_size;
        if (_Allocators_equal(_Getal(), _Right._Getal()) && _Fits_in_right) {
            // take _Right's buffer, max_size() is OK because _Fits_in_right
            // At this point, we have tested:
            // !(_Fits_in_left && _Right_capacity <= _Left_capacity) && _Fits_in_right
            // therefore: (by De Morgan's Laws)
            // (!_Fits_in_left || _Right_capacity > _Left_capacity) && _Fits_in_right
            // therefore: (by the distributive property)
            // (!_Fits_in_left && _Fits_in_right)  // implying _Right has more capacity
            //     || (_Right_capacity > _Left_capacity && _Fits_in_right)  // tests that _Right has more capacity
            // therefore: _Right must have more than the minimum capacity, so it must be _Large_mode_engaged()
            _STL_INTERNAL_CHECK(_Right_data._Large_mode_engaged());
            _My_data._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal())); // throws, hereafter nothrow in this block
            _Take_contents(_Right);
            const auto _Ptr = _Unfancy(_My_data._Bx._Ptr);
            _ASAN_STRING_MODIFY(*this, _Right_size, _New_size);
            _Traits::move(_Ptr + _Left_size, _Ptr, _Right_size + 1);
            _Traits::copy(_Ptr, _Left_data._Myptr(), _Left_size);
            _My_data._Mysize = _New_size;
            return;
        }

        // can't use either buffer, reallocate
        const auto _Max = max_size();
        if (_Max - _Left_size < _Right_size) { // check if max_size() is OK
            _Xlen_string();
        }

        size_type _New_capacity = _Calculate_growth(_New_size, _Small_string_capacity, _Max);
        auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data); // throws
        const pointer _Fancyptr = _Allocate_for_capacity(_Getal(), _New_capacity); // throws
        // nothrow hereafter
        _Construct_in_place(_My_data._Bx._Ptr, _Fancyptr);
        _My_data._Mysize = _New_size;
        _My_data._Myres = _New_capacity;
        const auto _Ptr = _Unfancy(_Fancyptr);
        _Traits::copy(_Ptr, _Left_data._Myptr(), _Left_size);
        _Traits::copy(_Ptr + _Left_size, _Right_data._Myptr(), _Right_size + 1);
        _ASAN_STRING_CREATE(*this);
        _Proxy._Release();
    }

#if _HAS_CXX17
    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    _CONSTEXPR20 explicit basic_string(const _StringViewIsh& _Right, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        const basic_string_view<_Elem, _Traits> _As_view = _Right;
        _Construct<_Construct_strategy::_From_ptr>(_As_view.data(), _Convert_size<size_type>(_As_view.size()));
    }

    template <class _Ty, enable_if_t<is_convertible_v<const _Ty&, basic_string_view<_Elem, _Traits>>, int> = 0>
    _CONSTEXPR20 basic_string(
        const _Ty& _Right, const size_type _Roff, const size_type _Count, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t{}, _Al) { // construct from _Right [_Roff, _Roff + _Count) using _Al
        const basic_string_view<_Elem, _Traits> _As_view = _Right;
        const auto _As_sub_view = _As_view.substr(_Roff, _Count);
        _Construct<_Construct_strategy::_From_ptr>(_As_sub_view.data(), _Convert_size<size_type>(_As_sub_view.size()));
    }
#endif // _HAS_CXX17

#if _HAS_CXX20
    basic_string(_String_constructor_rvalue_allocator_tag, _Alloc&& _Al)
        : _Mypair(_One_then_variadic_args_t{}, _STD move(_Al)) {
        // Used exclusively by basic_stringbuf
        _Construct_empty();
    }

    _NODISCARD bool _Move_assign_from_buffer(
        _Elem* const _Right, const size_type _Size, const size_type _Actual_allocation_size) {
        // Move assign from a buffer, used exclusively by basic_stringbuf; returns _Large_mode_engaged()
        auto& _My_data = _Mypair._Myval2;
        _STL_INTERNAL_CHECK(!_My_data._Large_mode_engaged() && _My_data._Mysize == 0);
        _STL_INTERNAL_CHECK(_Size < _Actual_allocation_size); // So there is room for null terminator
        _Traits::assign(_Right[_Size], _Elem());

        const bool _Is_large = _Actual_allocation_size >= _Least_allocation_size;
        if (_Is_large) {
            _ASAN_STRING_REMOVE(*this);
            _Construct_in_place(_My_data._Bx._Ptr, _Refancy<pointer>(_Right));
            _My_data._Mysize = _Size;
            _My_data._Myres = _Actual_allocation_size - 1;
            _ASAN_STRING_CREATE(*this);
        }
        else {
            _Traits::copy(_My_data._Bx._Buf, _Right, _Actual_allocation_size);
            _My_data._Mysize = _Size;
            _My_data._Myres = _Small_string_capacity;
        }

        return _Is_large;
    }

    // No instance of this type can exist where an exception may be thrown.
    struct _Released_buffer {
        pointer _Ptr;
        size_type _Size;
        size_type _Actual_allocation_size;
    };

    _NODISCARD _Released_buffer _Release_to_buffer(_Alloc& _Al) {
        // Release to a buffer, or allocate a new one if in small string mode; used exclusively by basic_stringbuf
        _Released_buffer _Result;
        auto& _My_data = _Mypair._Myval2;
        _Result._Size = _My_data._Mysize;
        _My_data._Orphan_all();
        _ASAN_STRING_REMOVE(*this);
        if (_My_data._Large_mode_engaged()) {
            _Result._Ptr = _My_data._Bx._Ptr;
            _Result._Actual_allocation_size = _My_data._Myres + 1;

            _My_data._Bx._Switch_to_buf();
        }
        else {
            // use _Least_allocation_size to avoid small mode, if the buffer is assigned back
            size_type _Allocated = _Least_allocation_size;
            _Result._Ptr = _Allocate_at_least_helper(_Al, _Allocated);
            _Traits::copy(_Unfancy(_Result._Ptr), _My_data._Bx._Buf, _BUF_SIZE);
            _Result._Actual_allocation_size = _Allocated;
        }
        _My_data._Mysize = 0;
        _My_data._Myres = _Small_string_capacity;
        _Traits::assign(_My_data._Bx._Buf[0], _Elem());
        return _Result;
    }
#endif // _HAS_CXX20

    _CONSTEXPR20 basic_string& operator=(basic_string&& _Right) noexcept(
        _Choose_pocma_v<_Alty> != _Pocma_values::_No_propagate_allocators) {
        if (this == _STD addressof(_Right)) {
            return *this;
        }

        auto& _Al = _Getal();
        auto& _Right_al = _Right._Getal();
        constexpr auto _Pocma_val = _Choose_pocma_v<_Alty>;
        if constexpr (_Pocma_val == _Pocma_values::_Propagate_allocators) {
            if (_Al != _Right_al) {
                // intentionally slams into noexcept on OOM, TRANSITION, VSO-466800
                _Mypair._Myval2._Orphan_all();
                _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
            }
        }
        else if constexpr (_Pocma_val == _Pocma_values::_No_propagate_allocators) {
            if (_Al != _Right_al) {
                assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
                return *this;
            }
        }

        _Tidy_deallocate();
        _Pocma(_Al, _Right_al);
        _Take_contents(_Right);
        return *this;
    }

    _CONSTEXPR20 basic_string& assign(basic_string&& _Right) noexcept(noexcept(*this = _STD move(_Right))) {
        *this = _STD move(_Right);
        return *this;
    }

private:
    _CONSTEXPR20 void _Take_contents(basic_string& _Right) noexcept {
        // assign by stealing _Right's buffer
        // pre: this != &_Right
        // pre: allocator propagation (POCMA) from _Right, if necessary, is complete
        // pre: *this owns no memory, iterators orphaned
        // (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
        auto& _My_data = _Mypair._Myval2;
        auto& _Right_data = _Right._Mypair._Myval2;

#if !defined(_INSERT_STRING_ANNOTATION)
        if constexpr (_Can_memcpy_val) {
#if _HAS_CXX20
            if (!_STD is_constant_evaluated())
#endif // _HAS_CXX20
            {
#if _ITERATOR_DEBUG_LEVEL != 0
                if (_Right_data._Large_mode_engaged()) {
                    // take ownership of _Right's iterators along with its buffer
                    _Swap_proxy_and_iterators(_Right);
                }
                else {
                    _Right_data._Orphan_all();
                }
#endif // _ITERATOR_DEBUG_LEVEL != 0

                const auto _My_data_mem =
                    reinterpret_cast<unsigned char*>(_STD addressof(_Mypair._Myval2)) + _Memcpy_val_offset;
                const auto _Right_data_mem =
                    reinterpret_cast<const unsigned char*>(_STD addressof(_Right._Mypair._Myval2)) + _Memcpy_val_offset;
                _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

                _Right_data._Mysize = 0;
                _Right_data._Myres = _Small_string_capacity;
                _Right_data._Activate_SSO_buffer();
                _Traits::assign(_Right_data._Bx._Buf[0], _Elem());
                return;
            }
        }
#endif // !defined(_INSERT_STRING_ANNOTATION)

        if (_Right_data._Large_mode_engaged()) { // steal buffer
            _Swap_proxy_and_iterators(_Right);

            _Construct_in_place(_My_data._Bx._Ptr, _Right_data._Bx._Ptr);
            _Right_data._Bx._Switch_to_buf();
        }
        else { // copy small string buffer
            _Right_data._Orphan_all();

            _My_data._Activate_SSO_buffer();
            _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _Right_data._Mysize + 1);
        }

        _My_data._Myres = _Right_data._Myres;
        _My_data._Mysize = _Right_data._Mysize;

        _Right_data._Mysize = 0;
        _Right_data._Myres = _Small_string_capacity;
        _Traits::assign(_Right_data._Bx._Buf[0], _Elem());
    }

#if _HAS_CXX23
    constexpr void _Move_construct_from_substr(basic_string& _Right, const size_type _Roff, const size_type _Size_max) {
        auto& _Right_data = _Right._Mypair._Myval2;
        _Right_data._Check_offset(_Roff);

        const auto _Result_size = _Right_data._Clamp_suffix_size(_Roff, _Size_max);
        const auto _Right_ptr = _Right_data._Myptr();
        auto& _Al = _Getal();
        if (_Allocators_equal(_Al, _Right._Getal()) && _Result_size > _Small_string_capacity) {
            _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al));

            if (_Roff != 0) {
                _Traits::move(_Right_ptr, _Right_ptr + _Roff, _Result_size);
            }
            _Right._Eos(_Result_size);
            _Take_contents(_Right);
        }
        else {
            _Construct<_Construct_strategy::_From_ptr>(_Right_ptr + _Roff, _Result_size);
        }
    }
#endif // _HAS_CXX23

public:
    _CONSTEXPR20 basic_string(initializer_list<_Elem> _Ilist, const _Alloc& _Al = allocator_type())
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        _Construct<_Construct_strategy::_From_ptr>(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
    }

    _CONSTEXPR20 basic_string& operator=(initializer_list<_Elem> _Ilist) {
        return assign(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
    }

    _CONSTEXPR20 basic_string& operator+=(initializer_list<_Elem> _Ilist) {
        return append(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
    }

    _CONSTEXPR20 basic_string& assign(initializer_list<_Elem> _Ilist) {
        return assign(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
    }

    _CONSTEXPR20 basic_string& append(initializer_list<_Elem> _Ilist) {
        return append(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
    }

    _CONSTEXPR20 iterator insert(const const_iterator _Where, const initializer_list<_Elem> _Ilist) {
#if _ITERATOR_DEBUG_LEVEL != 0
        _STL_VERIFY(_Where._Getcont() == _STD addressof(_Mypair._Myval2), "string iterator incompatible");
#endif // _ITERATOR_DEBUG_LEVEL != 0
        const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
        insert(_Off, _Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
        return begin() + static_cast<difference_type>(_Off);
    }

    _CONSTEXPR20 basic_string& replace(
        const const_iterator _First, const const_iterator _Last, const initializer_list<_Elem> _Ilist) {
        // replace with initializer_list
        _STD _Adl_verify_range(_First, _Last);
#if _ITERATOR_DEBUG_LEVEL != 0
        _STL_VERIFY(_First._Getcont() == _STD addressof(_Mypair._Myval2), "string iterators incompatible");
#endif // _ITERATOR_DEBUG_LEVEL != 0
        const auto _Offset = static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr());
        const auto _Length = static_cast<size_type>(_Last._Ptr - _First._Ptr);
        return replace(_Offset, _Length, _Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
    }

    _CONSTEXPR20 ~basic_string() noexcept {
        _Tidy_deallocate();
#if _ITERATOR_DEBUG_LEVEL != 0
        auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
        const auto _To_delete = _Mypair._Myval2._Myproxy;
        _Mypair._Myval2._Myproxy = nullptr;
        _Delete_plain_internal(_Alproxy, _To_delete);
#endif // _ITERATOR_DEBUG_LEVEL != 0
    }

    static constexpr auto npos{ static_cast<size_type>(-1) };

    _CONSTEXPR20 basic_string& operator=(const basic_string& _Right) {
        if (this == _STD addressof(_Right)) {
            return *this;
        }

        auto& _Al = _Getal();
        const auto& _Right_al = _Right._Getal();
        if constexpr (_Choose_pocca_v<_Alty>) {
            if (_Al != _Right_al) {
                auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
                auto&& _Right_alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Right_al);
                _Container_proxy_ptr<_Alty> _New_proxy(_Right_alproxy, _Leave_proxy_unbound{}); // throws

                const size_type _Right_size = _Right._Mypair._Myval2._Mysize;
                const _Elem* const _Right_ptr = _Right._Mypair._Myval2._Myptr();
                if (_Right_size > _Small_string_capacity) {
                    size_type _New_capacity = _Calculate_growth(_Right_size, _Small_string_capacity, _Right.max_size());
                    auto _Right_al_non_const = _Right_al;
                    const pointer _New_ptr = _Allocate_for_capacity(_Right_al_non_const, _New_capacity); // throws
                    _Traits::copy(_Unfancy(_New_ptr), _Right_ptr, _Right_size + 1);

                    _Tidy_deallocate();
                    _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);
                    _Mypair._Myval2._Mysize = _Right_size;
                    _Mypair._Myval2._Myres = _New_capacity;
                    _ASAN_STRING_CREATE(*this);
                }
                else {
                    _Tidy_deallocate();
                    _Traits::copy(_Mypair._Myval2._Bx._Buf, _Right_ptr, _Right_size + 1);
                    _Mypair._Myval2._Mysize = _Right_size;
                    _Mypair._Myval2._Myres = _Small_string_capacity;
                }

                _Pocca(_Al, _Right_al);
                _New_proxy._Bind(_Alproxy, _STD addressof(_Mypair._Myval2));
                return *this;
            }
        }

        _Pocca(_Al, _Right_al);
        assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
        return *this;
    }

#if _HAS_CXX17
    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    _CONSTEXPR20 basic_string& operator=(const _StringViewIsh& _Right) {
        return assign(_Right);
    }
#endif // _HAS_CXX17

    _CONSTEXPR20 basic_string& operator=(_In_z_ const _Elem* const _Ptr) {
        return assign(_Ptr);
    }

#if _HAS_CXX23
    basic_string& operator=(nullptr_t) = delete;
#endif // _HAS_CXX23

    _CONSTEXPR20 basic_string& operator=(const _Elem _Ch) { // assign {_Ch, _Elem()}
        _ASAN_STRING_MODIFY(*this, _Mypair._Myval2._Mysize, 1);
        _Mypair._Myval2._Mysize = 1;
        _Elem* const _Ptr = _Mypair._Myval2._Myptr();
        _Traits::assign(_Ptr[0], _Ch);
        _Traits::assign(_Ptr[1], _Elem());
        return *this;
    }

    _CONSTEXPR20 basic_string& operator+=(const basic_string& _Right) {
        return append(_Right);
    }

#if _HAS_CXX17
    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    _CONSTEXPR20 basic_string& operator+=(const _StringViewIsh& _Right) {
        return append(_Right);
    }
#endif // _HAS_CXX17

    _CONSTEXPR20 basic_string& operator+=(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)
        return append(_Ptr);
    }

    _CONSTEXPR20 basic_string& operator+=(_Elem _Ch) {
        push_back(_Ch);
        return *this;
    }

    _CONSTEXPR20 basic_string& append(const basic_string& _Right) {
        return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    }

    _CONSTEXPR20 basic_string& append(const basic_string& _Right, const size_type _Roff, size_type _Count = npos) {
        // append _Right [_Roff, _Roff + _Count)
        _Right._Mypair._Myval2._Check_offset(_Roff);
        _Count = _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count);
        return append(_Right._Mypair._Myval2._Myptr() + _Roff, _Count);
    }

#if _HAS_CXX17
    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    _CONSTEXPR20 basic_string& append(const _StringViewIsh& _Right) {
        const basic_string_view<_Elem, _Traits> _As_view = _Right;
        return append(_As_view.data(), _Convert_size<size_type>(_As_view.size()));
    }

    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    _CONSTEXPR20 basic_string& append(
        const _StringViewIsh& _Right, const size_type _Roff, const size_type _Count = npos) {
        // append _Right [_Roff, _Roff + _Count)
        basic_string_view<_Elem, _Traits> _As_view = _Right;
        return append(_As_view.substr(_Roff, _Count));
    }
#endif // _HAS_CXX17

    _CONSTEXPR20 basic_string& append(
        _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {
        // append [_Ptr, _Ptr + _Count)
        const size_type _Old_size = _Mypair._Myval2._Mysize;
        if (_Count <= _Mypair._Myval2._Myres - _Old_size) {
            _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
            _Mypair._Myval2._Mysize = _Old_size + _Count;
            _Elem* const _Old_ptr = _Mypair._Myval2._Myptr();
            _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);
            _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());
            return *this;
        }

        return _Reallocate_grow_by(
            _Count,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
                const size_type _Count) _STATIC_CALL_OPERATOR{
                _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
                _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
                _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
            },
            _Ptr, _Count);
    }

    _CONSTEXPR20 basic_string& append(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)
        return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
    }

    _CONSTEXPR20 basic_string& append(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) {
        // append _Count * _Ch
        const size_type _Old_size = _Mypair._Myval2._Mysize;
        if (_Count <= _Mypair._Myval2._Myres - _Old_size) {
            _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
            _Mypair._Myval2._Mysize = _Old_size + _Count;
            _Elem* const _Old_ptr = _Mypair._Myval2._Myptr();
            _Traits::assign(_Old_ptr + _Old_size, _Count, _Ch);
            _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());
            return *this;
        }

        return _Reallocate_grow_by(
            _Count,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Count,
                const _Elem _Ch) _STATIC_CALL_OPERATOR{
                _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
                _Traits::assign(_New_ptr + _Old_size, _Count, _Ch);
                _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
            },
            _Count, _Ch);
    }

    template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    _CONSTEXPR20 basic_string& append(const _Iter _First, const _Iter _Last) {
        // append [_First, _Last), input iterators
        _STD _Adl_verify_range(_First, _Last);
        const auto _UFirst = _STD _Get_unwrapped(_First);
        const auto _ULast = _STD _Get_unwrapped(_Last);
        if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
            return append(_UFirst, _STD _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
        }
        else {
            const basic_string _Right(_UFirst, _ULast, get_allocator());
            return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
        }
    }

#if _HAS_CXX23
    template <_Container_compatible_range<_Elem> _Rng>
    constexpr basic_string& append_range(_Rng&& _Range) {
        if constexpr (_RANGES sized_range<_Rng> && _Contiguous_range_of<_Rng, _Elem>) {
            const auto _Count = _Convert_size<size_type>(_To_unsigned_like(_RANGES size(_Range)));
            return append(_RANGES data(_Range), _Count);
        }
        else {
            const basic_string _Right(from_range, _Range, get_allocator());
            return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
        }
    }
#endif // _HAS_CXX23

    _CONSTEXPR20 basic_string& assign(const basic_string& _Right) {
        *this = _Right;
        return *this;
    }

    _CONSTEXPR20 basic_string& assign(const basic_string& _Right, const size_type _Roff, size_type _Count = npos) {
        // assign _Right [_Roff, _Roff + _Count)
        _Right._Mypair._Myval2._Check_offset(_Roff);
        _Count = _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count);
        return assign(_Right._Mypair._Myval2._Myptr() + _Roff, _Count);
    }

#if _HAS_CXX17
    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    _CONSTEXPR20 basic_string& assign(const _StringViewIsh& _Right) {
        const basic_string_view<_Elem, _Traits> _As_view = _Right;
        return assign(_As_view.data(), _Convert_size<size_type>(_As_view.size()));
    }

    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    _CONSTEXPR20 basic_string& assign(
        const _StringViewIsh& _Right, const size_type _Roff, const size_type _Count = npos) {
        // assign _Right [_Roff, _Roff + _Count)
        basic_string_view<_Elem, _Traits> _As_view = _Right;
        return assign(_As_view.substr(_Roff, _Count));
    }
#endif // _HAS_CXX17

    _CONSTEXPR20 basic_string& assign(
        _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {
        // assign [_Ptr, _Ptr + _Count)
        if (_Count <= _Mypair._Myval2._Myres) {
            _ASAN_STRING_REMOVE(*this);
            _Elem* const _Old_ptr = _Mypair._Myval2._Myptr();
            _Mypair._Myval2._Mysize = _Count;
            _Traits::move(_Old_ptr, _Ptr, _Count);
            _Traits::assign(_Old_ptr[_Count], _Elem());
            _ASAN_STRING_CREATE(*this);
            return *this;
        }

        return _Reallocate_for(
            _Count,
            [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) _STATIC_CALL_OPERATOR{
                _Traits::copy(_New_ptr, _Ptr, _Count);
                _Traits::assign(_New_ptr[_Count], _Elem());
            },
            _Ptr);
    }

    _CONSTEXPR20 basic_string& assign(_In_z_ const _Elem* const _Ptr) {
        return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
    }

    _CONSTEXPR20 basic_string& assign(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) {
        // assign _Count * _Ch
        if (_Count <= _Mypair._Myval2._Myres) {
            _ASAN_STRING_MODIFY(*this, _Mypair._Myval2._Mysize, _Count);
            _Elem* const _Old_ptr = _Mypair._Myval2._Myptr();
            _Mypair._Myval2._Mysize = _Count;
            _Traits::assign(_Old_ptr, _Count, _Ch);
            _Traits::assign(_Old_ptr[_Count], _Elem());
            return *this;
        }

        return _Reallocate_for(
            _Count,
            [](_Elem* const _New_ptr, const size_type _Count, const _Elem _Ch) _STATIC_CALL_OPERATOR{
                _Traits::assign(_New_ptr, _Count, _Ch);
                _Traits::assign(_New_ptr[_Count], _Elem());
            },
            _Ch);
    }

    template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    _CONSTEXPR20 basic_string& assign(const _Iter _First, const _Iter _Last) {
        _STD _Adl_verify_range(_First, _Last);
        const auto _UFirst = _STD _Get_unwrapped(_First);
        const auto _ULast = _STD _Get_unwrapped(_Last);
        if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
            return assign(_UFirst, _STD _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
        }
        else {
            basic_string _Right(_UFirst, _ULast, get_allocator());
            if (_Mypair._Myval2._Myres < _Right._Mypair._Myval2._Myres) {
                _Mypair._Myval2._Orphan_all();
                _Swap_data(_Right);
                return *this;
            }
            else {
                return assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
            }
        }
    }

#if _HAS_CXX23
    template <_Container_compatible_range<_Elem> _Rng>
    constexpr basic_string& assign_range(_Rng&& _Range) {
        if constexpr (_RANGES sized_range<_Rng> && _Contiguous_range_of<_Rng, _Elem>) {
            const auto _Count = _Convert_size<size_type>(_To_unsigned_like(_RANGES size(_Range)));
            return assign(_RANGES data(_Range), _Count);
        }
        else {
            basic_string _Right(from_range, _Range, get_allocator());
            if (_Mypair._Myval2._Myres < _Right._Mypair._Myval2._Myres) {
                _Mypair._Myval2._Orphan_all();
                _Swap_data(_Right);
                return *this;
            }
            else {
                return assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
            }
        }
    }
#endif // _HAS_CXX23

    _CONSTEXPR20 basic_string& insert(const size_type _Off, const basic_string& _Right) {
        // insert _Right at _Off
        return insert(_Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    }

    _CONSTEXPR20 basic_string& insert(
        const size_type _Off, const basic_string& _Right, const size_type _Roff, size_type _Count = npos) {
        // insert _Right [_Roff, _Roff + _Count) at _Off
        _Right._Mypair._Myval2._Check_offset(_Roff);
        _Count = _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count);
        return insert(_Off, _Right._Mypair._Myval2._Myptr() + _Roff, _Count);
    }

#if _HAS_CXX17
    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    _CONSTEXPR20 basic_string& insert(const size_type _Off, const _StringViewIsh& _Right) {
        // insert _Right at _Off
        const basic_string_view<_Elem, _Traits> _As_view = _Right;
        return insert(_Off, _As_view.data(), _Convert_size<size_type>(_As_view.size()));
    }

    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    _CONSTEXPR20 basic_string& insert(
        const size_type _Off, const _StringViewIsh& _Right, const size_type _Roff, const size_type _Count = npos) {
        // insert _Right [_Roff, _Roff + _Count) at _Off
        basic_string_view<_Elem, _Traits> _As_view = _Right;
        return insert(_Off, _As_view.substr(_Roff, _Count));
    }
#endif // _HAS_CXX17

    _CONSTEXPR20 basic_string& insert(
        const size_type _Off, _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {
        // insert [_Ptr, _Ptr + _Count) at _Off
        _Mypair._Myval2._Check_offset(_Off);
        const size_type _Old_size = _Mypair._Myval2._Mysize;

        // We can't check for overlapping ranges when constant evaluated since comparison of pointers into string
        // literals is unspecified, so always reallocate and copy to the new buffer if constant evaluated.
#if _HAS_CXX20
        const bool _Check_overlap = _Count <= _Mypair._Myval2._Myres - _Old_size && !_STD is_constant_evaluated();
#else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
        const bool _Check_overlap = _Count <= _Mypair._Myval2._Myres - _Old_size;
#endif // ^^^ !_HAS_CXX20 ^^^

        if (_Check_overlap) {
            _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
            _Mypair._Myval2._Mysize = _Old_size + _Count;
            _Elem* const _Old_ptr = _Mypair._Myval2._Myptr();
            _Elem* const _Insert_at = _Old_ptr + _Off;
            // the range [_Ptr, _Ptr + _Ptr_shifted_after) is left alone by moving the suffix out,
            // while the range [_Ptr + _Ptr_shifted_after, _Ptr + _Count) shifts down by _Count
            size_type _Ptr_shifted_after;
            if (_Ptr + _Count <= _Insert_at || _Ptr > _Old_ptr + _Old_size) {
                // inserted content is before the shifted region, or does not alias
                _Ptr_shifted_after = _Count; // none of _Ptr's data shifts
            }
            else if (_Insert_at <= _Ptr) { // all of [_Ptr, _Ptr + _Count) shifts
                _Ptr_shifted_after = 0;
            }
            else { // [_Ptr, _Ptr + _Count) contains _Insert_at, so only the part after _Insert_at shifts
                _Ptr_shifted_after = static_cast<size_type>(_Insert_at - _Ptr);
            }

            _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down
            _Traits::copy(_Insert_at, _Ptr, _Ptr_shifted_after);
            _Traits::copy(
                _Insert_at + _Ptr_shifted_after, _Ptr + _Count + _Ptr_shifted_after, _Count - _Ptr_shifted_after);
            return *this;
        }

        return _Reallocate_grow_by(
            _Count,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
                const _Elem* const _Ptr, const size_type _Count) _STATIC_CALL_OPERATOR{
                _Traits::copy(_New_ptr, _Old_ptr, _Off);
                _Traits::copy(_New_ptr + _Off, _Ptr, _Count);
                _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);
            },
            _Off, _Ptr, _Count);
    }

    _CONSTEXPR20 basic_string& insert(const size_type _Off, _In_z_ const _Elem* const _Ptr) {
        // insert [_Ptr, <null>) at _Off
        return insert(_Off, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
    }

    _CONSTEXPR20 basic_string& insert(
        const size_type _Off, _CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) {
        // insert _Count * _Ch at _Off
        _Mypair._Myval2._Check_offset(_Off);
        const size_type _Old_size = _Mypair._Myval2._Mysize;
        if (_Count <= _Mypair._Myval2._Myres - _Old_size) {
            _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
            _Mypair._Myval2._Mysize = _Old_size + _Count;
            _Elem* const _Old_ptr = _Mypair._Myval2._Myptr();
            _Elem* const _Insert_at = _Old_ptr + _Off;
            _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down
            _Traits::assign(_Insert_at, _Count, _Ch); // fill hole
            return *this;
        }

        return _Reallocate_grow_by(
            _Count,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
                const size_type _Count, const _Elem _Ch) _STATIC_CALL_OPERATOR{
                _Traits::copy(_New_ptr, _Old_ptr, _Off);
                _Traits::assign(_New_ptr + _Off, _Count, _Ch);
                _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);
            },
            _Off, _Count, _Ch);
    }

    _CONSTEXPR20 iterator insert(const const_iterator _Where, const _Elem _Ch) { // insert _Ch at _Where
#if _ITERATOR_DEBUG_LEVEL != 0
        _STL_VERIFY(_Where._Getcont() == _STD addressof(_Mypair._Myval2), "string iterator incompatible");
#endif // _ITERATOR_DEBUG_LEVEL != 0
        const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
        insert(_Off, 1, _Ch);
        return begin() + static_cast<difference_type>(_Off);
    }

    _CONSTEXPR20 iterator insert(
        const const_iterator _Where, _CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) {
        // insert _Count * _Elem at _Where
#if _ITERATOR_DEBUG_LEVEL != 0
        _STL_VERIFY(_Where._Getcont() == _STD addressof(_Mypair._Myval2), "string iterator incompatible");
#endif // _ITERATOR_DEBUG_LEVEL != 0
        const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
        insert(_Off, _Count, _Ch);
        return begin() + static_cast<difference_type>(_Off);
    }

    template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    _CONSTEXPR20 iterator insert(const const_iterator _Where, const _Iter _First, const _Iter _Last) {
        // insert [_First, _Last) at _Where, input iterators
#if _ITERATOR_DEBUG_LEVEL != 0
        _STL_VERIFY(_Where._Getcont() == _STD addressof(_Mypair._Myval2), "string iterator incompatible");
#endif // _ITERATOR_DEBUG_LEVEL != 0
        const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
        _STD _Adl_verify_range(_First, _Last);
        const auto _UFirst = _STD _Get_unwrapped(_First);
        const auto _ULast = _STD _Get_unwrapped(_Last);
        if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
            insert(_Off, _UFirst, _STD _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
        }
        else {
            const basic_string _Right(_UFirst, _ULast, get_allocator());
            insert(_Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
        }

        return begin() + static_cast<difference_type>(_Off);
    }

#if _HAS_CXX23
    template <_Container_compatible_range<_Elem> _Rng>
    constexpr iterator insert_range(const const_iterator _Where, _Rng&& _Range) {
#if _ITERATOR_DEBUG_LEVEL != 0
        _STL_VERIFY(_Where._Getcont() == _STD addressof(_Mypair._Myval2), "string iterator incompatible");
#endif // _ITERATOR_DEBUG_LEVEL != 0
        const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());

        if constexpr (_RANGES sized_range<_Rng> && _Contiguous_range_of<_Rng, _Elem>) {
            const auto _Count = _Convert_size<size_type>(_To_unsigned_like(_RANGES size(_Range)));
            insert(_Off, _RANGES data(_Range), _Count);
        }
        else {
            const basic_string _Right(from_range, _Range, get_allocator());
            insert(_Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
        }

        return begin() + static_cast<difference_type>(_Off);
    }
#endif // _HAS_CXX23

    _CONSTEXPR20 basic_string& erase(const size_type _Off = 0) { // erase elements [_Off, ...)
        _Mypair._Myval2._Check_offset(_Off);
        _Eos(_Off);
        return *this;
    }

private:
    _CONSTEXPR20 basic_string& _Erase_noexcept(const size_type _Off, size_type _Count) noexcept {
        _Count = _Mypair._Myval2._Clamp_suffix_size(_Off, _Count);
        const size_type _Old_size = _Mypair._Myval2._Mysize;
        _Elem* const _My_ptr = _Mypair._Myval2._Myptr();
        _Elem* const _Erase_at = _My_ptr + _Off;
        const size_type _New_size = _Old_size - _Count;
        _Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up
        _ASAN_STRING_MODIFY(*this, _Old_size, _New_size);
        _Mypair._Myval2._Mysize = _New_size;
        return *this;
    }

public:
    _CONSTEXPR20 basic_string& erase(const size_type _Off, const size_type _Count) {
        // erase elements [_Off, _Off + _Count)
        _Mypair._Myval2._Check_offset(_Off);
        return _Erase_noexcept(_Off, _Count);
    }

    _CONSTEXPR20 iterator erase(const const_iterator _Where) noexcept /* strengthened */ {
#if _ITERATOR_DEBUG_LEVEL != 0
        _STL_VERIFY(_Where._Getcont() == _STD addressof(_Mypair._Myval2), "string iterator incompatible");
#endif // _ITERATOR_DEBUG_LEVEL != 0
        const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
        _Erase_noexcept(_Off, 1);
        return begin() + static_cast<difference_type>(_Off);
    }

    _CONSTEXPR20 iterator erase(const const_iterator _First, const const_iterator _Last) noexcept
        /* strengthened */ {
        _STD _Adl_verify_range(_First, _Last);
#if _ITERATOR_DEBUG_LEVEL != 0
        _STL_VERIFY(_First._Getcont() == _STD addressof(_Mypair._Myval2), "string iterators incompatible");
#endif // _ITERATOR_DEBUG_LEVEL != 0
        const auto _Off = static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr());
        _Erase_noexcept(_Off, static_cast<size_type>(_Last._Ptr - _First._Ptr));
        return begin() + static_cast<difference_type>(_Off);
    }

    _CONSTEXPR20 void clear() noexcept { // erase all
        _Eos(0);
    }

    _CONSTEXPR20 basic_string& replace(const size_type _Off, const size_type _Nx, const basic_string& _Right) {
        // replace [_Off, _Off + _Nx) with _Right
        return replace(_Off, _Nx, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    }

    _CONSTEXPR20 basic_string& replace(const size_type _Off, size_type _Nx, const basic_string& _Right,
        const size_type _Roff, size_type _Count = npos) {
        // replace [_Off, _Off + _Nx) with _Right [_Roff, _Roff + _Count)
        _Right._Mypair._Myval2._Check_offset(_Roff);
        _Count = _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count);
        return replace(_Off, _Nx, _Right._Mypair._Myval2._Myptr() + _Roff, _Count);
    }

#if _HAS_CXX17
    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    _CONSTEXPR20 basic_string& replace(const size_type _Off, const size_type _Nx, const _StringViewIsh& _Right) {
        // replace [_Off, _Off + _Nx) with _Right
        basic_string_view<_Elem, _Traits> _As_view = _Right;
        return replace(_Off, _Nx, _As_view.data(), _Convert_size<size_type>(_As_view.size()));
    }

    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    _CONSTEXPR20 basic_string& replace(const size_type _Off, const size_type _Nx, const _StringViewIsh& _Right,
        const size_type _Roff, const size_type _Count = npos) {
        // replace [_Off, _Off + _Nx) with _Right [_Roff, _Roff + _Count)
        basic_string_view<_Elem, _Traits> _As_view = _Right;
        return replace(_Off, _Nx, _As_view.substr(_Roff, _Count));
    }
#endif // _HAS_CXX17

    _CONSTEXPR20 basic_string& replace(
        const size_type _Off, size_type _Nx, _In_reads_(_Count) const _Elem* const _Ptr, const size_type _Count) {
        // replace [_Off, _Off + _Nx) with [_Ptr, _Ptr + _Count)
        _Mypair._Myval2._Check_offset(_Off);
        _Nx = _Mypair._Myval2._Clamp_suffix_size(_Off, _Nx);
        if (_Nx == _Count) { // size doesn't change, so a single move does the trick
            _Traits::move(_Mypair._Myval2._Myptr() + _Off, _Ptr, _Count);
            return *this;
        }

        const size_type _Old_size = _Mypair._Myval2._Mysize;
        const size_type _Suffix_size = _Old_size - _Nx - _Off + 1;
        if (_Count < _Nx) { // suffix shifts backwards; we don't have to move anything out of the way
            _Elem* const _Old_ptr = _Mypair._Myval2._Myptr();
            _Elem* const _Insert_at = _Old_ptr + _Off;
            _Traits::move(_Insert_at, _Ptr, _Count);
            _Traits::move(_Insert_at + _Count, _Insert_at + _Nx, _Suffix_size);

            const auto _New_size = _Old_size - (_Nx - _Count);
            _ASAN_STRING_MODIFY(*this, _Old_size, _New_size);
            _Mypair._Myval2._Mysize = _New_size;
            return *this;
        }

        const size_type _Growth = static_cast<size_type>(_Count - _Nx);

        // checking for overlapping ranges is technically UB (considering string literals), so just always reallocate
        // and copy to the new buffer if constant evaluated
#if _HAS_CXX20
        if (!_STD is_constant_evaluated())
#endif // _HAS_CXX20
        {
            if (_Growth <= _Mypair._Myval2._Myres - _Old_size) { // growth fits
                _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Growth);
                _Mypair._Myval2._Mysize = _Old_size + _Growth;
                _Elem* const _Old_ptr = _Mypair._Myval2._Myptr();
                _Elem* const _Insert_at = _Old_ptr + _Off;
                _Elem* const _Suffix_at = _Insert_at + _Nx;

                size_type _Ptr_shifted_after; // see rationale in insert
                if (_Ptr + _Count <= _Insert_at || _Ptr > _Old_ptr + _Old_size) {
                    _Ptr_shifted_after = _Count;
                }
                else if (_Suffix_at <= _Ptr) {
                    _Ptr_shifted_after = 0;
                }
                else {
                    _Ptr_shifted_after = static_cast<size_type>(_Suffix_at - _Ptr);
                }

                _Traits::move(_Suffix_at + _Growth, _Suffix_at, _Suffix_size);
                // next case must be move, in case _Ptr begins before _Insert_at and contains part of the hole;
                // this case doesn't occur in insert because the new content must come from outside the removed
                // content there (because in insert there is no removed content)
                _Traits::move(_Insert_at, _Ptr, _Ptr_shifted_after);
                // the next case can be copy, because it comes from the chunk moved out of the way in the
                // first move, and the hole we're filling can't alias the chunk we moved out of the way
                _Traits::copy(
                    _Insert_at + _Ptr_shifted_after, _Ptr + _Growth + _Ptr_shifted_after, _Count - _Ptr_shifted_after);
                return *this;
            }
        }

        return _Reallocate_grow_by(
            _Growth,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
                const size_type _Nx, const _Elem* const _Ptr, const size_type _Count) _STATIC_CALL_OPERATOR{
                _Traits::copy(_New_ptr, _Old_ptr, _Off);
                _Traits::copy(_New_ptr + _Off, _Ptr, _Count);
                _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off + _Nx, _Old_size - _Nx - _Off + 1);
            },
            _Off, _Nx, _Ptr, _Count);
    }

    _CONSTEXPR20 basic_string& replace(const size_type _Off, const size_type _Nx, _In_z_ const _Elem* const _Ptr) {
        // replace [_Off, _Off + _Nx) with [_Ptr, <null>)
        return replace(_Off, _Nx, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
    }

    _CONSTEXPR20 basic_string& replace(const size_type _Off, size_type _Nx, const size_type _Count, const _Elem _Ch) {
        // replace [_Off, _Off + _Nx) with _Count * _Ch
        _Mypair._Myval2._Check_offset(_Off);
        _Nx = _Mypair._Myval2._Clamp_suffix_size(_Off, _Nx);
        if (_Count == _Nx) {
            _Traits::assign(_Mypair._Myval2._Myptr() + _Off, _Count, _Ch);
            return *this;
        }

        const size_type _Old_size = _Mypair._Myval2._Mysize;
        if (_Count < _Nx || _Count - _Nx <= _Mypair._Myval2._Myres - _Old_size) {
            // either we are shrinking, or the growth fits
            // may temporarily overflow; OK because size_type must be unsigned
            const auto _New_size = _Old_size + _Count - _Nx;
            _ASAN_STRING_REMOVE(*this);
            _Mypair._Myval2._Mysize = _New_size;
            _Elem* const _Old_ptr = _Mypair._Myval2._Myptr();
            _Elem* const _Insert_at = _Old_ptr + _Off;
            _Traits::move(_Insert_at + _Count, _Insert_at + _Nx, _Old_size - _Nx - _Off + 1);
            _Traits::assign(_Insert_at, _Count, _Ch);
            _ASAN_STRING_CREATE(*this);
            return *this;
        }

        return _Reallocate_grow_by(
            _Count - _Nx,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
                const size_type _Nx, const size_type _Count, const _Elem _Ch) _STATIC_CALL_OPERATOR{
                _Traits::copy(_New_ptr, _Old_ptr, _Off);
                _Traits::assign(_New_ptr + _Off, _Count, _Ch);
                _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off + _Nx, _Old_size - _Nx - _Off + 1);
            },
            _Off, _Nx, _Count, _Ch);
    }

    _CONSTEXPR20 basic_string& replace(
        const const_iterator _First, const const_iterator _Last, const basic_string& _Right) {
        // replace [_First, _Last) with _Right
        _STD _Adl_verify_range(_First, _Last);
#if _ITERATOR_DEBUG_LEVEL != 0
        _STL_VERIFY(_First._Getcont() == _STD addressof(_Mypair._Myval2), "string iterators incompatible");
#endif // _ITERATOR_DEBUG_LEVEL != 0
        return replace(static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr()),
            static_cast<size_type>(_Last._Ptr - _First._Ptr), _Right);
    }

#if _HAS_CXX17
    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    _CONSTEXPR20 basic_string& replace(
        const const_iterator _First, const const_iterator _Last, const _StringViewIsh& _Right) {
        // replace [_First, _Last) with _Right
        _STD _Adl_verify_range(_First, _Last);
#if _ITERATOR_DEBUG_LEVEL != 0
        _STL_VERIFY(_First._Getcont() == _STD addressof(_Mypair._Myval2), "string iterators incompatible");
#endif // _ITERATOR_DEBUG_LEVEL != 0
        return replace(static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr()),
            static_cast<size_type>(_Last._Ptr - _First._Ptr), _Right);
    }
#endif // _HAS_CXX17

    _CONSTEXPR20 basic_string& replace(const const_iterator _First, const const_iterator _Last,
        _In_reads_(_Count) const _Elem* const _Ptr, const size_type _Count) {
        // replace [_First, _Last) with [_Ptr, _Ptr + _Count)
        _STD _Adl_verify_range(_First, _Last);
#if _ITERATOR_DEBUG_LEVEL != 0
        _STL_VERIFY(_First._Getcont() == _STD addressof(_Mypair._Myval2), "string iterators incompatible");
#endif // _ITERATOR_DEBUG_LEVEL != 0
        return replace(static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr()),
            static_cast<size_type>(_Last._Ptr - _First._Ptr), _Ptr, _Count);
    }

    _CONSTEXPR20 basic_string& replace(
        const const_iterator _First, const const_iterator _Last, _In_z_ const _Elem* const _Ptr) {
        // replace [_First, _Last) with [_Ptr, <null>)
        _STD _Adl_verify_range(_First, _Last);
#if _ITERATOR_DEBUG_LEVEL != 0
        _STL_VERIFY(_First._Getcont() == _STD addressof(_Mypair._Myval2), "string iterators incompatible");
#endif // _ITERATOR_DEBUG_LEVEL != 0
        return replace(static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr()),
            static_cast<size_type>(_Last._Ptr - _First._Ptr), _Ptr);
    }

    _CONSTEXPR20 basic_string& replace(
        const const_iterator _First, const const_iterator _Last, const size_type _Count, const _Elem _Ch) {
        // replace [_First, _Last) with _Count * _Ch
        _STD _Adl_verify_range(_First, _Last);
#if _ITERATOR_DEBUG_LEVEL != 0
        _STL_VERIFY(_First._Getcont() == _STD addressof(_Mypair._Myval2), "string iterators incompatible");
#endif // _ITERATOR_DEBUG_LEVEL != 0
        return replace(static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr()),
            static_cast<size_type>(_Last._Ptr - _First._Ptr), _Count, _Ch);
    }

    template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    _CONSTEXPR20 basic_string& replace(
        const const_iterator _First, const const_iterator _Last, const _Iter _First2, const _Iter _Last2) {
        // replace [_First, _Last) with [_First2, _Last2), input iterators
        _STD _Adl_verify_range(_First, _Last);
#if _ITERATOR_DEBUG_LEVEL != 0
        _STL_VERIFY(_First._Getcont() == _STD addressof(_Mypair._Myval2), "string iterators incompatible");
#endif // _ITERATOR_DEBUG_LEVEL != 0
        const auto _Off = static_cast<size_type>(_STD _Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr());
        const auto _Length = static_cast<size_type>(_Last._Ptr - _First._Ptr);
        _STD _Adl_verify_range(_First2, _Last2);
        const auto _UFirst2 = _STD _Get_unwrapped(_First2);
        const auto _ULast2 = _STD _Get_unwrapped(_Last2);
        if constexpr (_Is_elem_cptr<decltype(_UFirst2)>::value) {
            return replace(
                _Off, _Length, _UFirst2, _STD _Convert_size<size_type>(static_cast<size_t>(_ULast2 - _UFirst2)));
        }
        else {
            const basic_string _Right(_UFirst2, _ULast2, get_allocator());
            return replace(_Off, _Length, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
        }
    }

#if _HAS_CXX23
    template <_Container_compatible_range<_Elem> _Rng>
    constexpr basic_string& replace_with_range(const const_iterator _First, const const_iterator _Last, _Rng&& _Range) {
        _STD _Adl_verify_range(_First, _Last);
#if _ITERATOR_DEBUG_LEVEL != 0
        _STL_VERIFY(_First._Getcont() == _STD addressof(_Mypair._Myval2), "string iterators incompatible");
#endif // _ITERATOR_DEBUG_LEVEL != 0
        const auto _Off = static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr());
        const auto _Length = static_cast<size_type>(_Last._Ptr - _First._Ptr);

        if constexpr (_RANGES sized_range<_Rng> && _Contiguous_range_of<_Rng, _Elem>) {
            const auto _Count = _Convert_size<size_type>(_To_unsigned_like(_RANGES size(_Range)));
            return replace(_Off, _Length, _RANGES data(_Range), _Count);
        }
        else {
            const basic_string _Right(from_range, _Range, get_allocator());
            return replace(_Off, _Length, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
        }
    }
#endif // _HAS_CXX23

    _NODISCARD _CONSTEXPR20 iterator begin() noexcept {
        return iterator(_Refancy<pointer>(_Mypair._Myval2._Myptr()), _STD addressof(_Mypair._Myval2));
    }

    _NODISCARD _CONSTEXPR20 const_iterator begin() const noexcept {
        return const_iterator(_Refancy<const_pointer>(_Mypair._Myval2._Myptr()), _STD addressof(_Mypair._Myval2));
    }

    _NODISCARD _CONSTEXPR20 iterator end() noexcept {
        return iterator(
            _Refancy<pointer>(_Mypair._Myval2._Myptr()) + static_cast<difference_type>(_Mypair._Myval2._Mysize),
            _STD addressof(_Mypair._Myval2));
    }

    _NODISCARD _CONSTEXPR20 const_iterator end() const noexcept {
        return const_iterator(
            _Refancy<const_pointer>(_Mypair._Myval2._Myptr()) + static_cast<difference_type>(_Mypair._Myval2._Mysize),
            _STD addressof(_Mypair._Myval2));
    }

    _NODISCARD _CONSTEXPR20 _Elem* _Unchecked_begin() noexcept {
        return _Mypair._Myval2._Myptr();
    }

    _NODISCARD _CONSTEXPR20 const _Elem* _Unchecked_begin() const noexcept {
        return _Mypair._Myval2._Myptr();
    }

    _NODISCARD _CONSTEXPR20 _Elem* _Unchecked_end() noexcept {
        return _Mypair._Myval2._Myptr() + _Mypair._Myval2._Mysize;
    }

    _NODISCARD _CONSTEXPR20 const _Elem* _Unchecked_end() const noexcept {
        return _Mypair._Myval2._Myptr() + _Mypair._Myval2._Mysize;
    }

    _NODISCARD _CONSTEXPR20 reverse_iterator rbegin() noexcept {
        return reverse_iterator(end());
    }

    _NODISCARD _CONSTEXPR20 const_reverse_iterator rbegin() const noexcept {
        return const_reverse_iterator(end());
    }

    _NODISCARD _CONSTEXPR20 reverse_iterator rend() noexcept {
        return reverse_iterator(begin());
    }

    _NODISCARD _CONSTEXPR20 const_reverse_iterator rend() const noexcept {
        return const_reverse_iterator(begin());
    }

    _NODISCARD _CONSTEXPR20 const_iterator cbegin() const noexcept {
        return begin();
    }

    _NODISCARD _CONSTEXPR20 const_iterator cend() const noexcept {
        return end();
    }

    _NODISCARD _CONSTEXPR20 const_reverse_iterator crbegin() const noexcept {
        return rbegin();
    }

    _NODISCARD _CONSTEXPR20 const_reverse_iterator crend() const noexcept {
        return rend();
    }

    _CONSTEXPR20 void shrink_to_fit() { // reduce capacity
        auto& _My_data = _Mypair._Myval2;

        if (!_My_data._Large_mode_engaged()) { // can't shrink from small mode
            return;
        }

        if (_My_data._Mysize <= _Small_string_capacity) {
            _Become_small();
            return;
        }

        size_type _Target_capacity = (_STD min)(_My_data._Mysize | _Alloc_mask, max_size());
        if (_Target_capacity < _My_data._Myres) { // worth shrinking, do it
            auto& _Al = _Getal();
            const pointer _New_ptr =
                _Allocate_for_capacity<_Allocation_policy::_Exactly>(_Al, _Target_capacity); // throws
            _ASAN_STRING_REMOVE(*this);

            _My_data._Orphan_all();
            _Traits::copy(_Unfancy(_New_ptr), _Unfancy(_My_data._Bx._Ptr), _My_data._Mysize + 1);
            _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);
            _My_data._Bx._Ptr = _New_ptr;
            _My_data._Myres = _Target_capacity;
            _ASAN_STRING_CREATE(*this);
        }
    }

    _NODISCARD _CONSTEXPR20 reference at(const size_type _Off) {
        _Mypair._Myval2._Check_offset_exclusive(_Off);
        return _Mypair._Myval2._Myptr()[_Off];
    }

    _NODISCARD _CONSTEXPR20 const_reference at(const size_type _Off) const {
        _Mypair._Myval2._Check_offset_exclusive(_Off);
        return _Mypair._Myval2._Myptr()[_Off];
    }

    _NODISCARD _CONSTEXPR20 reference operator[](const size_type _Off) noexcept /* strengthened */ {
#if _CONTAINER_DEBUG_LEVEL > 0
        _STL_VERIFY(_Off <= _Mypair._Myval2._Mysize, "string subscript out of range");
#endif // _CONTAINER_DEBUG_LEVEL > 0
        return _Mypair._Myval2._Myptr()[_Off];
    }

    _NODISCARD _CONSTEXPR20 const_reference operator[](const size_type _Off) const noexcept
        /* strengthened */ {
#if _CONTAINER_DEBUG_LEVEL > 0
        _STL_VERIFY(_Off <= _Mypair._Myval2._Mysize, "string subscript out of range");
#endif // _CONTAINER_DEBUG_LEVEL > 0
        return _Mypair._Myval2._Myptr()[_Off];
    }

#if _HAS_CXX17
    /* implicit */ _CONSTEXPR20 operator basic_string_view<_Elem, _Traits>() const noexcept {
        // return a string_view around *this's character-type sequence
        return basic_string_view<_Elem, _Traits>{_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize};
    }
#endif // _HAS_CXX17

    _CONSTEXPR20 void push_back(const _Elem _Ch) { // insert element at end
        const size_type _Old_size = _Mypair._Myval2._Mysize;
        if (_Old_size < _Mypair._Myval2._Myres) {
            _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
            _Mypair._Myval2._Mysize = _Old_size + 1;
            _Elem* const _Ptr = _Mypair._Myval2._Myptr();
            _Traits::assign(_Ptr[_Old_size], _Ch);
            _Traits::assign(_Ptr[_Old_size + 1], _Elem());
            return;
        }

        _Reallocate_grow_by(
            1,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem _Ch)
            _STATIC_CALL_OPERATOR{
                _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
                _Traits::assign(_New_ptr[_Old_size], _Ch);
                _Traits::assign(_New_ptr[_Old_size + 1], _Elem());
            },
            _Ch);
    }

    _CONSTEXPR20 void pop_back() noexcept /* strengthened */ {
        const size_type _Old_size = _Mypair._Myval2._Mysize;
#if _ITERATOR_DEBUG_LEVEL >= 1
        _STL_VERIFY(_Old_size != 0, "invalid to pop_back empty string");
#endif // _ITERATOR_DEBUG_LEVEL >= 1
        _Eos(_Old_size - 1);
    }

    _NODISCARD _CONSTEXPR20 reference front() noexcept /* strengthened */ {
#if _CONTAINER_DEBUG_LEVEL > 0
        _STL_VERIFY(_Mypair._Myval2._Mysize != 0, "front() called on empty string");
#endif // _CONTAINER_DEBUG_LEVEL > 0

        return _Mypair._Myval2._Myptr()[0];
    }

    _NODISCARD _CONSTEXPR20 const_reference front() const noexcept /* strengthened */ {
#if _CONTAINER_DEBUG_LEVEL > 0
        _STL_VERIFY(_Mypair._Myval2._Mysize != 0, "front() called on empty string");
#endif // _CONTAINER_DEBUG_LEVEL > 0

        return _Mypair._Myval2._Myptr()[0];
    }

    _NODISCARD _CONSTEXPR20 reference back() noexcept /* strengthened */ {
#if _CONTAINER_DEBUG_LEVEL > 0
        _STL_VERIFY(_Mypair._Myval2._Mysize != 0, "back() called on empty string");
#endif // _CONTAINER_DEBUG_LEVEL > 0

        return _Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize - 1];
    }

    _NODISCARD _CONSTEXPR20 const_reference back() const noexcept /* strengthened */ {
#if _CONTAINER_DEBUG_LEVEL > 0
        _STL_VERIFY(_Mypair._Myval2._Mysize != 0, "back() called on empty string");
#endif // _CONTAINER_DEBUG_LEVEL > 0

        return _Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize - 1];
    }

    _NODISCARD _CONSTEXPR20 _Ret_z_ const _Elem* c_str() const noexcept {
        return _Mypair._Myval2._Myptr();
    }

    _NODISCARD _CONSTEXPR20 _Ret_z_ const _Elem* data() const noexcept {
        return _Mypair._Myval2._Myptr();
    }

#if _HAS_CXX17
    _NODISCARD _CONSTEXPR20 _Ret_z_ _Elem* data() noexcept {
        return _Mypair._Myval2._Myptr();
    }
#endif // _HAS_CXX17

    _NODISCARD _CONSTEXPR20 size_type length() const noexcept {
        return _Mypair._Myval2._Mysize;
    }

    _NODISCARD _CONSTEXPR20 size_type size() const noexcept {
        return _Mypair._Myval2._Mysize;
    }

    _NODISCARD _CONSTEXPR20 size_type max_size() const noexcept {
        const size_type _Alloc_max = _Alty_traits::max_size(_Getal());
        const size_type _Storage_max = // can always store small string
            (_STD max)(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
        return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),
            _Storage_max - 1 // -1 is for null terminator and/or npos
            );
    }

    _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _New_size, const _Elem _Ch = _Elem()) {
        // determine new length, padding with _Ch elements as needed
        const size_type _Old_size = size();
        if (_New_size <= _Old_size) {
            _Eos(_New_size);
        }
        else {
            append(_New_size - _Old_size, _Ch);
        }
    }

    template <class _Operation>
    constexpr void
#if _HAS_CXX23
        resize_and_overwrite
#else // ^^^ _HAS_CXX23 / !_HAS_CXX23 vvv
        _Resize_and_overwrite
#endif // ^^^ !_HAS_CXX23 ^^^
        (_CRT_GUARDOVERFLOW const size_type _New_size, _Operation _Op) {
        if (_Mypair._Myval2._Myres < _New_size) {
            _Reallocate_grow_by(_New_size - _Mypair._Myval2._Mysize,
                [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size)
                _STATIC_CALL_OPERATOR{ _Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1); });
        }
        else {
            _ASAN_STRING_MODIFY(*this, _Mypair._Myval2._Mysize, _New_size);
            _Mypair._Myval2._Mysize = _New_size;
        }

        auto _Arg_ptr = _Mypair._Myval2._Myptr();
        auto _Arg_size = _New_size;
        const auto _Result_size = _STD move(_Op)(_Arg_ptr, _Arg_size);
        const auto _Result_as_size_type = static_cast<size_type>(_Result_size);
#if _CONTAINER_DEBUG_LEVEL > 0
        _STL_VERIFY(_Result_size >= 0, "the returned size can't be smaller than 0");
        _STL_VERIFY(_Result_as_size_type <= _New_size, "the returned size can't be greater than the passed size");
#endif // _CONTAINER_DEBUG_LEVEL > 0
        _Eos(_Result_as_size_type);
    }

#if _HAS_CXX23
    template <class _Operation>
    constexpr void _Resize_and_overwrite(_CRT_GUARDOVERFLOW const size_type _New_size, _Operation _Op) {
        resize_and_overwrite(_New_size, _Op);
    }
#endif // _HAS_CXX23

    _NODISCARD _CONSTEXPR20 size_type capacity() const noexcept {
        return _Mypair._Myval2._Myres;
    }

#if _HAS_CXX20
    constexpr void reserve(_CRT_GUARDOVERFLOW const size_type _Newcap) {
        // determine new minimum length of allocated storage
        if (_Mypair._Myval2._Myres >= _Newcap) { // requested capacity is not larger than current capacity, ignore
            return; // nothing to do
        }

        const size_type _Old_size = _Mypair._Myval2._Mysize;
        _Reallocate_grow_by(_Newcap - _Old_size,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size)
            _STATIC_CALL_OPERATOR{ _Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1); });

        _Mypair._Myval2._Mysize = _Old_size;
    }

    _CXX20_DEPRECATE_STRING_RESERVE_WITHOUT_ARGUMENT void reserve() {
        if (_Mypair._Myval2._Mysize == 0 && _Mypair._Myval2._Large_mode_engaged()) {
            _Become_small();
        }
    }
#else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
    void reserve(_CRT_GUARDOVERFLOW const size_type _Newcap = 0) { // determine new minimum length of allocated storage
        if (_Mypair._Myval2._Mysize > _Newcap) { // requested capacity is not large enough for current size, ignore
            return; // nothing to do
        }

        if (_Mypair._Myval2._Myres == _Newcap) { // we're already at the requested capacity
            return; // nothing to do
        }

        if (_Mypair._Myval2._Myres < _Newcap) { // reallocate to grow
            const size_type _Old_size = _Mypair._Myval2._Mysize;
            _Reallocate_grow_by(_Newcap - _Old_size,
                [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size)
                _STATIC_CALL_OPERATOR{ _Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1); });

            _Mypair._Myval2._Mysize = _Old_size;
            return;
        }

        if (_Newcap <= _Small_string_capacity && _Mypair._Myval2._Large_mode_engaged()) {
            // deallocate everything; switch back to "small" mode
            _Become_small();
            return;
        }

        // ignore requests to reserve to [_Small_string_capacity + 1, _Myres)
    }
#endif // ^^^ !_HAS_CXX20 ^^^

    _NODISCARD_EMPTY_MEMBER _CONSTEXPR20 bool empty() const noexcept {
        return _Mypair._Myval2._Mysize == 0;
    }

    _CONSTEXPR20 size_type copy(
        _Out_writes_(_Count) _Elem* const _Ptr, size_type _Count, const size_type _Off = 0) const {
        // copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
        _Mypair._Myval2._Check_offset(_Off);
        _Count = _Mypair._Myval2._Clamp_suffix_size(_Off, _Count);
        _Traits::copy(_Ptr, _Mypair._Myval2._Myptr() + _Off, _Count);
        return _Count;
    }

    _CONSTEXPR20 _Pre_satisfies_(_Dest_size >= _Count) size_type
        _Copy_s(_Out_writes_all_(_Dest_size) _Elem* const _Dest, const size_type _Dest_size, size_type _Count,
            const size_type _Off = 0) const {
        // copy [_Off, _Off + _Count) to [_Dest, _Dest + _Dest_size)
        _Mypair._Myval2._Check_offset(_Off);
        _Count = _Mypair._Myval2._Clamp_suffix_size(_Off, _Count);
        _Traits::_Copy_s(_Dest, _Dest_size, _Mypair._Myval2._Myptr() + _Off, _Count);
        return _Count;
    }

    static _CONSTEXPR20 void _Swap_bx_large_with_small(_Scary_val& _Starts_large, _Scary_val& _Starts_small) noexcept {
        // exchange a string in large mode with one in small mode
        const pointer _Ptr = _Starts_large._Bx._Ptr;
        _Starts_large._Bx._Switch_to_buf();
        _Traits::copy(_Starts_large._Bx._Buf, _Starts_small._Bx._Buf, _BUF_SIZE);

        _Construct_in_place(_Starts_small._Bx._Ptr, _Ptr);
    }

    _CONSTEXPR20 void _Swap_data(basic_string& _Right) noexcept {
        using _STD swap;

        auto& _My_data = _Mypair._Myval2;
        auto& _Right_data = _Right._Mypair._Myval2;

#if !defined(_INSERT_STRING_ANNOTATION)
        if constexpr (_Can_memcpy_val) {
#if _HAS_CXX20
            if (!_STD is_constant_evaluated())
#endif // _HAS_CXX20
            {
                const auto _My_data_mem =
                    reinterpret_cast<unsigned char*>(_STD addressof(_My_data)) + _Memcpy_val_offset;
                const auto _Right_data_mem =
                    reinterpret_cast<unsigned char*>(_STD addressof(_Right_data)) + _Memcpy_val_offset;
                unsigned char _Temp_mem[_Memcpy_val_size];
                _CSTD memcpy(_Temp_mem, _My_data_mem, _Memcpy_val_size);
                _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);
                _CSTD memcpy(_Right_data_mem, _Temp_mem, _Memcpy_val_size);

                return;
            }
        }
#endif // !defined(_INSERT_STRING_ANNOTATION)

        const bool _My_large = _My_data._Large_mode_engaged();
        const bool _Right_large = _Right_data._Large_mode_engaged();

        if (_My_large && _Right_large) { // swap buffers, iterators preserved
            swap(_My_data._Bx._Ptr, _Right_data._Bx._Ptr); // intentional ADL
        }
        else if (_My_large) { // swap large with small
            _Swap_bx_large_with_small(_My_data, _Right_data);
        }
        else if (_Right_large) { // swap small with large
            _Swap_bx_large_with_small(_Right_data, _My_data);
        }
        else {
            _Elem _Temp_buf[_BUF_SIZE];
            _Traits::copy(_Temp_buf, _My_data._Bx._Buf, _My_data._Mysize + 1);
            _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _Right_data._Mysize + 1);
            _Traits::copy(_Right_data._Bx._Buf, _Temp_buf, _My_data._Mysize + 1);
        }

        _STD swap(_My_data._Mysize, _Right_data._Mysize);
        _STD swap(_My_data._Myres, _Right_data._Myres);
    }

    _CONSTEXPR20 void swap(basic_string& _Right) noexcept /* strengthened */ {
        if (this != _STD addressof(_Right)) {
            _Pocs(_Getal(), _Right._Getal());

#if _ITERATOR_DEBUG_LEVEL != 0
            auto& _My_data = _Mypair._Myval2;
            auto& _Right_data = _Right._Mypair._Myval2;

            if (!_My_data._Large_mode_engaged()) {
                _My_data._Orphan_all();
            }

            if (!_Right_data._Large_mode_engaged()) {
                _Right_data._Orphan_all();
            }

            _My_data._Swap_proxy_and_iterators(_Right_data);
#endif // _ITERATOR_DEBUG_LEVEL != 0

            _Swap_data(_Right);
        }
    }

#if _HAS_CXX17
    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    _NODISCARD _CONSTEXPR20 size_type find(const _StringViewIsh& _Right, const size_type _Off = 0) const
        noexcept(_Is_nothrow_convertible_v<const _StringViewIsh&, basic_string_view<_Elem, _Traits>>) {
        // look for _Right beginning at or after _Off
        basic_string_view<_Elem, _Traits> _As_view = _Right;
        return static_cast<size_type>(_Traits_find<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _As_view.data(), _As_view.size()));
    }
#endif // _HAS_CXX17

    _NODISCARD _CONSTEXPR20 size_type find(const basic_string& _Right, const size_type _Off = 0) const noexcept {
        // look for _Right beginning at or after _Off
        return static_cast<size_type>(_Traits_find<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off,
            _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize));
    }

    _NODISCARD _CONSTEXPR20 size_type find(_In_reads_(_Count) const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept /* strengthened */ {
        // look for [_Ptr, _Ptr + _Count) beginning at or after _Off
        return static_cast<size_type>(
            _Traits_find<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Count));
    }

    _NODISCARD _CONSTEXPR20 size_type find(_In_z_ const _Elem* const _Ptr, const size_type _Off = 0) const noexcept
        /* strengthened */ {
        // look for [_Ptr, <null>) beginning at or after _Off
        return static_cast<size_type>(_Traits_find<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Traits::length(_Ptr)));
    }

    _NODISCARD _CONSTEXPR20 size_type find(const _Elem _Ch, const size_type _Off = 0) const noexcept {
        // look for _Ch at or after _Off
        return static_cast<size_type>(
            _Traits_find_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
    }

#if _HAS_CXX17
    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    _NODISCARD _CONSTEXPR20 size_type rfind(const _StringViewIsh& _Right, const size_type _Off = npos) const
        noexcept(_Is_nothrow_convertible_v<const _StringViewIsh&, basic_string_view<_Elem, _Traits>>) {
        // look for _Right beginning before _Off
        basic_string_view<_Elem, _Traits> _As_view = _Right;
        return static_cast<size_type>(_Traits_rfind<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _As_view.data(), _As_view.size()));
    }
#endif // _HAS_CXX17

    _NODISCARD _CONSTEXPR20 size_type rfind(const basic_string& _Right, const size_type _Off = npos) const noexcept {
        // look for _Right beginning before _Off
        return static_cast<size_type>(_Traits_rfind<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off,
            _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize));
    }

    _NODISCARD _CONSTEXPR20 size_type rfind(_In_reads_(_Count) const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept /* strengthened */ {
        // look for [_Ptr, _Ptr + _Count) beginning before _Off
        return static_cast<size_type>(
            _Traits_rfind<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Count));
    }

    _NODISCARD _CONSTEXPR20 size_type rfind(_In_z_ const _Elem* const _Ptr, const size_type _Off = npos) const noexcept
        /* strengthened */ {
        // look for [_Ptr, <null>) beginning before _Off
        return static_cast<size_type>(_Traits_rfind<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Traits::length(_Ptr)));
    }

    _NODISCARD _CONSTEXPR20 size_type rfind(const _Elem _Ch, const size_type _Off = npos) const noexcept {
        // look for _Ch before _Off
        return static_cast<size_type>(
            _Traits_rfind_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
    }

#if _HAS_CXX17
    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    _NODISCARD _CONSTEXPR20 size_type find_first_of(const _StringViewIsh& _Right, const size_type _Off = 0) const
        noexcept(_Is_nothrow_convertible_v<const _StringViewIsh&, basic_string_view<_Elem, _Traits>>) {
        // look for one of _Right at or after _Off
        basic_string_view<_Elem, _Traits> _As_view = _Right;
        return static_cast<size_type>(_Traits_find_first_of<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _As_view.data(), _As_view.size()));
    }
#endif // _HAS_CXX17

    _NODISCARD _CONSTEXPR20 size_type find_first_of(
        const basic_string& _Right, const size_type _Off = 0) const noexcept {
        // look for one of _Right at or after _Off
        return static_cast<size_type>(_Traits_find_first_of<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,
            _Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize));
    }

    _NODISCARD _CONSTEXPR20 size_type find_first_of(_In_reads_(_Count) const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept /* strengthened */ {
        // look for one of [_Ptr, _Ptr + _Count) at or after _Off
        return static_cast<size_type>(
            _Traits_find_first_of<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Count));
    }

    _NODISCARD _CONSTEXPR20 size_type find_first_of(
        _In_z_ const _Elem* const _Ptr, const size_type _Off = 0) const noexcept
        /* strengthened */ {
        // look for one of [_Ptr, <null>) at or after _Off
        return static_cast<size_type>(_Traits_find_first_of<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Traits::length(_Ptr)));
    }

    _NODISCARD _CONSTEXPR20 size_type find_first_of(const _Elem _Ch, const size_type _Off = 0) const noexcept {
        // look for _Ch at or after _Off
        return static_cast<size_type>(
            _Traits_find_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
    }

#if _HAS_CXX17
    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    _NODISCARD _CONSTEXPR20 size_type find_last_of(const _StringViewIsh& _Right, const size_type _Off = npos) const
        noexcept(_Is_nothrow_convertible_v<const _StringViewIsh&, basic_string_view<_Elem, _Traits>>) {
        // look for one of _Right before _Off
        basic_string_view<_Elem, _Traits> _As_view = _Right;
        return static_cast<size_type>(_Traits_find_last_of<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _As_view.data(), _As_view.size()));
    }
#endif // _HAS_CXX17

    _NODISCARD _CONSTEXPR20 size_type find_last_of(const basic_string& _Right, size_type _Off = npos) const noexcept {
        // look for one of _Right before _Off
        return static_cast<size_type>(_Traits_find_last_of<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,
            _Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize));
    }

    _NODISCARD _CONSTEXPR20 size_type find_last_of(_In_reads_(_Count) const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept /* strengthened */ {
        // look for one of [_Ptr, _Ptr + _Count) before _Off
        return static_cast<size_type>(
            _Traits_find_last_of<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Count));
    }

    _NODISCARD _CONSTEXPR20 size_type find_last_of(
        _In_z_ const _Elem* const _Ptr, const size_type _Off = npos) const noexcept /* strengthened */ {
        // look for one of [_Ptr, <null>) before _Off
        return static_cast<size_type>(_Traits_find_last_of<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Traits::length(_Ptr)));
    }

    _NODISCARD _CONSTEXPR20 size_type find_last_of(const _Elem _Ch, const size_type _Off = npos) const noexcept {
        // look for _Ch before _Off
        return static_cast<size_type>(
            _Traits_rfind_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
    }

#if _HAS_CXX17
    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    _NODISCARD _CONSTEXPR20 size_type find_first_not_of(const _StringViewIsh& _Right, const size_type _Off = 0) const
        noexcept(_Is_nothrow_convertible_v<const _StringViewIsh&, basic_string_view<_Elem, _Traits>>) {
        // look for none of _Right at or after _Off
        basic_string_view<_Elem, _Traits> _As_view = _Right;
        return static_cast<size_type>(_Traits_find_first_not_of<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _As_view.data(), _As_view.size()));
    }
#endif // _HAS_CXX17

    _NODISCARD _CONSTEXPR20 size_type find_first_not_of(
        const basic_string& _Right, const size_type _Off = 0) const noexcept {
        // look for none of _Right at or after _Off
        return static_cast<size_type>(_Traits_find_first_not_of<_Traits>(_Mypair._Myval2._Myptr(),
            _Mypair._Myval2._Mysize, _Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize));
    }

    _NODISCARD _CONSTEXPR20 size_type find_first_not_of(_In_reads_(_Count) const _Elem* const _Ptr,
        const size_type _Off, const size_type _Count) const noexcept /* strengthened */ {
        // look for none of [_Ptr, _Ptr + _Count) at or after _Off
        return static_cast<size_type>(
            _Traits_find_first_not_of<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Count));
    }

    _NODISCARD _CONSTEXPR20 size_type find_first_not_of(
        _In_z_ const _Elem* const _Ptr, size_type _Off = 0) const noexcept
        /* strengthened */ {
        // look for one of [_Ptr, <null>) at or after _Off
        return static_cast<size_type>(_Traits_find_first_not_of<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Traits::length(_Ptr)));
    }

    _NODISCARD _CONSTEXPR20 size_type find_first_not_of(const _Elem _Ch, const size_type _Off = 0) const noexcept {
        // look for non-_Ch at or after _Off
        return static_cast<size_type>(
            _Traits_find_not_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
    }

#if _HAS_CXX17
    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    _NODISCARD _CONSTEXPR20 size_type find_last_not_of(const _StringViewIsh& _Right, const size_type _Off = npos) const
        noexcept(_Is_nothrow_convertible_v<const _StringViewIsh&, basic_string_view<_Elem, _Traits>>) {
        // look for none of _Right before _Off
        basic_string_view<_Elem, _Traits> _As_view = _Right;
        return static_cast<size_type>(_Traits_find_last_not_of<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _As_view.data(), _As_view.size()));
    }
#endif // _HAS_CXX17

    _NODISCARD _CONSTEXPR20 size_type find_last_not_of(
        const basic_string& _Right, const size_type _Off = npos) const noexcept {
        // look for none of _Right before _Off
        return static_cast<size_type>(_Traits_find_last_not_of<_Traits>(_Mypair._Myval2._Myptr(),
            _Mypair._Myval2._Mysize, _Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize));
    }

    _NODISCARD _CONSTEXPR20 size_type find_last_not_of(_In_reads_(_Count) const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept /* strengthened */ {
        // look for none of [_Ptr, _Ptr + _Count) before _Off
        return static_cast<size_type>(
            _Traits_find_last_not_of<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Count));
    }

    _NODISCARD _CONSTEXPR20 size_type find_last_not_of(
        _In_z_ const _Elem* const _Ptr, const size_type _Off = npos) const noexcept /* strengthened */ {
        // look for none of [_Ptr, <null>) before _Off
        return static_cast<size_type>(_Traits_find_last_not_of<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Traits::length(_Ptr)));
    }

    _NODISCARD _CONSTEXPR20 size_type find_last_not_of(const _Elem _Ch, const size_type _Off = npos) const noexcept {
        // look for non-_Ch before _Off
        return static_cast<size_type>(
            _Traits_rfind_not_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
    }

#if _HAS_CXX17
    _NODISCARD bool _Starts_with(const basic_string_view<_Elem, _Traits> _Right) const noexcept {
        // Used exclusively by filesystem
        return basic_string_view<_Elem, _Traits>(*this)._Starts_with(_Right);
    }
#endif // _HAS_CXX17

    _NODISCARD _CONSTEXPR20 basic_string substr(const size_type _Off = 0, const size_type _Count = npos)
#if _HAS_CXX23
        const&
#else
        const
#endif
    {
        // return [_Off, _Off + _Count) as new string, default-constructing its allocator
        return basic_string{ *this, _Off, _Count };
    }

#if _HAS_CXX23
    _NODISCARD constexpr basic_string substr(const size_type _Off = 0, const size_type _Count = npos)&& {
        // return [_Off, _Off + _Count) as new string, potentially moving, default-constructing its allocator
        return basic_string{ _STD move(*this), _Off, _Count };
    }
#endif // _HAS_CXX23

    _CONSTEXPR20 bool _Equal(const basic_string& _Right) const noexcept {
        // compare [0, size()) with _Right for equality
        return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,
            _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    }

    _CONSTEXPR20 bool _Equal(_In_z_ const _Elem* const _Ptr) const noexcept {
        // compare [0, size()) with _Ptr for equality
        return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));
    }

#if _HAS_CXX17
    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    _NODISCARD _CONSTEXPR20 int compare(const _StringViewIsh& _Right) const
        noexcept(_Is_nothrow_convertible_v<const _StringViewIsh&, basic_string_view<_Elem, _Traits>>) {
        // compare [0, size()) with _Right
        basic_string_view<_Elem, _Traits> _As_view = _Right;
        return _Traits_compare<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _As_view.data(), _As_view.size());
    }

    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    _NODISCARD _CONSTEXPR20 int compare(const size_type _Off, const size_type _Nx, const _StringViewIsh& _Right) const {
        // compare [_Off, _Off + _Nx) with _Right
        basic_string_view<_Elem, _Traits> _As_view = _Right;
        _Mypair._Myval2._Check_offset(_Off);
        return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr() + _Off, _Mypair._Myval2._Clamp_suffix_size(_Off, _Nx),
            _As_view.data(), _As_view.size());
    }

    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    _NODISCARD _CONSTEXPR20 int compare(const size_type _Off, const size_type _Nx, const _StringViewIsh& _Right,
        const size_type _Roff, const size_type _Count = npos) const {
        // compare [_Off, _Off + _Nx) with _Right [_Roff, _Roff + _Count)
        basic_string_view<_Elem, _Traits> _As_view = _Right;
        _Mypair._Myval2._Check_offset(_Off);
        const auto _With_substr = _As_view.substr(_Roff, _Count);
        return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr() + _Off, _Mypair._Myval2._Clamp_suffix_size(_Off, _Nx),
            _With_substr.data(), _With_substr.size());
    }
#endif // _HAS_CXX17

    _NODISCARD _CONSTEXPR20 int compare(const basic_string& _Right) const noexcept {
        // compare [0, size()) with _Right
        return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,
            _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    }

    _NODISCARD _CONSTEXPR20 int compare(size_type _Off, size_type _Nx, const basic_string& _Right) const {
        // compare [_Off, _Off + _Nx) with _Right
        _Mypair._Myval2._Check_offset(_Off);
        return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr() + _Off, _Mypair._Myval2._Clamp_suffix_size(_Off, _Nx),
            _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    }

    _NODISCARD _CONSTEXPR20 int compare(const size_type _Off, const size_type _Nx, const basic_string& _Right,
        const size_type _Roff, const size_type _Count = npos) const {
        // compare [_Off, _Off + _Nx) with _Right [_Roff, _Roff + _Count)
        _Mypair._Myval2._Check_offset(_Off);
        _Right._Mypair._Myval2._Check_offset(_Roff);
        return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr() + _Off, _Mypair._Myval2._Clamp_suffix_size(_Off, _Nx),
            _Right._Mypair._Myval2._Myptr() + _Roff, _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count));
    }

    _NODISCARD _CONSTEXPR20 int compare(_In_z_ const _Elem* const _Ptr) const noexcept /* strengthened */ {
        // compare [0, size()) with [_Ptr, <null>)
        return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));
    }

    _NODISCARD _CONSTEXPR20 int compare(
        const size_type _Off, const size_type _Nx, _In_z_ const _Elem* const _Ptr) const {
        // compare [_Off, _Off + _Nx) with [_Ptr, <null>)
        _Mypair._Myval2._Check_offset(_Off);
        return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr() + _Off, _Mypair._Myval2._Clamp_suffix_size(_Off, _Nx),
            _Ptr, _Traits::length(_Ptr));
    }

    _NODISCARD _CONSTEXPR20 int compare(const size_type _Off, const size_type _Nx,
        _In_reads_(_Count) const _Elem* const _Ptr, const size_type _Count) const {
        // compare [_Off, _Off + _Nx) with [_Ptr, _Ptr + _Count)
        _Mypair._Myval2._Check_offset(_Off);
        return _Traits_compare<_Traits>(
            _Mypair._Myval2._Myptr() + _Off, _Mypair._Myval2._Clamp_suffix_size(_Off, _Nx), _Ptr, _Count);
    }

#if _HAS_CXX20
    _NODISCARD constexpr bool starts_with(const basic_string_view<_Elem, _Traits> _Right) const noexcept {
        return basic_string_view<_Elem, _Traits>{_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize}.starts_with(_Right);
    }

    _NODISCARD constexpr bool starts_with(const _Elem _Right) const noexcept {
        return basic_string_view<_Elem, _Traits>{_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize}.starts_with(_Right);
    }

    _NODISCARD constexpr bool starts_with(const _Elem* const _Right) const noexcept /* strengthened */ {
        return basic_string_view<_Elem, _Traits>{_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize}.starts_with(_Right);
    }

    _NODISCARD constexpr bool ends_with(const basic_string_view<_Elem, _Traits> _Right) const noexcept {
        return basic_string_view<_Elem, _Traits>{_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize}.ends_with(_Right);
    }

    _NODISCARD constexpr bool ends_with(const _Elem _Right) const noexcept {
        return basic_string_view<_Elem, _Traits>{_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize}.ends_with(_Right);
    }

    _NODISCARD constexpr bool ends_with(const _Elem* const _Right) const noexcept /* strengthened */ {
        return basic_string_view<_Elem, _Traits>{_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize}.ends_with(_Right);
    }
#endif // _HAS_CXX20

#if _HAS_CXX23
    _NODISCARD constexpr bool contains(const basic_string_view<_Elem, _Traits> _Right) const noexcept {
        return basic_string_view<_Elem, _Traits>{_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize}.contains(_Right);
    }

    _NODISCARD constexpr bool contains(const _Elem _Right) const noexcept {
        return basic_string_view<_Elem, _Traits>{_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize}.contains(_Right);
    }

    _NODISCARD constexpr bool contains(const _Elem* const _Right) const noexcept /* strengthened */ {
        return basic_string_view<_Elem, _Traits>{_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize}.contains(_Right);
    }
#endif // _HAS_CXX23

    _NODISCARD _CONSTEXPR20 allocator_type get_allocator() const noexcept {
        return static_cast<allocator_type>(_Getal());
    }

private:
    _NODISCARD static _CONSTEXPR20 size_type _Calculate_growth(
        const size_type _Requested, const size_type _Old, const size_type _Max) noexcept {
        const size_type _Masked = _Requested | _Alloc_mask;
        if (_Masked > _Max) { // the mask overflows, settle for max_size()
            return _Max;
        }

        if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
            return _Max;
        }

        return (_STD max)(_Masked, _Old + _Old / 2);
    }

    _NODISCARD _CONSTEXPR20 size_type _Calculate_growth(const size_type _Requested) const noexcept {
        return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());
    }

    template <class _Fty, class... _ArgTys>
    _CONSTEXPR20 basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {
        // reallocate to store exactly _New_size elements, new buffer prepared by
        // _Fn(_New_ptr, _New_size, _Args...)
        if (_New_size > max_size()) {
            _Xlen_string(); // result too long
        }

        const size_type _Old_capacity = _Mypair._Myval2._Myres;
        size_type _New_capacity = _Calculate_growth(_New_size);
        auto& _Al = _Getal();
        const pointer _New_ptr = _Allocate_for_capacity(_Al, _New_capacity); // throws

        _Mypair._Myval2._Orphan_all();
        _ASAN_STRING_REMOVE(*this);
        _Mypair._Myval2._Mysize = _New_size;
        _Mypair._Myval2._Myres = _New_capacity;
        _Fn(_Unfancy(_New_ptr), _New_size, _Args...);
        if (_Old_capacity > _Small_string_capacity) {
            _Deallocate_for_capacity(_Al, _Mypair._Myval2._Bx._Ptr, _Old_capacity);
            _Mypair._Myval2._Bx._Ptr = _New_ptr;
        }
        else {
            _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);
        }

        _ASAN_STRING_CREATE(*this);
        return *this;
    }

    template <class _Fty, class... _ArgTys>
    _CONSTEXPR20 basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {
        // reallocate to increase size by _Size_increase elements, new buffer prepared by
        // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
        auto& _My_data = _Mypair._Myval2;
        const size_type _Old_size = _My_data._Mysize;
        if (max_size() - _Old_size < _Size_increase) {
            _Xlen_string(); // result too long
        }

        const size_type _New_size = _Old_size + _Size_increase;
        const size_type _Old_capacity = _My_data._Myres;
        size_type _New_capacity = _Calculate_growth(_New_size);
        auto& _Al = _Getal();
        const pointer _New_ptr = _Allocate_for_capacity(_Al, _New_capacity); // throws

        _My_data._Orphan_all();
        _ASAN_STRING_REMOVE(*this);
        _My_data._Mysize = _New_size;
        _My_data._Myres = _New_capacity;
        _Elem* const _Raw_new = _Unfancy(_New_ptr);
        if (_Old_capacity > _Small_string_capacity) {
            const pointer _Old_ptr = _My_data._Bx._Ptr;
            _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);
            _Deallocate_for_capacity(_Al, _Old_ptr, _Old_capacity);
            _My_data._Bx._Ptr = _New_ptr;
        }
        else {
            _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);
            _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);
        }

        _ASAN_STRING_CREATE(*this);
        return *this;
    }

    _CONSTEXPR20 void _Become_small() noexcept {
        // release any held storage and return to small string mode
        auto& _My_data = _Mypair._Myval2;
        _STL_INTERNAL_CHECK(_My_data._Large_mode_engaged());
        _STL_INTERNAL_CHECK(_My_data._Mysize <= _Small_string_capacity);

        _My_data._Orphan_all();
        _ASAN_STRING_REMOVE(*this);
        const pointer _Ptr = _My_data._Bx._Ptr;
        _My_data._Bx._Switch_to_buf();
        _Traits::copy(_My_data._Bx._Buf, _Unfancy(_Ptr), _My_data._Mysize + 1);
        auto& _Al = _Getal();
        _Deallocate_for_capacity(_Al, _Ptr, _My_data._Myres);
        _My_data._Myres = _Small_string_capacity;
    }

    _CONSTEXPR20 void _Eos(const size_type _New_size) noexcept { // set new length and null terminator
        _ASAN_STRING_MODIFY(*this, _Mypair._Myval2._Mysize, _New_size);
        _Mypair._Myval2._Mysize = _New_size;
        _Traits::assign(_Mypair._Myval2._Myptr()[_New_size], _Elem());
    }

    _CONSTEXPR20 void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage
        auto& _My_data = _Mypair._Myval2;
        _My_data._Orphan_all();
        if (_My_data._Large_mode_engaged()) {
            _ASAN_STRING_REMOVE(*this);
            auto& _Al = _Getal();
            _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);
            _My_data._Bx._Switch_to_buf();
        }

        _My_data._Mysize = 0;
        _My_data._Myres = _Small_string_capacity;
        // the _Traits::assign is last so the codegen doesn't think the char write can alias this
        _Traits::assign(_My_data._Bx._Buf[0], _Elem());
    }

public:
    _CONSTEXPR20 void _Orphan_all() noexcept { // used by filesystem::path
        _Mypair._Myval2._Orphan_all();
    }

private:
    _CONSTEXPR20 void _Swap_proxy_and_iterators(basic_string& _Right) noexcept {
        _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
    }

    _CONSTEXPR20 _Alty& _Getal() noexcept {
        return _Mypair._Get_first();
    }

    _CONSTEXPR20 const _Alty& _Getal() const noexcept {
        return _Mypair._Get_first();
    }

    _Compressed_pair<_Alty, _Scary_val> _Mypair;
};

#if _HAS_CXX17
template <class _Iter, class _Alloc = allocator<_Iter_value_t<_Iter>>,
    enable_if_t<conjunction_v<_Is_iterator<_Iter>, _Is_allocator<_Alloc>>, int> = 0>
basic_string(_Iter, _Iter, _Alloc = _Alloc())
-> basic_string<_Iter_value_t<_Iter>, char_traits<_Iter_value_t<_Iter>>, _Alloc>;

template <class _Elem, class _Traits, class _Alloc = allocator<_Elem>,
    enable_if_t<_Is_allocator<_Alloc>::value, int> = 0>
explicit basic_string(basic_string_view<_Elem, _Traits>, const _Alloc & = _Alloc())
->basic_string<_Elem, _Traits, _Alloc>;

template <class _Elem, class _Traits, class _Alloc = allocator<_Elem>,
    enable_if_t<_Is_allocator<_Alloc>::value, int> = 0>
basic_string(basic_string_view<_Elem, _Traits>, _Guide_size_type_t<_Alloc>, _Guide_size_type_t<_Alloc>,
    const _Alloc & = _Alloc()) -> basic_string<_Elem, _Traits, _Alloc>;

#if _HAS_CXX23
template <_RANGES input_range _Rng, class _Alloc = allocator<_RANGES range_value_t<_Rng>>,
    enable_if_t<_Is_allocator<_Alloc>::value, int> = 0>
basic_string(from_range_t, _Rng&&, _Alloc = _Alloc())
-> basic_string<_RANGES range_value_t<_Rng>, char_traits<_RANGES range_value_t<_Rng>>, _Alloc>;
#endif // _HAS_CXX23
#endif // _HAS_CXX17

_EXPORT_STD template <class _Elem, class _Traits, class _Alloc>
_CONSTEXPR20 void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
    basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept /* strengthened */ {
    _Left.swap(_Right);
}

_EXPORT_STD template <class _Elem, class _Traits, class _Alloc>
_NODISCARD _CONSTEXPR20 basic_string<_Elem, _Traits, _Alloc> operator+(
    const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) {
    const auto _Left_size = _Left.size();
    const auto _Right_size = _Right.size();
    if (_Left.max_size() - _Left_size < _Right_size) {
        _Xlen_string();
    }

    return { _String_constructor_concat_tag{}, _Left, _Left.c_str(), _Left_size, _Right.c_str(), _Right_size };
}

_EXPORT_STD template <class _Elem, class _Traits, class _Alloc>
_NODISCARD _CONSTEXPR20 basic_string<_Elem, _Traits, _Alloc> operator+(
    _In_z_ const _Elem* const _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) {
    using _Size_type = typename basic_string<_Elem, _Traits, _Alloc>::size_type;
    const auto _Left_size = _Convert_size<_Size_type>(_Traits::length(_Left));
    const auto _Right_size = _Right.size();
    if (_Right.max_size() - _Right_size < _Left_size) {
        _Xlen_string();
    }

    return { _String_constructor_concat_tag{}, _Right, _Left, _Left_size, _Right.c_str(), _Right_size };
}

_EXPORT_STD template <class _Elem, class _Traits, class _Alloc>
_NODISCARD _CONSTEXPR20 basic_string<_Elem, _Traits, _Alloc> operator+(
    const _Elem _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) {
    const auto _Right_size = _Right.size();
    if (_Right_size == _Right.max_size()) {
        _Xlen_string();
    }

    return { _String_constructor_concat_tag{}, _Right, _STD addressof(_Left), 1, _Right.c_str(), _Right_size };
}

_EXPORT_STD template <class _Elem, class _Traits, class _Alloc>
_NODISCARD _CONSTEXPR20 basic_string<_Elem, _Traits, _Alloc> operator+(
    const basic_string<_Elem, _Traits, _Alloc>& _Left, _In_z_ const _Elem* const _Right) {
    using _Size_type = typename basic_string<_Elem, _Traits, _Alloc>::size_type;
    const auto _Left_size = _Left.size();
    const auto _Right_size = _Convert_size<_Size_type>(_Traits::length(_Right));
    if (_Left.max_size() - _Left_size < _Right_size) {
        _Xlen_string();
    }

    return { _String_constructor_concat_tag{}, _Left, _Left.c_str(), _Left_size, _Right, _Right_size };
}

_EXPORT_STD template <class _Elem, class _Traits, class _Alloc>
_NODISCARD _CONSTEXPR20 basic_string<_Elem, _Traits, _Alloc> operator+(
    const basic_string<_Elem, _Traits, _Alloc>& _Left, const _Elem _Right) {
    const auto _Left_size = _Left.size();
    if (_Left_size == _Left.max_size()) {
        _Xlen_string();
    }

    return { _String_constructor_concat_tag{}, _Left, _Left.c_str(), _Left_size, _STD addressof(_Right), 1 };
}

_EXPORT_STD template <class _Elem, class _Traits, class _Alloc>
_NODISCARD _CONSTEXPR20 basic_string<_Elem, _Traits, _Alloc> operator+(
    const basic_string<_Elem, _Traits, _Alloc>& _Left, basic_string<_Elem, _Traits, _Alloc>&& _Right) {
    return _STD move(_Right.insert(0, _Left));
}

_EXPORT_STD template <class _Elem, class _Traits, class _Alloc>
_NODISCARD _CONSTEXPR20 basic_string<_Elem, _Traits, _Alloc> operator+(
    basic_string<_Elem, _Traits, _Alloc>&& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) {
    return _STD move(_Left.append(_Right));
}

_EXPORT_STD template <class _Elem, class _Traits, class _Alloc>
_NODISCARD _CONSTEXPR20 basic_string<_Elem, _Traits, _Alloc> operator+(
    basic_string<_Elem, _Traits, _Alloc>&& _Left, basic_string<_Elem, _Traits, _Alloc>&& _Right) {
#if _ITERATOR_DEBUG_LEVEL == 2
    _STL_VERIFY(_STD addressof(_Left) != _STD addressof(_Right),
        "You cannot concatenate the same moved string to itself. See N4950 [res.on.arguments]/1.3: "
        "If a function argument is bound to an rvalue reference parameter, the implementation may assume that "
        "this parameter is a unique reference to this argument, except that the argument passed to "
        "a move-assignment operator may be a reference to *this ([lib.types.movedfrom]).");
#endif // _ITERATOR_DEBUG_LEVEL == 2
    return { _String_constructor_concat_tag{}, _Left, _Right };
}

_EXPORT_STD template <class _Elem, class _Traits, class _Alloc>
_NODISCARD _CONSTEXPR20 basic_string<_Elem, _Traits, _Alloc> operator+(
    _In_z_ const _Elem* const _Left, basic_string<_Elem, _Traits, _Alloc>&& _Right) {
    return _STD move(_Right.insert(0, _Left));
}

_EXPORT_STD template <class _Elem, class _Traits, class _Alloc>
_NODISCARD _CONSTEXPR20 basic_string<_Elem, _Traits, _Alloc> operator+(
    const _Elem _Left, basic_string<_Elem, _Traits, _Alloc>&& _Right) {
    return _STD move(_Right.insert(0, 1, _Left));
}

_EXPORT_STD template <class _Elem, class _Traits, class _Alloc>
_NODISCARD _CONSTEXPR20 basic_string<_Elem, _Traits, _Alloc> operator+(
    basic_string<_Elem, _Traits, _Alloc>&& _Left, _In_z_ const _Elem* const _Right) {
    return _STD move(_Left.append(_Right));
}

_EXPORT_STD template <class _Elem, class _Traits, class _Alloc>
_NODISCARD _CONSTEXPR20 basic_string<_Elem, _Traits, _Alloc> operator+(
    basic_string<_Elem, _Traits, _Alloc>&& _Left, const _Elem _Right) {
    _Left.push_back(_Right);
    return _STD move(_Left);
}

_EXPORT_STD template <class _Elem, class _Traits, class _Alloc>
_NODISCARD _CONSTEXPR20 bool operator==(
    const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept {
    return _Left._Equal(_Right);
}

_EXPORT_STD template <class _Elem, class _Traits, class _Alloc>
_NODISCARD _CONSTEXPR20 bool operator==(
    const basic_string<_Elem, _Traits, _Alloc>& _Left, _In_z_ const _Elem* const _Right) noexcept /* strengthened */ {
    return _Left._Equal(_Right);
}

#if _HAS_CXX20
_EXPORT_STD template <class _Elem, class _Traits, class _Alloc>
_NODISCARD constexpr _Get_comparison_category_t<_Traits> operator<=>(
    const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept {
    return static_cast<_Get_comparison_category_t<_Traits>>(_Left.compare(_Right) <=> 0);
}

_EXPORT_STD template <class _Elem, class _Traits, class _Alloc>
_NODISCARD constexpr _Get_comparison_category_t<_Traits> operator<=>(
    const basic_string<_Elem, _Traits, _Alloc>& _Left, _In_z_ const _Elem* const _Right) noexcept /* strengthened */ {
    return static_cast<_Get_comparison_category_t<_Traits>>(_Left.compare(_Right) <=> 0);
}
#else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
template <class _Elem, class _Traits, class _Alloc>
_NODISCARD bool operator==(_In_z_ const _Elem* const _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
/* strengthened */ {
    return _Right._Equal(_Left);
}

template <class _Elem, class _Traits, class _Alloc>
_NODISCARD bool operator!=(
    const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept {
    return !(_Left == _Right);
}

template <class _Elem, class _Traits, class _Alloc>
_NODISCARD bool operator!=(_In_z_ const _Elem* const _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
/* strengthened */ {
    return !(_Left == _Right);
}

template <class _Elem, class _Traits, class _Alloc>
_NODISCARD bool operator!=(const basic_string<_Elem, _Traits, _Alloc>& _Left, _In_z_ const _Elem* const _Right) noexcept
/* strengthened */ {
    return !(_Left == _Right);
}

template <class _Elem, class _Traits, class _Alloc>
_NODISCARD bool operator<(
    const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept {
    return _Left.compare(_Right) < 0;
}

template <class _Elem, class _Traits, class _Alloc>
_NODISCARD bool operator<(_In_z_ const _Elem* const _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
    /* strengthened */ {
    return _Right.compare(_Left) > 0;
}

template <class _Elem, class _Traits, class _Alloc>
_NODISCARD bool operator<(const basic_string<_Elem, _Traits, _Alloc>& _Left, _In_z_ const _Elem* const _Right) noexcept
    /* strengthened */ {
    return _Left.compare(_Right) < 0;
}

template <class _Elem, class _Traits, class _Alloc>
_NODISCARD bool operator>(
    const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept {
    return _Right < _Left;
}

template <class _Elem, class _Traits, class _Alloc>
_NODISCARD bool operator>(_In_z_ const _Elem* const _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
/* strengthened */ {
    return _Right < _Left;
}

template <class _Elem, class _Traits, class _Alloc>
_NODISCARD bool operator>(const basic_string<_Elem, _Traits, _Alloc>& _Left, _In_z_ const _Elem* const _Right) noexcept
/* strengthened */ {
    return _Right < _Left;
}

template <class _Elem, class _Traits, class _Alloc>
_NODISCARD bool operator<=(
    const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept {
    return !(_Right < _Left);
}

template <class _Elem, class _Traits, class _Alloc>
_NODISCARD bool operator<=(_In_z_ const _Elem* const _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
/* strengthened */ {
    return !(_Right < _Left);
}

template <class _Elem, class _Traits, class _Alloc>
_NODISCARD bool operator<=(const basic_string<_Elem, _Traits, _Alloc>& _Left, _In_z_ const _Elem* const _Right) noexcept
/* strengthened */ {
    return !(_Right < _Left);
}

template <class _Elem, class _Traits, class _Alloc>
_NODISCARD bool operator>=(
    const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept {
    return !(_Left < _Right);
}

template <class _Elem, class _Traits, class _Alloc>
_NODISCARD bool operator>=(_In_z_ const _Elem* const _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
/* strengthened */ {
    return !(_Left < _Right);
}

template <class _Elem, class _Traits, class _Alloc>
_NODISCARD bool operator>=(const basic_string<_Elem, _Traits, _Alloc>& _Left, _In_z_ const _Elem* const _Right) noexcept
/* strengthened */ {
    return !(_Left < _Right);
}
#endif // ^^^ !_HAS_CXX20 ^^^

_EXPORT_STD using string = basic_string<char, char_traits<char>, allocator<char>>;
_EXPORT_STD using wstring = basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>;
#ifdef __cpp_lib_char8_t
_EXPORT_STD using u8string = basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>>;
#endif // defined(__cpp_lib_char8_t)
_EXPORT_STD using u16string = basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>;
_EXPORT_STD using u32string = basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>;

template <class _Elem, class _Alloc>
struct hash<basic_string<_Elem, char_traits<_Elem>, _Alloc>>
    : _Conditionally_enabled_hash<basic_string<_Elem, char_traits<_Elem>, _Alloc>, _Is_EcharT<_Elem>> {
    _NODISCARD static size_t _Do_hash(const basic_string<_Elem, char_traits<_Elem>, _Alloc>& _Keyval) noexcept {
        return _Hash_array_representation(_Keyval.c_str(), _Keyval.size());
    }
};

_EXPORT_STD template <class _Elem, class _Traits, class _Alloc>
basic_istream<_Elem, _Traits>& operator>>(
    basic_istream<_Elem, _Traits>& _Istr, basic_string<_Elem, _Traits, _Alloc>& _Str) {
    using _Myis = basic_istream<_Elem, _Traits>;
    using _Ctype = typename _Myis::_Ctype;
    using _Mystr = basic_string<_Elem, _Traits, _Alloc>;
    using _Mysizt = typename _Mystr::size_type;

    typename _Myis::iostate _State = _Myis::goodbit;
    bool _Changed = false;
    const typename _Myis::sentry _Ok(_Istr);

    if (_Ok) { // state okay, extract characters
        const _Ctype& _Ctype_fac = _STD use_facet<_Ctype>(_Istr.getloc());
        _Str.erase();

        _TRY_IO_BEGIN
            _Mysizt _Size;
        if (0 < _Istr.width() && static_cast<_Mysizt>(_Istr.width()) < _Str.max_size()) {
            _Size = static_cast<_Mysizt>(_Istr.width());
        }
        else {
            _Size = _Str.max_size();
        }

        typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

        for (; 0 < _Size; --_Size, _Meta = _Istr.rdbuf()->snextc()) {
            if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { // end of file, quit
                _State |= _Myis::eofbit;
                break;
            }
            else if (_Ctype_fac.is(_Ctype::space, _Traits::to_char_type(_Meta))) {
                break; // whitespace, quit
            }
            else { // add character to string
                _Str.push_back(_Traits::to_char_type(_Meta));
                _Changed = true;
            }
        }
        _CATCH_IO_(_Myis, _Istr)
    }

    _Istr.width(0);
    if (!_Changed) {
        _State |= _Myis::failbit;
    }

    _Istr.setstate(_State);
    return _Istr;
}

_EXPORT_STD template <class _Elem, class _Traits, class _Alloc>
basic_ostream<_Elem, _Traits>& operator<<(
    basic_ostream<_Elem, _Traits>& _Ostr, const basic_string<_Elem, _Traits, _Alloc>& _Str) {
    return _Insert_string(_Ostr, _Str.data(), _Str.size());
}

inline namespace literals {
    inline namespace string_literals {
        _EXPORT_STD _NODISCARD _CONSTEXPR20 string operator""s(const char* _Str, size_t _Len) {
            return string{ _Str, _Len };
        }

        _EXPORT_STD _NODISCARD _CONSTEXPR20 wstring operator""s(const wchar_t* _Str, size_t _Len) {
            return wstring{ _Str, _Len };
        }

#ifdef __cpp_char8_t
        _EXPORT_STD _NODISCARD _CONSTEXPR20 basic_string<char8_t> operator""s(const char8_t* _Str, size_t _Len) {
            return basic_string<char8_t>{_Str, _Len};
        }
#endif // defined(__cpp_char8_t)

        _EXPORT_STD _NODISCARD _CONSTEXPR20 u16string operator""s(const char16_t* _Str, size_t _Len) {
            return u16string{ _Str, _Len };
        }

        _EXPORT_STD _NODISCARD _CONSTEXPR20 u32string operator""s(const char32_t* _Str, size_t _Len) {
            return u32string{ _Str, _Len };
        }
    } // namespace string_literals
} // namespace literals

#if _HAS_CXX20
_EXPORT_STD template <class _Elem, class _Traits, class _Alloc, class _Uty>
constexpr basic_string<_Elem, _Traits, _Alloc>::size_type erase(
    basic_string<_Elem, _Traits, _Alloc>& _Cont, const _Uty& _Val) {
    return _STD _Erase_remove(_Cont, _Val);
}

_EXPORT_STD template <class _Elem, class _Traits, class _Alloc, class _Pr>
constexpr basic_string<_Elem, _Traits, _Alloc>::size_type erase_if(
    basic_string<_Elem, _Traits, _Alloc>& _Cont, _Pr _Pred) {
    return _STD _Erase_remove_if(_Cont, _STD _Pass_fn(_Pred));
}
#endif // _HAS_CXX20

#if _HAS_CXX17
namespace pmr {
    _EXPORT_STD template <class _Elem, class _Traits = char_traits<_Elem>>
        using basic_string = _STD basic_string<_Elem, _Traits, polymorphic_allocator<_Elem>>;

    _EXPORT_STD using string = basic_string<char>;
#ifdef __cpp_lib_char8_t
    _EXPORT_STD using u8string = basic_string<char8_t>;
#endif // defined(__cpp_lib_char8_t)
    _EXPORT_STD using u16string = basic_string<char16_t>;
    _EXPORT_STD using u32string = basic_string<char32_t>;
    _EXPORT_STD using wstring = basic_string<wchar_t>;
} // namespace pmr
#endif // _HAS_CXX17
_STD_END

#undef _ASAN_STRING_REMOVE
#undef _ASAN_STRING_CREATE
#undef _ASAN_STRING_MODIFY
#undef _INSERT_STRING_ANNOTATION

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _XSTRING_


#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new
_STD_BEGIN
_EXPORT_STD class logic_error : public exception { // base of all logic-error exceptions
public:
    using _Mybase = exception;

    explicit logic_error(const string& _Message) : _Mybase(_Message.c_str()) {}

    explicit logic_error(const char* _Message) : _Mybase(_Message) {}

#if !_HAS_EXCEPTIONS
protected:
    void _Doraise() const override { // perform class-specific exception handling
        _RAISE(*this);
    }
#endif // !_HAS_EXCEPTIONS
};

_EXPORT_STD class domain_error : public logic_error { // base of all domain-error exceptions
public:
    using _Mybase = logic_error;

    explicit domain_error(const string& _Message) : _Mybase(_Message.c_str()) {}

    explicit domain_error(const char* _Message) : _Mybase(_Message) {}

#if !_HAS_EXCEPTIONS
protected:
    void _Doraise() const override { // perform class-specific exception handling
        _RAISE(*this);
    }
#endif // !_HAS_EXCEPTIONS
};

_EXPORT_STD class invalid_argument : public logic_error { // base of all invalid-argument exceptions
public:
    using _Mybase = logic_error;

    explicit invalid_argument(const string& _Message) : _Mybase(_Message.c_str()) {}

    explicit invalid_argument(const char* _Message) : _Mybase(_Message) {}

#if !_HAS_EXCEPTIONS
protected:
    void _Doraise() const override { // perform class-specific exception handling
        _RAISE(*this);
    }
#endif // !_HAS_EXCEPTIONS
};

_EXPORT_STD class length_error : public logic_error { // base of all length-error exceptions
public:
    using _Mybase = logic_error;

    explicit length_error(const string& _Message) : _Mybase(_Message.c_str()) {}

    explicit length_error(const char* _Message) : _Mybase(_Message) {}

#if !_HAS_EXCEPTIONS
protected:
    void _Doraise() const override { // perform class-specific exception handling
        _RAISE(*this);
    }
#endif // !_HAS_EXCEPTIONS
};

_EXPORT_STD class out_of_range : public logic_error { // base of all out-of-range exceptions
public:
    using _Mybase = logic_error;

    explicit out_of_range(const string& _Message) : _Mybase(_Message.c_str()) {}

    explicit out_of_range(const char* _Message) : _Mybase(_Message) {}

#if !_HAS_EXCEPTIONS
protected:
    void _Doraise() const override { // perform class-specific exception handling
        _RAISE(*this);
    }
#endif // !_HAS_EXCEPTIONS
};

_EXPORT_STD class runtime_error : public exception { // base of all runtime-error exceptions
public:
    using _Mybase = exception;

    explicit runtime_error(const string& _Message) : _Mybase(_Message.c_str()) {}

    explicit runtime_error(const char* _Message) : _Mybase(_Message) {}

#if !_HAS_EXCEPTIONS
protected:
    void _Doraise() const override { // perform class-specific exception handling
        _RAISE(*this);
    }
#endif // !_HAS_EXCEPTIONS
};

_EXPORT_STD class overflow_error : public runtime_error { // base of all overflow-error exceptions
public:
    using _Mybase = runtime_error;

    explicit overflow_error(const string& _Message) : _Mybase(_Message.c_str()) {}

    explicit overflow_error(const char* _Message) : _Mybase(_Message) {}

#if !_HAS_EXCEPTIONS
protected:
    void _Doraise() const override { // perform class-specific exception handling
        _RAISE(*this);
    }
#endif // !_HAS_EXCEPTIONS
};

_EXPORT_STD class underflow_error : public runtime_error { // base of all underflow-error exceptions
public:
    using _Mybase = runtime_error;

    explicit underflow_error(const string& _Message) : _Mybase(_Message.c_str()) {}

    explicit underflow_error(const char* _Message) : _Mybase(_Message) {}

#if !_HAS_EXCEPTIONS
protected:
    void _Doraise() const override { // perform class-specific exception handling
        _RAISE(*this);
    }
#endif // !_HAS_EXCEPTIONS
};

_EXPORT_STD class range_error : public runtime_error { // base of all range-error exceptions
public:
    using _Mybase = runtime_error;

    explicit range_error(const string& _Message) : _Mybase(_Message.c_str()) {}

    explicit range_error(const char* _Message) : _Mybase(_Message) {}

#if !_HAS_EXCEPTIONS
protected:
    void _Doraise() const override { // perform class-specific exception handling
        _RAISE(*this);
    }
#endif // !_HAS_EXCEPTIONS
};

[[noreturn]] inline void _Throw_range_error(const char* const _Message) {
    _THROW(range_error{ _Message });
}
_STD_END
#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _STDEXCEPT_


// xerrc.h internal header (core)

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#ifndef _XERRC_H
#define _XERRC_H
#if _STL_COMPILER_PREPROCESSOR

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_STD_BEGIN
_EXPORT_STD enum class errc { // names for generic error codes
    address_family_not_supported = 102, // EAFNOSUPPORT
    address_in_use = 100, // EADDRINUSE
    address_not_available = 101, // EADDRNOTAVAIL
    already_connected = 113, // EISCONN
    argument_list_too_long = 7, // E2BIG
    argument_out_of_domain = 33, // EDOM
    bad_address = 14, // EFAULT
    bad_file_descriptor = 9, // EBADF
    bad_message = 104, // EBADMSG
    broken_pipe = 32, // EPIPE
    connection_aborted = 106, // ECONNABORTED
    connection_already_in_progress = 103, // EALREADY
    connection_refused = 107, // ECONNREFUSED
    connection_reset = 108, // ECONNRESET
    cross_device_link = 18, // EXDEV
    destination_address_required = 109, // EDESTADDRREQ
    device_or_resource_busy = 16, // EBUSY
    directory_not_empty = 41, // ENOTEMPTY
    executable_format_error = 8, // ENOEXEC
    file_exists = 17, // EEXIST
    file_too_large = 27, // EFBIG
    filename_too_long = 38, // ENAMETOOLONG
    function_not_supported = 40, // ENOSYS
    host_unreachable = 110, // EHOSTUNREACH
    identifier_removed = 111, // EIDRM
    illegal_byte_sequence = 42, // EILSEQ
    inappropriate_io_control_operation = 25, // ENOTTY
    interrupted = 4, // EINTR
    invalid_argument = 22, // EINVAL
    invalid_seek = 29, // ESPIPE
    io_error = 5, // EIO
    is_a_directory = 21, // EISDIR
    message_size = 115, // EMSGSIZE
    network_down = 116, // ENETDOWN
    network_reset = 117, // ENETRESET
    network_unreachable = 118, // ENETUNREACH
    no_buffer_space = 119, // ENOBUFS
    no_child_process = 10, // ECHILD
    no_link = 121, // ENOLINK
    no_lock_available = 39, // ENOLCK
    no_message_available _CXX23_DEPRECATE_UNIX_STREAMS = 120, // ENODATA
    no_message = 122, // ENOMSG
    no_protocol_option = 123, // ENOPROTOOPT
    no_space_on_device = 28, // ENOSPC
    no_stream_resources _CXX23_DEPRECATE_UNIX_STREAMS = 124, // ENOSR
    no_such_device_or_address = 6, // ENXIO
    no_such_device = 19, // ENODEV
    no_such_file_or_directory = 2, // ENOENT
    no_such_process = 3, // ESRCH
    not_a_directory = 20, // ENOTDIR
    not_a_socket = 128, // ENOTSOCK
    not_a_stream _CXX23_DEPRECATE_UNIX_STREAMS = 125, // ENOSTR
    not_connected = 126, // ENOTCONN
    not_enough_memory = 12, // ENOMEM
    not_supported = 129, // ENOTSUP
    operation_canceled = 105, // ECANCELED
    operation_in_progress = 112, // EINPROGRESS
    operation_not_permitted = 1, // EPERM
    operation_not_supported = 130, // EOPNOTSUPP
    operation_would_block = 140, // EWOULDBLOCK
    owner_dead = 133, // EOWNERDEAD
    permission_denied = 13, // EACCES
    protocol_error = 134, // EPROTO
    protocol_not_supported = 135, // EPROTONOSUPPORT
    read_only_file_system = 30, // EROFS
    resource_deadlock_would_occur = 36, // EDEADLK
    resource_unavailable_try_again = 11, // EAGAIN
    result_out_of_range = 34, // ERANGE
    state_not_recoverable = 127, // ENOTRECOVERABLE
    stream_timeout _CXX23_DEPRECATE_UNIX_STREAMS = 137, // ETIME
    text_file_busy = 139, // ETXTBSY
    timed_out = 138, // ETIMEDOUT
    too_many_files_open_in_system = 23, // ENFILE
    too_many_files_open = 24, // EMFILE
    too_many_links = 31, // EMLINK
    too_many_symbolic_link_levels = 114, // ELOOP
    value_too_large = 132, // EOVERFLOW
    wrong_protocol_type = 136 // EPROTOTYPE
};

_STD_END

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)

#endif // _STL_COMPILER_PREPROCESSOR
#endif // _XERRC_H

#ifndef _M_CEE_PURE
#endif // !defined(_M_CEE_PURE)
#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

// TRANSITION, non-_Ugly attribute tokens
#pragma push_macro("msvc")
#pragma push_macro("noop_dtor")
#undef msvc
#undef noop_dtor

_STD_BEGIN
_EXPORT_STD enum class io_errc { // error codes for ios_base::failure
    stream = 1
};

_EXPORT_STD template <class _Enum>
struct is_error_code_enum : false_type {};

template <>
struct is_error_code_enum<io_errc> : true_type {};

_EXPORT_STD template <class _Ty>
_INLINE_VAR constexpr bool is_error_code_enum_v = is_error_code_enum<_Ty>::value;

_EXPORT_STD template <class _Enum>
struct is_error_condition_enum : false_type {};

template <>
struct is_error_condition_enum<errc> : true_type {};

_EXPORT_STD template <class _Ty>
_INLINE_VAR constexpr bool is_error_condition_enum_v = is_error_condition_enum<_Ty>::value;

_EXPORT_STD class error_code;
_EXPORT_STD class error_condition;

namespace _Ensure_adl {
    void make_error_code() = delete;
    void make_error_condition() = delete;
} // namespace _Ensure_adl

_EXPORT_STD class error_category;

_EXPORT_STD _NODISCARD const error_category& generic_category() noexcept;
_EXPORT_STD _NODISCARD const error_category& iostream_category() noexcept;
_EXPORT_STD _NODISCARD const error_category& system_category() noexcept;

_EXPORT_STD class __declspec(novtable) error_category { // categorize an error
public:
#ifdef _M_CEE_PURE
    /* constexpr */ error_category() noexcept { // TRANSITION, ABI
        _Addr = reinterpret_cast<uintptr_t>(this);
    }
#else // ^^^ defined(_M_CEE_PURE) / !defined(_M_CEE_PURE) vvv
#pragma warning(push)
#pragma warning(disable : 4355) // 'this': used in base member initializer list
    constexpr error_category() noexcept : _Addr(this) {}
#pragma warning(pop)
#endif // ^^^ !defined(_M_CEE_PURE) ^^^

    _CONSTEXPR20 virtual ~error_category() noexcept = default;

    _NODISCARD virtual const char* name() const noexcept = 0;

    _NODISCARD virtual string message(int _Errval) const = 0;

    _NODISCARD virtual error_condition default_error_condition(int _Errval) const noexcept;

    _NODISCARD virtual bool equivalent(int _Errval, const error_condition& _Cond) const noexcept;

    _NODISCARD virtual bool equivalent(const error_code& _Code, int _Errval) const noexcept;

    _NODISCARD bool operator==(const error_category& _Right) const noexcept {
#ifdef _M_CEE_PURE
        return _Addr == _Right._Addr;
#else // ^^^ defined(_M_CEE_PURE) / !defined(_M_CEE_PURE) vvv
        return _Bit_cast<uintptr_t>(_Addr) == _Bit_cast<uintptr_t>(_Right._Addr);
#endif // ^^^ !defined(_M_CEE_PURE) ^^^
    }

#if _HAS_CXX20
    _NODISCARD strong_ordering operator<=>(const error_category& _Right) const noexcept {
        return _Bit_cast<uintptr_t>(_Addr) <=> _Bit_cast<uintptr_t>(_Right._Addr);
    }
#else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
    _NODISCARD bool operator!=(const error_category& _Right) const noexcept {
        return !(*this == _Right);
    }

    _NODISCARD bool operator<(const error_category& _Right) const noexcept {
#ifdef _M_CEE_PURE
        return _Addr < _Right._Addr;
#else // ^^^ defined(_M_CEE_PURE) / !defined(_M_CEE_PURE) vvv
        return _Bit_cast<uintptr_t>(_Addr) < _Bit_cast<uintptr_t>(_Right._Addr);
#endif // ^^^ !defined(_M_CEE_PURE) ^^^
    }
#endif // ^^^ !_HAS_CXX20 ^^^

    error_category(const error_category&) = delete;
    error_category& operator=(const error_category&) = delete;

protected:
#ifdef _M_CEE_PURE
    uintptr_t _Addr;
#else // ^^^ defined(_M_CEE_PURE) / !defined(_M_CEE_PURE) vvv
    union _Addr_storage {
    private:
        uintptr_t _Num;
        error_category* _Ptr;

    public:
        constexpr explicit _Addr_storage(const uintptr_t _Addr_num) noexcept : _Num(_Addr_num) {}
        constexpr explicit _Addr_storage(error_category* const _Addr_ptr) noexcept : _Ptr(_Addr_ptr) {}

        // TRANSITION: As of Boost 1.80.0, boost::system::detail::std_category assigns to _Addr.
        constexpr _Addr_storage& operator=(const uintptr_t _Addr_num) noexcept {
            _Num = _Addr_num;
            return *this;
        }
    };
    _STL_INTERNAL_STATIC_ASSERT(sizeof(_Addr_storage) == sizeof(uintptr_t));
    _STL_INTERNAL_STATIC_ASSERT(alignof(_Addr_storage) == alignof(uintptr_t));

    _Addr_storage _Addr;
#endif // ^^^ !defined(_M_CEE_PURE) ^^^

    constexpr explicit error_category(const uintptr_t _Addr_) noexcept : _Addr(_Addr_) {}

    enum : uintptr_t { // symbolic addresses for Standard error_category objects
        _Future_addr = 1,
        _Generic_addr = 3,
        _Iostream_addr = 5,
        _System_addr = 7
    };
};

#if _STL_OPTIMIZE_SYSTEM_ERROR_OPERATORS
_NODISCARD inline bool _System_error_equal(const error_code&, const error_condition&) noexcept;
#endif // _STL_OPTIMIZE_SYSTEM_ERROR_OPERATORS

_EXPORT_STD class error_code { // store an implementation-specific error code and category
public:
    error_code() noexcept : _Myval(0), _Mycat(&_STD system_category()) {} // construct non-error

    error_code(int _Val, const error_category& _Cat) noexcept : _Myval(_Val), _Mycat(&_Cat) {}

    template <class _Enum, enable_if_t<is_error_code_enum_v<_Enum>, int> = 0>
    error_code(_Enum _Errcode) noexcept : _Myval(0), _Mycat(nullptr) {
        using _Ensure_adl::make_error_code;
        *this = make_error_code(_Errcode); // intentional ADL
    }

    void assign(int _Val, const error_category& _Cat) noexcept {
        _Myval = _Val;
        _Mycat = &_Cat;
    }

    template <class _Enum, enable_if_t<is_error_code_enum_v<_Enum>, int> = 0>
    error_code& operator=(_Enum _Errcode) noexcept {
        using _Ensure_adl::make_error_code;
        *this = make_error_code(_Errcode); // intentional ADL
        return *this;
    }

    void clear() noexcept {
        _Myval = 0;
        _Mycat = &_STD system_category();
    }

    _NODISCARD int value() const noexcept {
        return _Myval;
    }

    _NODISCARD const error_category& category() const noexcept {
        return *_Mycat;
    }

    _NODISCARD error_condition default_error_condition() const noexcept;

    _NODISCARD string message() const {
        return category().message(value());
    }

    explicit operator bool() const noexcept {
        return value() != 0;
    }

#if _STL_OPTIMIZE_SYSTEM_ERROR_OPERATORS
    _NODISCARD_FRIEND bool operator==(const error_code& _Left, const error_code& _Right) noexcept {
        return _Left.category() == _Right.category() && _Left.value() == _Right.value();
    }

    _NODISCARD_FRIEND bool operator==(const error_code& _Left, const error_condition& _Right) noexcept {
        return _System_error_equal(_Left, _Right);
    }

#if _HAS_CXX20
    _NODISCARD_FRIEND strong_ordering operator<=>(const error_code& _Left, const error_code& _Right) noexcept {
        if (const auto _Result = _Left.category() <=> _Right.category(); _Result != 0) {
            return _Result;
        }
        return _Left.value() <=> _Right.value();
    }
#else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
    _NODISCARD_FRIEND bool operator<(const error_code& _Left, const error_code& _Right) noexcept {
        return _Left.category() < _Right.category()
            || (_Left.category() == _Right.category() && _Left.value() < _Right.value());
    }
    _NODISCARD_FRIEND bool operator==(const error_condition& _Left, const error_code& _Right) noexcept {
        return _System_error_equal(_Right, _Left);
    }

    _NODISCARD_FRIEND bool operator!=(const error_code& _Left, const error_code& _Right) noexcept {
        return !(_Left == _Right);
    }

    _NODISCARD_FRIEND bool operator!=(const error_code& _Left, const error_condition& _Right) noexcept {
        return !_System_error_equal(_Left, _Right);
    }

    _NODISCARD_FRIEND bool operator!=(const error_condition& _Left, const error_code& _Right) noexcept {
        return !_System_error_equal(_Right, _Left);
    }
#endif // ^^^ !_HAS_CXX20 ^^^
#endif // _STL_OPTIMIZE_SYSTEM_ERROR_OPERATORS

private:
    int _Myval; // the stored error number
    const error_category* _Mycat; // pointer to error category
};

_EXPORT_STD class error_condition { // store an abstract error code and category
public:
    error_condition() noexcept : _Myval(0), _Mycat(&_STD generic_category()) {} // construct non-error

    error_condition(int _Val, const error_category& _Cat) noexcept : _Myval(_Val), _Mycat(&_Cat) {}

    template <class _Enum, enable_if_t<is_error_condition_enum_v<_Enum>, int> = 0>
    error_condition(_Enum _Errcode) noexcept : _Myval(0), _Mycat(nullptr) {
        using _Ensure_adl::make_error_condition;
        *this = make_error_condition(_Errcode); // intentional ADL
    }

    void assign(int _Val, const error_category& _Cat) noexcept {
        _Myval = _Val;
        _Mycat = &_Cat;
    }

    template <class _Enum, enable_if_t<is_error_condition_enum_v<_Enum>, int> = 0>
    error_condition& operator=(_Enum _Errcode) noexcept {
        using _Ensure_adl::make_error_condition;
        *this = make_error_condition(_Errcode); // intentional ADL
        return *this;
    }

    void clear() noexcept {
        _Myval = 0;
        _Mycat = &_STD generic_category();
    }

    _NODISCARD int value() const noexcept {
        return _Myval;
    }

    _NODISCARD const error_category& category() const noexcept {
        return *_Mycat;
    }

    _NODISCARD string message() const {
        return category().message(value());
    }

    explicit operator bool() const noexcept {
        return value() != 0;
    }

#if _STL_OPTIMIZE_SYSTEM_ERROR_OPERATORS
    _NODISCARD_FRIEND bool operator==(const error_condition& _Left, const error_condition& _Right) noexcept {
        return _Left.category() == _Right.category() && _Left.value() == _Right.value();
    }

#if _HAS_CXX20
    _NODISCARD_FRIEND strong_ordering operator<=>(
        const error_condition& _Left, const error_condition& _Right) noexcept {
        if (const auto _Result = _Left.category() <=> _Right.category(); _Result != 0) {
            return _Result;
        }
        return _Left.value() <=> _Right.value();
    }
#else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
    _NODISCARD_FRIEND bool operator<(const error_condition& _Left, const error_condition& _Right) noexcept {
        return _Left.category() < _Right.category()
            || (_Left.category() == _Right.category() && _Left.value() < _Right.value());
    }
    _NODISCARD_FRIEND bool operator!=(const error_condition& _Left, const error_condition& _Right) noexcept {
        return !(_Left == _Right);
    }
#endif // ^^^ !_HAS_CXX20 ^^^

    // We grant friendship to the operators from error_code here to allow is_error_code_enum_v but not
    // is_error_condition_enum_v enums to be compared directly with error_condition; for example:
    // io_errc::stream == make_error_condition(errc::out_of_memory)
    friend bool operator==(const error_code& _Left, const error_condition& _Right) noexcept;
#if !_HAS_CXX20
    friend bool operator==(const error_condition& _Left, const error_code& _Right) noexcept;
    friend bool operator!=(const error_code& _Left, const error_condition& _Right) noexcept;
    friend bool operator!=(const error_condition& _Left, const error_code& _Right) noexcept;
#endif // !_HAS_CXX20
#endif // _STL_OPTIMIZE_SYSTEM_ERROR_OPERATORS

private:
    int _Myval; // the stored error number
    const error_category* _Mycat; // pointer to error category
};

#if _STL_OPTIMIZE_SYSTEM_ERROR_OPERATORS
_NODISCARD inline bool _System_error_equal(const error_code& _Left, const error_condition& _Right) noexcept {
    return _Left.category().equivalent(_Left.value(), _Right) || _Right.category().equivalent(_Left, _Right.value());
}
#else // ^^^ _STL_OPTIMIZE_SYSTEM_ERROR_OPERATORS / !_STL_OPTIMIZE_SYSTEM_ERROR_OPERATORS vvv
_EXPORT_STD _NODISCARD inline bool operator==(const error_code& _Left, const error_code& _Right) noexcept {
    return _Left.category() == _Right.category() && _Left.value() == _Right.value();
}

_EXPORT_STD _NODISCARD inline bool operator==(const error_code& _Left, const error_condition& _Right) noexcept {
    return _Left.category().equivalent(_Left.value(), _Right) || _Right.category().equivalent(_Left, _Right.value());
}

_EXPORT_STD _NODISCARD inline bool operator==(const error_condition& _Left, const error_condition& _Right) noexcept {
    return _Left.category() == _Right.category() && _Left.value() == _Right.value();
}

#if _HAS_CXX20
_EXPORT_STD _NODISCARD inline strong_ordering operator<=>(const error_code& _Left, const error_code& _Right) noexcept {
    if (const auto _Result = _Left.category() <=> _Right.category(); _Result != 0) {
        return _Result;
    }
    return _Left.value() <=> _Right.value();
}

_EXPORT_STD _NODISCARD inline strong_ordering operator<=>(
    const error_condition& _Left, const error_condition& _Right) noexcept {
    if (const auto _Result = _Left.category() <=> _Right.category(); _Result != 0) {
        return _Result;
    }
    return _Left.value() <=> _Right.value();
}
#else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
_NODISCARD inline bool operator<(const error_code& _Left, const error_code& _Right) noexcept {
    return _Left.category() < _Right.category()
        || (_Left.category() == _Right.category() && _Left.value() < _Right.value());
}

_NODISCARD inline bool operator<(const error_condition& _Left, const error_condition& _Right) noexcept {
    return _Left.category() < _Right.category()
        || (_Left.category() == _Right.category() && _Left.value() < _Right.value());
}

_NODISCARD inline bool operator==(const error_condition& _Left, const error_code& _Right) noexcept {
    return _Right.category().equivalent(_Right.value(), _Left) || _Left.category().equivalent(_Right, _Left.value());
}

_NODISCARD inline bool operator!=(const error_code& _Left, const error_code& _Right) noexcept {
    return !(_Left == _Right);
}

_NODISCARD inline bool operator!=(const error_code& _Left, const error_condition& _Right) noexcept {
    return !(_Left == _Right);
}

_NODISCARD inline bool operator!=(const error_condition& _Left, const error_code& _Right) noexcept {
    return !(_Left == _Right);
}

_NODISCARD inline bool operator!=(const error_condition& _Left, const error_condition& _Right) noexcept {
    return !(_Left == _Right);
}
#endif // ^^^ !_HAS_CXX20 ^^^
#endif // ^^^ !_STL_OPTIMIZE_SYSTEM_ERROR_OPERATORS ^^^

_NODISCARD inline error_condition error_category::default_error_condition(int _Errval) const noexcept {
    // make error_condition for error code
    return error_condition(_Errval, *this);
}

_NODISCARD inline bool error_category::equivalent(int _Errval, const error_condition& _Cond) const noexcept {
    return default_error_condition(_Errval) == _Cond;
}

_NODISCARD inline bool error_category::equivalent(const error_code& _Code, int _Errval) const noexcept {
    return *this == _Code.category() && _Code.value() == _Errval;
}

_NODISCARD inline error_condition error_code::default_error_condition() const noexcept {
    // make error_condition for error code
    return category().default_error_condition(value());
}

_EXPORT_STD _NODISCARD inline error_code make_error_code(errc _Ec) noexcept {
    return error_code(static_cast<int>(_Ec), _STD generic_category());
}

_EXPORT_STD _NODISCARD inline error_code make_error_code(io_errc _Ec) noexcept {
    return error_code(static_cast<int>(_Ec), _STD iostream_category());
}

_EXPORT_STD _NODISCARD inline error_condition make_error_condition(errc _Ec) noexcept {
    return error_condition(static_cast<int>(_Ec), _STD generic_category());
}

_EXPORT_STD _NODISCARD inline error_condition make_error_condition(io_errc _Ec) noexcept {
    return error_condition(static_cast<int>(_Ec), _STD iostream_category());
}

template <>
struct hash<error_code> {
    using _ARGUMENT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = error_code;
    using _RESULT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = size_t;

    _NODISCARD _STATIC_CALL_OPERATOR size_t operator()(const error_code& _Keyval) _CONST_CALL_OPERATOR noexcept {
        return hash<int>{}(_Keyval.value());
    }
};

template <>
struct hash<error_condition> {
    using _ARGUMENT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = error_condition;
    using _RESULT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = size_t;

    _NODISCARD _STATIC_CALL_OPERATOR size_t operator()(const error_condition& _Keyval) _CONST_CALL_OPERATOR noexcept {
        return hash<int>{}(_Keyval.value());
    }
};

class _System_error : public runtime_error { // base of all system-error exceptions
private:
    static string _Makestr(error_code _Errcode, string _Message) { // compose error message
        if (!_Message.empty()) {
            _Message.append(": ");
        }

        _Message.append(_Errcode.message());
        return _Message;
    }

protected:
    _System_error(error_code _Errcode) : runtime_error(_Errcode.message()), _Mycode(_Errcode) {}

    _System_error(error_code _Errcode, const string& _Message)
        : runtime_error(_Makestr(_Errcode, _Message)), _Mycode(_Errcode) {}

    error_code _Mycode; // the stored error code
};

_EXPORT_STD class system_error : public _System_error { // base of all system-error exceptions
private:
    using _Mybase = _System_error;

public:
    system_error(error_code _Errcode) : _Mybase(_Errcode) {}

    system_error(error_code _Errcode, const string& _Message) : _Mybase(_Errcode, _Message) {}

    system_error(error_code _Errcode, const char* _Message) : _Mybase(_Errcode, _Message) {}

    system_error(int _Errval, const error_category& _Errcat) : _Mybase(error_code(_Errval, _Errcat)) {}

    system_error(int _Errval, const error_category& _Errcat, const string& _Message)
        : _Mybase(error_code(_Errval, _Errcat), _Message) {}

    system_error(int _Errval, const error_category& _Errcat, const char* _Message)
        : _Mybase(error_code(_Errval, _Errcat), _Message) {}

    _NODISCARD const error_code& code() const noexcept {
        return _Mycode;
    }

#if !_HAS_EXCEPTIONS
protected:
    void _Doraise() const override { // perform class-specific exception handling
        _RAISE(*this);
    }
#endif // !_HAS_EXCEPTIONS
};

[[noreturn]] inline void _Throw_system_error(const errc _Ec) {
    _THROW(system_error{ _STD make_error_code(_Ec) });
}

extern "C++" _CRTIMP2_PURE const char* __CLRCALL_PURE_OR_CDECL _Syserror_map(int);
extern "C++" _CRTIMP2_PURE int __CLRCALL_PURE_OR_CDECL _Winerror_map(int);

struct _System_error_message {
    char* _Str;
    size_t _Length;

    explicit _System_error_message(const unsigned long _Ec) noexcept
        : _Str(nullptr), _Length(_CSTD __std_system_error_allocate_message(_Ec, &_Str)) {}

    _System_error_message(const _System_error_message&) = delete;
    _System_error_message& operator=(const _System_error_message&) = delete;

    ~_System_error_message() {
        _CSTD __std_system_error_deallocate_message(_Str);
    }
};

class _Generic_error_category : public error_category { // categorize a generic error
public:
    constexpr _Generic_error_category() noexcept : error_category(_Generic_addr) {}

    _NODISCARD const char* name() const noexcept override {
        return "generic";
    }

    _NODISCARD string message(int _Errcode) const override {
        return _Syserror_map(_Errcode);
    }
};

class _Iostream_error_category2 : public error_category { // categorize an iostream error
public:
    constexpr _Iostream_error_category2() noexcept : error_category(_Iostream_addr) {}

    _NODISCARD const char* name() const noexcept override {
        return "iostream";
    }

    _NODISCARD string message(int _Errcode) const override {
        if (_Errcode == static_cast<int>(io_errc::stream)) {
            static constexpr char _Iostream_error[] = "iostream stream error";
            constexpr size_t _Iostream_error_length = sizeof(_Iostream_error) - 1; // TRANSITION, DevCom-906503
            return string{ _Iostream_error, _Iostream_error_length };
        }
        else {
            return _Syserror_map(_Errcode);
        }
    }
};

class _System_error_category : public error_category { // categorize an operating system error
public:
    constexpr _System_error_category() noexcept : error_category(_System_addr) {}

    _NODISCARD const char* name() const noexcept override {
        return "system";
    }

    _NODISCARD string message(int _Errcode) const override {
        const _System_error_message _Msg(static_cast<unsigned long>(_Errcode));
        if (_Msg._Length == 0) {
            static constexpr char _Unknown_error[] = "unknown error";
            constexpr size_t _Unknown_error_length = sizeof(_Unknown_error) - 1; // TRANSITION, DevCom-906503
            return string{ _Unknown_error, _Unknown_error_length };
        }
        else {
            _STL_INTERNAL_CHECK(_Msg._Str != nullptr);
            return string{ _Msg._Str, _Msg._Length }; // lgtm [cpp/uninitializedptrfield]
        }
    }

    _NODISCARD error_condition default_error_condition(int _Errval) const noexcept override {
        if (_Errval == 0) {
            return error_condition(0, _STD generic_category());
        }

        // make error_condition for error code (generic if possible)
        const int _Posv = _Winerror_map(_Errval);
        if (_Posv == 0) {
            return error_condition(_Errval, _STD system_category());
        }
        else {
            return error_condition(_Posv, _STD generic_category());
        }
    }
};

// _Immortalize_memcpy_image is used to provide a nonstandard guarantee.
// Specifically, we want the error category objects returned from things like std::system_category() to always
//   be available, even during DLL unload (otherwise, <system_error> would be a huge regression vs. legacy error codes).
// Moreover, we need to be very conservative in the runtime support we request. Thus, we have these constraints:
//
// * can't use magic statics in standard modes, because that would inject a .TLS section into all binaries using
//   <system_error> and would likely put borderline programs over the TLS slot count limit, and would destroy the
//   variable during DLL unload
// * can't declare the error_category as an ordinary constexpr variable for most compilers before C++20, because
//   error_category has a virtual destructor
// * can't declare the error_category as an ordinary non-constexpr variable even with a constexpr constructor, because
//   the compiler will emit code to destroy it which invalidates its use in these DLL shutdown scenarios
//
// As a result, we use a workaround: We create an atomic<uintptr_t> array to store the error_category instance, test
//   if the first atomic is nonzero (acquire), and if so, we know we have formed the instance and can return a
//   reinterpreted pointer to that storage. If the first atomic is zero, we write all except the first atomic (relaxed),
//   then write the first one as a store-release. (The non-first values are transferred to other threads in the
//   release sequence).
//
// Acknowledged undefined and implementation-defined behavior happening here:
// * There is a data race when filling in the values other than the first atomic; this is OK on all hardware we target
//   because the racing threads are all writing identical values that never change afterwards.
// * We are reaching into the layout of atomic<uintptr_t>[N] and assuming we can reinterpret that as some other type.
// * We are assuming that virtual functions are implemented with a vfptr located as the first member of an object.
// (there are probably others)
//
// Inspecting the resulting assembly of any callers of _Immortalize_memcpy_image is recommended.
//

#if defined(_M_CEE_PURE)
// /clr:pure doesn't ever do constant initialization, so rely on the CLR and magic statics
template <class _Ty>
_NODISCARD const _Ty& _Immortalize_memcpy_image() noexcept {
    /* MAGIC */ static _Immortalizer_impl<_Ty> _Static;
    return _Static._Storage;
}
#elif _HAS_CXX20
template <class _Ty>
_NODISCARD const _Ty& _Immortalize_memcpy_image() noexcept {
    static constexpr _Ty _Static;
    return _Static;
}
#elif defined(__clang__)
template <class _Ty>
_NODISCARD const _Ty& _Immortalize_memcpy_image() noexcept {
    [[_Clang::__require_constant_initialization__]] static _Ty _Static;
    return _Static;
}
#elif !defined(_M_CEE)
template <class _Ty>
struct _Constexpr_immortalize_impl {
    union {
        _Ty _Storage;
    };

    constexpr _Constexpr_immortalize_impl() noexcept : _Storage{} {}

    _Constexpr_immortalize_impl(const _Constexpr_immortalize_impl&) = delete;
    _Constexpr_immortalize_impl& operator=(const _Constexpr_immortalize_impl&) = delete;

    _MSVC_NOOP_DTOR ~_Constexpr_immortalize_impl() {
        // do nothing, allowing _Ty to be used during shutdown
    }
};

template <class _Ty>
_NODISCARD const _Ty& _Immortalize_memcpy_image() noexcept {
    static _Constexpr_immortalize_impl<_Ty> _Static;
    return _Static._Storage;
}
#else // ^^^ !defined(_M_CEE) / defined(_M_CEE), TRANSITION, VSO-1153256 vvv
template <class _Ty>
_NODISCARD const _Ty& _Immortalize_memcpy_image() noexcept {
    // return reference to a memcpy'd default-initialized _Ty
    // pre: A default-initialized _Ty sets the first pointer-sized field to nonzero
    constexpr size_t _Pointer_count = sizeof(_Ty) / sizeof(uintptr_t);
    static atomic<uintptr_t> _Storage[_Pointer_count];
    static_assert(sizeof(_Storage) == sizeof(_Ty), "Bad storage size");
    static_assert(alignof(decltype(_Storage)) >= alignof(_Ty), "Bad alignment assumptions");
    if (_Storage[0].load(memory_order_acquire) != 0) {
        return reinterpret_cast<_Ty&>(_Storage);
    }

    const _Ty _Target;
    const auto _Target_iter = reinterpret_cast<const uintptr_t*>(_STD addressof(_Target));
    _CSTD memcpy(_Storage + 1, _Target_iter + 1, sizeof(_Ty) - sizeof(uintptr_t));
    _Storage[0].store(_Target_iter[0], memory_order_release);
    return reinterpret_cast<_Ty&>(_Storage);
}
#endif // ^^^ defined(_M_CEE), TRANSITION, VSO-1153256 ^^^

_EXPORT_STD _NODISCARD inline const error_category& generic_category() noexcept {
    return _Immortalize_memcpy_image<_Generic_error_category>();
}

_EXPORT_STD _NODISCARD inline const error_category& iostream_category() noexcept {
    return _Immortalize_memcpy_image<_Iostream_error_category2>();
}

_EXPORT_STD _NODISCARD inline const error_category& system_category() noexcept {
    return _Immortalize_memcpy_image<_System_error_category>();
}
_STD_END

#if _HAS_CXX17
extern "C" {
    enum class __std_win_error : unsigned long;
} // extern "C"

_STD_BEGIN
// We would really love to use the proper way of building error_code by specializing
// is_error_code_enum and make_error_code for __std_win_error, but because:
//   1. We would like to keep the definition of __std_win_error in xfilesystem_abi.h
//   2. and xfilesystem_abi.h cannot include <system_error>
//   3. and specialization of is_error_code_enum and overload of make_error_code
//      need to be kept together with the enum (see limerick in N4950 [temp.expl.spec]/8)
// we resort to using this _Make_ec helper.
_NODISCARD inline error_code _Make_ec(__std_win_error _Errno) noexcept { // make an error_code
    return { static_cast<int>(_Errno), _STD system_category() };
}

[[noreturn]] inline void _Throw_system_error_from_std_win_error(const __std_win_error _Errno) {
    _THROW(system_error{ _Make_ec(_Errno) });
}
_STD_END
#endif // _HAS_CXX17

// TRANSITION, non-_Ugly attribute tokens
#pragma pop_macro("noop_dtor")
#pragma pop_macro("msvc")

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _SYSTEM_ERROR_

// xlocale internal header

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#ifndef _XLOCALE_
#define _XLOCALE_
#if _STL_COMPILER_PREPROCESSOR
// memory standard header

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#ifndef _MEMORY_
#define _MEMORY_
#if _STL_COMPILER_PREPROCESSOR
// typeinfo standard header

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#ifndef _TYPEINFO_
#define _TYPEINFO_
#if _STL_COMPILER_PREPROCESSOR

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

#pragma warning(disable : 4275) // non dll-interface class 'X' used as base for dll-interface class 'Y'

#pragma push_macro("raw_name") // TRANSITION, GH-2195
#undef raw_name
//
// vcruntime_typeinfo.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// <typeinfo> functionality that is implemented in the VCRuntime.
//
#pragma once

#if _VCRT_COMPILER_PREPROCESSOR


#pragma warning(push)
#pragma warning(disable: _VCRUNTIME_DISABLED_WARNINGS)

#pragma pack(push, _CRT_PACKING)

extern "C++" { // attach declarations to the global module, see N4910 [module.unit]/7

#if defined _M_CEE_MIXED && !defined _VCRT_BUILD
    // Provide a fake definition of __type_info_node to suppress linker warning
    // LNK4248: unresolved typeref token for '__type_info_node'; image may not run.
    struct __type_info_node { };
#else
    struct __type_info_node;
#endif

#ifdef _M_CEE_PURE
    extern System::IntPtr __type_info_root_node;
#else
    extern __type_info_node __type_info_root_node;
#endif

} // extern "C++"


_CRT_BEGIN_C_HEADER

struct __std_type_info_data
{
    const char* _UndecoratedName;
    const char   _DecoratedName[1];
    __std_type_info_data() = delete;
    __std_type_info_data(const __std_type_info_data&) = delete;
    __std_type_info_data(__std_type_info_data&&) = delete;

    __std_type_info_data& operator=(const __std_type_info_data&) = delete;
    __std_type_info_data& operator=(__std_type_info_data&&) = delete;
};

_VCRTIMP int __cdecl __std_type_info_compare(
    _In_ const __std_type_info_data* _Lhs,
    _In_ const __std_type_info_data* _Rhs
);

_VCRTIMP size_t __cdecl __std_type_info_hash(
    _In_ const __std_type_info_data* _Data
);

_VCRTIMP const char* __cdecl __std_type_info_name(
    _Inout_ __std_type_info_data* _Data,
    _Inout_ __type_info_node* _RootNode
);

_CRT_END_C_HEADER


extern "C++" { // attach declarations to the global module, see N4910 [module.unit]/7

#pragma warning(push)
#pragma warning(disable: 4577) // 'noexcept' used with no exception handling mode specified
    _VCRT_EXPORT_STD class type_info // Exported because for typeid, MSVC looks for type_info in the global namespace
    {
    public:

        type_info(const type_info&) = delete;
        type_info& operator=(const type_info&) = delete;

        _NODISCARD size_t hash_code() const noexcept
        {
            return __std_type_info_hash(&_Data);
        }

        _NODISCARD
#if _HAS_CXX23
            constexpr
#endif // _HAS_CXX23
            bool operator==(const type_info& _Other) const noexcept
        {
#if _HAS_CXX23
            if (__builtin_is_constant_evaluated())
            {
                return &_Data == &_Other._Data;
            }
#endif // _HAS_CXX23

            return __std_type_info_compare(&_Data, &_Other._Data) == 0;
        }

#if !_HAS_CXX20
        _NODISCARD bool operator!=(const type_info& _Other) const noexcept
        {
            return __std_type_info_compare(&_Data, &_Other._Data) != 0;
        }
#endif // !_HAS_CXX20

        _NODISCARD bool before(const type_info& _Other) const noexcept
        {
            return __std_type_info_compare(&_Data, &_Other._Data) < 0;
        }

        _NODISCARD const char* name() const noexcept
        {
#ifdef _M_CEE_PURE
            return __std_type_info_name(&_Data, static_cast<__type_info_node*>(__type_info_root_node.ToPointer()));
#else
            return __std_type_info_name(&_Data, &__type_info_root_node);
#endif
        }

        _NODISCARD const char* raw_name() const noexcept
        {
            return _Data._DecoratedName;
        }

        virtual ~type_info() noexcept;

    private:

        mutable __std_type_info_data _Data;
    };
#pragma warning(pop)

    namespace std {
        _VCRT_EXPORT_STD using ::type_info;
    }

#if _HAS_EXCEPTIONS

    namespace std {

#pragma warning(push)
#pragma warning(disable: 4577) // 'noexcept' used with no exception handling mode specified
        _VCRT_EXPORT_STD class bad_cast
            : public exception
        {
        public:

            bad_cast() noexcept
                : exception("bad cast", 1)
            {
            }

            static bad_cast __construct_from_string_literal(const char* const _Message) noexcept
            {
                return bad_cast(_Message, 1);
            }

        private:

            bad_cast(const char* const _Message, int) noexcept
                : exception(_Message, 1)
            {
            }
        };

        _VCRT_EXPORT_STD class bad_typeid
            : public exception
        {
        public:

            bad_typeid() noexcept
                : exception("bad typeid", 1)
            {
            }

            static bad_typeid __construct_from_string_literal(const char* const _Message) noexcept
            {
                return bad_typeid(_Message, 1);
            }

        private:

            friend class __non_rtti_object;

            bad_typeid(const char* const _Message, int) noexcept
                : exception(_Message, 1)
            {
            }
        };

        class __non_rtti_object
            : public bad_typeid
        {
        public:

            static __non_rtti_object __construct_from_string_literal(const char* const _Message) noexcept
            {
                return __non_rtti_object(_Message, 1);
            }

        private:

            __non_rtti_object(const char* const _Message, int) noexcept
                : bad_typeid(_Message, 1)
            {
            }
        };

#pragma warning(pop)
    } // namespace std

#endif // _HAS_EXCEPTIONS

} // extern "C++"

#pragma pack(pop)
#pragma warning(pop) // _VCRUNTIME_DISABLED_WARNINGS
#endif // _VCRT_COMPILER_PREPROCESSOR

#pragma pop_macro("raw_name")

#ifndef _VCRT_EXPORT_STD // TRANSITION, VCRuntime update expected in 17.10 Preview 3
// Follow N4971 [module.interface]/6 by exporting aliases (a type alias is not an entity, N4971 [basic.pre]/3):
_EXPORT_STD using type_info = type_info; // for typeid, MSVC looks for type_info in the global namespace
#endif // ^^^ workaround ^^^

_STD_BEGIN

// size in pointers of std::function and std::any (roughly 3 pointers larger than std::string when building debug)
_INLINE_VAR constexpr int _Small_object_num_ptrs = 6 + 16 / sizeof(void*);

#ifndef _VCRT_EXPORT_STD // TRANSITION, VCRuntime update expected in 17.10 Preview 3
_EXPORT_STD using ::type_info;
#endif // ^^^ workaround ^^^

#if _HAS_EXCEPTIONS
#ifndef _VCRT_EXPORT_STD // TRANSITION, VCRuntime update expected in 17.10 Preview 3
// Follow N4971 [module.interface]/6 by exporting aliases (a type alias is not an entity, N4971 [basic.pre]/3):
_EXPORT_STD using bad_cast = bad_cast;
_EXPORT_STD using bad_typeid = bad_typeid;
#endif // ^^^ workaround ^^^
#else // ^^^ _HAS_EXCEPTIONS / !_HAS_EXCEPTIONS vvv
_EXPORT_STD class bad_cast : public exception { // base of all bad cast exceptions
public:
    bad_cast(const char* _Message = "bad cast") noexcept : exception(_Message) {}

    ~bad_cast() noexcept override {}

protected:
    void _Doraise() const override { // perform class-specific exception handling
        _RAISE(*this);
    }
};

_EXPORT_STD class bad_typeid : public exception { // base of all bad typeid exceptions
public:
    bad_typeid(const char* _Message = "bad typeid") noexcept : exception(_Message) {}

    ~bad_typeid() noexcept override {}

protected:
    void _Doraise() const override { // perform class-specific exception handling
        _RAISE(*this);
    }
};

class __non_rtti_object : public bad_typeid { // report a non-RTTI object
public:
    __non_rtti_object(const char* _Message) : bad_typeid(_Message) {}
};
#endif // ^^^ !_HAS_EXCEPTIONS ^^^

[[noreturn]] inline void _Throw_bad_cast() {
    _THROW(bad_cast{});
}

_STD_END

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma pack(pop)
#pragma warning(pop)
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _TYPEINFO_

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

// TRANSITION, non-_Ugly attribute tokens
#pragma push_macro("msvc")
#undef msvc

_STD_BEGIN
#if _HAS_CXX17
#define _REQUIRE_PARALLEL_LVALUE_ITERATOR(_Iter)                                                                     \
    static_assert(_Is_ranges_fwd_iter_v<_Iter> && is_lvalue_reference_v<_Iter_ref_t<_Iter>>,                         \
        "Parallel specialized <memory> algorithms require the iterator type to be forward iterator and dereference " \
        "to lvalues.")

_EXPORT_STD template <class _ExPo, class _FwdIt, class _NoThrowFwdIt, _Enable_if_execution_policy_t<_ExPo> = 0>
_NoThrowFwdIt uninitialized_copy(_ExPo&&, const _FwdIt _First, const _FwdIt _Last, _NoThrowFwdIt _Dest) noexcept
/* terminates */ {
    // copy [_First, _Last) to raw [_Dest, ...)
    // not parallelized at present
    _REQUIRE_PARALLEL_ITERATOR(_FwdIt);
    _REQUIRE_PARALLEL_LVALUE_ITERATOR(_NoThrowFwdIt);

    return _STD uninitialized_copy(_First, _Last, _Dest);
}
#endif // _HAS_CXX17

#if _HAS_CXX20
namespace ranges {
    _EXPORT_STD template <class _In, class _Out>
        using uninitialized_copy_result = in_out_result<_In, _Out>;

    class _Uninitialized_copy_fn {
    public:
        template <input_iterator _It, sentinel_for<_It> _Se, _No_throw_forward_iterator _Out,
            _No_throw_sentinel_for<_Out> _OSe>
            requires constructible_from<iter_value_t<_Out>, iter_reference_t<_It>>
        _STATIC_CALL_OPERATOR uninitialized_copy_result<_It, _Out> operator()(
            _It _First1, _Se _Last1, _Out _First2, _OSe _Last2) _CONST_CALL_OPERATOR {
            _STD _Adl_verify_range(_First1, _Last1);
            _STD _Adl_verify_range(_First2, _Last2);
            auto _UResult = _Uninitialized_copy_unchecked(_RANGES _Unwrap_iter<_Se>(_STD move(_First1)),
                _RANGES _Unwrap_sent<_It>(_STD move(_Last1)), _RANGES _Unwrap_iter<_OSe>(_STD move(_First2)),
                _RANGES _Unwrap_sent<_Out>(_STD move(_Last2)));

            _STD _Seek_wrapped(_First1, _STD move(_UResult.in));
            _STD _Seek_wrapped(_First2, _STD move(_UResult.out));
            return { _STD move(_First1), _STD move(_First2) };
        }

        template <input_range _Rng1, _No_throw_forward_range _Rng2>
            requires constructible_from<range_value_t<_Rng2>, range_reference_t<_Rng1>>
        _STATIC_CALL_OPERATOR uninitialized_copy_result<borrowed_iterator_t<_Rng1>, borrowed_iterator_t<_Rng2>>
            operator()(_Rng1&& _Range1, _Rng2&& _Range2) _CONST_CALL_OPERATOR {
            auto _First1 = _RANGES begin(_Range1);
            auto _UResult = _Uninitialized_copy_unchecked(_RANGES _Unwrap_range_iter<_Rng1>(_STD move(_First1)),
                _Uend(_Range1), _Ubegin(_Range2), _Uend(_Range2));

            _STD _Seek_wrapped(_First1, _STD move(_UResult.in));
            return { _STD move(_First1), _RANGES _Rewrap_iterator(_Range2, _STD move(_UResult.out)) };
        }

    private:
        template <class _It, class _Se, class _Out, class _OSe>
        _NODISCARD static uninitialized_copy_result<_It, _Out> _Uninitialized_copy_unchecked(
            _It _IFirst, _Se _ILast, _Out _OFirst, _OSe _OLast) {
            _STL_INTERNAL_STATIC_ASSERT(input_iterator<_It>);
            _STL_INTERNAL_STATIC_ASSERT(sentinel_for<_Se, _It>);
            _STL_INTERNAL_STATIC_ASSERT(_No_throw_forward_iterator<_Out>);
            _STL_INTERNAL_STATIC_ASSERT(_No_throw_sentinel_for<_OSe, _Out>);
            _STL_INTERNAL_STATIC_ASSERT(constructible_from<iter_value_t<_Out>, iter_reference_t<_It>>);

            constexpr bool _Is_sized1 = sized_sentinel_for<_Se, _It>;
            constexpr bool _Is_sized2 = sized_sentinel_for<_OSe, _Out>;
            if constexpr (_Iter_copy_cat<_It, _Out>::_Bitcopy_constructible
                && _Sized_or_unreachable_sentinel_for<_Se, _It>
                && _Sized_or_unreachable_sentinel_for<_OSe, _Out>) {
                if constexpr (_Is_sized1 && _Is_sized2) {
                    return _RANGES _Copy_memcpy_common(_IFirst, _RANGES next(_IFirst, _STD move(_ILast)), _OFirst,
                        _RANGES next(_OFirst, _STD move(_OLast)));
                }
                else if constexpr (_Is_sized1) {
                    return _RANGES _Copy_memcpy_distance(
                        _IFirst, _OFirst, _IFirst, _RANGES next(_IFirst, _STD move(_ILast)));
                }
                else if constexpr (_Is_sized2) {
                    return _RANGES _Copy_memcpy_distance(
                        _IFirst, _OFirst, _OFirst, _RANGES next(_OFirst, _STD move(_OLast)));
                }
                else {
                    _STL_ASSERT(false, "Tried to uninitialized_copy two ranges with unreachable sentinels");
                }
            }
            else {
                _Uninitialized_backout _Backout{ _STD move(_OFirst) };

                for (; _IFirst != _ILast && _Backout._Last != _OLast; ++_IFirst) {
                    _Backout._Emplace_back(*_IFirst);
                }

                return { _STD move(_IFirst), _Backout._Release() };
            }
        }
    };

    _EXPORT_STD inline constexpr _Uninitialized_copy_fn uninitialized_copy;
} // namespace ranges
#endif // _HAS_CXX20

_EXPORT_STD template <class _InIt, class _Diff, class _NoThrowFwdIt>
_NoThrowFwdIt uninitialized_copy_n(const _InIt _First, const _Diff _Count_raw, _NoThrowFwdIt _Dest) {
    // copy [_First, _First + _Count) to [_Dest, ...)
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (_Count <= 0) {
        return _Dest;
    }

    auto _UFirst = _STD _Get_unwrapped_n(_First, _Count);
    auto _UDest = _STD _Get_unwrapped_n(_Dest, _Count);
    if constexpr (_Iter_copy_cat<decltype(_UFirst), decltype(_UDest)>::_Bitcopy_constructible) {
        _UDest = _STD _Copy_memmove_n(_UFirst, static_cast<size_t>(_Count), _UDest);
    }
    else {
        _Uninitialized_backout<decltype(_UDest)> _Backout{ _UDest };

        for (; _Count > 0; --_Count, (void) ++_UFirst) {
            _Backout._Emplace_back(*_UFirst);
        }

        _UDest = _Backout._Release();
    }

    _STD _Seek_wrapped(_Dest, _UDest);
    return _Dest;
}

#if _HAS_CXX17
_EXPORT_STD template <class _ExPo, class _FwdIt, class _Diff, class _NoThrowFwdIt,
    _Enable_if_execution_policy_t<_ExPo> = 0>
    _NoThrowFwdIt uninitialized_copy_n(_ExPo&&, const _FwdIt _First, const _Diff _Count_raw, _NoThrowFwdIt _Dest) noexcept
    /* terminates */ {
    // copy [_First, _First + _Count) to raw [_Dest, ...)
    // not parallelized at present
    _REQUIRE_PARALLEL_ITERATOR(_FwdIt);
    _REQUIRE_PARALLEL_LVALUE_ITERATOR(_NoThrowFwdIt);

    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    return _STD uninitialized_copy_n(_First, _Count, _Dest);
}
#endif // _HAS_CXX17

#if _HAS_CXX20
namespace ranges {
    _EXPORT_STD template <class _In, class _Out>
        using uninitialized_copy_n_result = in_out_result<_In, _Out>;

    class _Uninitialized_copy_n_fn {
    public:
        template <input_iterator _It, _No_throw_forward_iterator _Out, _No_throw_sentinel_for<_Out> _OSe>
            requires constructible_from<iter_value_t<_Out>, iter_reference_t<_It>>
        _STATIC_CALL_OPERATOR uninitialized_copy_n_result<_It, _Out> operator()(
            _It _First1, iter_difference_t<_It> _Count, _Out _First2, _OSe _Last2) _CONST_CALL_OPERATOR {
            if (_Count <= 0) {
                return { _STD move(_First1), _STD move(_First2) };
            }

            _STD _Adl_verify_range(_First2, _Last2);
            auto _IFirst = _STD _Get_unwrapped_n(_STD move(_First1), _Count);
            auto _OFirst = _RANGES _Unwrap_iter<_OSe>(_STD move(_First2));
            auto _OLast = _RANGES _Unwrap_sent<_Out>(_STD move(_Last2));
            if constexpr (_Iter_copy_cat<_It, _Out>::_Bitcopy_constructible
                && _Sized_or_unreachable_sentinel_for<_OSe, _Out>) {
                if constexpr (sized_sentinel_for<_OSe, _Out>) {
                    auto _UResult = _RANGES _Copy_memcpy_common(
                        _IFirst, _IFirst + _Count, _OFirst, _RANGES next(_OFirst, _STD move(_OLast)));
                    _IFirst = _STD move(_UResult.in);
                    _OFirst = _STD move(_UResult.out);
                }
                else {
                    auto _UResult = _RANGES _Copy_memcpy_count(_IFirst, _OFirst, static_cast<size_t>(_Count));
                    _IFirst = _STD move(_UResult.in);
                    _OFirst = _STD move(_UResult.out);
                }
            }
            else {
                _Uninitialized_backout _Backout{ _STD move(_OFirst) };

                for (; _Count > 0 && _Backout._Last != _OLast; --_Count, (void) ++_IFirst) {
                    _Backout._Emplace_back(*_IFirst);
                }

                _OFirst = _Backout._Release();
            }

            _STD _Seek_wrapped(_First1, _STD move(_IFirst));
            _STD _Seek_wrapped(_First2, _STD move(_OFirst));
            return { _STD move(_First1), _STD move(_First2) };
        }
    };

    _EXPORT_STD inline constexpr _Uninitialized_copy_n_fn uninitialized_copy_n;
} // namespace ranges
#endif // _HAS_CXX20

#if _HAS_CXX17
_EXPORT_STD template <class _InIt, class _NoThrowFwdIt>
_NoThrowFwdIt uninitialized_move(const _InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest) {
    // move [_First, _Last) to raw [_Dest, ...)
    _STD _Adl_verify_range(_First, _Last);
    const auto _UFirst = _STD _Get_unwrapped(_First);
    const auto _ULast = _STD _Get_unwrapped(_Last);
    const auto _UDest = _STD _Get_unwrapped_n(_Dest, _STD _Idl_distance<_InIt>(_UFirst, _ULast));
    _STD _Seek_wrapped(_Dest, _STD _Uninitialized_move_unchecked(_UFirst, _ULast, _UDest));
    return _Dest;
}

_EXPORT_STD template <class _ExPo, class _FwdIt, class _NoThrowFwdIt, _Enable_if_execution_policy_t<_ExPo> = 0>
_NoThrowFwdIt uninitialized_move(_ExPo&&, const _FwdIt _First, const _FwdIt _Last, _NoThrowFwdIt _Dest) noexcept
/* terminates */ {
    // move [_First, _Last) to raw [_Dest, ...)
    // not parallelized at present
    _REQUIRE_PARALLEL_ITERATOR(_FwdIt);
    _REQUIRE_PARALLEL_LVALUE_ITERATOR(_NoThrowFwdIt);

    return _STD uninitialized_move(_First, _Last, _Dest);
}

#if _HAS_CXX20
namespace ranges {
    class _Uninitialized_move_fn {
    public:
        template <input_iterator _It, sentinel_for<_It> _Se, _No_throw_forward_iterator _Out,
            _No_throw_sentinel_for<_Out> _OSe>
            requires constructible_from<iter_value_t<_Out>, iter_rvalue_reference_t<_It>>
        _STATIC_CALL_OPERATOR uninitialized_move_result<_It, _Out> operator()(
            _It _First1, _Se _Last1, _Out _First2, _OSe _Last2) _CONST_CALL_OPERATOR {
            _STD _Adl_verify_range(_First1, _Last1);
            _STD _Adl_verify_range(_First2, _Last2);
            auto _UResult = _RANGES _Uninitialized_move_unchecked(_RANGES _Unwrap_iter<_Se>(_STD move(_First1)),
                _RANGES _Unwrap_sent<_It>(_STD move(_Last1)), _RANGES _Unwrap_iter<_OSe>(_STD move(_First2)),
                _RANGES _Unwrap_sent<_Out>(_STD move(_Last2)));

            _STD _Seek_wrapped(_First1, _STD move(_UResult.in));
            _STD _Seek_wrapped(_First2, _STD move(_UResult.out));
            return { _STD move(_First1), _STD move(_First2) };
        }

        template <input_range _Rng1, _No_throw_forward_range _Rng2>
            requires constructible_from<range_value_t<_Rng2>, range_rvalue_reference_t<_Rng1>>
        _STATIC_CALL_OPERATOR uninitialized_move_result<borrowed_iterator_t<_Rng1>, borrowed_iterator_t<_Rng2>>
            operator()(_Rng1&& _Range1, _Rng2&& _Range2) _CONST_CALL_OPERATOR {
            auto _First1 = _RANGES begin(_Range1);
            auto _UResult = _RANGES _Uninitialized_move_unchecked(_RANGES _Unwrap_range_iter<_Rng1>(_STD move(_First1)),
                _Uend(_Range1), _Ubegin(_Range2), _Uend(_Range2));

            _STD _Seek_wrapped(_First1, _STD move(_UResult.in));
            return { _STD move(_First1), _RANGES _Rewrap_iterator(_Range2, _STD move(_UResult.out)) };
        }
    };

    _EXPORT_STD inline constexpr _Uninitialized_move_fn uninitialized_move;
} // namespace ranges
#endif // _HAS_CXX20

_EXPORT_STD template <class _InIt, class _Diff, class _NoThrowFwdIt>
pair<_InIt, _NoThrowFwdIt> uninitialized_move_n(_InIt _First, const _Diff _Count_raw, _NoThrowFwdIt _Dest) {
    // move [_First, _First + _Count) to [_Dest, ...)
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (_Count <= 0) {
        return { _First, _Dest };
    }

    auto _UFirst = _STD _Get_unwrapped_n(_First, _Count);
    auto _UDest = _STD _Get_unwrapped_n(_Dest, _Count);
    if constexpr (_Iter_move_cat<decltype(_UFirst), decltype(_UDest)>::_Bitcopy_constructible) {
        _UDest = _STD _Copy_memmove_n(_UFirst, static_cast<size_t>(_Count), _UDest);
        _UFirst += _Count;
    }
    else {
        _Uninitialized_backout<decltype(_UDest)> _Backout{ _UDest };

        for (; _Count > 0; --_Count, (void) ++_UFirst) {
            _Backout._Emplace_back(_STD move(*_UFirst));
        }

        _UDest = _Backout._Release();
    }

    _STD _Seek_wrapped(_Dest, _UDest);
    _STD _Seek_wrapped(_First, _UFirst);
    return { _First, _Dest };
}

_EXPORT_STD template <class _ExPo, class _FwdIt, class _Diff, class _NoThrowFwdIt,
    _Enable_if_execution_policy_t<_ExPo> = 0>
    pair<_FwdIt, _NoThrowFwdIt> uninitialized_move_n(
        _ExPo&&, const _FwdIt _First, const _Diff _Count_raw, _NoThrowFwdIt _Dest) noexcept /* terminates */ {
    // move [_First, _First + _Count) to raw [_Dest, ...)
    // not parallelized at present
    _REQUIRE_PARALLEL_ITERATOR(_FwdIt);
    _REQUIRE_PARALLEL_LVALUE_ITERATOR(_NoThrowFwdIt);

    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    return _STD uninitialized_move_n(_First, _Count, _Dest);
}

_EXPORT_STD template <class _ExPo, class _NoThrowFwdIt, class _Tval, _Enable_if_execution_policy_t<_ExPo> = 0>
void uninitialized_fill(_ExPo&&, const _NoThrowFwdIt _First, const _NoThrowFwdIt _Last, const _Tval& _Val) noexcept
/* terminates */ {
    // copy _Val throughout raw [_First, _Last)
    // not parallelized at present
    _REQUIRE_PARALLEL_LVALUE_ITERATOR(_NoThrowFwdIt);

    _STD uninitialized_fill(_First, _Last, _Val);
}
#endif // _HAS_CXX17

#if _HAS_CXX20
namespace ranges {
    _EXPORT_STD template <class _In, class _Out>
        using uninitialized_move_n_result = in_out_result<_In, _Out>;

    class _Uninitialized_move_n_fn {
    public:
        template <input_iterator _It, _No_throw_forward_iterator _Out, _No_throw_sentinel_for<_Out> _OSe>
            requires constructible_from<iter_value_t<_Out>, iter_rvalue_reference_t<_It>>
        _STATIC_CALL_OPERATOR uninitialized_move_n_result<_It, _Out> operator()(
            _It _First1, iter_difference_t<_It> _Count, _Out _First2, _OSe _Last2) _CONST_CALL_OPERATOR {
            if (_Count <= 0) {
                return { _STD move(_First1), _STD move(_First2) };
            }

            _STD _Adl_verify_range(_First2, _Last2);
            auto _IFirst = _STD _Get_unwrapped_n(_STD move(_First1), _Count);
            auto _OFirst = _RANGES _Unwrap_iter<_OSe>(_STD move(_First2));
            const auto _OLast = _RANGES _Unwrap_sent<_Out>(_STD move(_Last2));
            if constexpr (_Iter_move_cat<_It, _Out>::_Bitcopy_constructible
                && _Sized_or_unreachable_sentinel_for<_OSe, _Out>) {
                if constexpr (sized_sentinel_for<_OSe, _Out>) {
                    auto _UResult = _RANGES _Copy_memcpy_common(
                        _IFirst, _IFirst + _Count, _OFirst, _RANGES next(_OFirst, _STD move(_OLast)));
                    _IFirst = _STD move(_UResult.in);
                    _OFirst = _STD move(_UResult.out);
                }
                else {
                    auto _UResult = _RANGES _Copy_memcpy_count(_IFirst, _OFirst, static_cast<size_t>(_Count));
                    _IFirst = _STD move(_UResult.in);
                    _OFirst = _STD move(_UResult.out);
                }
            }
            else {
                _Uninitialized_backout _Backout{ _STD move(_OFirst) };

                for (; _Count > 0 && _Backout._Last != _OLast; --_Count, (void) ++_IFirst) {
                    _Backout._Emplace_back(_RANGES iter_move(_IFirst));
                }

                _OFirst = _Backout._Release();
            }

            _STD _Seek_wrapped(_First1, _STD move(_IFirst));
            _STD _Seek_wrapped(_First2, _STD move(_OFirst));
            return { _STD move(_First1), _STD move(_First2) };
        }
    };

    _EXPORT_STD inline constexpr _Uninitialized_move_n_fn uninitialized_move_n;

    class _Uninitialized_fill_fn {
    public:
        template <_No_throw_forward_iterator _It, _No_throw_sentinel_for<_It> _Se, class _Ty>
            requires constructible_from<iter_value_t<_It>, const _Ty&>
        _STATIC_CALL_OPERATOR _It operator()(_It _First, _Se _Last, const _Ty& _Val) _CONST_CALL_OPERATOR {
            _STD _Adl_verify_range(_First, _Last);
            auto _UResult = _Uninitialized_fill_unchecked(
                _RANGES _Unwrap_iter<_Se>(_STD move(_First)), _RANGES _Unwrap_sent<_It>(_STD move(_Last)), _Val);

            _STD _Seek_wrapped(_First, _STD move(_UResult));
            return _First;
        }

        template <_No_throw_forward_range _Rng, class _Ty>
            requires constructible_from<range_value_t<_Rng>, const _Ty&>
        _STATIC_CALL_OPERATOR borrowed_iterator_t<_Rng> operator()(
            _Rng&& _Range, const _Ty& _Val) _CONST_CALL_OPERATOR {
            return _RANGES _Rewrap_iterator(
                _Range, _Uninitialized_fill_unchecked(_Ubegin(_Range), _Uend(_Range), _Val));
        }

    private:
        template <class _It, class _Se, class _Ty>
        _NODISCARD static _It _Uninitialized_fill_unchecked(_It _OFirst, _Se _OLast, const _Ty& _Val) {
            _STL_INTERNAL_STATIC_ASSERT(_No_throw_forward_iterator<_It>);
            _STL_INTERNAL_STATIC_ASSERT(_No_throw_sentinel_for<_Se, _It>);
            _STL_INTERNAL_STATIC_ASSERT(constructible_from<iter_value_t<_It>, const _Ty&>);

            if constexpr (_Fill_memset_is_safe<_It, _Ty>) {
                const auto _OFinal = _RANGES next(_OFirst, _STD move(_OLast));
                _STD _Fill_memset(_OFirst, _Val, static_cast<size_t>(_OFinal - _OFirst));
                return _OFinal;
            }
            else {
                if constexpr (_Fill_zero_memset_is_safe<_It, _Ty>) {
                    if (_STD _Is_all_bits_zero(_Val)) {
                        const auto _OFinal = _RANGES next(_OFirst, _STD move(_OLast));
                        _STD _Fill_zero_memset(_OFirst, static_cast<size_t>(_OFinal - _OFirst));
                        return _OFinal;
                    }
                }

                _Uninitialized_backout _Backout{ _STD move(_OFirst) };

                while (_Backout._Last != _OLast) {
                    _Backout._Emplace_back(_Val);
                }

                return _Backout._Release();
            }
        }
    };

    _EXPORT_STD inline constexpr _Uninitialized_fill_fn uninitialized_fill;
} // namespace ranges
#endif // _HAS_CXX20

_EXPORT_STD template <class _NoThrowFwdIt, class _Diff, class _Tval>
_NoThrowFwdIt uninitialized_fill_n(_NoThrowFwdIt _First, const _Diff _Count_raw, const _Tval& _Val) {
    // copy _Count copies of _Val to raw _First
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (_Count <= 0) {
        return _First;
    }

    auto _UFirst = _STD _Get_unwrapped_n(_First, _Count);
    if constexpr (_Fill_memset_is_safe<decltype(_UFirst), _Tval>) {
        _STD _Fill_memset(_UFirst, _Val, static_cast<size_t>(_Count));
        _UFirst += _Count;
    }
    else {
        if constexpr (_Fill_zero_memset_is_safe<decltype(_UFirst), _Tval>) {
            if (_STD _Is_all_bits_zero(_Val)) {
                _STD _Fill_zero_memset(_UFirst, static_cast<size_t>(_Count));
                _STD _Seek_wrapped(_First, _UFirst + _Count);
                return _First;
            }
        }

        _Uninitialized_backout<decltype(_UFirst)> _Backout{ _UFirst };

        for (; _Count > 0; --_Count) {
            _Backout._Emplace_back(_Val);
        }

        _UFirst = _Backout._Release();
    }

    _STD _Seek_wrapped(_First, _UFirst);
    return _First;
}

#if _HAS_CXX17
_EXPORT_STD template <class _ExPo, class _NoThrowFwdIt, class _Diff, class _Tval,
    _Enable_if_execution_policy_t<_ExPo> = 0>
    _NoThrowFwdIt uninitialized_fill_n(
        _ExPo&&, const _NoThrowFwdIt _First, const _Diff _Count_raw, const _Tval& _Val) noexcept
    /* terminates */ {
    // copy _Count copies of _Val to raw _First
    // not parallelized at present
    _REQUIRE_PARALLEL_LVALUE_ITERATOR(_NoThrowFwdIt);

    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    return _STD uninitialized_fill_n(_First, _Count, _Val);
}
#endif // _HAS_CXX17

#if _HAS_CXX20
namespace ranges {
    class _Uninitialized_fill_n_fn {
    public:
        template <_No_throw_forward_iterator _It, class _Ty>
            requires constructible_from<iter_value_t<_It>, const _Ty&>
        _STATIC_CALL_OPERATOR _It operator()(
            _It _First, iter_difference_t<_It> _Count, const _Ty& _Val) _CONST_CALL_OPERATOR {
            if (_Count <= 0) {
                return _First;
            }

            auto _UFirst = _STD _Get_unwrapped_n(_STD move(_First), _Count);
            if constexpr (_Fill_memset_is_safe<decltype(_UFirst), _Ty>) {
                _STD _Fill_memset(_UFirst, _Val, static_cast<size_t>(_Count));
                _STD _Seek_wrapped(_First, _UFirst + _Count);
            }
            else {
                if constexpr (_Fill_zero_memset_is_safe<decltype(_UFirst), _Ty>) {
                    if (_STD _Is_all_bits_zero(_Val)) {
                        _STD _Fill_zero_memset(_UFirst, static_cast<size_t>(_Count));
                        _STD _Seek_wrapped(_First, _UFirst + _Count);
                        return _First;
                    }
                }

                _Uninitialized_backout _Backout{ _STD move(_UFirst) };

                for (; _Count > 0; --_Count) {
                    _Backout._Emplace_back(_Val);
                }

                _STD _Seek_wrapped(_First, _Backout._Release());
            }
            return _First;
        }
    };

    _EXPORT_STD inline constexpr _Uninitialized_fill_n_fn uninitialized_fill_n;

    class _Construct_at_fn {
    public:
        template <class _Ty, class... _Types>
            requires requires(_Ty* _Ptr, _Types&&... _Args) {
            ::new (static_cast<void*>(_Ptr)) _Ty(static_cast<_Types&&>(_Args)...); // per LWG-3888
        }
        _STATIC_CALL_OPERATOR constexpr _Ty* operator()(_Ty* _Location, _Types&&... _Args) _CONST_CALL_OPERATOR
            // clang-format off
            noexcept(noexcept(
                ::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {
            // clang-format on
#ifdef __EDG__
            return _STD construct_at(_Location, _STD forward<_Types>(_Args)...);
#else // ^^^ EDG / Other vvv
            _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);
#endif // ^^^ Other ^^^
        }
    };

    _EXPORT_STD inline constexpr _Construct_at_fn construct_at;

    template <_No_throw_input_iterator _It, _No_throw_sentinel_for<_It> _Se>
        requires destructible<iter_value_t<_It>>
    _NODISCARD constexpr _It _Destroy_unchecked(_It _First, _Se _Last) noexcept;

    class _Destroy_at_fn {
    public:
        template <destructible _Ty>
        _STATIC_CALL_OPERATOR constexpr void operator()(_Ty* const _Location) _CONST_CALL_OPERATOR noexcept {
            if constexpr (is_array_v<_Ty>) {
                (void)_RANGES _Destroy_unchecked(_RANGES begin(*_Location), _RANGES end(*_Location));
            }
            else {
                _Location->~_Ty();
            }
        }
    };

    _EXPORT_STD inline constexpr _Destroy_at_fn destroy_at;
} // namespace ranges
#endif // _HAS_CXX20

#if _HAS_CXX17
_EXPORT_STD template <class _NoThrowFwdIt>
_CONSTEXPR20 void destroy(const _NoThrowFwdIt _First, const _NoThrowFwdIt _Last) {
    // destroy all elements in [_First, _Last)
    _STD _Adl_verify_range(_First, _Last);
    _STD _Destroy_range(_STD _Get_unwrapped(_First), _STD _Get_unwrapped(_Last));
}

_EXPORT_STD template <class _ExPo, class _NoThrowFwdIt, _Enable_if_execution_policy_t<_ExPo> = 0>
void destroy(_ExPo&& _Exec, _NoThrowFwdIt _First, _NoThrowFwdIt _Last) noexcept; // terminates

#if _HAS_CXX20
namespace ranges {
    template <_No_throw_input_iterator _It, _No_throw_sentinel_for<_It> _Se>
        requires destructible<iter_value_t<_It>>
    _NODISCARD constexpr _It _Destroy_unchecked(_It _First, _Se _Last) noexcept {
        if constexpr (is_trivially_destructible_v<iter_value_t<_It>>) {
            _RANGES advance(_First, _STD move(_Last));
        }
        else {
            for (; _First != _Last; ++_First) {
                _RANGES destroy_at(_STD addressof(*_First));
            }
        }

        return _First;
    }

    class _Destroy_fn {
    public:
        template <_No_throw_input_iterator _It, _No_throw_sentinel_for<_It> _Se>
            requires destructible<iter_value_t<_It>>
        _STATIC_CALL_OPERATOR constexpr _It operator()(_It _First, _Se _Last) _CONST_CALL_OPERATOR noexcept {
            _STD _Adl_verify_range(_First, _Last);
            _STD _Seek_wrapped(_First, _RANGES _Destroy_unchecked(_RANGES _Unwrap_iter<_Se>(_STD move(_First)),
                _RANGES _Unwrap_sent<_It>(_STD move(_Last))));
            return _First;
        }

        template <_No_throw_input_range _Rng>
            requires destructible<range_value_t<_Rng>>
        _STATIC_CALL_OPERATOR constexpr borrowed_iterator_t<_Rng> operator()(
            _Rng&& _Range) _CONST_CALL_OPERATOR noexcept {
            auto _First = _RANGES begin(_Range);
            _STD _Seek_wrapped(
                _First, _RANGES _Destroy_unchecked(_RANGES _Unwrap_range_iter<_Rng>(_STD move(_First)), _Uend(_Range)));
            return _First;
        }
    };

    _EXPORT_STD inline constexpr _Destroy_fn destroy;
} // namespace ranges
#endif // _HAS_CXX20

_EXPORT_STD template <class _NoThrowFwdIt, class _Diff>
_CONSTEXPR20 _NoThrowFwdIt destroy_n(_NoThrowFwdIt _First, const _Diff _Count_raw) {
    // destroy all elements in [_First, _First + _Count)
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (_Count <= 0) {
        return _First;
    }

    auto _UFirst = _STD _Get_unwrapped_n(_First, _Count);
    if constexpr (is_trivially_destructible_v<_Iter_value_t<_NoThrowFwdIt>>) {
        _STD advance(_UFirst, _Count);
    }
    else {
        for (; _Count > 0; --_Count, (void) ++_UFirst) {
            _STD _Destroy_in_place(*_UFirst);
        }
    }

    _STD _Seek_wrapped(_First, _UFirst);
    return _First;
}

_EXPORT_STD template <class _ExPo, class _NoThrowFwdIt, class _Diff, _Enable_if_execution_policy_t<_ExPo> = 0>
_NoThrowFwdIt destroy_n(_ExPo&& _Exec, _NoThrowFwdIt _First, _Diff _Count_raw) noexcept; // terminates

#if _HAS_CXX20
namespace ranges {
    class _Destroy_n_fn {
    public:
        template <_No_throw_input_iterator _It>
            requires destructible<iter_value_t<_It>>
        _STATIC_CALL_OPERATOR constexpr _It operator()(
            _It _First, const iter_difference_t<_It> _Count_raw) _CONST_CALL_OPERATOR noexcept {
            _Algorithm_int_t<iter_difference_t<_It>> _Count = _Count_raw;
            if (_Count <= 0) {
                return _First;
            }

            auto _UFirst = _STD _Get_unwrapped_n(_STD move(_First), _Count);
            if constexpr (is_trivially_destructible_v<iter_value_t<_It>>) {
                _RANGES advance(_UFirst, _Count);
            }
            else {
                do {
                    _RANGES destroy_at(_STD addressof(*_UFirst));
                    ++_UFirst;
                    --_Count;
                } while (_Count > 0);
            }

            _STD _Seek_wrapped(_First, _STD move(_UFirst));
            return _First;
        }
    };

    _EXPORT_STD inline constexpr _Destroy_n_fn destroy_n;
} // namespace ranges
#endif // _HAS_CXX20

_EXPORT_STD template <class _NoThrowFwdIt>
void uninitialized_default_construct(const _NoThrowFwdIt _First, const _NoThrowFwdIt _Last) {
    // default-initialize all elements in [_First, _Last)
    using _Ty = remove_reference_t<_Iter_ref_t<_NoThrowFwdIt>>;
    _STD _Adl_verify_range(_First, _Last);
    if constexpr (!is_trivially_default_constructible_v<_Ty>) {
        _Uninitialized_backout _Backout{ _STD _Get_unwrapped(_First) };

        for (const auto _ULast = _STD _Get_unwrapped(_Last); _Backout._Last != _ULast; ++_Backout._Last) {
            _STD _Default_construct_in_place(*_Backout._Last);
        }

        _Backout._Release();
    }
}

_EXPORT_STD template <class _ExPo, class _NoThrowFwdIt, _Enable_if_execution_policy_t<_ExPo> = 0>
void uninitialized_default_construct(_ExPo&& _Exec, _NoThrowFwdIt _First, _NoThrowFwdIt _Last) noexcept; // terminates

#if _HAS_CXX20
namespace ranges {
    class _Uninitialized_default_construct_fn {
    public:
        template <_No_throw_forward_iterator _It, _No_throw_sentinel_for<_It> _Se>
            requires default_initializable<iter_value_t<_It>>
        _STATIC_CALL_OPERATOR _It operator()(_It _First, _Se _Last) _CONST_CALL_OPERATOR {
            _STD _Adl_verify_range(_First, _Last);
            auto _UResult = _Uninitialized_default_construct_unchecked(
                _RANGES _Unwrap_iter<_Se>(_STD move(_First)), _RANGES _Unwrap_sent<_It>(_STD move(_Last)));

            _STD _Seek_wrapped(_First, _STD move(_UResult));
            return _First;
        }

        template <_No_throw_forward_range _Rng>
            requires default_initializable<range_value_t<_Rng>>
        _STATIC_CALL_OPERATOR borrowed_iterator_t<_Rng> operator()(_Rng&& _Range) _CONST_CALL_OPERATOR {
            auto _UResult = _Uninitialized_default_construct_unchecked(_Ubegin(_Range), _Uend(_Range));

            return _RANGES _Rewrap_iterator(_Range, _STD move(_UResult));
        }

    private:
        template <class _It, class _Se>
        _NODISCARD static _It _Uninitialized_default_construct_unchecked(_It _OFirst, const _Se _OLast) {
            _STL_INTERNAL_STATIC_ASSERT(_No_throw_forward_iterator<_It>);
            _STL_INTERNAL_STATIC_ASSERT(_No_throw_sentinel_for<_Se, _It>);
            _STL_INTERNAL_STATIC_ASSERT(default_initializable<iter_value_t<_It>>);

            using _Ty = remove_reference_t<iter_reference_t<_It>>;
            if constexpr (is_trivially_default_constructible_v<_Ty>) {
                _RANGES advance(_OFirst, _OLast);
                return _OFirst;
            }
            else {
                _Uninitialized_backout _Backout{ _STD move(_OFirst) };

                for (; _Backout._Last != _OLast; ++_Backout._Last) {
                    _STD _Default_construct_in_place(*_Backout._Last);
                }

                return _Backout._Release();
            }
        }
    };

    _EXPORT_STD inline constexpr _Uninitialized_default_construct_fn uninitialized_default_construct;
} // namespace ranges
#endif // _HAS_CXX20

_EXPORT_STD template <class _NoThrowFwdIt, class _Diff>
_NoThrowFwdIt uninitialized_default_construct_n(_NoThrowFwdIt _First, const _Diff _Count_raw) {
    // default-initialize all elements in [_First, _First + _Count)
    using _Ty = _Iter_value_t<_NoThrowFwdIt>;
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (_Count <= 0) {
        return _First;
    }

    if constexpr (is_trivially_default_constructible_v<_Ty>) {
        _STD advance(_First, _Count);
    }
    else {
        _Uninitialized_backout _Backout{ _STD _Get_unwrapped_n(_First, _Count) };

        for (; _Count > 0; ++_Backout._Last, (void) --_Count) {
            _STD _Default_construct_in_place(*_Backout._Last);
        }

        _STD _Seek_wrapped(_First, _Backout._Release());
    }
    return _First;
}

_EXPORT_STD template <class _ExPo, class _NoThrowFwdIt, class _Diff, _Enable_if_execution_policy_t<_ExPo> = 0>
_NoThrowFwdIt uninitialized_default_construct_n(
    _ExPo&& _Exec, _NoThrowFwdIt _First, _Diff _Count_raw) noexcept; // terminates

#if _HAS_CXX20
namespace ranges {
    class _Uninitialized_default_construct_n_fn {
    public:
        template <_No_throw_forward_iterator _It>
            requires default_initializable<iter_value_t<_It>>
        _STATIC_CALL_OPERATOR _It operator()(_It _First, iter_difference_t<_It> _Count) _CONST_CALL_OPERATOR {
            if (_Count <= 0) {
                return _First;
            }

            using _Ty = remove_reference_t<iter_reference_t<_It>>;
            if constexpr (is_trivially_default_constructible_v<_Ty>) {
                _RANGES advance(_First, _Count);
            }
            else {
                _Uninitialized_backout _Backout{ _STD _Get_unwrapped_n(_STD move(_First), _Count) };

                for (; _Count > 0; --_Count, (void) ++_Backout._Last) {
                    _STD _Default_construct_in_place(*_Backout._Last);
                }

                _STD _Seek_wrapped(_First, _Backout._Release());
            }
            return _First;
        }
    };

    _EXPORT_STD inline constexpr _Uninitialized_default_construct_n_fn uninitialized_default_construct_n;
} // namespace ranges
#endif // _HAS_CXX20

_EXPORT_STD template <class _NoThrowFwdIt>
void uninitialized_value_construct(const _NoThrowFwdIt _First, const _NoThrowFwdIt _Last) {
    // value-initialize all elements in [_First, _Last)
    _STD _Adl_verify_range(_First, _Last);
    const auto _UFirst = _STD _Get_unwrapped(_First);
    const auto _ULast = _STD _Get_unwrapped(_Last);
    if constexpr (_Use_memset_value_construct_v<_Unwrapped_t<const _NoThrowFwdIt&>>) {
        _STD _Zero_range(_UFirst, _ULast);
    }
    else {
        _Uninitialized_backout _Backout{ _UFirst };

        while (_Backout._Last != _ULast) {
            _Backout._Emplace_back();
        }

        _Backout._Release();
    }
}

_EXPORT_STD template <class _ExPo, class _NoThrowFwdIt, _Enable_if_execution_policy_t<_ExPo> = 0>
void uninitialized_value_construct(_ExPo&& _Exec, _NoThrowFwdIt _First, _NoThrowFwdIt _Last) noexcept; // terminates

#if _HAS_CXX20
namespace ranges {
    class _Uninitialized_value_construct_fn {
    public:
        template <_No_throw_forward_iterator _It, _No_throw_sentinel_for<_It> _Se>
            requires default_initializable<iter_value_t<_It>>
        _STATIC_CALL_OPERATOR _It operator()(_It _First, _Se _Last) _CONST_CALL_OPERATOR {
            _STD _Adl_verify_range(_First, _Last);
            auto _UResult = _Uninitialized_value_construct_unchecked(
                _RANGES _Unwrap_iter<_Se>(_STD move(_First)), _RANGES _Unwrap_sent<_It>(_STD move(_Last)));

            _STD _Seek_wrapped(_First, _STD move(_UResult));
            return _First;
        }

        template <_No_throw_forward_range _Rng>
            requires default_initializable<range_value_t<_Rng>>
        _STATIC_CALL_OPERATOR borrowed_iterator_t<_Rng> operator()(_Rng&& _Range) _CONST_CALL_OPERATOR {
            auto _UResult = _Uninitialized_value_construct_unchecked(_Ubegin(_Range), _Uend(_Range));

            return _RANGES _Rewrap_iterator(_Range, _STD move(_UResult));
        }

    private:
        template <class _It, class _Se>
        _NODISCARD static _It _Uninitialized_value_construct_unchecked(_It _OFirst, _Se _OLast) {
            _STL_INTERNAL_STATIC_ASSERT(_No_throw_forward_iterator<_It>);
            _STL_INTERNAL_STATIC_ASSERT(_No_throw_sentinel_for<_Se, _It>);
            _STL_INTERNAL_STATIC_ASSERT(default_initializable<iter_value_t<_It>>);

            if constexpr (_Use_memset_value_construct_v<_It>) {
                return _STD _Zero_range(_OFirst, _RANGES next(_OFirst, _STD move(_OLast)));
            }
            else {
                _Uninitialized_backout _Backout{ _STD move(_OFirst) };

                while (_Backout._Last != _OLast) {
                    _Backout._Emplace_back();
                }

                return _Backout._Release();
            }
        }
    };

    _EXPORT_STD inline constexpr _Uninitialized_value_construct_fn uninitialized_value_construct;
} // namespace ranges
#endif // _HAS_CXX20

_EXPORT_STD template <class _NoThrowFwdIt, class _Diff>
_NoThrowFwdIt uninitialized_value_construct_n(_NoThrowFwdIt _First, const _Diff _Count_raw) {
    // value-initialize all elements in [_First, _First + _Count)
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (_Count <= 0) {
        return _First;
    }

    _STD _Seek_wrapped(
        _First, _STD _Uninitialized_value_construct_n_unchecked1(_STD _Get_unwrapped_n(_First, _Count), _Count));
    return _First;
}

_EXPORT_STD template <class _ExPo, class _NoThrowFwdIt, class _Diff, _Enable_if_execution_policy_t<_ExPo> = 0>
_NoThrowFwdIt uninitialized_value_construct_n(
    _ExPo&& _Exec, _NoThrowFwdIt _First, _Diff _Count_raw) noexcept; // terminates

#if _HAS_CXX20
namespace ranges {
    class _Uninitialized_value_construct_n_fn {
    public:
        template <_No_throw_forward_iterator _It>
            requires default_initializable<iter_value_t<_It>>
        _STATIC_CALL_OPERATOR _It operator()(_It _First, iter_difference_t<_It> _Count) _CONST_CALL_OPERATOR {
            if (_Count <= 0) {
                return _First;
            }

            auto _UFirst = _STD _Get_unwrapped_n(_STD move(_First), _Count);
            if constexpr (_Use_memset_value_construct_v<_It>) {
                _STD _Seek_wrapped(_First, _STD _Zero_range(_UFirst, _UFirst + _Count));
            }
            else {
                _Uninitialized_backout _Backout{ _STD move(_UFirst) };

                for (; _Count > 0; --_Count) {
                    _Backout._Emplace_back();
                }

                _STD _Seek_wrapped(_First, _Backout._Release());
            }
            return _First;
        }
    };

    _EXPORT_STD inline constexpr _Uninitialized_value_construct_n_fn uninitialized_value_construct_n;
} // namespace ranges
#endif // _HAS_CXX20
#endif // _HAS_CXX17

#if _HAS_CXX20
template <class _PtrTy>
_NODISCARD void* _Voidify_unfancy(_PtrTy _Ptr) noexcept {
    if constexpr (is_pointer_v<_PtrTy>) {
        return _Ptr;
    }
    else {
        return _STD addressof(*_Ptr);
    }
}
#endif // _HAS_CXX20

#if _HAS_DEPRECATED_RAW_STORAGE_ITERATOR
_EXPORT_STD template <class _OutIt, class _Ty>
class _CXX17_DEPRECATE_RAW_STORAGE_ITERATOR raw_storage_iterator { // wrap stores to raw buffer as output iterator
public:
    using iterator_category = output_iterator_tag;
    using value_type = void;
#if _HAS_CXX20
    using difference_type = ptrdiff_t;
#else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
    using difference_type = void;
#endif // ^^^ !_HAS_CXX20 ^^^
    using pointer = void;
    using reference = void;

    explicit raw_storage_iterator(_OutIt _First) : _Next(_First) {}

    _NODISCARD raw_storage_iterator& operator*() { // pretend to return designated value
        return *this;
    }

    raw_storage_iterator& operator=(const _Ty& _Val) { // construct value designated by stored iterator
        _STD _Construct_in_place(const_cast<_Remove_cvref_t<decltype(*_Next)>&>(*_Next), _Val);
        return *this;
    }

    raw_storage_iterator& operator=(_Ty&& _Val) { // construct value designated by stored iterator
        _STD _Construct_in_place(const_cast<_Remove_cvref_t<decltype(*_Next)>&>(*_Next), _STD move(_Val));
        return *this;
    }

    raw_storage_iterator& operator++() {
        ++_Next;
        return *this;
    }

    raw_storage_iterator operator++(int) {
        raw_storage_iterator _Ans = *this;
        ++_Next;
        return _Ans;
    }

    _NODISCARD _OutIt base() const {
        return _Next;
    }

private:
    _OutIt _Next;
};
#endif // _HAS_DEPRECATED_RAW_STORAGE_ITERATOR

#if _HAS_AUTO_PTR_ETC
_EXPORT_STD template <class _Ty>
class auto_ptr;

_EXPORT_STD template <class _Ty>
struct auto_ptr_ref { // proxy reference for auto_ptr copying
    explicit auto_ptr_ref(_Ty* _Right) : _Ref(_Right) {}

    _Ty* _Ref; // generic pointer to auto_ptr ptr
};

_EXPORT_STD template <class _Ty>
class auto_ptr { // wrap an object pointer to ensure destruction
public:
    using element_type = _Ty;

    explicit auto_ptr(_Ty* _Ptr = nullptr) noexcept : _Myptr(_Ptr) {}

    auto_ptr(auto_ptr& _Right) noexcept : _Myptr(_Right.release()) {}

    auto_ptr(auto_ptr_ref<_Ty> _Right) noexcept {
        _Ty* _Ptr = _Right._Ref;
        _Right._Ref = nullptr; // release old
        _Myptr = _Ptr; // reset this
    }

    template <class _Other>
    operator auto_ptr<_Other>() noexcept { // convert to compatible auto_ptr
        return auto_ptr<_Other>(*this);
    }

    template <class _Other>
    operator auto_ptr_ref<_Other>() noexcept { // convert to compatible auto_ptr_ref
        _Other* _Cvtptr = _Myptr; // test implicit conversion
        auto_ptr_ref<_Other> _Ans(_Cvtptr);
        _Myptr = nullptr; // pass ownership to auto_ptr_ref
        return _Ans;
    }

    template <class _Other>
    auto_ptr& operator=(auto_ptr<_Other>& _Right) noexcept {
        reset(_Right.release());
        return *this;
    }

    template <class _Other>
    auto_ptr(auto_ptr<_Other>& _Right) noexcept : _Myptr(_Right.release()) {}

    auto_ptr& operator=(auto_ptr& _Right) noexcept {
        reset(_Right.release());
        return *this;
    }

    auto_ptr& operator=(auto_ptr_ref<_Ty> _Right) noexcept {
        _Ty* _Ptr = _Right._Ref;
        _Right._Ref = 0; // release old
        reset(_Ptr); // set new
        return *this;
    }

    ~auto_ptr() noexcept {
        delete _Myptr;
    }

    _NODISCARD _Ty& operator*() const noexcept {
#if _ITERATOR_DEBUG_LEVEL == 2
        _STL_VERIFY(_Myptr, "auto_ptr not dereferenceable");
#endif // _ITERATOR_DEBUG_LEVEL == 2

        return *get();
    }

    _NODISCARD _Ty* operator->() const noexcept {
#if _ITERATOR_DEBUG_LEVEL == 2
        _STL_VERIFY(_Myptr, "auto_ptr not dereferenceable");
#endif // _ITERATOR_DEBUG_LEVEL == 2

        return get();
    }

    _NODISCARD _Ty* get() const noexcept {
        return _Myptr;
    }

    _Ty* release() noexcept {
        _Ty* _Tmp = _Myptr;
        _Myptr = nullptr;
        return _Tmp;
    }

    void reset(_Ty* _Ptr = nullptr) noexcept { // destroy designated object and store new pointer
        if (_Ptr != _Myptr) {
            delete _Myptr;
        }

        _Myptr = _Ptr;
    }

private:
    _Ty* _Myptr; // the wrapped object pointer
};

template <>
class auto_ptr<void> {
public:
    using element_type = void;
};
#endif // _HAS_AUTO_PTR_ETC

_EXPORT_STD class bad_weak_ptr : public exception { // exception type for invalid use of expired weak_ptr object
public:
    bad_weak_ptr() noexcept {}

    _NODISCARD const char* __CLR_OR_THIS_CALL what() const noexcept override {
        // return pointer to message string
        return "bad_weak_ptr";
    }
};

[[noreturn]] inline void _Throw_bad_weak_ptr() {
    _THROW(bad_weak_ptr{});
}

class __declspec(novtable) _Ref_count_base { // common code for reference counting
private:
#ifdef _M_CEE_PURE
    // permanent workaround to avoid mentioning _purecall in msvcurt.lib, ptrustu.lib, or other support libs
    virtual void _Destroy() noexcept {
        _CSTD abort();
    }

    virtual void _Delete_this() noexcept {
        _CSTD abort();
    }
#else // ^^^ defined(_M_CEE_PURE) / !defined(_M_CEE_PURE) vvv
    virtual void _Destroy() noexcept = 0; // destroy managed resource
    virtual void _Delete_this() noexcept = 0; // destroy self
#endif // ^^^ !defined(_M_CEE_PURE) ^^^

    _Atomic_counter_t _Uses = 1;
    _Atomic_counter_t _Weaks = 1;

protected:
    constexpr _Ref_count_base() noexcept = default; // non-atomic initializations

public:
    _Ref_count_base(const _Ref_count_base&) = delete;
    _Ref_count_base& operator=(const _Ref_count_base&) = delete;

    virtual ~_Ref_count_base() noexcept {} // TRANSITION, should be non-virtual

    bool _Incref_nz() noexcept { // increment use count if not zero, return true if successful
        auto& _Volatile_uses = reinterpret_cast<volatile long&>(_Uses);
#ifdef _M_CEE_PURE
        long _Count = *_Atomic_address_as<const long>(&_Volatile_uses);
#else
        long _Count = __iso_volatile_load32(reinterpret_cast<volatile int*>(&_Volatile_uses));
#endif
        while (_Count != 0) {
            const long _Old_value = _INTRIN_RELAXED(_InterlockedCompareExchange)(&_Volatile_uses, _Count + 1, _Count);
            if (_Old_value == _Count) {
                return true;
            }

            _Count = _Old_value;
        }

        return false;
    }

    void _Incref() noexcept { // increment use count
        _MT_INCR(_Uses);
    }

    void _Incwref() noexcept { // increment weak reference count
        _MT_INCR(_Weaks);
    }

    void _Decref() noexcept { // decrement use count
        if (_MT_DECR(_Uses) == 0) {
            _Destroy();
            _Decwref();
        }
    }

    void _Decwref() noexcept { // decrement weak reference count
        if (_MT_DECR(_Weaks) == 0) {
            _Delete_this();
        }
    }

    long _Use_count() const noexcept {
        return static_cast<long>(_Uses);
    }

    virtual void* _Get_deleter(const type_info&) const noexcept {
        return nullptr;
    }
};

template <class _Ty>
class _Ref_count : public _Ref_count_base { // handle reference counting for pointer without deleter
public:
    explicit _Ref_count(_Ty* _Px) : _Ref_count_base(), _Ptr(_Px) {}

private:
    void _Destroy() noexcept override { // destroy managed resource
        delete _Ptr;
    }

    void _Delete_this() noexcept override { // destroy self
        delete this;
    }

    _Ty* _Ptr;
};

template <class _Resource, class _Dx>
class _Ref_count_resource : public _Ref_count_base { // handle reference counting for object with deleter
public:
    _Ref_count_resource(_Resource _Px, _Dx _Dt)
        : _Ref_count_base(), _Mypair(_One_then_variadic_args_t{}, _STD move(_Dt), _Px) {}

    ~_Ref_count_resource() noexcept override = default; // TRANSITION, should be non-virtual

    void* _Get_deleter(const type_info& _Typeid) const noexcept override {
#if _HAS_STATIC_RTTI
        if (_Typeid == typeid(_Dx)) {
            return const_cast<_Dx*>(_STD addressof(_Mypair._Get_first()));
        }
#else // ^^^ _HAS_STATIC_RTTI / !_HAS_STATIC_RTTI vvv
        (void)_Typeid;
#endif // ^^^ !_HAS_STATIC_RTTI ^^^

        return nullptr;
    }

private:
    void _Destroy() noexcept override { // destroy managed resource
        _Mypair._Get_first()(_Mypair._Myval2);
    }

    void _Delete_this() noexcept override { // destroy self
        delete this;
    }

    _Compressed_pair<_Dx, _Resource> _Mypair;
};

template <class _Resource, class _Dx, class _Alloc>
class _Ref_count_resource_alloc : public _Ref_count_base {
    // handle reference counting for object with deleter and allocator
public:
    _Ref_count_resource_alloc(_Resource _Px, _Dx _Dt, const _Alloc& _Ax)
        : _Ref_count_base(),
        _Mypair(_One_then_variadic_args_t{}, _STD move(_Dt), _One_then_variadic_args_t{}, _Ax, _Px) {}

    ~_Ref_count_resource_alloc() noexcept override = default; // TRANSITION, should be non-virtual

    void* _Get_deleter(const type_info& _Typeid) const noexcept override {
#if _HAS_STATIC_RTTI
        if (_Typeid == typeid(_Dx)) {
            return const_cast<_Dx*>(_STD addressof(_Mypair._Get_first()));
        }
#else // ^^^ _HAS_STATIC_RTTI / !_HAS_STATIC_RTTI vvv
        (void)_Typeid;
#endif // ^^^ !_HAS_STATIC_RTTI ^^^

        return nullptr;
    }

private:
    using _Myalty = _Rebind_alloc_t<_Alloc, _Ref_count_resource_alloc>;

    void _Destroy() noexcept override { // destroy managed resource
        _Mypair._Get_first()(_Mypair._Myval2._Myval2);
    }

    void _Delete_this() noexcept override { // destroy self
        _Myalty _Al = _Mypair._Myval2._Get_first();
        this->~_Ref_count_resource_alloc();
        _STD _Deallocate_plain(_Al, this);
    }

    _Compressed_pair<_Dx, _Compressed_pair<_Myalty, _Resource>> _Mypair;
};

_EXPORT_STD template <class _Ty>
struct default_delete;

_EXPORT_STD template <class _Ty, class _Dx = default_delete<_Ty>>
class unique_ptr;

_EXPORT_STD template <class _Ty>
class shared_ptr;

_EXPORT_STD template <class _Ty>
class weak_ptr;

template <class _Yty, class = void>
struct _Can_enable_shared : false_type {}; // detect unambiguous and accessible inheritance from enable_shared_from_this

template <class _Yty>
struct _Can_enable_shared<_Yty, void_t<typename _Yty::_Esft_type>>
    : is_convertible<remove_cv_t<_Yty>*, typename _Yty::_Esft_type*>::type {
    // is_convertible is necessary to verify unambiguous inheritance
};

struct _Exception_ptr_access;

template <class _Ty>
class _Ptr_base { // base class for shared_ptr and weak_ptr
public:
    using element_type = remove_extent_t<_Ty>;

    _NODISCARD long use_count() const noexcept {
        return _Rep ? _Rep->_Use_count() : 0;
    }

    template <class _Ty2>
    _NODISCARD bool owner_before(const _Ptr_base<_Ty2>& _Right) const noexcept { // compare addresses of manager objects
        return _Rep < _Right._Rep;
    }

    _Ptr_base(const _Ptr_base&) = delete;
    _Ptr_base& operator=(const _Ptr_base&) = delete;

protected:
    _NODISCARD element_type* get() const noexcept {
        return _Ptr;
    }

    constexpr _Ptr_base() noexcept = default;

    ~_Ptr_base() = default;

    template <class _Ty2>
    void _Move_construct_from(_Ptr_base<_Ty2>&& _Right) noexcept {
        // implement shared_ptr's (converting) move ctor and weak_ptr's move ctor
        _Ptr = _Right._Ptr;
        _Rep = _Right._Rep;

        _Right._Ptr = nullptr;
        _Right._Rep = nullptr;
    }

    template <class _Ty2>
    void _Copy_construct_from(const shared_ptr<_Ty2>& _Other) noexcept {
        // implement shared_ptr's (converting) copy ctor
        _Other._Incref();

        _Ptr = _Other._Ptr;
        _Rep = _Other._Rep;
    }

    template <class _Ty2>
    void _Alias_construct_from(const shared_ptr<_Ty2>& _Other, element_type* _Px) noexcept {
        // implement shared_ptr's aliasing ctor
        _Other._Incref();

        _Ptr = _Px;
        _Rep = _Other._Rep;
    }

    template <class _Ty2>
    void _Alias_move_construct_from(shared_ptr<_Ty2>&& _Other, element_type* _Px) noexcept {
        // implement shared_ptr's aliasing move ctor
        _Ptr = _Px;
        _Rep = _Other._Rep;

        _Other._Ptr = nullptr;
        _Other._Rep = nullptr;
    }

    template <class _Ty0>
    friend class weak_ptr; // specifically, weak_ptr::lock()

    template <class _Ty2>
    bool _Construct_from_weak(const weak_ptr<_Ty2>& _Other) noexcept {
        // implement shared_ptr's ctor from weak_ptr, and weak_ptr::lock()
        if (_Other._Rep && _Other._Rep->_Incref_nz()) {
            _Ptr = _Other._Ptr;
            _Rep = _Other._Rep;
            return true;
        }

        return false;
    }

    void _Incref() const noexcept {
        if (_Rep) {
            _Rep->_Incref();
        }
    }

    void _Decref() noexcept { // decrement reference count
        if (_Rep) {
            _Rep->_Decref();
        }
    }

    void _Swap(_Ptr_base& _Right) noexcept { // swap pointers
        _STD swap(_Ptr, _Right._Ptr);
        _STD swap(_Rep, _Right._Rep);
    }

    template <class _Ty2>
    void _Weakly_construct_from(const _Ptr_base<_Ty2>& _Other) noexcept { // implement weak_ptr's ctors
        if (_Other._Rep) {
            _Ptr = _Other._Ptr;
            _Rep = _Other._Rep;
            _Rep->_Incwref();
        }
        else {
            _STL_INTERNAL_CHECK(!_Ptr && !_Rep);
        }
    }

    template <class _Ty2>
    void _Weakly_convert_lvalue_avoiding_expired_conversions(const _Ptr_base<_Ty2>& _Other) noexcept {
        // implement weak_ptr's copy converting ctor
        if (_Other._Rep) {
            _Rep = _Other._Rep; // always share ownership
            _Rep->_Incwref();

            if (_Rep->_Incref_nz()) {
                _Ptr = _Other._Ptr; // keep resource alive during conversion, handling virtual inheritance
                _Rep->_Decref();
            }
            else {
                _STL_INTERNAL_CHECK(!_Ptr);
            }
        }
        else {
            _STL_INTERNAL_CHECK(!_Ptr && !_Rep);
        }
    }

    template <class _Ty2>
    void _Weakly_convert_rvalue_avoiding_expired_conversions(_Ptr_base<_Ty2>&& _Other) noexcept {
        // implement weak_ptr's move converting ctor
        _Rep = _Other._Rep; // always transfer ownership
        _Other._Rep = nullptr;

        if (_Rep && _Rep->_Incref_nz()) {
            _Ptr = _Other._Ptr; // keep resource alive during conversion, handling virtual inheritance
            _Rep->_Decref();
        }
        else {
            _STL_INTERNAL_CHECK(!_Ptr);
        }

        _Other._Ptr = nullptr;
    }

    void _Incwref() const noexcept {
        if (_Rep) {
            _Rep->_Incwref();
        }
    }

    void _Decwref() noexcept { // decrement weak reference count
        if (_Rep) {
            _Rep->_Decwref();
        }
    }

private:
    element_type* _Ptr{ nullptr };
    _Ref_count_base* _Rep{ nullptr };

    template <class _Ty0>
    friend class _Ptr_base;

    friend shared_ptr<_Ty>;

    template <class _Ty0>
    friend struct atomic;

    friend _Exception_ptr_access;

#if _HAS_STATIC_RTTI
    template <class _Dx, class _Ty0>
    friend _Dx* get_deleter(const shared_ptr<_Ty0>& _Sx) noexcept;
#endif // _HAS_STATIC_RTTI
};

template <class _Yty, class = void>
struct _Can_scalar_delete : false_type {};
template <class _Yty>
struct _Can_scalar_delete<_Yty, void_t<decltype(delete _STD declval<_Yty*>())>> : bool_constant<!is_void_v<_Yty>> {};

template <class _Yty, class = void>
struct _Can_array_delete : false_type {};
template <class _Yty>
struct _Can_array_delete<_Yty, void_t<decltype(delete[] _STD declval<_Yty*>())>> : true_type {};

template <class _Fx, class _Arg, class = void>
struct _Can_call_function_object : false_type {};
template <class _Fx, class _Arg>
struct _Can_call_function_object<_Fx, _Arg, void_t<decltype(_STD declval<_Fx>()(_STD declval<_Arg>()))>> : true_type {};

template <class _Yty, class _Ty, class = void>
struct _SP_convertible : is_convertible<_Yty*, _Ty*>::type {};

template <class _Yty, class _Uty, class _Void>
struct _SP_convertible<_Yty, _Uty[], _Void> : false_type {};
template <class _Yty, class _Uty>
struct _SP_convertible<_Yty, _Uty[], void_t<_Yty(*)[]>> : is_convertible<_Yty(*)[], _Uty(*)[]>::type {};

template <class _Yty, class _Uty, size_t _Ext, class _Void>
struct _SP_convertible<_Yty, _Uty[_Ext], _Void> : false_type {};
template <class _Yty, class _Uty, size_t _Ext>
struct _SP_convertible<_Yty, _Uty[_Ext], void_t<_Yty(*)[_Ext]>>
    : is_convertible<_Yty(*)[_Ext], _Uty(*)[_Ext]>::type {};

template <class _Yty, class _Ty>
struct _SP_pointer_compatible : is_convertible<_Yty*, _Ty*>::type {
    // N4950 [util.smartptr.shared.general]/6 "a pointer type Y* is said to be compatible
    // with a pointer type T* when either Y* is convertible to T* ..."
};
template <class _Uty, size_t _Ext>
struct _SP_pointer_compatible<_Uty[_Ext], _Uty[]> : true_type {
    // N4950 [util.smartptr.shared.general]/6 "... or Y is U[N] and T is cv U[]."
};
template <class _Uty, size_t _Ext>
struct _SP_pointer_compatible<_Uty[_Ext], const _Uty[]> : true_type {
    // N4950 [util.smartptr.shared.general]/6 "... or Y is U[N] and T is cv U[]."
};
template <class _Uty, size_t _Ext>
struct _SP_pointer_compatible<_Uty[_Ext], volatile _Uty[]> : true_type {
    // N4950 [util.smartptr.shared.general]/6 "... or Y is U[N] and T is cv U[]."
};
template <class _Uty, size_t _Ext>
struct _SP_pointer_compatible<_Uty[_Ext], const volatile _Uty[]> : true_type {
    // N4950 [util.smartptr.shared.general]/6 "... or Y is U[N] and T is cv U[]."
};

template <class _Ux>
struct _Temporary_owner {
    _Ux* _Ptr;

    explicit _Temporary_owner(_Ux* const _Ptr_) noexcept : _Ptr(_Ptr_) {}
    _Temporary_owner(const _Temporary_owner&) = delete;
    _Temporary_owner& operator=(const _Temporary_owner&) = delete;
    ~_Temporary_owner() {
        delete _Ptr;
    }
};

template <class _UxptrOrNullptr, class _Dx>
struct _Temporary_owner_del {
    _UxptrOrNullptr _Ptr;
    _Dx& _Dt;
    bool _Call_deleter = true;

    explicit _Temporary_owner_del(const _UxptrOrNullptr _Ptr_, _Dx& _Dt_) noexcept : _Ptr(_Ptr_), _Dt(_Dt_) {}
    _Temporary_owner_del(const _Temporary_owner_del&) = delete;
    _Temporary_owner_del& operator=(const _Temporary_owner_del&) = delete;
    ~_Temporary_owner_del() {
        if (_Call_deleter) {
            _Dt(_Ptr);
        }
    }
};

_EXPORT_STD template <class _Ty>
class shared_ptr : public _Ptr_base<_Ty> { // class for reference counted resource management
private:
    using _Mybase = _Ptr_base<_Ty>;

public:
    using typename _Mybase::element_type;

#if _HAS_CXX17
    using weak_type = weak_ptr<_Ty>;
#endif // _HAS_CXX17

    constexpr shared_ptr() noexcept = default;

    constexpr shared_ptr(nullptr_t) noexcept {} // construct empty shared_ptr

    template <class _Ux,
        enable_if_t<conjunction_v<conditional_t<is_array_v<_Ty>, _Can_array_delete<_Ux>, _Can_scalar_delete<_Ux>>,
        _SP_convertible<_Ux, _Ty>>,
        int> = 0>
        explicit shared_ptr(_Ux* _Px) { // construct shared_ptr object that owns _Px
        if constexpr (is_array_v<_Ty>) {
            _Setpd(_Px, default_delete<_Ux[]>{});
        }
        else {
            _Temporary_owner<_Ux> _Owner(_Px);
            _Set_ptr_rep_and_enable_shared(_Owner._Ptr, new _Ref_count<_Ux>(_Owner._Ptr));
            _Owner._Ptr = nullptr;
        }
    }

    template <class _Ux, class _Dx,
        enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx&, _Ux*&>,
        _SP_convertible<_Ux, _Ty>>,
        int> = 0>
        shared_ptr(_Ux* _Px, _Dx _Dt) { // construct with _Px, deleter
        _Setpd(_Px, _STD move(_Dt));
    }

    template <class _Ux, class _Dx, class _Alloc,
        enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx&, _Ux*&>,
        _SP_convertible<_Ux, _Ty>>,
        int> = 0>
        shared_ptr(_Ux* _Px, _Dx _Dt, _Alloc _Ax) { // construct with _Px, deleter, allocator
        _Setpda(_Px, _STD move(_Dt), _Ax);
    }

    template <class _Dx,
        enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx&, nullptr_t&>>, int> = 0>
    shared_ptr(nullptr_t, _Dx _Dt) { // construct with nullptr, deleter
        _Setpd(nullptr, _STD move(_Dt));
    }

    template <class _Dx, class _Alloc,
        enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx&, nullptr_t&>>, int> = 0>
    shared_ptr(nullptr_t, _Dx _Dt, _Alloc _Ax) { // construct with nullptr, deleter, allocator
        _Setpda(nullptr, _STD move(_Dt), _Ax);
    }

    template <class _Ty2>
    shared_ptr(const shared_ptr<_Ty2>& _Right, element_type* _Px) noexcept {
        // construct shared_ptr object that aliases _Right
        this->_Alias_construct_from(_Right, _Px);
    }

    template <class _Ty2>
    shared_ptr(shared_ptr<_Ty2>&& _Right, element_type* _Px) noexcept {
        // move construct shared_ptr object that aliases _Right
        this->_Alias_move_construct_from(_STD move(_Right), _Px);
    }

    shared_ptr(const shared_ptr& _Other) noexcept { // construct shared_ptr object that owns same resource as _Other
        this->_Copy_construct_from(_Other);
    }

    template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
    shared_ptr(const shared_ptr<_Ty2>& _Other) noexcept {
        // construct shared_ptr object that owns same resource as _Other
        this->_Copy_construct_from(_Other);
    }

    shared_ptr(shared_ptr&& _Right) noexcept { // construct shared_ptr object that takes resource from _Right
        this->_Move_construct_from(_STD move(_Right));
    }

    template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
    shared_ptr(shared_ptr<_Ty2>&& _Right) noexcept { // construct shared_ptr object that takes resource from _Right
        this->_Move_construct_from(_STD move(_Right));
    }

    template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
    explicit shared_ptr(const weak_ptr<_Ty2>& _Other) { // construct shared_ptr object that owns resource *_Other
        if (!this->_Construct_from_weak(_Other)) {
            _Throw_bad_weak_ptr();
        }
    }

#if _HAS_AUTO_PTR_ETC
    template <class _Ty2, enable_if_t<is_convertible_v<_Ty2*, _Ty*>, int> = 0>
    shared_ptr(auto_ptr<_Ty2>&& _Other) { // construct shared_ptr object that owns *_Other.get()
        _Ty2* _Px = _Other.get();
        _Set_ptr_rep_and_enable_shared(_Px, new _Ref_count<_Ty2>(_Px));
        _Other.release();
    }
#endif // _HAS_AUTO_PTR_ETC

    template <class _Ux, class _Dx,
        enable_if_t<conjunction_v<_SP_pointer_compatible<_Ux, _Ty>,
        is_convertible<typename unique_ptr<_Ux, _Dx>::pointer, element_type*>>,
        int> = 0>
        shared_ptr(unique_ptr<_Ux, _Dx>&& _Other) {
        using _Fancy_t = typename unique_ptr<_Ux, _Dx>::pointer;
        using _Raw_t = typename unique_ptr<_Ux, _Dx>::element_type*;
        using _Deleter_t = conditional_t<is_reference_v<_Dx>, decltype(_STD ref(_Other.get_deleter())), _Dx>;

        const _Fancy_t _Fancy = _Other.get();

        if (_Fancy) {
            const _Raw_t _Raw = _Fancy;
            const auto _Rx =
                new _Ref_count_resource<_Fancy_t, _Deleter_t>(_Fancy, _STD forward<_Dx>(_Other.get_deleter()));
            _Set_ptr_rep_and_enable_shared(_Raw, _Rx);
            _Other.release();
        }
    }

    ~shared_ptr() noexcept { // release resource
        this->_Decref();
    }

    shared_ptr& operator=(const shared_ptr& _Right) noexcept {
        shared_ptr(_Right).swap(*this);
        return *this;
    }

    template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
    shared_ptr& operator=(const shared_ptr<_Ty2>& _Right) noexcept {
        shared_ptr(_Right).swap(*this);
        return *this;
    }

    shared_ptr& operator=(shared_ptr&& _Right) noexcept { // take resource from _Right
        shared_ptr(_STD move(_Right)).swap(*this);
        return *this;
    }

    template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
    shared_ptr& operator=(shared_ptr<_Ty2>&& _Right) noexcept { // take resource from _Right
        shared_ptr(_STD move(_Right)).swap(*this);
        return *this;
    }

#if _HAS_AUTO_PTR_ETC
    template <class _Ty2, enable_if_t<is_convertible_v<_Ty2*, _Ty*>, int> = 0>
    shared_ptr& operator=(auto_ptr<_Ty2>&& _Right) {
        shared_ptr(_STD move(_Right)).swap(*this);
        return *this;
    }
#endif // _HAS_AUTO_PTR_ETC

    template <class _Ux, class _Dx,
        enable_if_t<conjunction_v<_SP_pointer_compatible<_Ux, _Ty>,
        is_convertible<typename unique_ptr<_Ux, _Dx>::pointer, element_type*>>,
        int> = 0>
        shared_ptr& operator=(unique_ptr<_Ux, _Dx>&& _Right) { // move from unique_ptr
        shared_ptr(_STD move(_Right)).swap(*this);
        return *this;
    }

    void swap(shared_ptr& _Other) noexcept {
        this->_Swap(_Other);
    }

    void reset() noexcept { // release resource and convert to empty shared_ptr object
        shared_ptr().swap(*this);
    }

    template <class _Ux,
        enable_if_t<conjunction_v<conditional_t<is_array_v<_Ty>, _Can_array_delete<_Ux>, _Can_scalar_delete<_Ux>>,
        _SP_convertible<_Ux, _Ty>>,
        int> = 0>
        void reset(_Ux* _Px) { // release, take ownership of _Px
        shared_ptr(_Px).swap(*this);
    }

    template <class _Ux, class _Dx,
        enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx&, _Ux*&>,
        _SP_convertible<_Ux, _Ty>>,
        int> = 0>
        void reset(_Ux* _Px, _Dx _Dt) { // release, take ownership of _Px, with deleter _Dt
        shared_ptr(_Px, _Dt).swap(*this);
    }

    template <class _Ux, class _Dx, class _Alloc,
        enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx&, _Ux*&>,
        _SP_convertible<_Ux, _Ty>>,
        int> = 0>
        void reset(_Ux* _Px, _Dx _Dt, _Alloc _Ax) { // release, take ownership of _Px, with deleter _Dt, allocator _Ax
        shared_ptr(_Px, _Dt, _Ax).swap(*this);
    }

    using _Mybase::get;

    template <class _Ty2 = _Ty, enable_if_t<!disjunction_v<is_array<_Ty2>, is_void<_Ty2>>, int> = 0>
    _NODISCARD _Ty2& operator*() const noexcept {
        return *get();
    }

    template <class _Ty2 = _Ty, enable_if_t<!is_array_v<_Ty2>, int> = 0>
    _NODISCARD _Ty2* operator->() const noexcept {
        return get();
    }

    template <class _Ty2 = _Ty, class _Elem = element_type, enable_if_t<is_array_v<_Ty2>, int> = 0>
    _NODISCARD _Elem& operator[](ptrdiff_t _Idx) const noexcept /* strengthened */ {
        return get()[_Idx];
    }

#if _HAS_DEPRECATED_SHARED_PTR_UNIQUE
    _CXX17_DEPRECATE_SHARED_PTR_UNIQUE _NODISCARD bool unique() const noexcept {
        // return true if no other shared_ptr object owns this resource
        return this->use_count() == 1;
    }
#endif // _HAS_DEPRECATED_SHARED_PTR_UNIQUE

    explicit operator bool() const noexcept {
        return get() != nullptr;
    }

private:
    template <class _UxptrOrNullptr, class _Dx>
    void _Setpd(const _UxptrOrNullptr _Px, _Dx _Dt) { // take ownership of _Px, deleter _Dt
        _Temporary_owner_del<_UxptrOrNullptr, _Dx> _Owner(_Px, _Dt);
        _Set_ptr_rep_and_enable_shared(
            _Owner._Ptr, new _Ref_count_resource<_UxptrOrNullptr, _Dx>(_Owner._Ptr, _STD move(_Dt)));
        _Owner._Call_deleter = false;
    }

    template <class _UxptrOrNullptr, class _Dx, class _Alloc>
    void _Setpda(const _UxptrOrNullptr _Px, _Dx _Dt, _Alloc _Ax) { // take ownership of _Px, deleter _Dt, allocator _Ax
        using _Alref_alloc = _Rebind_alloc_t<_Alloc, _Ref_count_resource_alloc<_UxptrOrNullptr, _Dx, _Alloc>>;

        _Temporary_owner_del<_UxptrOrNullptr, _Dx> _Owner(_Px, _Dt);
        _Alref_alloc _Alref(_Ax);
        _Alloc_construct_ptr<_Alref_alloc> _Constructor(_Alref);
        _Constructor._Allocate();
        _STD _Construct_in_place(*_Constructor._Ptr, _Owner._Ptr, _STD move(_Dt), _Ax);
        _Set_ptr_rep_and_enable_shared(_Owner._Ptr, _STD _Unfancy(_Constructor._Ptr));
        _Constructor._Ptr = nullptr;
        _Owner._Call_deleter = false;
    }

#if _HAS_CXX20
    template <class _Ty0, class... _Types>
    friend enable_if_t<!is_array_v<_Ty0>, shared_ptr<_Ty0>> make_shared(_Types&&... _Args);

    template <class _Ty0, class _Alloc, class... _Types>
    friend enable_if_t<!is_array_v<_Ty0>, shared_ptr<_Ty0>> allocate_shared(const _Alloc& _Al_arg, _Types&&... _Args);

    template <class _Ty0>
    friend enable_if_t<is_bounded_array_v<_Ty0>, shared_ptr<_Ty0>> make_shared();

    template <class _Ty0, class _Alloc>
    friend enable_if_t<is_bounded_array_v<_Ty0>, shared_ptr<_Ty0>> allocate_shared(const _Alloc& _Al_arg);

    template <class _Ty0>
    friend enable_if_t<is_bounded_array_v<_Ty0>, shared_ptr<_Ty0>> make_shared(const remove_extent_t<_Ty0>& _Val);

    template <class _Ty0, class _Alloc>
    friend enable_if_t<is_bounded_array_v<_Ty0>, shared_ptr<_Ty0>> allocate_shared(
        const _Alloc& _Al_arg, const remove_extent_t<_Ty0>& _Val);

    template <class _Ty0>
    friend enable_if_t<!is_unbounded_array_v<_Ty0>, shared_ptr<_Ty0>> make_shared_for_overwrite();

    template <class _Ty0, class _Alloc>
    friend enable_if_t<!is_unbounded_array_v<_Ty0>, shared_ptr<_Ty0>> allocate_shared_for_overwrite(
        const _Alloc& _Al_arg);

    template <class _Ty0, class... _ArgTypes>
    friend shared_ptr<_Ty0> _Make_shared_unbounded_array(size_t _Count, const _ArgTypes&... _Args);

    template <bool _IsForOverwrite, class _Ty0, class _Alloc, class... _ArgTypes>
    friend shared_ptr<_Ty0> _Allocate_shared_unbounded_array(
        const _Alloc& _Al, size_t _Count, const _ArgTypes&... _Args);
#else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
    template <class _Ty0, class... _Types>
    friend shared_ptr<_Ty0> make_shared(_Types&&... _Args);

    template <class _Ty0, class _Alloc, class... _Types>
    friend shared_ptr<_Ty0> allocate_shared(const _Alloc& _Al_arg, _Types&&... _Args);
#endif // ^^^ !_HAS_CXX20 ^^^

    template <class _Ux>
    void _Set_ptr_rep_and_enable_shared(_Ux* const _Px, _Ref_count_base* const _Rx) noexcept { // take ownership of _Px
        this->_Ptr = _Px;
        this->_Rep = _Rx;
        if constexpr (conjunction_v<negation<is_array<_Ty>>, negation<is_volatile<_Ux>>, _Can_enable_shared<_Ux>>) {
            if (_Px && _Px->_Wptr.expired()) {
                _Px->_Wptr = shared_ptr<remove_cv_t<_Ux>>(*this, const_cast<remove_cv_t<_Ux>*>(_Px));
            }
        }
    }

    void _Set_ptr_rep_and_enable_shared(nullptr_t, _Ref_count_base* const _Rx) noexcept { // take ownership of nullptr
        this->_Ptr = nullptr;
        this->_Rep = _Rx;
    }
};

#if _HAS_CXX17
template <class _Ty>
shared_ptr(weak_ptr<_Ty>) -> shared_ptr<_Ty>;

template <class _Ty, class _Dx>
shared_ptr(unique_ptr<_Ty, _Dx>) -> shared_ptr<_Ty>;
#endif // _HAS_CXX17

_EXPORT_STD template <class _Ty1, class _Ty2>
_NODISCARD bool operator==(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) noexcept {
    return _Left.get() == _Right.get();
}

#if _HAS_CXX20
_EXPORT_STD template <class _Ty1, class _Ty2>
_NODISCARD strong_ordering operator<=>(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) noexcept {
    return _Left.get() <=> _Right.get();
}
#else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
template <class _Ty1, class _Ty2>
_NODISCARD bool operator!=(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) noexcept {
    return _Left.get() != _Right.get();
}

template <class _Ty1, class _Ty2>
_NODISCARD bool operator<(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) noexcept {
    return _Left.get() < _Right.get();
}

template <class _Ty1, class _Ty2>
_NODISCARD bool operator>=(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) noexcept {
    return _Left.get() >= _Right.get();
}

template <class _Ty1, class _Ty2>
_NODISCARD bool operator>(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) noexcept {
    return _Left.get() > _Right.get();
}

template <class _Ty1, class _Ty2>
_NODISCARD bool operator<=(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) noexcept {
    return _Left.get() <= _Right.get();
}
#endif // ^^^ !_HAS_CXX20 ^^^

_EXPORT_STD template <class _Ty>
_NODISCARD bool operator==(const shared_ptr<_Ty>& _Left, nullptr_t) noexcept {
    return _Left.get() == nullptr;
}

#if _HAS_CXX20
_EXPORT_STD template <class _Ty>
_NODISCARD strong_ordering operator<=>(const shared_ptr<_Ty>& _Left, nullptr_t) noexcept {
    return _Left.get() <=> static_cast<shared_ptr<_Ty>::element_type*>(nullptr);
}
#else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
template <class _Ty>
_NODISCARD bool operator==(nullptr_t, const shared_ptr<_Ty>& _Right) noexcept {
    return nullptr == _Right.get();
}

template <class _Ty>
_NODISCARD bool operator!=(const shared_ptr<_Ty>& _Left, nullptr_t) noexcept {
    return _Left.get() != nullptr;
}

template <class _Ty>
_NODISCARD bool operator!=(nullptr_t, const shared_ptr<_Ty>& _Right) noexcept {
    return nullptr != _Right.get();
}

template <class _Ty>
_NODISCARD bool operator<(const shared_ptr<_Ty>& _Left, nullptr_t) noexcept {
    return _Left.get() < static_cast<typename shared_ptr<_Ty>::element_type*>(nullptr);
}

template <class _Ty>
_NODISCARD bool operator<(nullptr_t, const shared_ptr<_Ty>& _Right) noexcept {
    return static_cast<typename shared_ptr<_Ty>::element_type*>(nullptr) < _Right.get();
}

template <class _Ty>
_NODISCARD bool operator>=(const shared_ptr<_Ty>& _Left, nullptr_t) noexcept {
    return _Left.get() >= static_cast<typename shared_ptr<_Ty>::element_type*>(nullptr);
}

template <class _Ty>
_NODISCARD bool operator>=(nullptr_t, const shared_ptr<_Ty>& _Right) noexcept {
    return static_cast<typename shared_ptr<_Ty>::element_type*>(nullptr) >= _Right.get();
}

template <class _Ty>
_NODISCARD bool operator>(const shared_ptr<_Ty>& _Left, nullptr_t) noexcept {
    return _Left.get() > static_cast<typename shared_ptr<_Ty>::element_type*>(nullptr);
}

template <class _Ty>
_NODISCARD bool operator>(nullptr_t, const shared_ptr<_Ty>& _Right) noexcept {
    return static_cast<typename shared_ptr<_Ty>::element_type*>(nullptr) > _Right.get();
}

template <class _Ty>
_NODISCARD bool operator<=(const shared_ptr<_Ty>& _Left, nullptr_t) noexcept {
    return _Left.get() <= static_cast<typename shared_ptr<_Ty>::element_type*>(nullptr);
}

template <class _Ty>
_NODISCARD bool operator<=(nullptr_t, const shared_ptr<_Ty>& _Right) noexcept {
    return static_cast<typename shared_ptr<_Ty>::element_type*>(nullptr) <= _Right.get();
}
#endif // ^^^ !_HAS_CXX20 ^^^

_EXPORT_STD template <class _Elem, class _Traits, class _Ty>
basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Out, const shared_ptr<_Ty>& _Px) {
    // write contained pointer to stream
    return _Out << _Px.get();
}

_EXPORT_STD template <class _Ty>
void swap(shared_ptr<_Ty>& _Left, shared_ptr<_Ty>& _Right) noexcept {
    _Left.swap(_Right);
}

_EXPORT_STD template <class _Ty1, class _Ty2>
_NODISCARD shared_ptr<_Ty1> static_pointer_cast(const shared_ptr<_Ty2>& _Other) noexcept {
    // static_cast for shared_ptr that properly respects the reference count control block
    const auto _Ptr = static_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());
    return shared_ptr<_Ty1>(_Other, _Ptr);
}

_EXPORT_STD template <class _Ty1, class _Ty2>
_NODISCARD shared_ptr<_Ty1> static_pointer_cast(shared_ptr<_Ty2>&& _Other) noexcept {
    // static_cast for shared_ptr that properly respects the reference count control block
    const auto _Ptr = static_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());
    return shared_ptr<_Ty1>(_STD move(_Other), _Ptr);
}

_EXPORT_STD template <class _Ty1, class _Ty2>
_NODISCARD shared_ptr<_Ty1> const_pointer_cast(const shared_ptr<_Ty2>& _Other) noexcept {
    // const_cast for shared_ptr that properly respects the reference count control block
    const auto _Ptr = const_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());
    return shared_ptr<_Ty1>(_Other, _Ptr);
}

_EXPORT_STD template <class _Ty1, class _Ty2>
_NODISCARD shared_ptr<_Ty1> const_pointer_cast(shared_ptr<_Ty2>&& _Other) noexcept {
    // const_cast for shared_ptr that properly respects the reference count control block
    const auto _Ptr = const_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());
    return shared_ptr<_Ty1>(_STD move(_Other), _Ptr);
}

_EXPORT_STD template <class _Ty1, class _Ty2>
_NODISCARD shared_ptr<_Ty1> reinterpret_pointer_cast(const shared_ptr<_Ty2>& _Other) noexcept {
    // reinterpret_cast for shared_ptr that properly respects the reference count control block
    const auto _Ptr = reinterpret_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());
    return shared_ptr<_Ty1>(_Other, _Ptr);
}

_EXPORT_STD template <class _Ty1, class _Ty2>
_NODISCARD shared_ptr<_Ty1> reinterpret_pointer_cast(shared_ptr<_Ty2>&& _Other) noexcept {
    // reinterpret_cast for shared_ptr that properly respects the reference count control block
    const auto _Ptr = reinterpret_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());
    return shared_ptr<_Ty1>(_STD move(_Other), _Ptr);
}

#ifdef _CPPRTTI
_EXPORT_STD template <class _Ty1, class _Ty2>
_NODISCARD shared_ptr<_Ty1> dynamic_pointer_cast(const shared_ptr<_Ty2>& _Other) noexcept {
    // dynamic_cast for shared_ptr that properly respects the reference count control block
    const auto _Ptr = dynamic_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());

    if (_Ptr) {
        return shared_ptr<_Ty1>(_Other, _Ptr);
    }

    return {};
}

_EXPORT_STD template <class _Ty1, class _Ty2>
_NODISCARD shared_ptr<_Ty1> dynamic_pointer_cast(shared_ptr<_Ty2>&& _Other) noexcept {
    // dynamic_cast for shared_ptr that properly respects the reference count control block
    const auto _Ptr = dynamic_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());

    if (_Ptr) {
        return shared_ptr<_Ty1>(_STD move(_Other), _Ptr);
    }

    return {};
}
#else // ^^^ defined(_CPPRTTI) / !defined(_CPPRTTI) vvv
_EXPORT_STD template <class _Ty1, class _Ty2>
shared_ptr<_Ty1> dynamic_pointer_cast(const shared_ptr<_Ty2>&) noexcept = delete; // requires /GR option
_EXPORT_STD template <class _Ty1, class _Ty2>
shared_ptr<_Ty1> dynamic_pointer_cast(shared_ptr<_Ty2>&&) noexcept = delete; // requires /GR option
#endif // ^^^ !defined(_CPPRTTI) ^^^

#if _HAS_STATIC_RTTI
_EXPORT_STD template <class _Dx, class _Ty>
_NODISCARD _Dx* get_deleter(const shared_ptr<_Ty>& _Sx) noexcept {
    // return pointer to shared_ptr's deleter object if its type is _Dx
    if (_Sx._Rep) {
        return static_cast<_Dx*>(_Sx._Rep->_Get_deleter(typeid(_Dx)));
    }

    return nullptr;
}
#else // ^^^ _HAS_STATIC_RTTI / !_HAS_STATIC_RTTI vvv
_EXPORT_STD template <class _Dx, class _Ty>
_Dx* get_deleter(const shared_ptr<_Ty>&) noexcept = delete; // requires static RTTI
#endif // ^^^ !_HAS_STATIC_RTTI ^^^

#if _HAS_CXX20
struct _For_overwrite_tag {
    explicit _For_overwrite_tag() = default;
};
#endif // _HAS_CXX20

template <class _Ty>
class _Ref_count_obj2 : public _Ref_count_base { // handle reference counting for object in control block, no allocator
public:
    template <class... _Types>
    explicit _Ref_count_obj2(_Types&&... _Args) : _Ref_count_base() {
#if _HAS_CXX20
        if constexpr (sizeof...(_Types) == 1 && (is_same_v<_For_overwrite_tag, remove_cvref_t<_Types>> && ...)) {
            _STD _Default_construct_in_place(_Storage._Value);
            ((void)_Args, ...);
        }
        else
#endif // _HAS_CXX20
        {
            _STD _Construct_in_place(_Storage._Value, _STD forward<_Types>(_Args)...);
        }
    }

    ~_Ref_count_obj2() noexcept override { // TRANSITION, should be non-virtual
        // nothing to do, _Storage._Value was already destroyed in _Destroy

        // N4950 [class.dtor]/7:
        // "A defaulted destructor for a class X is defined as deleted if:
        // X is a union-like class that has a variant member with a non-trivial destructor"
    }

    union {
        _Wrap<remove_cv_t<_Ty>> _Storage;
    };

private:
    void _Destroy() noexcept override { // destroy managed resource
        _STD _Destroy_in_place(_Storage._Value);
    }

    void _Delete_this() noexcept override { // destroy self
        delete this;
    }
};

#if _HAS_CXX20
template <size_t _Align>
struct _Alignas_storage_unit {
    alignas(_Align) char _Space[_Align];
};

enum class _Check_overflow : bool { _Nope, _Yes };

template <class _Refc, _Check_overflow _Check>
_NODISCARD size_t _Calculate_bytes_for_flexible_array(const size_t _Count) noexcept(_Check == _Check_overflow::_Nope) {
    constexpr size_t _Align = alignof(_Refc);

    size_t _Bytes = sizeof(_Refc); // contains storage for one element

    if (_Count > 1) {
        constexpr size_t _Element_size = sizeof(typename _Refc::_Element_type);

        size_t _Extra_bytes;

        if constexpr (_Check == _Check_overflow::_Yes) {
            _Extra_bytes = _Get_size_of_n<_Element_size>(_Count - 1); // check multiplication overflow

            if (_Extra_bytes > static_cast<size_t>(-1) - _Bytes - (_Align - 1)) { // assume worst case adjustment
                _Throw_bad_array_new_length(); // addition overflow
            }
        }
        else {
            _Extra_bytes = _Element_size * (_Count - 1);
        }

        _Bytes += _Extra_bytes;

        _Bytes = (_Bytes + _Align - 1) & ~(_Align - 1);
    }

#ifdef _ENABLE_STL_INTERNAL_CHECK
    using _Storage = _Alignas_storage_unit<_Align>;
    _STL_INTERNAL_CHECK(_Bytes % sizeof(_Storage) == 0);
#endif // _ENABLE_STL_INTERNAL_CHECK

    return _Bytes;
}

template <class _Refc>
_NODISCARD _Refc* _Allocate_flexible_array(const size_t _Count) {
    const size_t _Bytes = _Calculate_bytes_for_flexible_array<_Refc, _Check_overflow::_Yes>(_Count);
#ifdef __cpp_aligned_new
    constexpr size_t _Align = alignof(_Refc);
    if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
        return static_cast<_Refc*>(::operator new(_Bytes, align_val_t{ _Align }));
    }
    else
#endif // defined(__cpp_aligned_new)
    {
        return static_cast<_Refc*>(::operator new(_Bytes));
    }
}

template <class _Refc>
void _Deallocate_flexible_array(_Refc* const _Ptr) noexcept {
#ifdef __cpp_aligned_new
    constexpr size_t _Align = alignof(_Refc);
    if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
        ::operator delete(static_cast<void*>(_Ptr), align_val_t{ _Align });
    }
    else
#endif // defined(__cpp_aligned_new)
    {
        ::operator delete(static_cast<void*>(_Ptr));
    }
}

template <class _NoThrowIt>
struct _NODISCARD _Uninitialized_rev_destroying_backout {
    // struct to undo partially constructed ranges in _Uninitialized_xxx algorithms
    _NoThrowIt _First;
    _NoThrowIt _Last;

    explicit _Uninitialized_rev_destroying_backout(_NoThrowIt _Dest) noexcept : _First(_Dest), _Last(_Dest) {}

    _Uninitialized_rev_destroying_backout(const _Uninitialized_rev_destroying_backout&) = delete;
    _Uninitialized_rev_destroying_backout& operator=(const _Uninitialized_rev_destroying_backout&) = delete;

    ~_Uninitialized_rev_destroying_backout() {
        while (_Last != _First) {
            --_Last;
            _STD destroy_at(_STD addressof(*_Last));
        }
    }

    template <class... _Types>
    void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment
        _STD _Construct_in_place(*_Last, _STD forward<_Types>(_Vals)...);
        ++_Last;
    }

    void _Emplace_back_for_overwrite() {
        _STD _Default_construct_in_place(*_Last);
        ++_Last;
    }

    _NoThrowIt _Release() noexcept { // suppress any exception handling backout and return _Last
        _First = _Last;
        return _Last;
    }
};

template <class _Ty>
void _Reverse_destroy_multidimensional_n(_Ty* const _Arr, size_t _Size) noexcept {
    while (_Size > 0) {
        --_Size;
        if constexpr (is_array_v<_Ty>) {
            _STD _Reverse_destroy_multidimensional_n(_Arr[_Size], extent_v<_Ty>);
        }
        else {
            _STD _Destroy_in_place(_Arr[_Size]);
        }
    }
}

template <class _Ty>
struct _NODISCARD _Reverse_destroy_multidimensional_n_guard {
    _Ty* _Target;
    size_t _Index;

    ~_Reverse_destroy_multidimensional_n_guard() {
        if (_Target) {
            _STD _Reverse_destroy_multidimensional_n(_Target, _Index);
        }
    }
};

template <class _Ty, size_t _Size>
void _Uninitialized_copy_multidimensional(const _Ty(&_In)[_Size], _Ty(&_Out)[_Size]) {
    if constexpr (is_trivial_v<_Ty>) {
        _STD _Copy_memmove_n(_In, _Size, _Out);
    }
    else if constexpr (is_array_v<_Ty>) {
        _Reverse_destroy_multidimensional_n_guard<_Ty> _Guard{ _Out, 0 };
        for (size_t& _Idx = _Guard._Index; _Idx < _Size; ++_Idx) {
            _STD _Uninitialized_copy_multidimensional(_In[_Idx], _Out[_Idx]);
        }
        _Guard._Target = nullptr;
    }
    else {
        _Uninitialized_rev_destroying_backout _Backout{ _Out };
        for (size_t _Idx = 0; _Idx < _Size; ++_Idx) {
            _Backout._Emplace_back(_In[_Idx]);
        }
        _Backout._Release();
    }
}

template <class _Ty>
void _Uninitialized_value_construct_multidimensional_n(_Ty* const _Out, const size_t _Size) {
    using _Item = remove_all_extents_t<_Ty>;
    if constexpr (_Use_memset_value_construct_v<_Item*>) {
        _STD _Zero_range(_Out, _Out + _Size);
    }
    else if constexpr (is_array_v<_Ty>) {
        _Reverse_destroy_multidimensional_n_guard<_Ty> _Guard{ _Out, 0 };
        for (size_t& _Idx = _Guard._Index; _Idx < _Size; ++_Idx) {
            _STD _Uninitialized_value_construct_multidimensional_n(_Out[_Idx], extent_v<_Ty>);
        }
        _Guard._Target = nullptr;
    }
    else {
        _Uninitialized_rev_destroying_backout _Backout{ _Out };
        for (size_t _Idx = 0; _Idx < _Size; ++_Idx) {
            _Backout._Emplace_back();
        }
        _Backout._Release();
    }
}

template <class _Ty>
void _Uninitialized_default_construct_multidimensional_n(_Ty* const _Out, const size_t _Size) {
    if constexpr (!is_trivially_default_constructible_v<_Ty>) {
        if constexpr (is_array_v<_Ty>) {
            _Reverse_destroy_multidimensional_n_guard<_Ty> _Guard{ _Out, 0 };
            for (size_t& _Idx = _Guard._Index; _Idx < _Size; ++_Idx) {
                _STD _Uninitialized_default_construct_multidimensional_n(_Out[_Idx], extent_v<_Ty>);
            }
            _Guard._Target = nullptr;
        }
        else {
            _Uninitialized_rev_destroying_backout _Backout{ _Out };
            for (size_t _Idx = 0; _Idx < _Size; ++_Idx) {
                _Backout._Emplace_back_for_overwrite();
            }
            _Backout._Release();
        }
    }
}

template <class _Ty>
void _Uninitialized_fill_multidimensional_n(_Ty* const _Out, const size_t _Size, const _Ty& _Val) {
    if constexpr (is_array_v<_Ty>) {
        _Reverse_destroy_multidimensional_n_guard<_Ty> _Guard{ _Out, 0 };
        for (size_t& _Idx = _Guard._Index; _Idx < _Size; ++_Idx) {
            _STD _Uninitialized_copy_multidimensional(_Val, _Out[_Idx]); // intentionally copy, not fill
        }
        _Guard._Target = nullptr;
    }
    else if constexpr (_Fill_memset_is_safe<_Ty*, _Ty>) {
        _STD _Fill_memset(_Out, _Val, _Size);
    }
    else {
        if constexpr (_Fill_zero_memset_is_safe<_Ty*, _Ty>) {
            if (_STD _Is_all_bits_zero(_Val)) {
                _STD _Fill_zero_memset(_Out, _Size);
                return;
            }
        }
        _Uninitialized_rev_destroying_backout _Backout{ _Out };
        for (size_t _Idx = 0; _Idx < _Size; ++_Idx) {
            _Backout._Emplace_back(_Val);
        }
        _Backout._Release();
    }
}

template <class _Ty, bool = is_trivially_destructible_v<remove_extent_t<_Ty>>>
class _Ref_count_unbounded_array : public _Ref_count_base {
    // handle reference counting for unbounded array with trivial destruction in control block, no allocator
public:
    static_assert(is_unbounded_array_v<_Ty>);

    using _Element_type = remove_extent_t<_Ty>;

    explicit _Ref_count_unbounded_array(const size_t _Count) : _Ref_count_base() {
        _STD _Uninitialized_value_construct_multidimensional_n(_Get_ptr(), _Count);
    }

    template <class _Arg>
    explicit _Ref_count_unbounded_array(const size_t _Count, const _Arg& _Val) : _Ref_count_base() {
        if constexpr (is_same_v<_For_overwrite_tag, _Arg>) {
            _STD _Uninitialized_default_construct_multidimensional_n(_Get_ptr(), _Count);
        }
        else {
            _STD _Uninitialized_fill_multidimensional_n(_Get_ptr(), _Count, _Val);
        }
    }

    _NODISCARD auto _Get_ptr() noexcept {
        return _STD addressof(_Storage._Value);
    }

private:
    union {
        _Wrap<remove_cv_t<_Element_type>> _Storage; // flexible array must be last member
    };

    ~_Ref_count_unbounded_array() noexcept override { // TRANSITION, should be non-virtual
        // nothing to do, _Ty is trivially destructible

        // See N4950 [class.dtor]/7.
    }

    void _Destroy() noexcept override { // destroy managed resource
        // nothing to do, _Ty is trivially destructible
    }

    void _Delete_this() noexcept override { // destroy self
        this->~_Ref_count_unbounded_array();
        _STD _Deallocate_flexible_array(this);
    }
};

template <class _Ty>
class _Ref_count_unbounded_array<_Ty, false> : public _Ref_count_base {
    // handle reference counting for unbounded array with non-trivial destruction in control block, no allocator
public:
    static_assert(is_unbounded_array_v<_Ty>);

    using _Element_type = remove_extent_t<_Ty>;

    explicit _Ref_count_unbounded_array(const size_t _Count) : _Ref_count_base(), _Size(_Count) {
        _STD _Uninitialized_value_construct_multidimensional_n(_Get_ptr(), _Size);
    }

    template <class _Arg>
    explicit _Ref_count_unbounded_array(const size_t _Count, const _Arg& _Val) : _Ref_count_base(), _Size(_Count) {
        if constexpr (is_same_v<_For_overwrite_tag, _Arg>) {
            _STD _Uninitialized_default_construct_multidimensional_n(_Get_ptr(), _Size);
        }
        else {
            _STD _Uninitialized_fill_multidimensional_n(_Get_ptr(), _Size, _Val);
        }
    }

    _NODISCARD auto _Get_ptr() noexcept {
        return _STD addressof(_Storage._Value);
    }

private:
    size_t _Size;

    union {
        _Wrap<remove_cv_t<_Element_type>> _Storage; // flexible array must be last member
    };

    ~_Ref_count_unbounded_array() noexcept override { // TRANSITION, should be non-virtual
        // nothing to do, _Storage was already destroyed in _Destroy

        // See N4950 [class.dtor]/7.
    }

    void _Destroy() noexcept override { // destroy managed resource
        _STD _Reverse_destroy_multidimensional_n(_Get_ptr(), _Size);
    }

    void _Delete_this() noexcept override { // destroy self
        this->~_Ref_count_unbounded_array();
        _STD _Deallocate_flexible_array(this);
    }
};

template <class _Ty>
class _Ref_count_bounded_array : public _Ref_count_base {
    // handle reference counting for bounded array in control block, no allocator
public:
    static_assert(is_bounded_array_v<_Ty>);

    _Ref_count_bounded_array() : _Ref_count_base(), _Storage() {} // value-initializing _Storage is necessary here

    template <class _Arg>
    explicit _Ref_count_bounded_array(const _Arg& _Val) : _Ref_count_base() { // don't value-initialize _Storage
        if constexpr (is_same_v<_For_overwrite_tag, _Arg>) {
            _STD _Uninitialized_default_construct_multidimensional_n(_Storage._Value, extent_v<_Ty>);
        }
        else {
            _STD _Uninitialized_fill_multidimensional_n(_Storage._Value, extent_v<_Ty>, _Val);
        }
    }

    union {
        _Wrap<remove_cv_t<_Ty>> _Storage;
    };

private:
    ~_Ref_count_bounded_array() noexcept override { // TRANSITION, should be non-virtual
        // nothing to do, _Storage was already destroyed in _Destroy

        // See N4950 [class.dtor]/7.
    }

    void _Destroy() noexcept override { // destroy managed resource
        // not _Storage._Value as _Ty is an array type (not a class type or a scalar type),
        // and thus cannot be used as a pseudo-destructor (N4950 [expr.prim.id.dtor]).
        _STD _Destroy_in_place(_Storage);
    }

    void _Delete_this() noexcept override { // destroy self
        delete this;
    }
};
#endif // _HAS_CXX20

template <class _Ty, class _Alloc>
class _Ref_count_obj_alloc3 : public _Ebco_base<_Rebind_alloc_t<_Alloc, _Ty>>, public _Ref_count_base {
    // handle reference counting for object in control block, allocator
private:
    static_assert(is_same_v<_Ty, remove_cv_t<_Ty>>, "allocate_shared should remove_cv_t");

    using _Rebound = _Rebind_alloc_t<_Alloc, _Ty>;

public:
    template <class... _Types>
    explicit _Ref_count_obj_alloc3(const _Alloc& _Al_arg, _Types&&... _Args)
        : _Ebco_base<_Rebound>(_Al_arg), _Ref_count_base() {
#if _HAS_CXX20 && defined(_ENABLE_STL_INTERNAL_CHECK)
        if constexpr (sizeof...(_Types) == 1) {
            // allocate_shared_for_overwrite should use another type for the control block
            _STL_INTERNAL_STATIC_ASSERT(!(is_same_v<_For_overwrite_tag, remove_cvref_t<_Types>> && ...));
        }
#endif // _HAS_CXX20 && defined(_ENABLE_STL_INTERNAL_CHECK)
        allocator_traits<_Rebound>::construct(
            this->_Get_val(), _STD addressof(_Storage._Value), _STD forward<_Types>(_Args)...);
    }

    union {
        _Wrap<_Ty> _Storage;
    };

private:
    ~_Ref_count_obj_alloc3() noexcept override { // TRANSITION, should be non-virtual
        // nothing to do; _Storage._Value already destroyed by _Destroy()

        // See N4950 [class.dtor]/7.
    }

    void _Destroy() noexcept override { // destroy managed resource
        allocator_traits<_Rebound>::destroy(this->_Get_val(), _STD addressof(_Storage._Value));
    }

    void _Delete_this() noexcept override { // destroy self
        _Rebind_alloc_t<_Alloc, _Ref_count_obj_alloc3> _Al(this->_Get_val());
        this->~_Ref_count_obj_alloc3();
        _STD _Deallocate_plain(_Al, this);
    }
};

#if _HAS_CXX20
template <class _Ty, class _Alloc>
class _Ref_count_obj_alloc_for_overwrite : public _Ebco_base<_Rebind_alloc_t<_Alloc, _Ty>>, public _Ref_count_base {
    // handle reference counting for object in control block, allocator
    // initialize and destroy objects by the default mechanism
private:
    static_assert(is_same_v<_Ty, remove_cv_t<_Ty>>, "allocate_shared_for_overwrite should remove_cv_t");

    using _Rebound = _Rebind_alloc_t<_Alloc, _Ty>;

public:
    template <class... _Types>
    explicit _Ref_count_obj_alloc_for_overwrite(const _Alloc& _Al_arg)
        : _Ebco_base<_Rebound>(_Al_arg), _Ref_count_base() {
        _STD _Default_construct_in_place(_Storage._Value);
    }

    union {
        _Wrap<_Ty> _Storage;
    };

private:
    ~_Ref_count_obj_alloc_for_overwrite() noexcept override { // TRANSITION, should be non-virtual
        // nothing to do; _Storage._Value already destroyed by _Destroy()

        // See N4964 [class.dtor]/7.
    }

    void _Destroy() noexcept override { // destroy managed resource
        _STD _Destroy_in_place(_Storage._Value); // use the default mechanism per LWG-4024
    }

    void _Delete_this() noexcept override { // destroy self
        _Rebind_alloc_t<_Alloc, _Ref_count_obj_alloc_for_overwrite> _Al(this->_Get_val());
        this->~_Ref_count_obj_alloc_for_overwrite();
        _STD _Deallocate_plain(_Al, this);
    }
};

template <class _Alloc>
class _NODISCARD _Uninitialized_rev_destroying_backout_al {
    // class to undo partially constructed ranges in _Uninitialized_xxx_al algorithms

private:
    using pointer = _Alloc_ptr_t<_Alloc>;

public:
    _Uninitialized_rev_destroying_backout_al(pointer _Dest, _Alloc& _Al_) noexcept
        : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

    _Uninitialized_rev_destroying_backout_al(const _Uninitialized_rev_destroying_backout_al&) = delete;
    _Uninitialized_rev_destroying_backout_al& operator=(const _Uninitialized_rev_destroying_backout_al&) = delete;

    ~_Uninitialized_rev_destroying_backout_al() {
        while (_Last != _First) {
            --_Last;
            allocator_traits<_Alloc>::destroy(_Al, _Last);
        }
    }

    template <class... _Types>
    void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment
        allocator_traits<_Alloc>::construct(_Al, _STD _Unfancy(_Last), _STD forward<_Types>(_Vals)...);
        ++_Last;
    }

    pointer _Release() noexcept { // suppress any exception handling backout and return _Last
        _First = _Last;
        return _Last;
    }

private:
    pointer _First;
    pointer _Last;
    _Alloc& _Al;
};

template <class _Ty, class _Alloc>
void _Reverse_destroy_multidimensional_n_al(_Ty* const _Arr, size_t _Size, _Alloc& _Al) noexcept {
    while (_Size > 0) {
        --_Size;
        if constexpr (is_array_v<_Ty>) {
            _STD _Reverse_destroy_multidimensional_n_al(_Arr[_Size], extent_v<_Ty>, _Al);
        }
        else {
            allocator_traits<_Alloc>::destroy(_Al, _Arr + _Size);
        }
    }
}

template <class _Ty, class _Alloc>
struct _NODISCARD _Reverse_destroy_multidimensional_n_al_guard {
    _Ty* _Target;
    size_t _Index;
    _Alloc& _Al;

    ~_Reverse_destroy_multidimensional_n_al_guard() {
        if (_Target) {
            _STD _Reverse_destroy_multidimensional_n_al(_Target, _Index, _Al);
        }
    }
};

template <class _Ty, size_t _Size, class _Alloc>
void _Uninitialized_copy_multidimensional_al(const _Ty(&_In)[_Size], _Ty(&_Out)[_Size], _Alloc& _Al) {
    using _Item = remove_all_extents_t<_Ty>;
    if constexpr (conjunction_v<is_trivial<_Ty>, _Uses_default_construct<_Alloc, _Item*, const _Item&>>) {
        _STD _Copy_memmove_n(_In, _Size, _Out);
    }
    else if constexpr (is_array_v<_Ty>) {
        _Reverse_destroy_multidimensional_n_al_guard<_Ty, _Alloc> _Guard{ _Out, 0, _Al };
        for (size_t& _Idx = _Guard._Index; _Idx < _Size; ++_Idx) {
            _STD _Uninitialized_copy_multidimensional_al(_In[_Idx], _Out[_Idx], _Al);
        }
        _Guard._Target = nullptr;
    }
    else {
        _Uninitialized_rev_destroying_backout_al _Backout{ _Out, _Al };
        for (size_t _Idx = 0; _Idx < _Size; ++_Idx) {
            _Backout._Emplace_back(_In[_Idx]);
        }
        _Backout._Release();
    }
}

template <class _Ty, class _Alloc>
void _Uninitialized_value_construct_multidimensional_n_al(_Ty* const _Out, const size_t _Size, _Alloc& _Al) {
    using _Item = remove_all_extents_t<_Ty>;
    if constexpr (_Use_memset_value_construct_v<_Item*> && _Uses_default_construct<_Alloc, _Item*>::value) {
        _STD _Zero_range(_Out, _Out + _Size);
    }
    else if constexpr (is_array_v<_Ty>) {
        _Reverse_destroy_multidimensional_n_al_guard<_Ty, _Alloc> _Guard{ _Out, 0, _Al };
        for (size_t& _Idx = _Guard._Index; _Idx < _Size; ++_Idx) {
            _STD _Uninitialized_value_construct_multidimensional_n_al(_Out[_Idx], extent_v<_Ty>, _Al);
        }
        _Guard._Target = nullptr;
    }
    else {
        _Uninitialized_rev_destroying_backout_al _Backout{ _Out, _Al };
        for (size_t _Idx = 0; _Idx < _Size; ++_Idx) {
            _Backout._Emplace_back();
        }
        _Backout._Release();
    }
}

template <class _Ty, class _Alloc>
void _Uninitialized_fill_multidimensional_n_al(_Ty* const _Out, const size_t _Size, const _Ty& _Val, _Alloc& _Al) {
    if constexpr (is_array_v<_Ty>) {
        _Reverse_destroy_multidimensional_n_al_guard<_Ty, _Alloc> _Guard{ _Out, 0, _Al };
        for (size_t& _Idx = _Guard._Index; _Idx < _Size; ++_Idx) {
            _STD _Uninitialized_copy_multidimensional_al(_Val, _Out[_Idx], _Al); // intentionally copy, not fill
        }
        _Guard._Target = nullptr;
    }
    else if constexpr (_Fill_memset_is_safe<_Ty*, _Ty> && _Uses_default_construct<_Alloc, _Ty*, const _Ty&>::value) {
        _STD _Fill_memset(_Out, _Val, _Size);
    }
    else {
        if constexpr (_Fill_zero_memset_is_safe<_Ty*, _Ty>
            && _Uses_default_construct<_Alloc, _Ty*, const _Ty&>::value) {
            if (_STD _Is_all_bits_zero(_Val)) {
                _STD _Fill_zero_memset(_Out, _Size);
                return;
            }
        }
        _Uninitialized_rev_destroying_backout_al _Backout{ _Out, _Al };
        for (size_t _Idx = 0; _Idx < _Size; ++_Idx) {
            _Backout._Emplace_back(_Val);
        }
        _Backout._Release();
    }
}

template <class _Ty, class _Alloc>
class _Ref_count_unbounded_array_alloc : public _Ebco_base<_Rebind_alloc_t<_Alloc, remove_all_extents_t<_Ty>>>,
    public _Ref_count_base {
    // handle reference counting for unbounded array in control block, allocator
private:
    static_assert(is_unbounded_array_v<_Ty>);
    static_assert(is_same_v<_Ty, remove_cv_t<_Ty>>, "allocate_shared should remove_cv_t");

    using _Item = remove_all_extents_t<_Ty>;
    using _Rebound = _Rebind_alloc_t<_Alloc, _Item>;

public:
    using _Element_type = remove_extent_t<_Ty>;

    explicit _Ref_count_unbounded_array_alloc(const _Alloc& _Al_arg, const size_t _Count)
        : _Ebco_base<_Rebound>(_Al_arg), _Ref_count_base(), _Size(_Count) {
        _STD _Uninitialized_value_construct_multidimensional_n_al(_Get_ptr(), _Size, this->_Get_val());
    }

    template <class _Arg>
    explicit _Ref_count_unbounded_array_alloc(const _Alloc& _Al_arg, const size_t _Count, const _Arg& _Val)
        : _Ebco_base<_Rebound>(_Al_arg), _Ref_count_base(), _Size(_Count) {
        // allocate_shared_for_overwrite should use another type for the control block
        _STL_INTERNAL_STATIC_ASSERT(!is_same_v<_For_overwrite_tag, _Arg>);

        _STD _Uninitialized_fill_multidimensional_n_al(_Get_ptr(), _Size, _Val, this->_Get_val());
    }

    _NODISCARD auto _Get_ptr() noexcept {
        return _STD addressof(_Storage._Value);
    }

private:
    size_t _Size;

    union {
        _Wrap<_Element_type> _Storage; // flexible array must be last member
    };

    ~_Ref_count_unbounded_array_alloc() noexcept override { // TRANSITION, should be non-virtual
        // nothing to do; _Storage._Value already destroyed by _Destroy()

        // See N4950 [class.dtor]/7.
    }

    void _Destroy() noexcept override { // destroy managed resource
        if constexpr (!conjunction_v<is_trivially_destructible<_Item>, _Uses_default_destroy<_Rebound, _Item*>>) {
            _STD _Reverse_destroy_multidimensional_n_al(_Get_ptr(), _Size, this->_Get_val());
        }
    }

    void _Delete_this() noexcept override { // destroy self
        constexpr size_t _Align = alignof(_Ref_count_unbounded_array_alloc);
        using _Storage = _Alignas_storage_unit<_Align>;
        using _Rebound_alloc = _Rebind_alloc_t<_Alloc, _Storage>;

        _Rebound_alloc _Al(this->_Get_val());
        const size_t _Bytes =
            _Calculate_bytes_for_flexible_array<_Ref_count_unbounded_array_alloc, _Check_overflow::_Nope>(_Size);
        const size_t _Storage_units = _Bytes / sizeof(_Storage);

        this->~_Ref_count_unbounded_array_alloc();

        _Al.deallocate(_STD _Refancy<_Alloc_ptr_t<_Rebound_alloc>>(reinterpret_cast<_Storage*>(this)),
            static_cast<_Alloc_size_t<_Rebound_alloc>>(_Storage_units));
    }
};

template <class _Ty, class _Alloc>
class _Ref_count_unbounded_array_alloc_for_overwrite
    : public _Ebco_base<_Rebind_alloc_t<_Alloc, remove_all_extents_t<_Ty>>>,
    public _Ref_count_base {
    // handle reference counting for unbounded array in control block, allocator
    // initialize and destroy objects by the default mechanism
private:
    static_assert(is_unbounded_array_v<_Ty>);
    static_assert(is_same_v<_Ty, remove_cv_t<_Ty>>, "allocate_shared_for_overwrite should remove_cv_t");

    using _Item = remove_all_extents_t<_Ty>;
    using _Rebound = _Rebind_alloc_t<_Alloc, _Item>;

public:
    using _Element_type = remove_extent_t<_Ty>;

    explicit _Ref_count_unbounded_array_alloc_for_overwrite(const _Alloc& _Al_arg, const size_t _Count)
        : _Ebco_base<_Rebound>(_Al_arg), _Ref_count_base(), _Size(_Count) {
        _STD _Uninitialized_default_construct_multidimensional_n(_Get_ptr(), _Size); // the allocator isn't needed
    }

    _NODISCARD auto _Get_ptr() noexcept {
        return _STD addressof(_Storage._Value);
    }

private:
    size_t _Size;

    union {
        _Wrap<_Element_type> _Storage; // flexible array must be last member
    };

    ~_Ref_count_unbounded_array_alloc_for_overwrite() noexcept override { // TRANSITION, should be non-virtual
        // nothing to do; _Storage._Value already destroyed by _Destroy()

        // See N4964 [class.dtor]/7.
    }

    void _Destroy() noexcept override { // destroy managed resource
        _STD _Reverse_destroy_multidimensional_n(_Get_ptr(), _Size); // use the default mechanism per LWG-4024
    }

    void _Delete_this() noexcept override { // destroy self
        constexpr size_t _Align = alignof(_Ref_count_unbounded_array_alloc_for_overwrite);
        using _Storage = _Alignas_storage_unit<_Align>;
        using _Rebound_alloc = _Rebind_alloc_t<_Alloc, _Storage>;

        _Rebound_alloc _Al(this->_Get_val());
        const size_t _Bytes = _Calculate_bytes_for_flexible_array< //
            _Ref_count_unbounded_array_alloc_for_overwrite, _Check_overflow::_Nope>(_Size);
        const size_t _Storage_units = _Bytes / sizeof(_Storage);

        this->~_Ref_count_unbounded_array_alloc_for_overwrite();

        _Al.deallocate(_STD _Refancy<_Alloc_ptr_t<_Rebound_alloc>>(reinterpret_cast<_Storage*>(this)),
            static_cast<_Alloc_size_t<_Rebound_alloc>>(_Storage_units));
    }
};

template <class _Ty, class _Alloc>
class _Ref_count_bounded_array_alloc : public _Ebco_base<_Rebind_alloc_t<_Alloc, remove_all_extents_t<_Ty>>>,
    public _Ref_count_base {
    // handle reference counting for bounded array in control block, allocator
private:
    static_assert(is_bounded_array_v<_Ty>);
    static_assert(is_same_v<_Ty, remove_cv_t<_Ty>>, "allocate_shared should remove_cv_t");

    using _Item = remove_all_extents_t<_Ty>;
    using _Rebound = _Rebind_alloc_t<_Alloc, _Item>;

public:
    explicit _Ref_count_bounded_array_alloc(const _Alloc& _Al_arg)
        : _Ebco_base<_Rebound>(_Al_arg), _Ref_count_base() { // don't value-initialize _Storage
        _STD _Uninitialized_value_construct_multidimensional_n_al(_Storage._Value, extent_v<_Ty>, this->_Get_val());
    }

    template <class _Arg>
    explicit _Ref_count_bounded_array_alloc(const _Alloc& _Al_arg, const _Arg& _Val)
        : _Ebco_base<_Rebound>(_Al_arg), _Ref_count_base() { // don't value-initialize _Storage
        // allocate_shared_for_overwrite should use another type for the control block
        _STL_INTERNAL_STATIC_ASSERT(!is_same_v<_For_overwrite_tag, _Arg>);

        _STD _Uninitialized_fill_multidimensional_n_al(_Storage._Value, extent_v<_Ty>, _Val, this->_Get_val());
    }

    union {
        _Wrap<_Ty> _Storage;
    };

private:
    ~_Ref_count_bounded_array_alloc() noexcept override { // TRANSITION, should be non-virtual
        // nothing to do; _Storage._Value already destroyed by _Destroy()

        // See N4950 [class.dtor]/7.
    }

    void _Destroy() noexcept override { // destroy managed resource
        if constexpr (!conjunction_v<is_trivially_destructible<_Item>, _Uses_default_destroy<_Rebound, _Item*>>) {
            _STD _Reverse_destroy_multidimensional_n_al(_Storage._Value, extent_v<_Ty>, this->_Get_val());
        }
    }

    void _Delete_this() noexcept override { // destroy self
        _Rebind_alloc_t<_Alloc, _Ref_count_bounded_array_alloc> _Al(this->_Get_val());
        this->~_Ref_count_bounded_array_alloc();
        _STD _Deallocate_plain(_Al, this);
    }
};

template <class _Ty, class _Alloc>
class _Ref_count_bounded_array_alloc_for_overwrite
    : public _Ebco_base<_Rebind_alloc_t<_Alloc, remove_all_extents_t<_Ty>>>,
    public _Ref_count_base {
    // handle reference counting for bounded array in control block, allocator
    // initialize and destroy objects by the default mechanism
private:
    static_assert(is_bounded_array_v<_Ty>);
    static_assert(is_same_v<_Ty, remove_cv_t<_Ty>>, "allocate_shared_for_overwrite should remove_cv_t");

    using _Item = remove_all_extents_t<_Ty>;
    using _Rebound = _Rebind_alloc_t<_Alloc, _Item>;

public:
    explicit _Ref_count_bounded_array_alloc_for_overwrite(const _Alloc& _Al_arg)
        : _Ebco_base<_Rebound>(_Al_arg), _Ref_count_base() { // don't value-initialize _Storage
        _STD _Uninitialized_default_construct_multidimensional_n(
            _Storage._Value, extent_v<_Ty>); // the allocator isn't needed
    }

    union {
        _Wrap<_Ty> _Storage;
    };

private:
    ~_Ref_count_bounded_array_alloc_for_overwrite() noexcept override { // TRANSITION, should be non-virtual
        // nothing to do; _Storage._Value already destroyed by _Destroy()

        // See N4964 [class.dtor]/7.
    }

    void _Destroy() noexcept override { // destroy managed resource
        // not _Storage._Value as _Ty is an array type (not a class type or a scalar type),
        // and thus cannot be used as a pseudo-destructor (N4964 [expr.prim.id.dtor]).
        _STD _Destroy_in_place(_Storage); // use the default mechanism per LWG-4024
    }

    void _Delete_this() noexcept override { // destroy self
        _Rebind_alloc_t<_Alloc, _Ref_count_bounded_array_alloc_for_overwrite> _Al(this->_Get_val());
        this->~_Ref_count_bounded_array_alloc_for_overwrite();
        _STD _Deallocate_plain(_Al, this);
    }
};
#endif // _HAS_CXX20

_EXPORT_STD template <class _Ty, class... _Types>
_NODISCARD_SMART_PTR_ALLOC
#if _HAS_CXX20
enable_if_t<!is_array_v<_Ty>, shared_ptr<_Ty>>
#else
shared_ptr<_Ty>
#endif
make_shared(_Types&&... _Args) { // make a shared_ptr to non-array object
    const auto _Rx = new _Ref_count_obj2<_Ty>(_STD forward<_Types>(_Args)...);
    shared_ptr<_Ty> _Ret;
    _Ret._Set_ptr_rep_and_enable_shared(_STD addressof(_Rx->_Storage._Value), _Rx);
    return _Ret;
}

#if _HAS_CXX20
template <class _Refc>
struct _NODISCARD _Global_delete_guard {
    _Refc* _Target;

    ~_Global_delete_guard() {
        // While this branch is technically unnecessary because N4950 [new.delete.single]/16 requires
        // `::operator delete(nullptr)` to be a no-op, it's here to help optimizers see that after
        // `_Guard._Target = nullptr;`, this destructor can be eliminated.
        if (_Target) {
            _STD _Deallocate_flexible_array(_Target);
        }
    }
};

_EXPORT_STD /* TRANSITION, VSO-1538698 */ template <class _Ty, class... _ArgTypes>
_NODISCARD shared_ptr<_Ty> _Make_shared_unbounded_array(const size_t _Count, const _ArgTypes&... _Args) {
    // make a shared_ptr to an unbounded array
    static_assert(is_unbounded_array_v<_Ty>);
    using _Refc = _Ref_count_unbounded_array<_Ty>;
    const auto _Rx = _Allocate_flexible_array<_Refc>(_Count);
    _Global_delete_guard<_Refc> _Guard{ _Rx };
    ::new (static_cast<void*>(_Rx)) _Refc(_Count, _Args...);
    _Guard._Target = nullptr;
    shared_ptr<_Ty> _Ret;
    _Ret._Set_ptr_rep_and_enable_shared(_Rx->_Get_ptr(), _Rx);
    return _Ret;
}

_EXPORT_STD template <class _Ty>
_NODISCARD_SMART_PTR_ALLOC enable_if_t<is_unbounded_array_v<_Ty>, shared_ptr<_Ty>> make_shared(const size_t _Count) {
    return _STD _Make_shared_unbounded_array<_Ty>(_Count);
}

_EXPORT_STD template <class _Ty>
_NODISCARD_SMART_PTR_ALLOC enable_if_t<is_unbounded_array_v<_Ty>, shared_ptr<_Ty>> make_shared(
    const size_t _Count, const remove_extent_t<_Ty>& _Val) {
    return _STD _Make_shared_unbounded_array<_Ty>(_Count, _Val);
}

_EXPORT_STD template <class _Ty>
_NODISCARD_SMART_PTR_ALLOC enable_if_t<is_bounded_array_v<_Ty>, shared_ptr<_Ty>> make_shared() {
    // make a shared_ptr to a bounded array
    const auto _Rx = new _Ref_count_bounded_array<_Ty>();
    shared_ptr<_Ty> _Ret;
    _Ret._Set_ptr_rep_and_enable_shared(_Rx->_Storage._Value, _Rx);
    return _Ret;
}

_EXPORT_STD template <class _Ty>
_NODISCARD_SMART_PTR_ALLOC enable_if_t<is_bounded_array_v<_Ty>, shared_ptr<_Ty>> make_shared(
    const remove_extent_t<_Ty>& _Val) {
    // make a shared_ptr to a bounded array
    const auto _Rx = new _Ref_count_bounded_array<_Ty>(_Val);
    shared_ptr<_Ty> _Ret;
    _Ret._Set_ptr_rep_and_enable_shared(_Rx->_Storage._Value, _Rx);
    return _Ret;
}

_EXPORT_STD template <class _Ty>
_NODISCARD_SMART_PTR_ALLOC enable_if_t<!is_unbounded_array_v<_Ty>, shared_ptr<_Ty>> make_shared_for_overwrite() {
    shared_ptr<_Ty> _Ret;
    if constexpr (is_array_v<_Ty>) {
        // make a shared_ptr to a bounded array
        const auto _Rx = new _Ref_count_bounded_array<_Ty>(_For_overwrite_tag{});
        _Ret._Set_ptr_rep_and_enable_shared(_Rx->_Storage._Value, _Rx);
    }
    else {
        // make a shared_ptr to non-array object
        const auto _Rx = new _Ref_count_obj2<_Ty>(_For_overwrite_tag{});
        _Ret._Set_ptr_rep_and_enable_shared(_STD addressof(_Rx->_Storage._Value), _Rx);
    }
    return _Ret;
}

_EXPORT_STD template <class _Ty>
_NODISCARD_SMART_PTR_ALLOC enable_if_t<is_unbounded_array_v<_Ty>, shared_ptr<_Ty>> make_shared_for_overwrite(
    const size_t _Count) {
    return _STD _Make_shared_unbounded_array<_Ty>(_Count, _For_overwrite_tag{});
}
#endif // _HAS_CXX20

_EXPORT_STD template <class _Ty, class _Alloc, class... _Types>
_NODISCARD_SMART_PTR_ALLOC
#if _HAS_CXX20
enable_if_t<!is_array_v<_Ty>, shared_ptr<_Ty>>
#else
shared_ptr<_Ty>
#endif
allocate_shared(const _Alloc& _Al, _Types&&... _Args) { // make a shared_ptr to non-array object
    // Note: As of 2019-05-28, this implements the proposed resolution of LWG-3210 (which controls whether
    // allocator::construct sees T or const T when _Ty is const qualified)
    using _Refoa = _Ref_count_obj_alloc3<remove_cv_t<_Ty>, _Alloc>;
    using _Alblock = _Rebind_alloc_t<_Alloc, _Refoa>;
    _Alblock _Rebound(_Al);
    _Alloc_construct_ptr<_Alblock> _Constructor{ _Rebound };
    _Constructor._Allocate();
    _STD _Construct_in_place(*_Constructor._Ptr, _Al, _STD forward<_Types>(_Args)...);
    shared_ptr<_Ty> _Ret;
    const auto _Ptr = reinterpret_cast<_Ty*>(_STD addressof(_Constructor._Ptr->_Storage._Value));
    _Ret._Set_ptr_rep_and_enable_shared(_Ptr, _STD _Unfancy(_Constructor._Release()));
    return _Ret;
}

#if _HAS_CXX20
template <class _Alloc>
struct _Allocate_n_ptr {
    _Alloc& _Al;
    _Alloc_ptr_t<_Alloc> _Ptr;
    size_t _Nx;

    _Allocate_n_ptr(_Alloc& _Al_, const size_t _Nx_)
        : _Al(_Al_), _Ptr(_Al_.allocate(_Convert_size<_Alloc_size_t<_Alloc>>(_Nx_))), _Nx(_Nx_) {}

    ~_Allocate_n_ptr() {
        if (_Ptr) {
            _Al.deallocate(_Ptr, static_cast<_Alloc_size_t<_Alloc>>(_Nx));
        }
    }

    _Allocate_n_ptr(const _Allocate_n_ptr&) = delete;
    _Allocate_n_ptr& operator=(const _Allocate_n_ptr&) = delete;
};

_EXPORT_STD /* TRANSITION, VSO-1538698 */ template <bool _IsForOverwrite, class _Ty, class _Alloc, class... _ArgTypes>
_NODISCARD shared_ptr<_Ty> _Allocate_shared_unbounded_array(
    const _Alloc& _Al, const size_t _Count, const _ArgTypes&... _Args) {
    // make a shared_ptr to an unbounded array
    static_assert(is_unbounded_array_v<_Ty>);
    using _Refc = conditional_t<_IsForOverwrite, //
        _Ref_count_unbounded_array_alloc_for_overwrite<remove_cv_t<_Ty>, _Alloc>,
        _Ref_count_unbounded_array_alloc<remove_cv_t<_Ty>, _Alloc>>;
    constexpr size_t _Align = alignof(_Refc);
    using _Storage = _Alignas_storage_unit<_Align>;
    _Rebind_alloc_t<_Alloc, _Storage> _Rebound(_Al);
    const size_t _Bytes = _Calculate_bytes_for_flexible_array<_Refc, _Check_overflow::_Yes>(_Count);
    const size_t _Storage_units = _Bytes / sizeof(_Storage);
    _Allocate_n_ptr _Guard{ _Rebound, _Storage_units };
    const auto _Rx = reinterpret_cast<_Refc*>(_STD _Unfancy(_Guard._Ptr));
    ::new (static_cast<void*>(_Rx)) _Refc(_Al, _Count, _Args...);
    _Guard._Ptr = nullptr;
    shared_ptr<_Ty> _Ret;
    _Ret._Set_ptr_rep_and_enable_shared(_Rx->_Get_ptr(), _Rx);
    return _Ret;
}

_EXPORT_STD template <class _Ty, class _Alloc>
_NODISCARD_SMART_PTR_ALLOC enable_if_t<is_unbounded_array_v<_Ty>, shared_ptr<_Ty>> allocate_shared(
    const _Alloc& _Al, const size_t _Count) {
    return _STD _Allocate_shared_unbounded_array<false, _Ty>(_Al, _Count);
}

_EXPORT_STD template <class _Ty, class _Alloc>
_NODISCARD_SMART_PTR_ALLOC enable_if_t<is_unbounded_array_v<_Ty>, shared_ptr<_Ty>> allocate_shared(
    const _Alloc& _Al, const size_t _Count, const remove_extent_t<_Ty>& _Val) {
    return _STD _Allocate_shared_unbounded_array<false, _Ty>(_Al, _Count, _Val);
}

_EXPORT_STD template <class _Ty, class _Alloc>
_NODISCARD_SMART_PTR_ALLOC enable_if_t<is_bounded_array_v<_Ty>, shared_ptr<_Ty>> allocate_shared(const _Alloc& _Al) {
    // make a shared_ptr to a bounded array
    using _Refc = _Ref_count_bounded_array_alloc<remove_cv_t<_Ty>, _Alloc>;
    using _Alblock = _Rebind_alloc_t<_Alloc, _Refc>;
    _Alblock _Rebound(_Al);
    _Alloc_construct_ptr _Constructor{ _Rebound };
    _Constructor._Allocate();
    ::new (_STD _Voidify_unfancy(_Constructor._Ptr)) _Refc(_Al);
    shared_ptr<_Ty> _Ret;
    const auto _Ptr = static_cast<remove_extent_t<_Ty>*>(_Constructor._Ptr->_Storage._Value);
    _Ret._Set_ptr_rep_and_enable_shared(_Ptr, _STD _Unfancy(_Constructor._Release()));
    return _Ret;
}

_EXPORT_STD template <class _Ty, class _Alloc>
_NODISCARD_SMART_PTR_ALLOC enable_if_t<is_bounded_array_v<_Ty>, shared_ptr<_Ty>> allocate_shared(
    const _Alloc& _Al, const remove_extent_t<_Ty>& _Val) {
    // make a shared_ptr to a bounded array
    using _Refc = _Ref_count_bounded_array_alloc<remove_cv_t<_Ty>, _Alloc>;
    using _Alblock = _Rebind_alloc_t<_Alloc, _Refc>;
    _Alblock _Rebound(_Al);
    _Alloc_construct_ptr _Constructor{ _Rebound };
    _Constructor._Allocate();
    ::new (_STD _Voidify_unfancy(_Constructor._Ptr)) _Refc(_Al, _Val);
    shared_ptr<_Ty> _Ret;
    const auto _Ptr = static_cast<remove_extent_t<_Ty>*>(_Constructor._Ptr->_Storage._Value);
    _Ret._Set_ptr_rep_and_enable_shared(_Ptr, _STD _Unfancy(_Constructor._Release()));
    return _Ret;
}

_EXPORT_STD template <class _Ty, class _Alloc>
_NODISCARD_SMART_PTR_ALLOC enable_if_t<!is_unbounded_array_v<_Ty>, shared_ptr<_Ty>> allocate_shared_for_overwrite(
    const _Alloc& _Al) {
    shared_ptr<_Ty> _Ret;
    if constexpr (is_array_v<_Ty>) {
        // make a shared_ptr to a bounded array
        using _Refc = _Ref_count_bounded_array_alloc_for_overwrite<remove_cv_t<_Ty>, _Alloc>;
        using _Alblock = _Rebind_alloc_t<_Alloc, _Refc>;
        _Alblock _Rebound(_Al);
        _Alloc_construct_ptr _Constructor{ _Rebound };
        _Constructor._Allocate();
        ::new (_STD _Voidify_unfancy(_Constructor._Ptr)) _Refc(_Al);
        const auto _Ptr = static_cast<remove_extent_t<_Ty>*>(_Constructor._Ptr->_Storage._Value);
        _Ret._Set_ptr_rep_and_enable_shared(_Ptr, _STD _Unfancy(_Constructor._Release()));
    }
    else {
        // make a shared_ptr to non-array object
        using _Refoa = _Ref_count_obj_alloc_for_overwrite<remove_cv_t<_Ty>, _Alloc>;
        using _Alblock = _Rebind_alloc_t<_Alloc, _Refoa>;
        _Alblock _Rebound(_Al);
        _Alloc_construct_ptr<_Alblock> _Constructor{ _Rebound };
        _Constructor._Allocate();
        _STD _Construct_in_place(*_Constructor._Ptr, _Al);
        const auto _Ptr = reinterpret_cast<_Ty*>(_STD addressof(_Constructor._Ptr->_Storage._Value));
        _Ret._Set_ptr_rep_and_enable_shared(_Ptr, _STD _Unfancy(_Constructor._Release()));
    }

    return _Ret;
}

_EXPORT_STD template <class _Ty, class _Alloc>
_NODISCARD_SMART_PTR_ALLOC enable_if_t<is_unbounded_array_v<_Ty>, shared_ptr<_Ty>> allocate_shared_for_overwrite(
    const _Alloc& _Al, const size_t _Count) {
    return _STD _Allocate_shared_unbounded_array<true, _Ty>(_Al, _Count);
}
#endif // _HAS_CXX20

_EXPORT_STD template <class _Ty>
class weak_ptr : public _Ptr_base<_Ty> { // class for pointer to reference counted resource
public:
#ifndef _M_CEE_PURE
    // When a constructor is converting from weak_ptr<_Ty2> to weak_ptr<_Ty>, the below type trait intentionally asks
    // whether it would be possible to static_cast from _Ty* to const _Ty2*; see N4950 [expr.static.cast]/12.

    // Primary template, the value is used when the substitution fails.
    template <class _Ty2, class = const _Ty2*>
    static constexpr bool _Must_avoid_expired_conversions_from = true;

    // Template specialization, the value is used when the substitution succeeds.
    template <class _Ty2>
    static constexpr bool
        _Must_avoid_expired_conversions_from<_Ty2, decltype(static_cast<const _Ty2*>(static_cast<_Ty*>(nullptr)))> =
        false;
#endif // ^^^ !defined(_M_CEE_PURE) ^^^

    constexpr weak_ptr() noexcept {}

    weak_ptr(const weak_ptr& _Other) noexcept {
        this->_Weakly_construct_from(_Other); // same type, no conversion
    }

    template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
    weak_ptr(const shared_ptr<_Ty2>& _Other) noexcept {
        this->_Weakly_construct_from(_Other); // shared_ptr keeps resource alive during conversion
    }

    template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
    weak_ptr(const weak_ptr<_Ty2>& _Other) noexcept {
#ifdef _M_CEE_PURE
        constexpr bool _Avoid_expired_conversions = true; // slow, but always safe; avoids error LNK1179
#else
        constexpr bool _Avoid_expired_conversions = _Must_avoid_expired_conversions_from<_Ty2>;
#endif

        if constexpr (_Avoid_expired_conversions) {
            this->_Weakly_convert_lvalue_avoiding_expired_conversions(_Other);
        }
        else {
            this->_Weakly_construct_from(_Other);
        }
    }

    weak_ptr(weak_ptr&& _Other) noexcept {
        this->_Move_construct_from(_STD move(_Other));
    }

    template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
    weak_ptr(weak_ptr<_Ty2>&& _Other) noexcept {
#ifdef _M_CEE_PURE
        constexpr bool _Avoid_expired_conversions = true; // slow, but always safe; avoids error LNK1179
#else
        constexpr bool _Avoid_expired_conversions = _Must_avoid_expired_conversions_from<_Ty2>;
#endif

        if constexpr (_Avoid_expired_conversions) {
            this->_Weakly_convert_rvalue_avoiding_expired_conversions(_STD move(_Other));
        }
        else {
            this->_Move_construct_from(_STD move(_Other));
        }
    }

    ~weak_ptr() noexcept {
        this->_Decwref();
    }

    weak_ptr& operator=(const weak_ptr& _Right) noexcept {
        weak_ptr(_Right).swap(*this);
        return *this;
    }

    template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
    weak_ptr& operator=(const weak_ptr<_Ty2>& _Right) noexcept {
        weak_ptr(_Right).swap(*this);
        return *this;
    }

    weak_ptr& operator=(weak_ptr&& _Right) noexcept {
        weak_ptr(_STD move(_Right)).swap(*this);
        return *this;
    }

    template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
    weak_ptr& operator=(weak_ptr<_Ty2>&& _Right) noexcept {
        weak_ptr(_STD move(_Right)).swap(*this);
        return *this;
    }

    template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
    weak_ptr& operator=(const shared_ptr<_Ty2>& _Right) noexcept {
        weak_ptr(_Right).swap(*this);
        return *this;
    }

    void reset() noexcept { // release resource, convert to null weak_ptr object
        weak_ptr{}.swap(*this);
    }

    void swap(weak_ptr& _Other) noexcept {
        this->_Swap(_Other);
    }

    _NODISCARD bool expired() const noexcept {
        return this->use_count() == 0;
    }

    _NODISCARD shared_ptr<_Ty> lock() const noexcept { // convert to shared_ptr
        shared_ptr<_Ty> _Ret;
        (void)_Ret._Construct_from_weak(*this);
        return _Ret;
    }
};

#if _HAS_CXX17
template <class _Ty>
weak_ptr(shared_ptr<_Ty>) -> weak_ptr<_Ty>;
#endif // _HAS_CXX17

_EXPORT_STD template <class _Ty>
void swap(weak_ptr<_Ty>& _Left, weak_ptr<_Ty>& _Right) noexcept {
    _Left.swap(_Right);
}

_EXPORT_STD template <class _Ty>
class enable_shared_from_this { // provide member functions that create shared_ptr to this
public:
    using _Esft_type = enable_shared_from_this;

    _NODISCARD shared_ptr<_Ty> shared_from_this() {
        return shared_ptr<_Ty>(_Wptr);
    }

    _NODISCARD shared_ptr<const _Ty> shared_from_this() const {
        return shared_ptr<const _Ty>(_Wptr);
    }

    _NODISCARD weak_ptr<_Ty> weak_from_this() noexcept {
        return _Wptr;
    }

    _NODISCARD weak_ptr<const _Ty> weak_from_this() const noexcept {
        return _Wptr;
    }

protected:
    constexpr enable_shared_from_this() noexcept : _Wptr() {}

    enable_shared_from_this(const enable_shared_from_this&) noexcept : _Wptr() {
        // construct (must value-initialize _Wptr)
    }

    enable_shared_from_this& operator=(const enable_shared_from_this&) noexcept { // assign (must not change _Wptr)
        return *this;
    }

    ~enable_shared_from_this() = default;

private:
    template <class _Yty>
    friend class shared_ptr;

    mutable weak_ptr<_Ty> _Wptr;
};

_EXPORT_STD template <class _Ty>
struct default_delete { // default deleter for unique_ptr
    constexpr default_delete() noexcept = default;

    template <class _Ty2, enable_if_t<is_convertible_v<_Ty2*, _Ty*>, int> = 0>
    _CONSTEXPR23 default_delete(const default_delete<_Ty2>&) noexcept {}

    _CONSTEXPR23 void operator()(_Ty* _Ptr) const noexcept /* strengthened */ { // delete a pointer
        static_assert(0 < sizeof(_Ty), "can't delete an incomplete type");
        delete _Ptr;
    }
};

template <class _Ty>
struct default_delete<_Ty[]> { // default deleter for unique_ptr to array of unknown size
    constexpr default_delete() noexcept = default;

    template <class _Uty, enable_if_t<is_convertible_v<_Uty(*)[], _Ty(*)[]>, int> = 0>
    _CONSTEXPR23 default_delete(const default_delete<_Uty[]>&) noexcept {}

    template <class _Uty, enable_if_t<is_convertible_v<_Uty(*)[], _Ty(*)[]>, int> = 0>
    _CONSTEXPR23 void operator()(_Uty* _Ptr) const noexcept /* strengthened */ { // delete a pointer
        static_assert(0 < sizeof(_Uty), "can't delete an incomplete type");
        delete[] _Ptr;
    }
};

template <class _Ty, class _Dx_noref, class = void>
struct _Get_deleter_pointer_type { // provide fallback
    using type = _Ty*;
};

template <class _Ty, class _Dx_noref>
struct _Get_deleter_pointer_type<_Ty, _Dx_noref, void_t<typename _Dx_noref::pointer>> { // get _Dx_noref::pointer
    using type = typename _Dx_noref::pointer;
};

template <class _Dx2>
using _Unique_ptr_enable_default_t =
enable_if_t<conjunction_v<negation<is_pointer<_Dx2>>, is_default_constructible<_Dx2>>, int>;

_EXPORT_STD template <class _Ty, class _Dx /* = default_delete<_Ty> */>
class unique_ptr { // non-copyable pointer to an object
public:
    using pointer = typename _Get_deleter_pointer_type<_Ty, remove_reference_t<_Dx>>::type;
    using element_type = _Ty;
    using deleter_type = _Dx;

    template <class _Dx2 = _Dx, _Unique_ptr_enable_default_t<_Dx2> = 0>
    constexpr unique_ptr() noexcept : _Mypair(_Zero_then_variadic_args_t{}) {}

    template <class _Dx2 = _Dx, _Unique_ptr_enable_default_t<_Dx2> = 0>
    constexpr unique_ptr(nullptr_t) noexcept : _Mypair(_Zero_then_variadic_args_t{}) {}

    _CONSTEXPR23 unique_ptr& operator=(nullptr_t) noexcept {
        reset();
        return *this;
    }

    // The Standard depicts these constructors that accept pointer as taking type_identity_t<pointer> to inhibit CTAD.
    // Since pointer is an opaque type alias in our implementation, it inhibits CTAD without extra decoration.
    template <class _Dx2 = _Dx, _Unique_ptr_enable_default_t<_Dx2> = 0>
    _CONSTEXPR23 explicit unique_ptr(pointer _Ptr) noexcept : _Mypair(_Zero_then_variadic_args_t{}, _Ptr) {}

    template <class _Dx2 = _Dx, enable_if_t<is_constructible_v<_Dx2, const _Dx2&>, int> = 0>
    _CONSTEXPR23 unique_ptr(pointer _Ptr, const _Dx& _Dt) noexcept : _Mypair(_One_then_variadic_args_t{}, _Dt, _Ptr) {}

    template <class _Dx2 = _Dx,
        enable_if_t<conjunction_v<negation<is_reference<_Dx2>>, is_constructible<_Dx2, _Dx2>>, int> = 0>
    _CONSTEXPR23 unique_ptr(pointer _Ptr, _Dx&& _Dt) noexcept
        : _Mypair(_One_then_variadic_args_t{}, _STD move(_Dt), _Ptr) {}

    template <class _Dx2 = _Dx,
        enable_if_t<conjunction_v<is_reference<_Dx2>, is_constructible<_Dx2, remove_reference_t<_Dx2>>>, int> = 0>
    unique_ptr(pointer, remove_reference_t<_Dx>&&) = delete;

    template <class _Dx2 = _Dx, enable_if_t<is_move_constructible_v<_Dx2>, int> = 0>
    _CONSTEXPR23 unique_ptr(unique_ptr&& _Right) noexcept
        : _Mypair(_One_then_variadic_args_t{}, _STD forward<_Dx>(_Right.get_deleter()), _Right.release()) {}

    template <class _Ty2, class _Dx2,
        enable_if_t<
        conjunction_v<negation<is_array<_Ty2>>, is_convertible<typename unique_ptr<_Ty2, _Dx2>::pointer, pointer>,
        conditional_t<is_reference_v<_Dx>, is_same<_Dx2, _Dx>, is_convertible<_Dx2, _Dx>>>,
        int> = 0>
    _CONSTEXPR23 unique_ptr(unique_ptr<_Ty2, _Dx2>&& _Right) noexcept
        : _Mypair(_One_then_variadic_args_t{}, _STD forward<_Dx2>(_Right.get_deleter()), _Right.release()) {}

#if _HAS_AUTO_PTR_ETC
    template <class _Ty2,
        enable_if_t<conjunction_v<is_convertible<_Ty2*, _Ty*>, is_same<_Dx, default_delete<_Ty>>>, int> = 0>
    unique_ptr(auto_ptr<_Ty2>&& _Right) noexcept : _Mypair(_Zero_then_variadic_args_t{}, _Right.release()) {}
#endif // _HAS_AUTO_PTR_ETC

    template <class _Ty2, class _Dx2,
        enable_if_t<conjunction_v<negation<is_array<_Ty2>>, is_assignable<_Dx&, _Dx2>,
        is_convertible<typename unique_ptr<_Ty2, _Dx2>::pointer, pointer>>,
        int> = 0>
        _CONSTEXPR23 unique_ptr& operator=(unique_ptr<_Ty2, _Dx2>&& _Right) noexcept {
        reset(_Right.release());
        _Mypair._Get_first() = _STD forward<_Dx2>(_Right._Mypair._Get_first());
        return *this;
    }

    template <class _Dx2 = _Dx, enable_if_t<is_move_assignable_v<_Dx2>, int> = 0>
    _CONSTEXPR23 unique_ptr& operator=(unique_ptr&& _Right) noexcept {
        reset(_Right.release());
        _Mypair._Get_first() = _STD forward<_Dx>(_Right._Mypair._Get_first());
        return *this;
    }

    _CONSTEXPR23 void swap(unique_ptr& _Right) noexcept {
        using _STD swap;
        swap(_Mypair._Myval2, _Right._Mypair._Myval2); // intentional ADL
        swap(_Mypair._Get_first(), _Right._Mypair._Get_first()); // intentional ADL
    }

    _CONSTEXPR23 ~unique_ptr() noexcept {
        if (_Mypair._Myval2) {
            _Mypair._Get_first()(_Mypair._Myval2);
        }
    }

    _NODISCARD _CONSTEXPR23 _Dx& get_deleter() noexcept {
        return _Mypair._Get_first();
    }

    _NODISCARD _CONSTEXPR23 const _Dx& get_deleter() const noexcept {
        return _Mypair._Get_first();
    }

    _NODISCARD _CONSTEXPR23 add_lvalue_reference_t<_Ty> operator*() const noexcept(noexcept(*_STD declval<pointer>())) {
        return *_Mypair._Myval2;
    }

    _NODISCARD _CONSTEXPR23 pointer operator->() const noexcept {
        return _Mypair._Myval2;
    }

    _NODISCARD _CONSTEXPR23 pointer get() const noexcept {
        return _Mypair._Myval2;
    }

    _CONSTEXPR23 explicit operator bool() const noexcept {
        return static_cast<bool>(_Mypair._Myval2);
    }

    _CONSTEXPR23 pointer release() noexcept {
        return _STD exchange(_Mypair._Myval2, nullptr);
    }

    _CONSTEXPR23 void reset(pointer _Ptr = nullptr) noexcept {
        pointer _Old = _STD exchange(_Mypair._Myval2, _Ptr);
        if (_Old) {
            _Mypair._Get_first()(_Old);
        }
    }

    unique_ptr(const unique_ptr&) = delete;
    unique_ptr& operator=(const unique_ptr&) = delete;

private:
    template <class, class>
    friend class unique_ptr;

    _Compressed_pair<_Dx, pointer> _Mypair;
};

template <class _Ty, class _Dx>
class unique_ptr<_Ty[], _Dx> { // non-copyable pointer to an array object
public:
    using pointer = typename _Get_deleter_pointer_type<_Ty, remove_reference_t<_Dx>>::type;
    using element_type = _Ty;
    using deleter_type = _Dx;

    template <class _Dx2 = _Dx, _Unique_ptr_enable_default_t<_Dx2> = 0>
    constexpr unique_ptr() noexcept : _Mypair(_Zero_then_variadic_args_t{}) {}

    template <class _Uty, class _Is_nullptr = is_same<_Uty, nullptr_t>>
    using _Enable_ctor_reset =
        enable_if_t<is_same_v<_Uty, pointer> || _Is_nullptr::value
        || (is_same_v<pointer, element_type*> && is_pointer_v<_Uty>
            && is_convertible_v<remove_pointer_t<_Uty>(*)[], element_type(*)[]>),
        int>;

    template <class _Uty, class _Dx2 = _Dx, _Unique_ptr_enable_default_t<_Dx2> = 0, _Enable_ctor_reset<_Uty> = 0>
    _CONSTEXPR23 explicit unique_ptr(_Uty _Ptr) noexcept : _Mypair(_Zero_then_variadic_args_t{}, _Ptr) {}

    template <class _Uty, class _Dx2 = _Dx, enable_if_t<is_constructible_v<_Dx2, const _Dx2&>, int> = 0,
        _Enable_ctor_reset<_Uty> = 0>
    _CONSTEXPR23 unique_ptr(_Uty _Ptr, const _Dx& _Dt) noexcept : _Mypair(_One_then_variadic_args_t{}, _Dt, _Ptr) {}

    template <class _Uty, class _Dx2 = _Dx,
        enable_if_t<conjunction_v<negation<is_reference<_Dx2>>, is_constructible<_Dx2, _Dx2>>, int> = 0,
        _Enable_ctor_reset<_Uty> = 0>
    _CONSTEXPR23 unique_ptr(_Uty _Ptr, _Dx&& _Dt) noexcept
        : _Mypair(_One_then_variadic_args_t{}, _STD move(_Dt), _Ptr) {}

    template <class _Uty, class _Dx2 = _Dx,
        enable_if_t<conjunction_v<is_reference<_Dx2>, is_constructible<_Dx2, remove_reference_t<_Dx2>>>, int> = 0>
    unique_ptr(_Uty, remove_reference_t<_Dx>&&) = delete;

    template <class _Dx2 = _Dx, enable_if_t<is_move_constructible_v<_Dx2>, int> = 0>
    _CONSTEXPR23 unique_ptr(unique_ptr&& _Right) noexcept
        : _Mypair(_One_then_variadic_args_t{}, _STD forward<_Dx>(_Right.get_deleter()), _Right.release()) {}

    template <class _Dx2 = _Dx, enable_if_t<is_move_assignable_v<_Dx2>, int> = 0>
    _CONSTEXPR23 unique_ptr& operator=(unique_ptr&& _Right) noexcept {
        if (this != _STD addressof(_Right)) {
            reset(_Right.release());
            _Mypair._Get_first() = _STD move(_Right._Mypair._Get_first());
        }

        return *this;
    }

    template <class _Uty, class _Ex, class _More, class _UP_pointer = typename unique_ptr<_Uty, _Ex>::pointer,
        class _UP_element_type = typename unique_ptr<_Uty, _Ex>::element_type>
    using _Enable_conversion = enable_if_t<
        conjunction_v<is_array<_Uty>, is_same<pointer, element_type*>, is_same<_UP_pointer, _UP_element_type*>,
        is_convertible<_UP_element_type(*)[], element_type(*)[]>, _More>,
        int>;

    template <class _Uty, class _Ex,
        _Enable_conversion<_Uty, _Ex, conditional_t<is_reference_v<_Dx>, is_same<_Ex, _Dx>, is_convertible<_Ex, _Dx>>> =
        0>
    _CONSTEXPR23 unique_ptr(unique_ptr<_Uty, _Ex>&& _Right) noexcept
        : _Mypair(_One_then_variadic_args_t{}, _STD forward<_Ex>(_Right.get_deleter()), _Right.release()) {}

    template <class _Uty, class _Ex, _Enable_conversion<_Uty, _Ex, is_assignable<_Dx&, _Ex>> = 0>
    _CONSTEXPR23 unique_ptr& operator=(unique_ptr<_Uty, _Ex>&& _Right) noexcept {
        reset(_Right.release());
        _Mypair._Get_first() = _STD forward<_Ex>(_Right._Mypair._Get_first());
        return *this;
    }

    template <class _Dx2 = _Dx, _Unique_ptr_enable_default_t<_Dx2> = 0>
    constexpr unique_ptr(nullptr_t) noexcept : _Mypair(_Zero_then_variadic_args_t{}) {}

    _CONSTEXPR23 unique_ptr& operator=(nullptr_t) noexcept {
        reset();
        return *this;
    }

    _CONSTEXPR23 void reset(nullptr_t = nullptr) noexcept {
        reset(pointer());
    }

    _CONSTEXPR23 void swap(unique_ptr& _Right) noexcept {
        using _STD swap;
        swap(_Mypair._Myval2, _Right._Mypair._Myval2); // intentional ADL
        swap(_Mypair._Get_first(), _Right._Mypair._Get_first()); // intentional ADL
    }

    _CONSTEXPR23 ~unique_ptr() noexcept {
        if (_Mypair._Myval2) {
            _Mypair._Get_first()(_Mypair._Myval2);
        }
    }

    _NODISCARD _CONSTEXPR23 _Dx& get_deleter() noexcept {
        return _Mypair._Get_first();
    }

    _NODISCARD _CONSTEXPR23 const _Dx& get_deleter() const noexcept {
        return _Mypair._Get_first();
    }

    _NODISCARD _CONSTEXPR23 _Ty& operator[](size_t _Idx) const noexcept /* strengthened */ {
        return _Mypair._Myval2[_Idx];
    }

    _NODISCARD _CONSTEXPR23 pointer get() const noexcept {
        return _Mypair._Myval2;
    }

    _CONSTEXPR23 explicit operator bool() const noexcept {
        return static_cast<bool>(_Mypair._Myval2);
    }

    _CONSTEXPR23 pointer release() noexcept {
        return _STD exchange(_Mypair._Myval2, nullptr);
    }

    template <class _Uty, _Enable_ctor_reset<_Uty, false_type> = 0>
    _CONSTEXPR23 void reset(_Uty _Ptr) noexcept {
        pointer _Old = _STD exchange(_Mypair._Myval2, _Ptr);
        if (_Old) {
            _Mypair._Get_first()(_Old);
        }
    }

    unique_ptr(const unique_ptr&) = delete;
    unique_ptr& operator=(const unique_ptr&) = delete;

private:
    template <class, class>
    friend class unique_ptr;

    _Compressed_pair<_Dx, pointer> _Mypair;
};

_EXPORT_STD template <class _Ty, class... _Types, enable_if_t<!is_array_v<_Ty>, int> = 0>
_NODISCARD_SMART_PTR_ALLOC _CONSTEXPR23 unique_ptr<_Ty> make_unique(_Types&&... _Args) { // make a unique_ptr
    return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));
}

_EXPORT_STD template <class _Ty, enable_if_t<is_array_v<_Ty>&& extent_v<_Ty> == 0, int> = 0>
_NODISCARD_SMART_PTR_ALLOC _CONSTEXPR23 unique_ptr<_Ty> make_unique(const size_t _Size) { // make a unique_ptr
    using _Elem = remove_extent_t<_Ty>;
    return unique_ptr<_Ty>(new _Elem[_Size]());
}

_EXPORT_STD template <class _Ty, class... _Types, enable_if_t<extent_v<_Ty> != 0, int> = 0>
void make_unique(_Types&&...) = delete;

#if _HAS_CXX20
_EXPORT_STD template <class _Ty, enable_if_t<!is_array_v<_Ty>, int> = 0>
_NODISCARD_SMART_PTR_ALLOC _CONSTEXPR23 unique_ptr<_Ty> make_unique_for_overwrite() {
    // make a unique_ptr with default initialization
    return unique_ptr<_Ty>(new _Ty);
}

_EXPORT_STD template <class _Ty, enable_if_t<is_unbounded_array_v<_Ty>, int> = 0>
_NODISCARD_SMART_PTR_ALLOC _CONSTEXPR23 unique_ptr<_Ty> make_unique_for_overwrite(const size_t _Size) {
    // make a unique_ptr with default initialization
    using _Elem = remove_extent_t<_Ty>;
    return unique_ptr<_Ty>(new _Elem[_Size]);
}

_EXPORT_STD template <class _Ty, class... _Types, enable_if_t<is_bounded_array_v<_Ty>, int> = 0>
void make_unique_for_overwrite(_Types&&...) = delete;
#endif // _HAS_CXX20

_EXPORT_STD template <class _Ty, class _Dx, enable_if_t<_Is_swappable<_Dx>::value, int> = 0>
_CONSTEXPR23 void swap(unique_ptr<_Ty, _Dx>& _Left, unique_ptr<_Ty, _Dx>& _Right) noexcept {
    _Left.swap(_Right);
}

_EXPORT_STD template <class _Ty1, class _Dx1, class _Ty2, class _Dx2>
_NODISCARD _CONSTEXPR23 bool operator==(const unique_ptr<_Ty1, _Dx1>& _Left, const unique_ptr<_Ty2, _Dx2>& _Right) {
    return _Left.get() == _Right.get();
}

#if !_HAS_CXX20
template <class _Ty1, class _Dx1, class _Ty2, class _Dx2>
_NODISCARD bool operator!=(const unique_ptr<_Ty1, _Dx1>& _Left, const unique_ptr<_Ty2, _Dx2>& _Right) {
    return !(_Left == _Right);
}
#endif // !_HAS_CXX20

_EXPORT_STD template <class _Ty1, class _Dx1, class _Ty2, class _Dx2>
_NODISCARD bool operator<(const unique_ptr<_Ty1, _Dx1>& _Left, const unique_ptr<_Ty2, _Dx2>& _Right) {
    using _Ptr1 = typename unique_ptr<_Ty1, _Dx1>::pointer;
    using _Ptr2 = typename unique_ptr<_Ty2, _Dx2>::pointer;
    using _Common = common_type_t<_Ptr1, _Ptr2>;
    return less<_Common>{}(_Left.get(), _Right.get());
}

_EXPORT_STD template <class _Ty1, class _Dx1, class _Ty2, class _Dx2>
_NODISCARD bool operator>=(const unique_ptr<_Ty1, _Dx1>& _Left, const unique_ptr<_Ty2, _Dx2>& _Right) {
    return !(_Left < _Right);
}

_EXPORT_STD template <class _Ty1, class _Dx1, class _Ty2, class _Dx2>
_NODISCARD bool operator>(const unique_ptr<_Ty1, _Dx1>& _Left, const unique_ptr<_Ty2, _Dx2>& _Right) {
    return _Right < _Left;
}

_EXPORT_STD template <class _Ty1, class _Dx1, class _Ty2, class _Dx2>
_NODISCARD bool operator<=(const unique_ptr<_Ty1, _Dx1>& _Left, const unique_ptr<_Ty2, _Dx2>& _Right) {
    return !(_Right < _Left);
}

#if _HAS_CXX20
// clang-format off
_EXPORT_STD template <class _Ty1, class _Dx1, class _Ty2, class _Dx2>
    requires three_way_comparable_with<typename unique_ptr<_Ty1, _Dx1>::pointer,
typename unique_ptr<_Ty2, _Dx2>::pointer>
_NODISCARD compare_three_way_result_t<typename unique_ptr<_Ty1, _Dx1>::pointer,
    typename unique_ptr<_Ty2, _Dx2>::pointer>
    operator<=>(const unique_ptr<_Ty1, _Dx1>& _Left, const unique_ptr<_Ty2, _Dx2>& _Right) {
    // clang-format on
    return _Left.get() <=> _Right.get();
}
#endif // _HAS_CXX20

_EXPORT_STD template <class _Ty, class _Dx>
_NODISCARD _CONSTEXPR23 bool operator==(const unique_ptr<_Ty, _Dx>& _Left, nullptr_t) noexcept {
    return !_Left;
}

#if !_HAS_CXX20
template <class _Ty, class _Dx>
_NODISCARD bool operator==(nullptr_t, const unique_ptr<_Ty, _Dx>& _Right) noexcept {
    return !_Right;
}

template <class _Ty, class _Dx>
_NODISCARD bool operator!=(const unique_ptr<_Ty, _Dx>& _Left, nullptr_t) noexcept {
    return !(_Left == nullptr);
}

template <class _Ty, class _Dx>
_NODISCARD bool operator!=(nullptr_t, const unique_ptr<_Ty, _Dx>& _Right) noexcept {
    return !(nullptr == _Right);
}
#endif // !_HAS_CXX20

_EXPORT_STD template <class _Ty, class _Dx>
_NODISCARD _CONSTEXPR23 bool operator<(const unique_ptr<_Ty, _Dx>& _Left, nullptr_t) {
    using _Ptr = typename unique_ptr<_Ty, _Dx>::pointer;
    return less<_Ptr>{}(_Left.get(), nullptr);
}

_EXPORT_STD template <class _Ty, class _Dx>
_NODISCARD _CONSTEXPR23 bool operator<(nullptr_t, const unique_ptr<_Ty, _Dx>& _Right) {
    using _Ptr = typename unique_ptr<_Ty, _Dx>::pointer;
    return less<_Ptr>{}(nullptr, _Right.get());
}

_EXPORT_STD template <class _Ty, class _Dx>
_NODISCARD _CONSTEXPR23 bool operator>=(const unique_ptr<_Ty, _Dx>& _Left, nullptr_t) {
    return !(_Left < nullptr);
}

_EXPORT_STD template <class _Ty, class _Dx>
_NODISCARD _CONSTEXPR23 bool operator>=(nullptr_t, const unique_ptr<_Ty, _Dx>& _Right) {
    return !(nullptr < _Right);
}

_EXPORT_STD template <class _Ty, class _Dx>
_NODISCARD _CONSTEXPR23 bool operator>(const unique_ptr<_Ty, _Dx>& _Left, nullptr_t) {
    return nullptr < _Left;
}

_EXPORT_STD template <class _Ty, class _Dx>
_NODISCARD _CONSTEXPR23 bool operator>(nullptr_t, const unique_ptr<_Ty, _Dx>& _Right) {
    return _Right < nullptr;
}

_EXPORT_STD template <class _Ty, class _Dx>
_NODISCARD _CONSTEXPR23 bool operator<=(const unique_ptr<_Ty, _Dx>& _Left, nullptr_t) {
    return !(nullptr < _Left);
}

_EXPORT_STD template <class _Ty, class _Dx>
_NODISCARD _CONSTEXPR23 bool operator<=(nullptr_t, const unique_ptr<_Ty, _Dx>& _Right) {
    return !(_Right < nullptr);
}

#if _HAS_CXX20
_EXPORT_STD template <class _Ty, class _Dx>
    requires three_way_comparable<typename unique_ptr<_Ty, _Dx>::pointer>
_NODISCARD _CONSTEXPR23 compare_three_way_result_t<typename unique_ptr<_Ty, _Dx>::pointer> operator<=>(
    const unique_ptr<_Ty, _Dx>& _Left, nullptr_t) {
    return _Left.get() <=> static_cast<typename unique_ptr<_Ty, _Dx>::pointer>(nullptr);
}
#endif // _HAS_CXX20

template <class _OutTy, class _PxTy, class = void>
struct _Can_stream_unique_ptr : false_type {};
template <class _OutTy, class _PxTy>
struct _Can_stream_unique_ptr<_OutTy, _PxTy, void_t<decltype(_STD declval<_OutTy>() << _STD declval<_PxTy>().get())>>
    : true_type {};

_EXPORT_STD template <class _Elem, class _Traits, class _Yty, class _Dx,
    enable_if_t<_Can_stream_unique_ptr<basic_ostream<_Elem, _Traits>&, const unique_ptr<_Yty, _Dx>&>::value, int> = 0>
    basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Out, const unique_ptr<_Yty, _Dx>& _Px) {
    // write contained pointer to stream
    _Out << _Px.get();
    return _Out;
}

#if _HAS_GARBAGE_COLLECTION_SUPPORT_DELETED_IN_CXX23
_EXPORT_STD enum class pointer_safety { relaxed, preferred, strict };

_EXPORT_STD inline void declare_reachable(void*) {}

_EXPORT_STD template <class _Ty>
_Ty* undeclare_reachable(_Ty* _Ptr) {
    return _Ptr;
}

_EXPORT_STD inline void declare_no_pointers(char*, size_t) {}

_EXPORT_STD inline void undeclare_no_pointers(char*, size_t) {}

_EXPORT_STD inline pointer_safety get_pointer_safety() noexcept {
    return pointer_safety::relaxed;
}
#endif // _HAS_GARBAGE_COLLECTION_SUPPORT_DELETED_IN_CXX23

_EXPORT_STD template <class _Ty = void>
struct owner_less; // not defined

template <class _Ty>
struct owner_less<shared_ptr<_Ty>> {
    using _FIRST_ARGUMENT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = shared_ptr<_Ty>;
    using _SECOND_ARGUMENT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = shared_ptr<_Ty>;
    using _RESULT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = bool;

    _NODISCARD bool operator()(const shared_ptr<_Ty>& _Left, const shared_ptr<_Ty>& _Right) const noexcept {
        return _Left.owner_before(_Right);
    }

    _NODISCARD bool operator()(const shared_ptr<_Ty>& _Left, const weak_ptr<_Ty>& _Right) const noexcept {
        return _Left.owner_before(_Right);
    }

    _NODISCARD bool operator()(const weak_ptr<_Ty>& _Left, const shared_ptr<_Ty>& _Right) const noexcept {
        return _Left.owner_before(_Right);
    }
};

template <class _Ty>
struct owner_less<weak_ptr<_Ty>> {
    using _FIRST_ARGUMENT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = weak_ptr<_Ty>;
    using _SECOND_ARGUMENT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = weak_ptr<_Ty>;
    using _RESULT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = bool;

    _NODISCARD bool operator()(const weak_ptr<_Ty>& _Left, const weak_ptr<_Ty>& _Right) const noexcept {
        return _Left.owner_before(_Right);
    }

    _NODISCARD bool operator()(const weak_ptr<_Ty>& _Left, const shared_ptr<_Ty>& _Right) const noexcept {
        return _Left.owner_before(_Right);
    }

    _NODISCARD bool operator()(const shared_ptr<_Ty>& _Left, const weak_ptr<_Ty>& _Right) const noexcept {
        return _Left.owner_before(_Right);
    }
};

template <>
struct owner_less<void> {
    template <class _Ty, class _Uty>
    _NODISCARD bool operator()(const shared_ptr<_Ty>& _Left, const shared_ptr<_Uty>& _Right) const noexcept {
        return _Left.owner_before(_Right);
    }

    template <class _Ty, class _Uty>
    _NODISCARD bool operator()(const shared_ptr<_Ty>& _Left, const weak_ptr<_Uty>& _Right) const noexcept {
        return _Left.owner_before(_Right);
    }

    template <class _Ty, class _Uty>
    _NODISCARD bool operator()(const weak_ptr<_Ty>& _Left, const shared_ptr<_Uty>& _Right) const noexcept {
        return _Left.owner_before(_Right);
    }

    template <class _Ty, class _Uty>
    _NODISCARD bool operator()(const weak_ptr<_Ty>& _Left, const weak_ptr<_Uty>& _Right) const noexcept {
        return _Left.owner_before(_Right);
    }

    using is_transparent = int;
};

template <class _Ty, class _Dx>
struct hash<unique_ptr<_Ty, _Dx>> : _Conditionally_enabled_hash<unique_ptr<_Ty, _Dx>,
    is_default_constructible_v<hash<typename unique_ptr<_Ty, _Dx>::pointer>>> {
    static size_t _Do_hash(const unique_ptr<_Ty, _Dx>& _Keyval) noexcept(
        _Is_nothrow_hashable<typename unique_ptr<_Ty, _Dx>::pointer>::value) {
        return hash<typename unique_ptr<_Ty, _Dx>::pointer>{}(_Keyval.get());
    }
};

template <class _Ty>
struct hash<shared_ptr<_Ty>> {
    using _ARGUMENT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = shared_ptr<_Ty>;
    using _RESULT_TYPE_NAME _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS = size_t;

    _NODISCARD _STATIC_CALL_OPERATOR size_t operator()(const shared_ptr<_Ty>& _Keyval) _CONST_CALL_OPERATOR noexcept {
        return hash<typename shared_ptr<_Ty>::element_type*>()(_Keyval.get());
    }
};

#if _HAS_CXX20
_EXPORT_STD template <size_t _Nx, class _Ty>
_NODISCARD_ASSUME_ALIGNED constexpr _Ty* assume_aligned(_Ty* const _Ptr) noexcept /* strengthened */ {
    if (_STD is_constant_evaluated()) {
        return _Ptr;
    }
    else {
        // this enforces the requirement that _Nx be a power of two
        return static_cast<_Ty*>(__builtin_assume_aligned(_Ptr, _Nx));
    }
}
#endif // _HAS_CXX20

extern "C" {
    _CRTIMP2_PURE void __cdecl _Lock_shared_ptr_spin_lock() noexcept;
    _CRTIMP2_PURE void __cdecl _Unlock_shared_ptr_spin_lock() noexcept;
} // extern "C"

struct _Shared_ptr_spin_lock { // class to manage a spin lock for shared_ptr atomic operations
    _Shared_ptr_spin_lock() { // lock the spin lock
        _Lock_shared_ptr_spin_lock();
    }

    ~_Shared_ptr_spin_lock() noexcept { // unlock the spin lock
        _Unlock_shared_ptr_spin_lock();
    }
};

_EXPORT_STD template <class _Ty>
_CXX20_DEPRECATE_OLD_SHARED_PTR_ATOMIC_SUPPORT _NODISCARD bool atomic_is_lock_free(const shared_ptr<_Ty>*) {
    // return true if atomic operations on shared_ptr<_Ty> are lock-free
    return false;
}

_EXPORT_STD template <class _Ty>
_CXX20_DEPRECATE_OLD_SHARED_PTR_ATOMIC_SUPPORT _NODISCARD shared_ptr<_Ty> atomic_load_explicit(
    const shared_ptr<_Ty>* _Ptr, memory_order) {
    // load *_Ptr atomically
    _Shared_ptr_spin_lock _Lock;
    shared_ptr<_Ty> _Result = *_Ptr;
    return _Result;
}

_EXPORT_STD template <class _Ty>
_CXX20_DEPRECATE_OLD_SHARED_PTR_ATOMIC_SUPPORT _NODISCARD shared_ptr<_Ty> atomic_load(
    const shared_ptr<_Ty>* _Ptr) { // load *_Ptr atomically
    return _STD atomic_load_explicit(_Ptr, memory_order_seq_cst);
}

_EXPORT_STD template <class _Ty>
_CXX20_DEPRECATE_OLD_SHARED_PTR_ATOMIC_SUPPORT void atomic_store_explicit(
    shared_ptr<_Ty>* _Ptr, shared_ptr<_Ty> _Other, memory_order) {
    // store _Other to *_Ptr atomically
    _Shared_ptr_spin_lock _Lock;
    _Ptr->swap(_Other);
}

_EXPORT_STD template <class _Ty>
_CXX20_DEPRECATE_OLD_SHARED_PTR_ATOMIC_SUPPORT void atomic_store(
    shared_ptr<_Ty>* _Ptr, shared_ptr<_Ty> _Other) { // store _Other to *_Ptr atomically
    _STD atomic_store_explicit(_Ptr, _STD move(_Other), memory_order_seq_cst);
}

_EXPORT_STD template <class _Ty>
_CXX20_DEPRECATE_OLD_SHARED_PTR_ATOMIC_SUPPORT shared_ptr<_Ty> atomic_exchange_explicit(
    shared_ptr<_Ty>* _Ptr, shared_ptr<_Ty> _Other, memory_order) {
    // copy _Other to *_Ptr and return previous value of *_Ptr atomically
    _Shared_ptr_spin_lock _Lock;
    _Ptr->swap(_Other);
    return _Other;
}

_EXPORT_STD template <class _Ty>
_CXX20_DEPRECATE_OLD_SHARED_PTR_ATOMIC_SUPPORT shared_ptr<_Ty> atomic_exchange(
    shared_ptr<_Ty>* _Ptr, shared_ptr<_Ty> _Other) {
    // copy _Other to *_Ptr and return previous value of *_Ptr atomically
    return _STD atomic_exchange_explicit(_Ptr, _STD move(_Other), memory_order_seq_cst);
}

_EXPORT_STD template <class _Ty>
_CXX20_DEPRECATE_OLD_SHARED_PTR_ATOMIC_SUPPORT bool atomic_compare_exchange_weak_explicit(shared_ptr<_Ty>* _Ptr,
    shared_ptr<_Ty>* _Exp, shared_ptr<_Ty> _Value, memory_order, memory_order) { // atomically compare and exchange
    shared_ptr<_Ty> _Old_exp; // destroyed outside spin lock
    _Shared_ptr_spin_lock _Lock;
    bool _Success = _Ptr->get() == _Exp->get() && !_Ptr->owner_before(*_Exp) && !_Exp->owner_before(*_Ptr);
    if (_Success) {
        _Ptr->swap(_Value);
    }
    else { // match failed
        _Exp->swap(_Old_exp);
        *_Exp = *_Ptr;
    }
    return _Success;
}

_EXPORT_STD template <class _Ty>
_CXX20_DEPRECATE_OLD_SHARED_PTR_ATOMIC_SUPPORT bool atomic_compare_exchange_weak(
    shared_ptr<_Ty>* _Ptr, shared_ptr<_Ty>* _Exp, shared_ptr<_Ty> _Value) {
    // atomically compare and exchange
    return _STD atomic_compare_exchange_weak_explicit(
        _Ptr, _Exp, _STD move(_Value), memory_order_seq_cst, memory_order_seq_cst);
}

_EXPORT_STD template <class _Ty>
_CXX20_DEPRECATE_OLD_SHARED_PTR_ATOMIC_SUPPORT bool atomic_compare_exchange_strong_explicit(shared_ptr<_Ty>* _Ptr,
    shared_ptr<_Ty>* _Exp, shared_ptr<_Ty> _Value, memory_order, memory_order) { // atomically compare and exchange
    return _STD atomic_compare_exchange_weak_explicit(
        _Ptr, _Exp, _STD move(_Value), memory_order_seq_cst, memory_order_seq_cst);
}

_EXPORT_STD template <class _Ty>
_CXX20_DEPRECATE_OLD_SHARED_PTR_ATOMIC_SUPPORT bool atomic_compare_exchange_strong(
    shared_ptr<_Ty>* _Ptr, shared_ptr<_Ty>* _Exp, shared_ptr<_Ty> _Value) {
    // atomically compare and exchange
    return _STD atomic_compare_exchange_strong_explicit(
        _Ptr, _Exp, _STD move(_Value), memory_order_seq_cst, memory_order_seq_cst);
}

#if _HAS_CXX20
template <class _Ty>
class alignas(2 * sizeof(void*)) _Atomic_ptr_base {
    // overalignment is to allow potential future use of cmpxchg16b
protected:
    constexpr _Atomic_ptr_base() noexcept = default;

    _Atomic_ptr_base(remove_extent_t<_Ty>* const _Px, _Ref_count_base* const _Ref) noexcept
        : _Ptr(_Px), _Repptr(_Ref) {}

    void _Wait(remove_extent_t<_Ty>* _Old_ptr, _Ref_count_base* const _Old_rep, memory_order) const noexcept {
        unsigned long _Remaining_timeout = 16; // milliseconds
        const unsigned long _Max_timeout = 1048576; // milliseconds, ~17.5 minutes
        for (;;) {
            auto _Rep = _Repptr._Lock_and_load();
            bool _Equal = _Ptr.load(memory_order_relaxed) == _Old_ptr && _Rep == _Old_rep;
            _Repptr._Store_and_unlock(_Rep);
            if (!_Equal) {
                break;
            }
            ::__std_atomic_wait_direct(
                _STD addressof(_Ptr), _STD addressof(_Old_ptr), sizeof(_Old_ptr), _Remaining_timeout);
            _Remaining_timeout = (_STD min)(_Max_timeout, _Remaining_timeout * 2);
        }
    }

    void notify_one() noexcept {
        _Ptr.notify_one();
    }

    void notify_all() noexcept {
        _Ptr.notify_all();
    }

    atomic<remove_extent_t<_Ty>*> _Ptr{ nullptr };
    mutable _Locked_pointer<_Ref_count_base> _Repptr;
};

template <class _Ty>
struct atomic<shared_ptr<_Ty>> : private _Atomic_ptr_base<_Ty> {
private:
    using _Base = _Atomic_ptr_base<_Ty>;

public:
    using value_type = shared_ptr<_Ty>;

    static constexpr bool is_always_lock_free = false;

    _NODISCARD bool is_lock_free() const noexcept {
        return false;
    }

    void store(shared_ptr<_Ty> _Value, const memory_order _Order = memory_order_seq_cst) noexcept {
        _Check_store_memory_order(_Order);
        const auto _Rep = this->_Repptr._Lock_and_load();
        remove_extent_t<_Ty>* const _Tmp = _Value._Ptr;
        _Value._Ptr = this->_Ptr.load(memory_order_relaxed);
        this->_Ptr.store(_Tmp, memory_order_relaxed);
        this->_Repptr._Store_and_unlock(_Value._Rep);
        _Value._Rep = _Rep;
    }

    _NODISCARD shared_ptr<_Ty> load(const memory_order _Order = memory_order_seq_cst) const noexcept {
        _Check_load_memory_order(_Order);
        shared_ptr<_Ty> _Result;
        const auto _Rep = this->_Repptr._Lock_and_load();
        _Result._Ptr = this->_Ptr.load(memory_order_relaxed);
        _Result._Rep = _Rep;
        _Result._Incref();
        this->_Repptr._Store_and_unlock(_Rep);
        return _Result;
    }

    operator shared_ptr<_Ty>() const noexcept {
        return load();
    }

    shared_ptr<_Ty> exchange(shared_ptr<_Ty> _Value, const memory_order _Order = memory_order_seq_cst) noexcept {
        _Check_memory_order(static_cast<unsigned int>(_Order));
        shared_ptr<_Ty> _Result;
        _Result._Rep = this->_Repptr._Lock_and_load();
        _Result._Ptr = this->_Ptr.load(memory_order_relaxed);
        this->_Ptr.store(_Value._Ptr, memory_order_relaxed);
        this->_Repptr._Store_and_unlock(_Value._Rep);
        _Value._Ptr = nullptr; // ownership of _Value ref has been given to this, silence decrement
        _Value._Rep = nullptr;
        return _Result;
    }

    bool compare_exchange_weak(shared_ptr<_Ty>& _Expected, shared_ptr<_Ty> _Desired, const memory_order _Success,
        const memory_order _Failure) noexcept {
        return compare_exchange_strong(_Expected, _STD move(_Desired), _Combine_cas_memory_orders(_Success, _Failure));
    }

    bool compare_exchange_strong(shared_ptr<_Ty>& _Expected, shared_ptr<_Ty> _Desired, const memory_order _Success,
        const memory_order _Failure) noexcept {
        return compare_exchange_strong(_Expected, _STD move(_Desired), _Combine_cas_memory_orders(_Success, _Failure));
    }

    bool compare_exchange_weak(shared_ptr<_Ty>& _Expected, shared_ptr<_Ty> _Desired,
        const memory_order _Order = memory_order_seq_cst) noexcept {
        return compare_exchange_strong(_Expected, _STD move(_Desired), _Order);
    }

    bool compare_exchange_strong(shared_ptr<_Ty>& _Expected, shared_ptr<_Ty> _Desired,
        const memory_order _Order = memory_order_seq_cst) noexcept {
        _Check_memory_order(static_cast<unsigned int>(_Order));
        auto _Rep = this->_Repptr._Lock_and_load();
        if (this->_Ptr.load(memory_order_relaxed) == _Expected._Ptr && _Rep == _Expected._Rep) {
            remove_extent_t<_Ty>* const _Tmp = _Desired._Ptr;
            _Desired._Ptr = this->_Ptr.load(memory_order_relaxed);
            this->_Ptr.store(_Tmp, memory_order_relaxed);
            _STD swap(_Rep, _Desired._Rep);
            this->_Repptr._Store_and_unlock(_Rep);
            return true;
        }
        _Ref_count_base* _Expected_rep = _Expected._Rep;
        _Expected._Ptr = this->_Ptr.load(memory_order_relaxed);
        _Expected._Rep = _Rep;
        _Expected._Incref();
        this->_Repptr._Store_and_unlock(_Rep);
        if (_Expected_rep) {
            _Expected_rep->_Decref();
        }
        return false;
    }

    void wait(shared_ptr<_Ty> _Old, memory_order _Order = memory_order_seq_cst) const noexcept {
        this->_Wait(_Old._Ptr, _Old._Rep, _Order);
    }

    using _Base::notify_all;
    using _Base::notify_one;

    constexpr atomic() noexcept = default;

    constexpr atomic(nullptr_t) noexcept : atomic() {}

    atomic(const shared_ptr<_Ty> _Value) noexcept : _Base(_Value._Ptr, _Value._Rep) {
        _Value._Incref();
    }

    atomic(const atomic&) = delete;
    void operator=(const atomic&) = delete;

    void operator=(shared_ptr<_Ty> _Value) noexcept {
        store(_STD move(_Value));
    }

    void operator=(nullptr_t) noexcept {
        store(nullptr);
    }

    ~atomic() {
        const auto _Rep = this->_Repptr._Unsafe_load_relaxed();
        if (_Rep) {
            _Rep->_Decref();
        }
    }
};

template <class _Ty>
struct atomic<weak_ptr<_Ty>> : private _Atomic_ptr_base<_Ty> {
private:
    using _Base = _Atomic_ptr_base<_Ty>;

public:
    using value_type = weak_ptr<_Ty>;

    static constexpr bool is_always_lock_free = false;

    _NODISCARD bool is_lock_free() const noexcept {
        return false;
    }

    void store(weak_ptr<_Ty> _Value, const memory_order _Order = memory_order_seq_cst) noexcept {
        _Check_store_memory_order(_Order);
        const auto _Rep = this->_Repptr._Lock_and_load();
        remove_extent_t<_Ty>* const _Tmp = _Value._Ptr;
        _Value._Ptr = this->_Ptr.load(memory_order_relaxed);
        this->_Ptr.store(_Tmp, memory_order_relaxed);
        this->_Repptr._Store_and_unlock(_Value._Rep);
        _Value._Rep = _Rep;
    }

    _NODISCARD weak_ptr<_Ty> load(const memory_order _Order = memory_order_seq_cst) const noexcept {
        _Check_load_memory_order(_Order);
        weak_ptr<_Ty> _Result;
        const auto _Rep = this->_Repptr._Lock_and_load();
        _Result._Ptr = this->_Ptr.load(memory_order_relaxed);
        _Result._Rep = _Rep;
        _Result._Incwref();
        this->_Repptr._Store_and_unlock(_Rep);
        return _Result;
    }

    operator weak_ptr<_Ty>() const noexcept {
        return load();
    }

    weak_ptr<_Ty> exchange(weak_ptr<_Ty> _Value, const memory_order _Order = memory_order_seq_cst) noexcept {
        _Check_memory_order(static_cast<unsigned int>(_Order));
        weak_ptr<_Ty> _Result;
        _Result._Rep = this->_Repptr._Lock_and_load();
        _Result._Ptr = this->_Ptr.load(memory_order_relaxed);
        this->_Ptr.store(_Value._Ptr, memory_order_relaxed);
        this->_Repptr._Store_and_unlock(_Value._Rep);
        _Value._Ptr = nullptr; // ownership of _Value ref has been given to this, silence decrement
        _Value._Rep = nullptr;
        return _Result;
    }

    bool compare_exchange_weak(weak_ptr<_Ty>& _Expected, weak_ptr<_Ty> _Desired, const memory_order _Success,
        const memory_order _Failure) noexcept {
        return compare_exchange_strong(_Expected, _STD move(_Desired), _Combine_cas_memory_orders(_Success, _Failure));
    }

    bool compare_exchange_strong(weak_ptr<_Ty>& _Expected, weak_ptr<_Ty> _Desired, const memory_order _Success,
        const memory_order _Failure) noexcept {
        return compare_exchange_strong(_Expected, _STD move(_Desired), _Combine_cas_memory_orders(_Success, _Failure));
    }

    bool compare_exchange_weak(
        weak_ptr<_Ty>& _Expected, weak_ptr<_Ty> _Desired, const memory_order _Order = memory_order_seq_cst) noexcept {
        return compare_exchange_strong(_Expected, _STD move(_Desired), _Order);
    }

    bool compare_exchange_strong(
        weak_ptr<_Ty>& _Expected, weak_ptr<_Ty> _Desired, const memory_order _Order = memory_order_seq_cst) noexcept {
        _Check_memory_order(static_cast<unsigned int>(_Order));
        auto _Rep = this->_Repptr._Lock_and_load();
        if (this->_Ptr.load(memory_order_relaxed) == _Expected._Ptr && _Rep == _Expected._Rep) {
            remove_extent_t<_Ty>* const _Tmp = _Desired._Ptr;
            _Desired._Ptr = this->_Ptr.load(memory_order_relaxed);
            this->_Ptr.store(_Tmp, memory_order_relaxed);
            _STD swap(_Rep, _Desired._Rep);
            this->_Repptr._Store_and_unlock(_Rep);
            return true;
        }
        const auto _Expected_rep = _Expected._Rep;
        _Expected._Ptr = this->_Ptr.load(memory_order_relaxed);
        _Expected._Rep = _Rep;
        _Expected._Incwref();
        this->_Repptr._Store_and_unlock(_Rep);
        if (_Expected_rep) {
            _Expected_rep->_Decwref();
        }
        return false;
    }

    void wait(weak_ptr<_Ty> _Old, memory_order _Order = memory_order_seq_cst) const noexcept {
        this->_Wait(_Old._Ptr, _Old._Rep, _Order);
    }

    using _Base::notify_all;
    using _Base::notify_one;

    constexpr atomic() noexcept = default;

    atomic(const weak_ptr<_Ty> _Value) noexcept : _Base(_Value._Ptr, _Value._Rep) {
        _Value._Incwref();
    }

    atomic(const atomic&) = delete;
    void operator=(const atomic&) = delete;

    void operator=(weak_ptr<_Ty> _Value) noexcept {
        store(_STD move(_Value));
    }

    ~atomic() {
        const auto _Rep = this->_Repptr._Unsafe_load_relaxed();
        if (_Rep) {
            _Rep->_Decwref();
        }
    }
};
#endif // _HAS_CXX20

#if _HAS_CXX23
template <class _Ty>
struct _Pointer_of_helper {};

template <_Has_member_pointer _Ty>
struct _Pointer_of_helper<_Ty> {
    using type = _Ty::pointer;
};

template <_Has_member_element_type _Ty>
    requires (!_Has_member_pointer<_Ty>)
struct _Pointer_of_helper<_Ty> {
    using type = _Ty::element_type*;
};

// clang-format off
template <class _Ty>
    requires (!_Has_member_element_type<_Ty> && !_Has_member_pointer<_Ty>
&& _Has_member_element_type<pointer_traits<_Ty>>)
struct _Pointer_of_helper<_Ty> {
    using type = pointer_traits<_Ty>::element_type*;
};
// clang-format on

template <class _Ty>
using _Pointer_of = _Pointer_of_helper<_Ty>::type;

template <class _Ty, class _Uty>
struct _Pointer_of_or_helper {
    using type = _Uty;
};

template <class _Ty, class _Uty>
    requires requires { typename _Pointer_of<_Ty>; }
struct _Pointer_of_or_helper<_Ty, _Uty> {
    using type = _Pointer_of<_Ty>;
};

template <class _Ty, class _Uty>
using _Pointer_of_or = _Pointer_of_or_helper<_Ty, _Uty>::type;

template <class _SmartPtr, class _Sp, class _Pointer, class... _ArgsT>
concept _Resettable_pointer = requires(_SmartPtr & _Smart_ptr, _Pointer _Ptr, _ArgsT&&... _Args) {
    _Smart_ptr.reset(static_cast<_Sp>(_Ptr), _STD forward<_ArgsT>(_Args)...);
};

_EXPORT_STD template <class _SmartPtr, class _Pointer, class... _ArgsT>
class out_ptr_t {
    static_assert(!_Is_specialization_v<_SmartPtr, shared_ptr> || sizeof...(_ArgsT) != 0,
        "out_ptr_t with shared_ptr requires a deleter (N4950 [out.ptr.t]/3)");

public:
    explicit out_ptr_t(_SmartPtr& _Smart_ptr_, _ArgsT... _Args_) noexcept(
        is_nothrow_constructible_v<tuple<_ArgsT...>, _ArgsT...>) /* strengthened */
        : _Smart_ptr(_Smart_ptr_),
        _Mypair(_One_then_variadic_args_t{}, tuple<_ArgsT...>{_STD forward<_ArgsT>(_Args_)...}) {
        constexpr bool _Is_resettable = requires { _Smart_ptr.reset(); }; // TRANSITION, DevCom-10291456
        if constexpr (_Is_resettable) {
            _Smart_ptr.reset();
        }
        else {
            static_assert(is_constructible_v<_SmartPtr>, "the adapted pointer type must be default constructible.");
            _Smart_ptr = _SmartPtr();
        }
    }

    out_ptr_t(const out_ptr_t&) = delete;

    ~out_ptr_t() {
        if (!_Get_ptr()) {
            return;
        }

        _STD apply(
            [this](auto&&... _Args_) {
                using _Sp = _Pointer_of_or<_SmartPtr, _Pointer>;
                if constexpr (_Resettable_pointer<_SmartPtr, _Sp, _Pointer, _ArgsT...>) {
                    _Smart_ptr.reset(static_cast<_Sp>(_Get_ptr()), _STD forward<_ArgsT>(_Args_)...);
                }
                else {
                    static_assert(is_constructible_v<_SmartPtr, _Sp, _ArgsT...>, "(N4950 [out.ptr.t]/9.3)");
                    _Smart_ptr = _SmartPtr(static_cast<_Sp>(_Get_ptr()), _STD forward<_ArgsT>(_Args_)...);
                }
            },
            _STD move(_Get_args()));
    }

    operator _Pointer* () const noexcept {
        return _STD addressof(_Get_ptr());
    }

    operator void** () const noexcept
        requires (!is_same_v<_Pointer, void*>)
    {
        static_assert(is_pointer_v<_Pointer>, "conversion of out_ptr_t<Smart, Pointer, Args...> to void** requires "
            "Pointer to be a raw pointer (N4950 [out.ptr.t]/13)");
        return reinterpret_cast<void**>(_STD addressof(_Get_ptr()));
    }

private:
    _NODISCARD _Pointer& _Get_ptr() const noexcept {
        return const_cast<_Pointer&>(_Mypair._Myval2);
    }

    _NODISCARD tuple<_ArgsT...>& _Get_args() noexcept {
        return _Mypair._Get_first();
    }

    _SmartPtr& _Smart_ptr;
    _Compressed_pair<tuple<_ArgsT...>, _Pointer> _Mypair;
};

_EXPORT_STD template <class _Pointer = void, class _SmartPtr, class... _ArgsT>
_NODISCARD auto out_ptr(_SmartPtr& _Smart_ptr, _ArgsT&&... _Args) {
    if constexpr (is_void_v<_Pointer>) {
        return out_ptr_t<_SmartPtr, _Pointer_of<_SmartPtr>, _ArgsT&&...>(_Smart_ptr, _STD forward<_ArgsT>(_Args)...);
    }
    else {
        return out_ptr_t<_SmartPtr, _Pointer, _ArgsT&&...>(_Smart_ptr, _STD forward<_ArgsT>(_Args)...);
    }
}

_EXPORT_STD template <class _SmartPtr, class _Pointer, class... _ArgsT>
class inout_ptr_t {
    static_assert(!_Is_specialization_v<_SmartPtr, shared_ptr>,
        "inout_ptr_t doesn't work with shared_ptr (N4950 [inout.ptr.t]/3)");

private:
    _NODISCARD static auto _Get_ptr_from_smart(_SmartPtr& _Smart_ptr) noexcept
        requires is_pointer_v<_SmartPtr>
    {
        return _Smart_ptr;
    }

    _NODISCARD static auto _Get_ptr_from_smart(_SmartPtr& _Smart_ptr) noexcept(noexcept(_Smart_ptr.get())) {
        return _Smart_ptr.get();
    }

public:
    explicit inout_ptr_t(_SmartPtr& _Smart_ptr_, _ArgsT... _Args_) noexcept(
        is_nothrow_constructible_v<tuple<_ArgsT...>, _ArgsT...> //
        && noexcept(_Get_ptr_from_smart(_Smart_ptr_))) /* strengthened */
        : _Smart_ptr(_Smart_ptr_),
        _Mypair(_One_then_variadic_args_t{}, tuple<_ArgsT...>{_STD forward<_ArgsT>(_Args_)...},
            _Get_ptr_from_smart(_Smart_ptr_)) {}

    inout_ptr_t(const inout_ptr_t&) = delete;

    ~inout_ptr_t() {
        if constexpr (!is_pointer_v<_SmartPtr>) {
            _Smart_ptr.release();

            if (!_Get_ptr()) {
                return;
            }
        }

        _STD apply(
            [this](auto&&... _Args_) {
                using _Sp = _Pointer_of_or<_SmartPtr, _Pointer>;
                if constexpr (is_pointer_v<_SmartPtr>) {
                    _Smart_ptr = _SmartPtr(static_cast<_Sp>(_Get_ptr()), _STD forward<_ArgsT>(_Args_)...);
                }
                else if constexpr (_Resettable_pointer<_SmartPtr, _Sp, _Pointer, _ArgsT...>) {
                    _Smart_ptr.reset(static_cast<_Sp>(_Get_ptr()), _STD forward<_ArgsT>(_Args_)...);
                }
                else {
                    static_assert(is_constructible_v<_SmartPtr, _Sp, _ArgsT...>, "(N4950 [inout.ptr.t]/11.4)");
                    _Smart_ptr = _SmartPtr(static_cast<_Sp>(_Get_ptr()), _STD forward<_ArgsT>(_Args_)...);
                }
            },
            _STD move(_Get_args()));
    }

    operator _Pointer* () const noexcept {
        return _STD addressof(_Get_ptr());
    }

    operator void** () const noexcept
        requires (!is_same_v<_Pointer, void*>)
    {
        static_assert(is_pointer_v<_Pointer>, "conversion of inout_ptr_t<Smart, Pointer, Args...> to void** requires "
            "Pointer to be a raw pointer (N4950 [inout.ptr.t]/15)");
        return reinterpret_cast<void**>(_STD addressof(_Get_ptr()));
    }

private:
    _NODISCARD _Pointer& _Get_ptr() const noexcept {
        return const_cast<_Pointer&>(_Mypair._Myval2);
    }

    _NODISCARD tuple<_ArgsT...>& _Get_args() noexcept {
        return _Mypair._Get_first();
    }

    _SmartPtr& _Smart_ptr;
    _Compressed_pair<tuple<_ArgsT...>, _Pointer> _Mypair;
};

_EXPORT_STD template <class _Pointer = void, class _SmartPtr, class... _ArgsT>
_NODISCARD auto inout_ptr(_SmartPtr& _Smart_ptr, _ArgsT&&... _Args) {
    if constexpr (is_void_v<_Pointer>) {
        return inout_ptr_t<_SmartPtr, _Pointer_of<_SmartPtr>, _ArgsT&&...>(_Smart_ptr, _STD forward<_ArgsT>(_Args)...);
    }
    else {
        return inout_ptr_t<_SmartPtr, _Pointer, _ArgsT&&...>(_Smart_ptr, _STD forward<_ArgsT>(_Args)...);
    }
}
#endif // _HAS_CXX23

#if _HAS_TR1_NAMESPACE
namespace _DEPRECATE_TR1_NAMESPACE tr1 {
    using _STD allocate_shared;
    using _STD bad_weak_ptr;
    using _STD const_pointer_cast;
    using _STD dynamic_pointer_cast;
    using _STD enable_shared_from_this;
    using _STD get_deleter;
    using _STD make_shared;
    using _STD shared_ptr;
    using _STD static_pointer_cast;
    using _STD swap;
    using _STD weak_ptr;
} // namespace _DEPRECATE_TR1_NAMESPACE tr1
#endif // _HAS_TR1_NAMESPACE

_STD_END

// TRANSITION, non-_Ugly attribute tokens
#pragma pop_macro("msvc")

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _MEMORY_


// xfacet internal header

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

// This header is used to compile the import library (via locale0_implib.cpp => locale0.cpp => xfacet).
// MAJOR LIMITATIONS apply to what can be included here!
// Before editing this file, read: /docs/import_library.md

#ifndef _XFACET_
#define _XFACET_
#if _STL_COMPILER_PREPROCESSOR

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_STD_BEGIN
extern "C++" class _CRTIMP2_PURE_IMPORT _Facet_base { // code for reference counting a facet
public:
    virtual __CLR_OR_THIS_CALL ~_Facet_base() noexcept {} // ensure that derived classes can be destroyed properly

    // increment use count
    virtual void __CLR_OR_THIS_CALL _Incref() noexcept = 0;

    // decrement use count
    virtual _Facet_base* __CLR_OR_THIS_CALL _Decref() noexcept = 0;
};

#if defined(_M_CEE)
void __CLRCALL_OR_CDECL _Facet_Register_m(_Facet_base*);
#else // ^^^ defined(_M_CEE) / !defined(_M_CEE) vvv
extern "C++" void __CLRCALL_OR_CDECL _Facet_Register(_Facet_base*);
#endif // ^^^ !defined(_M_CEE) ^^^
_STD_END
#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _XFACET_

// xlocinfo internal header

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#ifndef _XLOCINFO_
#define _XLOCINFO_
#if _STL_COMPILER_PREPROCESSOR
// __msvc_xlocinfo_types.hpp internal header (core)

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#ifndef __MSVC_XLOCINFO_TYPES_HPP
#define __MSVC_XLOCINFO_TYPES_HPP
#if _STL_COMPILER_PREPROCESSOR

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_EXTERN_C_UNLESS_PURE

struct _Collvec { // stuff needed by _Strcoll, etc.
    unsigned int _Page; // UINT
    wchar_t* _LocaleName;
};

struct _Ctypevec { // stuff needed by _Tolower, etc.
    unsigned int _Page; // UINT
    const short* _Table;
    int _Delfl;
    wchar_t* _LocaleName;
};

struct _Cvtvec { // stuff needed by _Mbrtowc, etc.
    unsigned int _Page; // UINT
    unsigned int _Mbcurmax;
    int _Isclocale; // LCID == _CLOCALEHANDLE
    unsigned char _Isleadbyte[32]; // 256 bits
};

_END_EXTERN_C_UNLESS_PURE

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#endif // _STL_COMPILER_PREPROCESSOR
#endif // __MSVC_XLOCINFO_TYPES_HPP

// cctype standard header (core)

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#ifndef _CCTYPE_
#define _CCTYPE_
#if _STL_COMPILER_PREPROCESSOR

//
// ctype.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// This file declares the narrow character (char) classification functionality.
//
#pragma once
#ifndef _INC_CTYPE // include guard for 3rd party interop
#define _INC_CTYPE

//
// corecrt_wctype.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// This file declares the wide character (wchar_t) classification functionality,
// shared by <ctype.h>, <wchar.h>, and <wctype.h>.
//
#pragma once
#pragma warning(push)
#pragma warning(disable: _UCRT_DISABLED_WARNINGS)
_UCRT_DISABLE_CLANG_WARNINGS

_CRT_BEGIN_C_HEADER



#define WEOF ((wint_t)(0xFFFF))



// This declaration allows the user access to the ctype look-up
// array _ctype defined in ctype.obj by simply including ctype.h
#ifndef _CTYPE_DISABLE_MACROS

#if defined _CRT_DISABLE_PERFCRIT_LOCKS && !defined _DLL
#define __PCTYPE_FUNC  _pctype
#else
#define __PCTYPE_FUNC __pctype_func()
#endif

_ACRTIMP const unsigned short* __cdecl __pctype_func(void);
_ACRTIMP const wctype_t* __cdecl __pwctype_func(void);

#ifdef _CRT_DECLARE_GLOBAL_VARIABLES_DIRECTLY
extern const unsigned short* _pctype;
extern const wctype_t* _pwctype;
#else
#define _pctype  (__pctype_func())
#define _pwctype (__pwctype_func())
#endif
#endif

// Bit masks for the possible character types
#define _UPPER   0x01     // uppercase letter
#define _LOWER   0x02     // lowercase letter
#define _DIGIT   0x04     // digit[0-9]
#define _SPACE   0x08     // tab, carriage return, newline, vertical tab, or form feed
#define _PUNCT   0x10     // punctuation character
#define _CONTROL 0x20     // control character
#define _BLANK   0x40     // space char (tab is handled separately)
#define _HEX     0x80     // hexadecimal digit

#define _LEADBYTE 0x8000                    // multibyte leadbyte
#define _ALPHA   (0x0100 | _UPPER | _LOWER) // alphabetic character



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Wide Character Classification and Conversion Functions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
_Check_return_ _ACRTIMP int __cdecl iswalnum(_In_ wint_t _C);
_Check_return_ _ACRTIMP int __cdecl iswalpha(_In_ wint_t _C);
_Check_return_ _ACRTIMP int __cdecl iswascii(_In_ wint_t _C);
_Check_return_ _ACRTIMP int __cdecl iswblank(_In_ wint_t _C);
_Check_return_ _ACRTIMP int __cdecl iswcntrl(_In_ wint_t _C);

_When_(_Param_(1) == 0, _Post_equal_to_(0))
_Check_return_ _ACRTIMP int __cdecl iswdigit(_In_ wint_t _C);

_Check_return_ _ACRTIMP int __cdecl iswgraph(_In_ wint_t _C);
_Check_return_ _ACRTIMP int __cdecl iswlower(_In_ wint_t _C);
_Check_return_ _ACRTIMP int __cdecl iswprint(_In_ wint_t _C);
_Check_return_ _ACRTIMP int __cdecl iswpunct(_In_ wint_t _C);
_Check_return_ _ACRTIMP int __cdecl iswspace(_In_ wint_t _C);
_Check_return_ _ACRTIMP int __cdecl iswupper(_In_ wint_t _C);
_Check_return_ _ACRTIMP int __cdecl iswxdigit(_In_ wint_t _C);
_Check_return_ _ACRTIMP int __cdecl __iswcsymf(_In_ wint_t _C);
_Check_return_ _ACRTIMP int __cdecl __iswcsym(_In_ wint_t _C);

_Check_return_ _ACRTIMP int __cdecl _iswalnum_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP int __cdecl _iswalpha_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP int __cdecl _iswblank_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP int __cdecl _iswcntrl_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP int __cdecl _iswdigit_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP int __cdecl _iswgraph_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP int __cdecl _iswlower_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP int __cdecl _iswprint_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP int __cdecl _iswpunct_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP int __cdecl _iswspace_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP int __cdecl _iswupper_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP int __cdecl _iswxdigit_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP int __cdecl _iswcsymf_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP int __cdecl _iswcsym_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale);


_Check_return_ _ACRTIMP wint_t __cdecl towupper(_In_ wint_t _C);
_Check_return_ _ACRTIMP wint_t __cdecl towlower(_In_ wint_t _C);
_Check_return_ _ACRTIMP int    __cdecl iswctype(_In_ wint_t _C, _In_ wctype_t _Type);

_Check_return_ _ACRTIMP wint_t __cdecl _towupper_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP wint_t __cdecl _towlower_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP int    __cdecl _iswctype_l(_In_ wint_t _C, _In_ wctype_t _Type, _In_opt_ _locale_t _Locale);


#ifdef _CRT_USE_WINAPI_FAMILY_DESKTOP_APP
_Check_return_ _ACRTIMP int __cdecl isleadbyte(_In_ int _C);
_Check_return_ _ACRTIMP int __cdecl _isleadbyte_l(_In_ int _C, _In_opt_ _locale_t _Locale);

_CRT_OBSOLETE(iswctype) _DCRTIMP int __cdecl is_wctype(_In_ wint_t _C, _In_ wctype_t _Type);
#endif



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Macro and Inline Definitions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#if !defined __cplusplus || defined _M_CEE_PURE || defined MRTDLL || defined _CORECRT_BUILD
#ifndef _CTYPE_DISABLE_MACROS

#define iswalpha(_c)  (iswctype(_c, _ALPHA))
#define iswupper(_c)  (iswctype(_c, _UPPER))
#define iswlower(_c)  (iswctype(_c, _LOWER))
#define iswdigit(_c)  (iswctype(_c, _DIGIT))
#define iswxdigit(_c) (iswctype(_c, _HEX))
#define iswspace(_c)  (iswctype(_c, _SPACE))
#define iswpunct(_c)  (iswctype(_c, _PUNCT))
#define iswblank(_c)  (((_c) == '\t') ? _BLANK : iswctype(_c,_BLANK) )
#define iswalnum(_c)  (iswctype(_c, _ALPHA | _DIGIT))
#define iswprint(_c)  (iswctype(_c, _BLANK | _PUNCT | _ALPHA | _DIGIT))
#define iswgraph(_c)  (iswctype(_c, _PUNCT | _ALPHA | _DIGIT))
#define iswcntrl(_c)  (iswctype(_c, _CONTROL))
#define iswascii(_c)  ((unsigned)(_c) < 0x80)

#define _iswalpha_l(_c,_p)  (iswctype(_c, _ALPHA))
#define _iswupper_l(_c,_p)  (iswctype(_c, _UPPER))
#define _iswlower_l(_c,_p)  (iswctype(_c, _LOWER))
#define _iswdigit_l(_c,_p)  (iswctype(_c, _DIGIT))
#define _iswxdigit_l(_c,_p) (iswctype(_c, _HEX))
#define _iswspace_l(_c,_p)  (iswctype(_c, _SPACE))
#define _iswpunct_l(_c,_p)  (iswctype(_c, _PUNCT))
#define _iswblank_l(_c,_p)  (iswctype(_c, _BLANK))
#define _iswalnum_l(_c,_p)  (iswctype(_c, _ALPHA | _DIGIT))
#define _iswprint_l(_c,_p)  (iswctype(_c, _BLANK | _PUNCT | _ALPHA | _DIGIT))
#define _iswgraph_l(_c,_p)  (iswctype(_c, _PUNCT | _ALPHA | _DIGIT))
#define _iswcntrl_l(_c,_p)  (iswctype(_c, _CONTROL))

#ifdef _CRT_USE_WINAPI_FAMILY_DESKTOP_APP
#define isleadbyte(_c)  (__PCTYPE_FUNC[(unsigned char)(_c)] & _LEADBYTE)
#endif

#endif // _CTYPE_DISABLE_MACROS
// CRT_REFACTOR TODO I've had to remove the inline function definitions because
// they break the debugger build.  These were moved here from <wctype.h> in
// C968560.  We need to figure out what is wrong.
//#else
//    #ifndef _CTYPE_DISABLE_MACROS
//        inline int __cdecl iswalpha (_In_ wint_t _C) { return iswctype(_C, _ALPHA); }
//        inline int __cdecl iswupper (_In_ wint_t _C) { return iswctype(_C, _UPPER); }
//        inline int __cdecl iswlower (_In_ wint_t _C) { return iswctype(_C, _LOWER); }
//        inline int __cdecl iswdigit (_In_ wint_t _C) { return iswctype(_C, _DIGIT); }
//        inline int __cdecl iswxdigit(_In_ wint_t _C) { return iswctype(_C, _HEX); }
//        inline int __cdecl iswspace (_In_ wint_t _C) { return iswctype(_C, _SPACE); }
//        inline int __cdecl iswpunct (_In_ wint_t _C) { return iswctype(_C, _PUNCT); }
//        inline int __cdecl iswblank (_In_ wint_t _C) { return (((_C) == '\t') ? _BLANK : iswctype(_C,_BLANK)); }
//        inline int __cdecl iswalnum (_In_ wint_t _C) { return iswctype(_C, _ALPHA | _DIGIT); }
//        inline int __cdecl iswprint (_In_ wint_t _C) { return iswctype(_C, _BLANK | _PUNCT | _ALPHA | _DIGIT); }
//        inline int __cdecl iswgraph (_In_ wint_t _C) { return iswctype(_C, _PUNCT | _ALPHA | _DIGIT); }
//        inline int __cdecl iswcntrl (_In_ wint_t _C) { return iswctype(_C, _CONTROL); }
//        inline int __cdecl iswascii (_In_ wint_t _C) { return (unsigned)(_C) < 0x80; }
//
//        inline int __cdecl _iswalpha_l (_In_ wint_t _C, _In_opt_ _locale_t) { return iswctype(_C, _ALPHA); }
//        inline int __cdecl _iswupper_l (_In_ wint_t _C, _In_opt_ _locale_t) { return iswctype(_C, _UPPER); }
//        inline int __cdecl _iswlower_l (_In_ wint_t _C, _In_opt_ _locale_t) { return iswctype(_C, _LOWER); }
//        inline int __cdecl _iswdigit_l (_In_ wint_t _C, _In_opt_ _locale_t) { return iswctype(_C, _DIGIT); }
//        inline int __cdecl _iswxdigit_l(_In_ wint_t _C, _In_opt_ _locale_t) { return iswctype(_C, _HEX); }
//        inline int __cdecl _iswspace_l (_In_ wint_t _C, _In_opt_ _locale_t) { return iswctype(_C, _SPACE); }
//        inline int __cdecl _iswpunct_l (_In_ wint_t _C, _In_opt_ _locale_t) { return iswctype(_C, _PUNCT); }
//        inline int __cdecl _iswblank_l (_In_ wint_t _C, _In_opt_ _locale_t) { return iswctype(_C, _BLANK); }
//        inline int __cdecl _iswalnum_l (_In_ wint_t _C, _In_opt_ _locale_t) { return iswctype(_C, _ALPHA | _DIGIT); }
//        inline int __cdecl _iswprint_l (_In_ wint_t _C, _In_opt_ _locale_t) { return iswctype(_C, _BLANK | _PUNCT | _ALPHA | _DIGIT); }
//        inline int __cdecl _iswgraph_l (_In_ wint_t _C, _In_opt_ _locale_t) { return iswctype(_C, _PUNCT | _ALPHA | _DIGIT); }
//        inline int __cdecl _iswcntrl_l (_In_ wint_t _C, _In_opt_ _locale_t) { return iswctype(_C, _CONTROL); }
//
//        #ifdef _CRT_USE_WINAPI_FAMILY_DESKTOP_APP
//        inline int __cdecl isleadbyte(_In_ int _C)
//        {
//            return __pctype_func()[(unsigned char)(_C)] & _LEADBYTE;
//        }
//        #endif
//    #endif
#endif



_CRT_END_C_HEADER
_UCRT_RESTORE_CLANG_WARNINGS
#pragma warning(pop) // _UCRT_DISABLED_WARNINGS


#pragma warning(push)
#pragma warning(disable: _UCRT_DISABLED_WARNINGS)
_UCRT_DISABLE_CLANG_WARNINGS

_CRT_BEGIN_C_HEADER
#if !defined __midl && !defined RC_INVOKED



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Character Classification Function Declarations
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
_Check_return_ _ACRTIMP int __cdecl _isctype(_In_ int _C, _In_ int _Type);
_Check_return_ _ACRTIMP int __cdecl _isctype_l(_In_ int _C, _In_ int _Type, _In_opt_ _locale_t _Locale);
_Check_return_ _CRT_JIT_INTRINSIC _ACRTIMP int __cdecl isalpha(_In_ int _C);
_Check_return_ _ACRTIMP int __cdecl _isalpha_l(_In_ int _C, _In_opt_ _locale_t _Locale);
_Check_return_ _CRT_JIT_INTRINSIC _ACRTIMP int __cdecl isupper(_In_ int _C);
_Check_return_ _ACRTIMP int __cdecl _isupper_l(_In_ int _C, _In_opt_ _locale_t _Locale);
_Check_return_ _CRT_JIT_INTRINSIC _ACRTIMP int __cdecl islower(_In_ int _C);
_Check_return_ _ACRTIMP int __cdecl _islower_l(_In_ int _C, _In_opt_ _locale_t _Locale);

_When_(_Param_(1) == 0, _Post_equal_to_(0))
_Check_return_ _CRT_JIT_INTRINSIC _ACRTIMP int __cdecl isdigit(_In_ int _C);

_Check_return_ _ACRTIMP int __cdecl _isdigit_l(_In_ int _C, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP int __cdecl isxdigit(_In_ int _C);
_Check_return_ _ACRTIMP int __cdecl _isxdigit_l(_In_ int _C, _In_opt_ _locale_t _Locale);

_When_(_Param_(1) == 0, _Post_equal_to_(0))
_Check_return_ _CRT_JIT_INTRINSIC _ACRTIMP int __cdecl isspace(_In_ int _C);

_Check_return_ _ACRTIMP int __cdecl _isspace_l(_In_ int _C, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP int __cdecl ispunct(_In_ int _C);
_Check_return_ _ACRTIMP int __cdecl _ispunct_l(_In_ int _C, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP int __cdecl isblank(_In_ int _C);
_Check_return_ _ACRTIMP int __cdecl _isblank_l(_In_ int _C, _In_opt_ _locale_t _Locale);
_Check_return_ _CRT_JIT_INTRINSIC _ACRTIMP int __cdecl isalnum(_In_ int _C);
_Check_return_ _ACRTIMP int __cdecl _isalnum_l(_In_ int _C, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP int __cdecl isprint(_In_ int _C);
_Check_return_ _ACRTIMP int __cdecl _isprint_l(_In_ int _C, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP int __cdecl isgraph(_In_ int _C);
_Check_return_ _ACRTIMP int __cdecl _isgraph_l(_In_ int _C, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP int __cdecl iscntrl(_In_ int _C);
_Check_return_ _ACRTIMP int __cdecl _iscntrl_l(_In_ int _C, _In_opt_ _locale_t _Locale);

_When_(_Param_(1) == 0, _Post_equal_to_(0))
_Check_return_ _CRT_JIT_INTRINSIC _ACRTIMP int __cdecl toupper(_In_ int _C);

_When_(_Param_(1) == 0, _Post_equal_to_(0))
_Check_return_ _CRT_JIT_INTRINSIC _ACRTIMP int __cdecl tolower(_In_ int _C);

_Check_return_ _CRT_JIT_INTRINSIC _ACRTIMP int __cdecl _tolower(_In_ int _C);
_Check_return_ _ACRTIMP int __cdecl _tolower_l(_In_ int _C, _In_opt_ _locale_t _Locale);
_Check_return_ _CRT_JIT_INTRINSIC _ACRTIMP int __cdecl _toupper(_In_ int _C);
_Check_return_ _ACRTIMP int __cdecl _toupper_l(_In_ int _C, _In_opt_ _locale_t _Locale);

_Check_return_ _ACRTIMP int __cdecl __isascii(_In_ int _C);
_Check_return_ _ACRTIMP int __cdecl __toascii(_In_ int _C);
_Check_return_ _ACRTIMP int __cdecl __iscsymf(_In_ int _C);
_Check_return_ _ACRTIMP int __cdecl __iscsym(_In_ int _C);



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Character Classification Macro Definitions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
__inline int __CRTDECL __acrt_locale_get_ctype_array_value(
    _In_reads_(_Char_value + 1) unsigned short const* const _Locale_pctype_array,
    _In_range_(-1, 255)         int                    const _Char_value,
    _In_                        int                    const _Mask
)
{
    // The C Standard specifies valid input to a ctype function ranges from -1 to 255.
    // To avoid undefined behavior, we should check this range for all accesses.
    // Note _locale_pctype array does extend to -127 to support accessing
    // _pctype directly with signed chars.

    if (_Char_value >= -1 && _Char_value <= 255)
    {
        return _Locale_pctype_array[_Char_value] & _Mask;
    }

    return 0;
}

#ifndef _CTYPE_DISABLE_MACROS

// Maximum number of bytes in multi-byte character in the current locale
// (also defined in stdlib.h).
#ifndef MB_CUR_MAX
#if defined _CRT_DISABLE_PERFCRIT_LOCKS && !defined _DLL
#define MB_CUR_MAX __mb_cur_max
#else
#define MB_CUR_MAX ___mb_cur_max_func()
#endif

#ifdef _CRT_DECLARE_GLOBAL_VARIABLES_DIRECTLY
extern int __mb_cur_max;
#else
#define __mb_cur_max (___mb_cur_max_func())
#endif

// MB_LEN_MAX = 5 in limits.h but we do not include that header here so use 5
// directly.
_Post_satisfies_(return > 0 && return < 5)
    _ACRTIMP int __cdecl ___mb_cur_max_func(void);
_Post_satisfies_(return > 0 && return < 5)
    _ACRTIMP int __cdecl ___mb_cur_max_l_func(_locale_t _Locale);
#endif

// In the debug CRT, we make all calls through the validation function to catch
// invalid integer inputs that yield undefined behavior.
#ifdef _DEBUG
_ACRTIMP int __cdecl _chvalidator(_In_ int _Ch, _In_ int _Mask);
#define __chvalidchk(a, b) _chvalidator(a, b)
#else

#define __chvalidchk(a, b) (__acrt_locale_get_ctype_array_value(__PCTYPE_FUNC, (a), (b)))
#endif



#define __ascii_isalpha(c)   ( __chvalidchk(c, _ALPHA))
#define __ascii_isdigit(c)   ( __chvalidchk(c, _DIGIT))

#ifdef _CRT_DEFINE_ASCII_CTYPE_MACROS
#define __ascii_tolower(c)   ( (((c) >= 'A') && ((c) <= 'Z')) ? ((c) - 'A' + 'a') : (c) )
#define __ascii_toupper(c)   ( (((c) >= 'a') && ((c) <= 'z')) ? ((c) - 'a' + 'A') : (c) )
#define __ascii_iswalpha(c)  ( ('A' <= (c) && (c) <= 'Z') || ( 'a' <= (c) && (c) <= 'z'))
#define __ascii_iswdigit(c)  ( '0' <= (c) && (c) <= '9')
#define __ascii_towlower(c)  ( (((c) >= L'A') && ((c) <= L'Z')) ? ((c) - L'A' + L'a') : (c) )
#define __ascii_towupper(c)  ( (((c) >= L'a') && ((c) <= L'z')) ? ((c) - L'a' + L'A') : (c) )
#else
__forceinline int __CRTDECL __ascii_tolower(int const _C)
{
    if (_C >= 'A' && _C <= 'Z')
    {
        return _C - ('A' - 'a');
    }
    return _C;
}

__forceinline int __CRTDECL __ascii_toupper(int const _C)
{
    if (_C >= 'a' && _C <= 'z')
    {
        return _C - ('a' - 'A');
    }
    return _C;
}

__forceinline int __CRTDECL __ascii_iswalpha(int const _C)
{
    return (_C >= 'A' && _C <= 'Z') || (_C >= 'a' && _C <= 'z');
}

__forceinline int __CRTDECL __ascii_iswdigit(int const _C)
{
    return _C >= '0' && _C <= '9';
}

__forceinline int __CRTDECL __ascii_towlower(int const _C)
{
    return __ascii_tolower(_C);
}

__forceinline int __CRTDECL __ascii_towupper(int const _C)
{
    return __ascii_toupper(_C);
}
#endif



#if defined _CRT_DISABLE_PERFCRIT_LOCKS && !defined _DLL && !defined __cplusplus
#define isalpha(c)  (MB_CUR_MAX > 1 ? _isctype(c, _ALPHA) : __chvalidchk(c, _ALPHA))
#define isupper(c)  (MB_CUR_MAX > 1 ? _isctype(c, _UPPER) : __chvalidchk(c, _UPPER))
#define islower(c)  (MB_CUR_MAX > 1 ? _isctype(c, _LOWER) : __chvalidchk(c, _LOWER))
#define isdigit(c)  (MB_CUR_MAX > 1 ? _isctype(c, _DIGIT) : __chvalidchk(c, _DIGIT))
#define isxdigit(c) (MB_CUR_MAX > 1 ? _isctype(c, _HEX)   : __chvalidchk(c, _HEX))
#define isspace(c)  (MB_CUR_MAX > 1 ? _isctype(c, _SPACE) : __chvalidchk(c, _SPACE))
#define ispunct(c)  (MB_CUR_MAX > 1 ? _isctype(c, _PUNCT) : __chvalidchk(c, _PUNCT))
#define isblank(c)  (MB_CUR_MAX > 1 ? (((c) == '\t') ? _BLANK : _isctype(c, _BLANK)) : (((c) == '\t') ? _BLANK : __chvalidchk(c, _BLANK)))
#define isalnum(c)  (MB_CUR_MAX > 1 ? _isctype(c, _ALPHA | _DIGIT) : __chvalidchk(c, (_ALPHA | _DIGIT)))
#define isprint(c)  (MB_CUR_MAX > 1 ? _isctype(c, _BLANK | _PUNCT | _ALPHA | _DIGIT) : __chvalidchk(c, (_BLANK | _PUNCT | _ALPHA | _DIGIT)))
#define isgraph(c)  (MB_CUR_MAX > 1 ? _isctype(c, _PUNCT | _ALPHA | _DIGIT) : __chvalidchk(c, (_PUNCT | _ALPHA | _DIGIT)))
#define iscntrl(c)  (MB_CUR_MAX > 1 ? _isctype(c, _CONTROL) : __chvalidchk(c, _CONTROL))
#endif

__inline __crt_locale_data_public* __CRTDECL __acrt_get_locale_data_prefix(void const volatile* const _LocalePointers)
{
    _locale_t const _TypedLocalePointers = (_locale_t)_LocalePointers;
    return (__crt_locale_data_public*)_TypedLocalePointers->locinfo;
}

#ifdef _DEBUG
_ACRTIMP int __cdecl _chvalidator_l(_In_opt_ _locale_t, _In_ int _Ch, _In_ int _Mask);
#endif

__inline int __CRTDECL _chvalidchk_l(
    _In_     int       const _C,
    _In_     int       const _Mask,
    _In_opt_ _locale_t const _Locale
)
{
#ifdef _DEBUG
    return _chvalidator_l(_Locale, _C, _Mask);
#else
    if (!_Locale)
    {
        return __chvalidchk(_C, _Mask);
    }

    return __acrt_locale_get_ctype_array_value(__acrt_get_locale_data_prefix(_Locale)->_locale_pctype, _C, _Mask);
#endif
}

#define __ascii_isalpha_l(c, locale) (_chvalidchk_l(c, _ALPHA, locale))
#define __ascii_isdigit_l(c, locale) (_chvalidchk_l(c, _DIGIT, locale))

__inline int __CRTDECL _ischartype_l(
    _In_     int       const _C,
    _In_     int       const _Mask,
    _In_opt_ _locale_t const _Locale
)
{
    if (!_Locale)
    {
        return _chvalidchk_l(_C, _Mask, 0);
    }

    if (_C >= -1 && _C <= 255)
    {
        return __acrt_get_locale_data_prefix(_Locale)->_locale_pctype[_C] & _Mask;
    }

    if (__acrt_get_locale_data_prefix(_Locale)->_locale_mb_cur_max > 1)
    {
        return _isctype_l(_C, _Mask, _Locale);
    }

    return 0; // >0xFF and SBCS locale
}

#define _isalpha_l(c, locale)  _ischartype_l(c, _ALPHA, locale)
#define _isupper_l(c, locale)  _ischartype_l(c, _UPPER, locale)
#define _islower_l(c, locale)  _ischartype_l(c, _LOWER, locale)
#define _isdigit_l(c, locale)  _ischartype_l(c, _DIGIT, locale)
#define _isxdigit_l(c, locale) _ischartype_l(c, _HEX, locale)
#define _isspace_l(c, locale)  _ischartype_l(c, _SPACE, locale)
#define _ispunct_l(c, locale)  _ischartype_l(c, _PUNCT, locale)
#define _isblank_l(c, locale)  (((c) == '\t') ? _BLANK : _ischartype_l(c, _BLANK, locale))
#define _isalnum_l(c, locale)  _ischartype_l(c, _ALPHA | _DIGIT, locale)
#define _isprint_l(c, locale)  _ischartype_l(c, _BLANK | _PUNCT | _ALPHA | _DIGIT, locale)
#define _isgraph_l(c, locale)  _ischartype_l(c, _PUNCT | _ALPHA | _DIGIT, locale)
#define _iscntrl_l(c, locale)  _ischartype_l(c, _CONTROL, locale)

#define _tolower(c) ((c) - 'A' + 'a')
#define _toupper(c) ((c) - 'a' + 'A')

#define __isascii(c)   ((unsigned)(c) < 0x80)
#define __toascii(c)   ((c) & 0x7f)


// Microsoft C version 2.0 extended ctype macros
#define __iscsymf(c)  (isalpha(c) || ((c) == '_'))
#define __iscsym(c)   (isalnum(c) || ((c) == '_'))
#define __iswcsymf(c) (iswalpha(c) || ((c) == '_'))
#define __iswcsym(c)  (iswalnum(c) || ((c) == '_'))

#define _iscsymf_l(c, p)  (_isalpha_l(c, p) || ((c) == '_'))
#define _iscsym_l(c, p)   (_isalnum_l(c, p) || ((c) == '_'))
#define _iswcsymf_l(c, p) (iswalpha(c) || ((c) == '_'))
#define _iswcsym_l(c, p)  (iswalnum(c) || ((c) == '_'))

#endif // _CTYPE_DISABLE_MACROS


#if defined(_CRT_INTERNAL_NONSTDC_NAMES) && _CRT_INTERNAL_NONSTDC_NAMES
#define isascii __isascii
#define toascii __toascii
#define iscsymf __iscsymf
#define iscsym  __iscsym
#endif



#endif // !defined __midl && !defined RC_INVOKED
_CRT_END_C_HEADER
_UCRT_RESTORE_CLANG_WARNINGS
#pragma warning(pop) // _UCRT_DISABLED_WARNINGS
#endif // _INC_CTYPE


#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_STD_BEGIN
_EXPORT_STD using _CSTD isalnum;
_EXPORT_STD using _CSTD isalpha;
_EXPORT_STD using _CSTD iscntrl;
_EXPORT_STD using _CSTD isdigit;
_EXPORT_STD using _CSTD isgraph;
_EXPORT_STD using _CSTD islower;
_EXPORT_STD using _CSTD isprint;
_EXPORT_STD using _CSTD ispunct;
_EXPORT_STD using _CSTD isspace;
_EXPORT_STD using _CSTD isupper;
_EXPORT_STD using _CSTD isxdigit;
_EXPORT_STD using _CSTD tolower;
_EXPORT_STD using _CSTD toupper;

_EXPORT_STD using _CSTD isblank;
_STD_END

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)

#endif // _STL_COMPILER_PREPROCESSOR
#endif // _CCTYPE_

// clocale standard header (core)

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#ifndef _CLOCALE_
#define _CLOCALE_
#if _STL_COMPILER_PREPROCESSOR

//
// locale.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The C locale library.
//
#pragma once
#ifndef _INC_LOCALE // include guard for 3rd party interop
#define _INC_LOCALE



#pragma warning(push)
#pragma warning(disable: _UCRT_DISABLED_WARNINGS)
_UCRT_DISABLE_CLANG_WARNINGS

_CRT_BEGIN_C_HEADER



// Locale categories
#define LC_ALL          0
#define LC_COLLATE      1
#define LC_CTYPE        2
#define LC_MONETARY     3
#define LC_NUMERIC      4
#define LC_TIME         5

#define LC_MIN          LC_ALL
#define LC_MAX          LC_TIME

// Locale convention structure
struct lconv
{
    char* decimal_point;
    char* thousands_sep;
    char* grouping;
    char* int_curr_symbol;
    char* currency_symbol;
    char* mon_decimal_point;
    char* mon_thousands_sep;
    char* mon_grouping;
    char* positive_sign;
    char* negative_sign;
    char     int_frac_digits;
    char     frac_digits;
    char     p_cs_precedes;
    char     p_sep_by_space;
    char     n_cs_precedes;
    char     n_sep_by_space;
    char     p_sign_posn;
    char     n_sign_posn;
    wchar_t* _W_decimal_point;
    wchar_t* _W_thousands_sep;
    wchar_t* _W_int_curr_symbol;
    wchar_t* _W_currency_symbol;
    wchar_t* _W_mon_decimal_point;
    wchar_t* _W_mon_thousands_sep;
    wchar_t* _W_positive_sign;
    wchar_t* _W_negative_sign;
};

struct tm;

// ANSI: char lconv members default is CHAR_MAX which is compile time dependent.
// Defining and using __do_unsigned_char_lconv_initialization here causes CRT
// startup code to initialize lconv members properly
#ifdef _CHAR_UNSIGNED
extern int __do_unsigned_char_lconv_initialization;
extern __inline int __use_char_max(void)
{
    return __do_unsigned_char_lconv_initialization;
}
#endif



#define _ENABLE_PER_THREAD_LOCALE         0x0001
#define _DISABLE_PER_THREAD_LOCALE        0x0002
#define _ENABLE_PER_THREAD_LOCALE_GLOBAL  0x0010
#define _DISABLE_PER_THREAD_LOCALE_GLOBAL 0x0020
#define _ENABLE_PER_THREAD_LOCALE_NEW     0x0100
#define _DISABLE_PER_THREAD_LOCALE_NEW    0x0200

#if _CRT_FUNCTIONS_REQUIRED

_ACRTIMP void __cdecl _lock_locales(void);
_ACRTIMP void __cdecl _unlock_locales(void);

_Check_return_opt_
_ACRTIMP int __cdecl _configthreadlocale(
    _In_ int _Flag
);

_Check_return_opt_ _Success_(return != 0) _Ret_z_
_ACRTIMP char* __cdecl setlocale(
    _In_       int         _Category,
    _In_opt_z_ char const* _Locale
);

_Check_return_opt_
_ACRTIMP struct lconv* __cdecl localeconv(void);

_Check_return_opt_
_ACRTIMP _locale_t __cdecl _get_current_locale(void);

_Check_return_opt_
_ACRTIMP _locale_t __cdecl _create_locale(
    _In_   int         _Category,
    _In_z_ char const* _Locale
);

_ACRTIMP void __cdecl _free_locale(
    _In_opt_ _locale_t _Locale
);

// Also declared in <wchar.h>
_Check_return_opt_ _Success_(return != 0) _Ret_z_
_ACRTIMP wchar_t* __cdecl _wsetlocale(
    _In_       int            _Category,
    _In_opt_z_ wchar_t const* _Locale
);

_Check_return_opt_
_ACRTIMP _locale_t __cdecl _wcreate_locale(
    _In_   int            _Category,
    _In_z_ wchar_t const* _Locale
);



_ACRTIMP wchar_t** __cdecl ___lc_locale_name_func(void);
_ACRTIMP unsigned int __cdecl ___lc_codepage_func(void);
_ACRTIMP unsigned int __cdecl ___lc_collate_cp_func(void);




// Time-related functions
_Success_(return != 0)
_Ret_z_
_ACRTIMP char* __cdecl _Getdays(void);

_Success_(return != 0)
_Ret_z_
_ACRTIMP char* __cdecl _Getmonths(void);

_ACRTIMP void* __cdecl _Gettnames(void);

_Success_(return != 0)
_Ret_z_
_ACRTIMP wchar_t* __cdecl _W_Getdays(void);

_Success_(return != 0)
_Ret_z_
_ACRTIMP wchar_t* __cdecl _W_Getmonths(void);

_ACRTIMP void* __cdecl _W_Gettnames(void);

_Success_(return > 0)
_ACRTIMP size_t __cdecl _Strftime(
    _Out_writes_z_(_Max_size) char* _Buffer,
    _In_                     size_t           _Max_size,
    _In_z_                   char const* _Format,
    _In_                     struct tm const* _Timeptr,
    _In_opt_                 void* _Lc_time_arg);

_Success_(return > 0)
_ACRTIMP size_t __cdecl _Wcsftime(
    _Out_writes_z_(_Max_size) wchar_t* _Buffer,
    _In_                     size_t           _Max_size,
    _In_z_                   wchar_t const* _Format,
    _In_                     struct tm const* _Timeptr,
    _In_opt_                 void* _Lc_time_arg
);

#endif // _CRT_FUNCTIONS_REQUIRED


_CRT_END_C_HEADER
_UCRT_RESTORE_CLANG_WARNINGS
#pragma warning(pop) // _UCRT_DISABLED_WARNINGS
#endif // _INC_LOCALE


#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_STD_BEGIN
_EXPORT_STD using _CSTD lconv;
_EXPORT_STD using _CSTD localeconv;
_EXPORT_STD using _CSTD setlocale;
_STD_END

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)

#endif // _STL_COMPILER_PREPROCESSOR
#endif // _CLOCALE_
// TRANSITION, VSO-661721
// cstdlib standard header (core)

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

// xstring internal header

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

// (<string_view> without emitting non-C++17 warnings)

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_EXTERN_C_UNLESS_PURE

#define _X_ALL      LC_ALL
#define _X_COLLATE  LC_COLLATE
#define _X_CTYPE    LC_CTYPE
#define _X_MONETARY LC_MONETARY
#define _X_NUMERIC  LC_NUMERIC
#define _X_TIME     LC_TIME
#define _X_MAX      LC_MAX
#define _X_MESSAGES 6
#define _NCAT       (_X_MESSAGES + 1) // maximum + 1

#define _CATMASK(n) ((1 << (n)) >> 1)
#define _M_COLLATE  _CATMASK(_X_COLLATE)
#define _M_CTYPE    _CATMASK(_X_CTYPE)
#define _M_MONETARY _CATMASK(_X_MONETARY)
#define _M_NUMERIC  _CATMASK(_X_NUMERIC)
#define _M_TIME     _CATMASK(_X_TIME)
#define _M_MESSAGES _CATMASK(_X_MESSAGES)
#define _M_ALL      (_CATMASK(_NCAT) - 1)

_CRTIMP2_PURE _Collvec __CLRCALL_PURE_OR_CDECL _Getcoll() noexcept;
_CRTIMP2_PURE _Ctypevec __CLRCALL_PURE_OR_CDECL _Getctype() noexcept;
_CRTIMP2_PURE _Cvtvec __CLRCALL_PURE_OR_CDECL _Getcvt() noexcept;
_CRTIMP2_PURE int __CLRCALL_PURE_OR_CDECL _Getdateorder() noexcept;

#ifdef _M_CEE_PURE
[System::Runtime::InteropServices::DllImport(_CRT_MSVCP_CURRENT, EntryPoint = "_Mbrtowc",
    CallingConvention = System::Runtime::InteropServices::CallingConvention::Cdecl)] extern "C" int
    _Mbrtowc(_Out_opt_ wchar_t*, const char*, size_t, mbstate_t*, const _Cvtvec*) noexcept;
#else // ^^^ defined(_M_CEE_PURE) / !defined(_M_CEE_PURE) vvv
_MRTIMP2 _Success_(return >= 0) int __cdecl _Mbrtowc(_When_(_Max_multibyte != 0, _Out_) wchar_t*, const char*,
    size_t _Max_multibyte, mbstate_t*, const _Cvtvec*) noexcept;
#endif // ^^^ !defined(_M_CEE_PURE) ^^^

_CRTIMP2_PURE int __CLRCALL_PURE_OR_CDECL _Strcoll(
    const char*, const char*, const char*, const char*, const _Collvec*) noexcept;
_CRTIMP2_PURE size_t __CLRCALL_PURE_OR_CDECL _Strxfrm(_Out_writes_(_End1 - _String1)
    _Post_readable_size_(return) char* _String1,
    _In_z_ char* _End1, const char*, const char*, const _Collvec*) noexcept;
_CRTIMP2_PURE int __CLRCALL_PURE_OR_CDECL _Tolower(int, const _Ctypevec*) noexcept;
_CRTIMP2_PURE int __CLRCALL_PURE_OR_CDECL _Toupper(int, const _Ctypevec*) noexcept;
_CRTIMP2_PURE _Success_(return != -1) int __CLRCALL_PURE_OR_CDECL
_Wcrtomb(_Out_ char*, wchar_t, mbstate_t*, const _Cvtvec*) noexcept;
_CRTIMP2_PURE int __CLRCALL_PURE_OR_CDECL _Wcscoll(
    const wchar_t*, const wchar_t*, const wchar_t*, const wchar_t*, const _Collvec*) noexcept;
_CRTIMP2_PURE size_t __CLRCALL_PURE_OR_CDECL _Wcsxfrm(_Out_writes_(_End1 - _String1) _Post_readable_size_(return)
    wchar_t* _String1,
    _In_z_ wchar_t* _End1, const wchar_t*, const wchar_t*, const _Collvec*) noexcept;

_CRTIMP2_PURE short __CLRCALL_PURE_OR_CDECL _Getwctype(wchar_t, const _Ctypevec*) noexcept;
_CRTIMP2_PURE const wchar_t* __CLRCALL_PURE_OR_CDECL _Getwctypes(
    const wchar_t*, const wchar_t*, short*, const _Ctypevec*) noexcept;
_CRTIMP2_PURE wchar_t __CLRCALL_PURE_OR_CDECL _Towlower(wchar_t, const _Ctypevec*) noexcept;
_CRTIMP2_PURE wchar_t __CLRCALL_PURE_OR_CDECL _Towupper(wchar_t, const _Ctypevec*) noexcept;

_END_EXTERN_C_UNLESS_PURE

extern "C" {
    // These _should_ be explicitly `noexcept` but cannot be made so here because
    // the primary declarations in the C runtime headers are not.

    _Success_(return != 0) _Ret_z_ _ACRTIMP char* __cdecl _Getdays();

    _Success_(return != 0) _Ret_z_ _ACRTIMP char* __cdecl _Getmonths();

    _ACRTIMP void* __cdecl _Gettnames();

    _Success_(return > 0) _ACRTIMP size_t __cdecl _Strftime(
        _Out_writes_z_(_Maxsize) char*, _In_ size_t _Maxsize, _In_z_ const char*, _In_ const tm*, _In_opt_ void*);

    _Success_(return != 0) _Ret_z_ _ACRTIMP wchar_t* __cdecl _W_Getdays();

    _Success_(return != 0) _Ret_z_ _ACRTIMP wchar_t* __cdecl _W_Getmonths();

    _ACRTIMP void* __cdecl _W_Gettnames();

    _Success_(return > 0) _ACRTIMP size_t __cdecl _Wcsftime(
        _Out_writes_z_(_Maxsize) wchar_t*, _In_ size_t _Maxsize, _In_z_ const wchar_t*, _In_ const tm*, _In_opt_ void*);
} // extern "C"

_STD_BEGIN
extern "C++" class _CRTIMP2_PURE_IMPORT _Timevec { // smart pointer to information used by _Strftime
public:
    explicit __CLR_OR_THIS_CALL _Timevec(void* _Ptr = nullptr) : _Timeptr(_Ptr) {}

    __CLR_OR_THIS_CALL _Timevec(const _Timevec& _Right) : _Timeptr(nullptr) {
        *this = _Right;
    }

    __CLR_OR_THIS_CALL ~_Timevec() noexcept {
        _CSTD free(_Timeptr);
    }

    _Timevec& __CLR_OR_THIS_CALL operator=(const _Timevec& _Right) { // transfer ownership of _Timeptr from _Right
        if (this != &_Right) {
            _CSTD free(_Timeptr);
            _Timeptr = _Right._Timeptr;
            const_cast<_Timevec&>(_Right)._Timeptr = nullptr; // TRANSITION, should be movable-only
        }

        return *this;
    }

    void* __CLR_OR_THIS_CALL _Getptr() const {
        return _Timeptr;
    }

private:
    void* _Timeptr; // pointer to time information
};

extern "C++" template <class _Elem>
class _CRTIMP2_PURE_IMPORT _Yarn { // wrap a NTCTS
public:
    __CLR_OR_THIS_CALL _Yarn() noexcept : _Myptr(nullptr), _Nul(0) {}

    __CLR_OR_THIS_CALL _Yarn(const _Yarn& _Right) noexcept : _Myptr(nullptr), _Nul(0) {
        *this = _Right;
    }

    __CLR_OR_THIS_CALL _Yarn(const _Elem* _Right) noexcept : _Myptr(nullptr), _Nul(0) {
        *this = _Right;
    }

    _Yarn& __CLR_OR_THIS_CALL operator=(const _Yarn& _Right) noexcept {
        return *this = _Right._Myptr;
    }

    _Yarn& __CLR_OR_THIS_CALL operator=(const _Elem* _Right) noexcept {
        if (_Myptr != _Right) { // new value, discard old and copy new
            _Tidy();

            if (_Right) { // new is not empty, copy it
                const _Elem* _Ptr = _Right;
                while (*_Ptr != _Elem{}) {
                    ++_Ptr;
                }

                const auto _Count = (++_Ptr - _Right) * sizeof(_Elem);

#ifdef _DEBUG
                _Myptr = static_cast<_Elem*>(_malloc_dbg(_Count, _CRT_BLOCK, __FILE__, __LINE__));
#else
                _Myptr = static_cast<_Elem*>(_CSTD malloc(_Count));
#endif

                if (_Myptr) {
                    _CSTD memcpy(_Myptr, _Right, _Count);
                }
            }
        }

        return *this;
    }

    __CLR_OR_THIS_CALL ~_Yarn() noexcept {
        _Tidy();
    }

    _NODISCARD bool __CLR_OR_THIS_CALL empty() const noexcept {
        return _Myptr == nullptr;
    }

    _Ret_z_ const _Elem* __CLR_OR_THIS_CALL c_str() const noexcept {
        return _Myptr ? _Myptr : &_Nul;
    }

    _NODISCARD bool __CLR_OR_THIS_CALL _Empty() const noexcept {
        return _Myptr == nullptr;
    }

    _Ret_z_ const _Elem* __CLR_OR_THIS_CALL _C_str() const noexcept {
        return _Myptr ? _Myptr : &_Nul;
    }

private:
    void __CLR_OR_THIS_CALL _Tidy() noexcept {
        if (_Myptr) {
#ifdef _DEBUG
            _free_dbg(_Myptr, _CRT_BLOCK);
#else
            _CSTD free(_Myptr);
#endif
        }

        _Myptr = nullptr;
    }

    _Elem* _Myptr; // pointer to allocated string
    _Elem _Nul; // nul terminator for unallocated string
};

extern "C++" class _CRTIMP2_PURE_IMPORT _Locinfo { // summary of all stuff specific to a locale used by standard facets
public:
    using _Collvec = ::_Collvec;
    using _Ctypevec = ::_Ctypevec;
    using _Cvtvec = ::_Cvtvec;
    using _Timevec = _STD _Timevec;

    static void __CLRCALL_PURE_OR_CDECL _Locinfo_ctor(_Locinfo*, const char*);
    static void __CLRCALL_PURE_OR_CDECL _Locinfo_ctor(_Locinfo*, int, const char*);
    static void __CLRCALL_PURE_OR_CDECL _Locinfo_dtor(_Locinfo*);
    static _Locinfo& __CLRCALL_PURE_OR_CDECL _Locinfo_Addcats(_Locinfo*, int, const char*);

    __CLR_OR_THIS_CALL _Locinfo(const char* _Pch = "C")
#ifndef _M_CEE_PURE
        : _Lock(_LOCK_LOCALE)
#endif // !defined(_M_CEE_PURE)
    {
        if (_Pch) {
            _Locinfo_ctor(this, _Pch);
            return;
        }

        _Xruntime_error("bad locale name");
    }

    __CLR_OR_THIS_CALL _Locinfo(int _Cat, const char* _Pch)
#ifndef _M_CEE_PURE
        : _Lock(_LOCK_LOCALE)
#endif // !defined(_M_CEE_PURE)
    {
        if (_Pch) {
            _Locinfo_ctor(this, _Cat, _Pch);
            return;
        }

        _Xruntime_error("bad locale name");
    }

    __CLR_OR_THIS_CALL ~_Locinfo() noexcept {
        _Locinfo_dtor(this);
    }

    _Locinfo& __CLR_OR_THIS_CALL _Addcats(int _Cat, const char* _Pch) { // add facets matching category mask and NTBS
        if (_Pch) {
            return _Locinfo_Addcats(this, _Cat, _Pch);
        }

        _Xruntime_error("bad locale name");
    }

    const char* __CLR_OR_THIS_CALL _Getname() const {
        return _Newlocname._C_str();
    }

    _Collvec __CLR_OR_THIS_CALL _Getcoll() const {
        return ::_Getcoll();
    }

    _Ctypevec __CLR_OR_THIS_CALL _Getctype() const {
        return ::_Getctype();
    }

    _Cvtvec __CLR_OR_THIS_CALL _Getcvt() const {
        return ::_Getcvt();
    }

    const lconv* __CLR_OR_THIS_CALL _Getlconv() const {
        return localeconv();
    }

    _Timevec __CLR_OR_THIS_CALL _Gettnames() const {
        return _Timevec(::_Gettnames());
    }

    const char* __CLR_OR_THIS_CALL _Getdays() const {
        const char* _Ptr = ::_Getdays();
        if (_Ptr) { // capture names and free allocated C string
            const_cast<_Locinfo*>(this)->_Days = _Ptr;
            _CSTD free(const_cast<char*>(_Ptr));
        }

        return !_Days._Empty() ? _Days._C_str()
            : ":Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday"
            ":Thu:Thursday:Fri:Friday:Sat:Saturday";
    }

    const char* __CLR_OR_THIS_CALL _Getmonths() const {
        const char* _Ptr = ::_Getmonths();
        if (_Ptr) { // capture names and free allocated C string
            const_cast<_Locinfo*>(this)->_Months = _Ptr;
            _CSTD free(const_cast<char*>(_Ptr));
        }

        return !_Months._Empty() ? _Months._C_str()
            : ":Jan:January:Feb:February:Mar:March"
            ":Apr:April:May:May:Jun:June"
            ":Jul:July:Aug:August:Sep:September"
            ":Oct:October:Nov:November:Dec:December";
    }

    const char* __CLR_OR_THIS_CALL _Getfalse() const {
        return "false";
    }

    const char* __CLR_OR_THIS_CALL _Gettrue() const {
        return "true";
    }

    int __CLR_OR_THIS_CALL _Getdateorder() const {
        return ::_Getdateorder();
    }

    _Timevec __CLR_OR_THIS_CALL _W_Gettnames() const {
        return _Timevec(::_W_Gettnames());
    }

    const unsigned short* __CLR_OR_THIS_CALL _W_Getdays() const {
        const wchar_t* _Ptr = ::_W_Getdays();
        if (_Ptr) { // capture names and free allocated C string
            const_cast<_Locinfo*>(this)->_W_Days = _Ptr;
            _CSTD free(const_cast<wchar_t*>(_Ptr));
        }

        const wchar_t* _Ret;

        if (_W_Days._Empty()) {
            _Ret = L":Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday:Thu:Thursday:Fri:Friday:Sat:Saturday";
        }
        else {
            _Ret = _W_Days._C_str();
        }

        return reinterpret_cast<const unsigned short*>(_Ret);
    }

    const unsigned short* __CLR_OR_THIS_CALL _W_Getmonths() const {
        const wchar_t* _Ptr = ::_W_Getmonths();
        if (_Ptr) { // capture names and free allocated C string
            const_cast<_Locinfo*>(this)->_W_Months = _Ptr;
            _CSTD free(const_cast<wchar_t*>(_Ptr));
        }

        const wchar_t* _Ret;

        if (_W_Months._Empty()) {
            _Ret = L":Jan:January:Feb:February:Mar:March:Apr:April:May:May:Jun:June"
                L":Jul:July:Aug:August:Sep:September:Oct:October:Nov:November:Dec:December";
        }
        else {
            _Ret = _W_Months._C_str();
        }

        return reinterpret_cast<const unsigned short*>(_Ret);
    }

    _Locinfo(const _Locinfo&) = delete;
    _Locinfo& operator=(const _Locinfo&) = delete;

private:
#ifdef _M_CEE_PURE
    _EmptyLockit _Empty_lock; // to maintain same size
#else // ^^^ defined(_M_CEE_PURE) / !defined(_M_CEE_PURE) vvv
    _Lockit _Lock; // thread lock, because global locale is altered
#endif // ^^^ !defined(_M_CEE_PURE) ^^^

    _Yarn<char> _Days; // weekday names
    _Yarn<char> _Months; // month names
    _Yarn<wchar_t> _W_Days; // wide weekday names
    _Yarn<wchar_t> _W_Months; // wide month names
    _Yarn<char> _Oldlocname; // old locale name to revert to on destruction
    _Yarn<char> _Newlocname; // new locale name for this object
};

template <class _Elem>
int __CRTDECL _LStrcoll(const _Elem * _First1, const _Elem * _Last1, const _Elem * _First2, const _Elem * _Last2,
    const _Locinfo::_Collvec*) { // perform locale-specific comparison of _Elem sequences
    for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, ++_First2) {
        if (*_First1 < *_First2) {
            return -1; // [_First1, _Last1) < [_First2, _Last2)
        }
        else if (*_First2 < *_First1) {
            return +1; // [_First1, _Last1) > [_First2, _Last2)
        }
    }

    return _First2 != _Last2 ? -1 : _First1 != _Last1 ? +1 : 0;
}

template <>
inline int __CRTDECL _LStrcoll(const char* _First1, const char* _Last1, const char* _First2, const char* _Last2,
    const _Locinfo::_Collvec * _Vector) { // perform locale-specific comparison of char sequences
    return _Strcoll(_First1, _Last1, _First2, _Last2, _Vector);
}

template <>
inline int __CRTDECL _LStrcoll(const wchar_t* _First1, const wchar_t* _Last1, const wchar_t* _First2,
    const wchar_t* _Last2,
    const _Locinfo::_Collvec * _Vector) { // perform locale-specific comparison of wchar_t sequences
    return _Wcscoll(_First1, _Last1, _First2, _Last2, _Vector);
}

template <class _Elem>
size_t __CRTDECL _LStrxfrm(_Elem * _First1, _Elem * _Last1, const _Elem * _First2, const _Elem * _Last2,
    const _Locinfo::_Collvec*) { // perform locale-specific transform of _Elems [_First1, _Last1)
    const ptrdiff_t _Count = _Last2 - _First2;
    if (_Count <= _Last1 - _First1) {
        _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));
    }

    return _Count;
}

template <>
inline size_t __CRTDECL _LStrxfrm(_Out_writes_(_Last1 - _First1) _Post_readable_size_(return) char* _First1,
    _In_z_ char* _Last1, const char* _First2, const char* _Last2,
    const _Locinfo::_Collvec* _Vector) { // perform locale-specific transform of chars [_First1, _Last1)
    return _Strxfrm(_First1, _Last1, _First2, _Last2, _Vector);
}

template <>
inline size_t __CRTDECL _LStrxfrm(_Out_writes_(_Last1 - _First1) _Post_readable_size_(return) wchar_t* _First1,
    _In_z_ wchar_t* _Last1, const wchar_t* _First2, const wchar_t* _Last2,
    const _Locinfo::_Collvec* _Vector) { // perform locale-specific transform of wchar_ts [_First1, _Last1)
    return _Wcsxfrm(_First1, _Last1, _First2, _Last2, _Vector);
}
_STD_END
#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _XLOCINFO_


#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_STD_BEGIN
template <class _Dummy>
class _Locbase {}; // TRANSITION, ABI, affects sizeof(locale)

_EXPORT_STD template <class _Elem>
class collate;

extern "C++" struct _CRTIMP2_PURE_IMPORT _Crt_new_delete { // base class for marking allocations as CRT blocks
#ifdef _DEBUG
    void* __CLRCALL_OR_CDECL operator new(size_t _Size) { // replace operator new
        void* _Ptr = operator new(_Size, nothrow);
        if (!_Ptr) {
            _Xbad_alloc();
        }

        return _Ptr;
    }

    void* __CLRCALL_OR_CDECL operator new(size_t _Size, const nothrow_t&) noexcept { // replace nothrow operator new
        return _malloc_dbg(_Size > 0 ? _Size : 1, _CRT_BLOCK, __FILE__, __LINE__);
    }

    void __CLRCALL_OR_CDECL operator delete(void* _Ptr) noexcept { // replace operator delete
        _CSTD free(_Ptr);
    }

    void __CLRCALL_OR_CDECL operator delete(void* _Ptr, const nothrow_t&) noexcept { // replace nothrow operator delete
        operator delete(_Ptr);
    }

    void* __CLRCALL_OR_CDECL operator new(size_t, void* _Ptr) noexcept { // imitate True Placement New
        return _Ptr;
    }

    void __CLRCALL_OR_CDECL operator delete(void*, void*) noexcept {} // imitate True Placement Delete
#endif // _DEBUG
};

_EXPORT_STD extern "C++" class locale : public _Locbase<int>, public _Crt_new_delete {
public:
    using category = int;

    static constexpr category collate = _M_COLLATE;
    static constexpr category ctype = _M_CTYPE;
    static constexpr category monetary = _M_MONETARY;
    static constexpr category numeric = _M_NUMERIC;
    static constexpr category time = _M_TIME;
    static constexpr category messages = _M_MESSAGES;
    static constexpr category all = _M_ALL;
    static constexpr category none = 0;

    class _CRTIMP2_PURE_IMPORT id { // identifier stamp, unique for each distinct kind of facet
    public:
        __CLR_OR_THIS_CALL id(size_t _Val = 0) : _Id(_Val) {}

        id(const id&) = delete;
        id& operator=(const id&) = delete;

        __CLR_OR_THIS_CALL operator size_t() { // get stamp, with lazy allocation
            if (_Id == 0) { // still zero, allocate stamp
                _BEGIN_LOCK(_LOCK_LOCALE)
                    if (_Id == 0) {
                        _Id = static_cast<size_t>(++_Id_cnt);
                    }
                _END_LOCK()
            }
            return _Id;
        }

    private:
        size_t _Id; // the identifier stamp

        __PURE_APPDOMAIN_GLOBAL static int _Id_cnt;
    };

    struct _Facet_guard;

    class _CRTIMP2_PURE_IMPORT facet : public _Facet_base, public _Crt_new_delete {
        // base class for all locale facets, performs reference counting
    private:
        friend _Facet_guard;

    public:
        static size_t __CLRCALL_OR_CDECL _Getcat(const facet** = nullptr, const locale* = nullptr) {
            // get category value, or -1 if no corresponding C category
            return static_cast<size_t>(-1);
        }

        void __CLR_OR_THIS_CALL _Incref() noexcept override { // increment use count
            _MT_INCR(_Myrefs);
        }

        _Facet_base* __CLR_OR_THIS_CALL _Decref() noexcept override { // decrement use count
            if (_MT_DECR(_Myrefs) == 0) {
                return this;
            }

            return nullptr;
        }

    private:
        _Atomic_counter_t _Myrefs; // the reference count

    protected:
        explicit __CLR_OR_THIS_CALL facet(size_t _Initrefs = 0) noexcept // strengthened
            : _Myrefs(static_cast<_Atomic_counter_t>(_Initrefs)) // non-atomic initialization
        {}

        __CLR_OR_THIS_CALL ~facet() noexcept override {}

    public:
        __CLR_OR_THIS_CALL facet(const facet&) = delete;
        facet& __CLR_OR_THIS_CALL operator=(const facet&) = delete;
    };

    struct _NODISCARD _Facet_guard {
        facet* _Target;
        ~_Facet_guard() {
            if (_Target) {
                delete _Target->_Decref();
            }
        }
    };

    class _CRTIMP2_PURE_IMPORT _Locimp : public facet { // reference-counted actual implementation of a locale
    protected:
        __CLR_OR_THIS_CALL ~_Locimp() noexcept {
            _Locimp_dtor(this);
        }

    private:
        static _Locimp* __CLRCALL_PURE_OR_CDECL _New_Locimp(bool _Transparent = false);
        static _Locimp* __CLRCALL_PURE_OR_CDECL _New_Locimp(const _Locimp& _Right);

        static void __CLRCALL_PURE_OR_CDECL _Locimp_dtor(_Locimp*);
        static void __CLRCALL_PURE_OR_CDECL _Locimp_Addfac(_Locimp*, facet*, size_t); // add a facet
        static void __CLRCALL_PURE_OR_CDECL _Locimp_ctor(_Locimp*, const _Locimp&);

        friend locale;

        __CLR_OR_THIS_CALL _Locimp(bool _Transparent)
            : locale::facet(1), _Facetvec(nullptr), _Facetcount(0), _Catmask(none), _Xparent(_Transparent), _Name("*") {
        }

        __CLR_OR_THIS_CALL _Locimp(const _Locimp& _Right)
            : locale::facet(1), _Facetvec(nullptr), _Facetcount(_Right._Facetcount), _Catmask(_Right._Catmask),
            _Xparent(_Right._Xparent), _Name(_Right._Name.c_str()) {
            _Locimp_ctor(this, _Right);
        }

        void __CLR_OR_THIS_CALL _Addfac(facet* _Pfacet, size_t _Id) { // add a facet
            _Locimp_Addfac(this, _Pfacet, _Id);
        }

        static _Locimp* __CLRCALL_OR_CDECL _Makeloc(
            const _Locinfo&, category, _Locimp*, const locale*); // make essential facets

        static void __CLRCALL_OR_CDECL _Makewloc(
            const _Locinfo&, category, _Locimp*, const locale*); // make wchar_t facets

#if defined(_NATIVE_WCHAR_T_DEFINED) && !_ENFORCE_FACET_SPECIALIZATIONS
        static void __CLRCALL_OR_CDECL _Makeushloc(
            const _Locinfo&, category, _Locimp*, const locale*); // make ushort facets
#endif // defined(_NATIVE_WCHAR_T_DEFINED) && !_ENFORCE_FACET_SPECIALIZATIONS

        static void __CLRCALL_OR_CDECL _Makexloc(
            const _Locinfo&, category, _Locimp*, const locale*); // make remaining facets

        facet** _Facetvec; // pointer to vector of facets
        size_t _Facetcount; // size of vector of facets
        category _Catmask; // mask describing implemented categories
        bool _Xparent; // true if locale is transparent
        _Yarn<char> _Name; // locale name, or "*" if not known

        __PURE_APPDOMAIN_GLOBAL static _Locimp* _Clocptr;

    public:
        _Locimp& __CLR_OR_THIS_CALL operator=(const _Locimp&) = delete;
    };

    template <class _Elem, class _Traits, class _Alloc>
    bool operator()(
        const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) const {
        // compare _Left and _Right strings using collate facet in locale
        const auto& _Coll_fac = _STD use_facet<_STD collate<_Elem>>(*this);

        const _Elem* const _Left_data = _Left.data();
        const _Elem* const _Right_data = _Right.data();
        return _Coll_fac.compare(_Left_data, _Left_data + _Left.size(), _Right_data, _Right_data + _Right.size()) < 0;
    }

    template <class _Facet>
    locale combine(const locale& _Loc) const { // combine two locales
        _Facet* _Facptr;

        _TRY_BEGIN
            _Facptr = const_cast<_Facet*>(_STD addressof(_STD use_facet<_Facet>(_Loc)));
        _CATCH_ALL
            _Xruntime_error("locale::combine facet missing");
        _CATCH_END

            _Locimp* _Newimp = _Locimp::_New_Locimp(*_Ptr);
        _Newimp->_Addfac(_Facptr, _Facet::id);
        _Newimp->_Catmask = none;
        _Newimp->_Name = "*";
        return locale{ _Secret_locale_construct_tag{}, _Newimp };
    }

    template <class _Facet>
    locale(const locale& _Loc, const _Facet* _Facptr) : _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr)) {
        if (_Facptr) { // replace facet
            _Ptr->_Addfac(const_cast<_Facet*>(_Facptr), _Facet::id);
            _Ptr->_Catmask = none;
            _Ptr->_Name = "*";
        }
    }

#pragma warning(push)
#pragma warning(disable : 26495) // Variable 'std::locale::_Ptr' is uninitialized.
    // Always initialize a member variable (type.6).

// We must not explicitly initialize _Ptr here; we rely on it maintaining the value
// previously created in its storage. To be precise:
// In locale0.cpp, locale::_Init() uses True Placement New at classic_locale's address,
// and classic_locale is constructed from the _Noinit enumerator of type _Uninitialized.
// The sequencing is highly unusual; the True Placement New happens before the _Uninitialized construction,
// so while _Ptr here formally has indeterminate value, we expect it to actually keep the previous value.
    locale(_Uninitialized) {} // defer construction
#pragma warning(pop)

    locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) {
        _Ptr->_Incref();
    }

    locale() noexcept : _Ptr(_Init(true)) {}

#if !defined(MRTDLL) || !defined(_CRTBLD)
    locale(const locale& _Loc, const locale& _Other, category _Cat) : _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr)) {
        // construct a locale by copying named facets
        if (_Cat != none) { // worth adding, do it
            _STL_ASSERT((_Cat & all) == _Cat, "the bitmask value specifying category must be valid");
            _Facet_guard _Guard{ _Ptr };
            _BEGIN_LOCINFO(_Lobj)
                _Locimp::_Makeloc(_Lobj, _Cat, _Ptr, &_Other);
            _Lobj._Addcats(_Loc._Ptr->_Catmask, _Loc.name().c_str());
            _Lobj._Addcats(_Other._Ptr->_Catmask, _Other.name().c_str());
            _Ptr->_Catmask = _Loc._Ptr->_Catmask | _Other._Ptr->_Catmask;
            _Ptr->_Name = _Lobj._Getname();
            _END_LOCINFO()
                _Guard._Target = nullptr;
        }
    }

private:
    void _Construct(const string& _Str, category _Cat) {
        _STL_ASSERT((_Cat & all) == _Cat, "the bitmask value specifying category must be valid");
        // construct a locale with named facets
        bool _Bad = false;
        _Init();
        if (_Cat != none) { // worth adding, do it
            _Facet_guard _Guard{ _Ptr };
            _BEGIN_LOCINFO(_Lobj(_Cat, _Str.c_str()))
                if (_Badname(_Lobj)) {
                    _Bad = true;
                }
                else { // name okay, build the locale
                    _Locimp::_Makeloc(_Lobj, _Cat, _Ptr, nullptr);
                    _Ptr->_Catmask = _Cat;
                    _Ptr->_Name = _Str.c_str();
                }
            _END_LOCINFO()
                _Guard._Target = nullptr;
        }

        if (_Bad) { // Don't throw within _BEGIN_LOCINFO if we can avoid it
            delete _Ptr->_Decref();
            _Xruntime_error("bad locale name");
        }
    }

public:
    explicit locale(const char* _Locname, category _Cat = all) : _Ptr(_Locimp::_New_Locimp()) {
        // construct a locale with named facets
        // _Locname might have been returned from setlocale().
        // Therefore, _Construct() takes const string&.
        if (_Locname) {
            _Construct(_Locname, _Cat);
            return;
        }

        _Xruntime_error("bad locale name");
    }

    locale(const locale& _Loc, const char* _Locname, category _Cat) : _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr)) {
        // construct a locale by copying, replacing named facets
        // _Locname might have been returned from setlocale().
        // Therefore, _Construct() takes const string&.
        if (_Locname) {
            _Construct(_Locname, _Cat);
            return;
        }

        _Xruntime_error("bad locale name");
    }

    explicit locale(const string& _Str, category _Cat = all) : _Ptr(_Locimp::_New_Locimp()) {
        // construct a locale with named facets
        _Construct(_Str, _Cat);
    }

    locale(const locale& _Loc, const string& _Str, category _Cat) : _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr)) {
        // construct a locale by copying, replacing named facets
        _Construct(_Str, _Cat);
    }
#endif // !MRTDLL || !_CRTBLD

    ~locale() noexcept {
        if (_Ptr) {
            delete _Ptr->_Decref();
        }
    }

    const locale& operator=(const locale& _Right) noexcept {
        if (_Ptr != _Right._Ptr) { // different implementation, point at new one
            delete _Ptr->_Decref();
            _Ptr = _Right._Ptr;
            _Ptr->_Incref();
        }
        return *this;
    }

    string name() const {
        return _Ptr ? _Ptr->_Name.c_str() : string{};
    }

    _Ret_z_ const char* _C_str() const noexcept {
        return _Ptr ? _Ptr->_Name.c_str() : "";
    }

    const facet* _Getfacet(size_t _Id) const { // look up a facet in locale object
        const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end
        if (_Facptr || !_Ptr->_Xparent) {
            return _Facptr; // found facet or not transparent
        }

        // look in current locale
        locale::_Locimp* _Ptr0 = _Getgloballocale();
        if (_Id < _Ptr0->_Facetcount) {
            return _Ptr0->_Facetvec[_Id]; // get from current locale
        }

        return nullptr; // no entry in current locale
    }

    _NODISCARD bool operator==(const locale& _Loc) const noexcept /* strengthened */ { // compare locales for equality
        return _Ptr == _Loc._Ptr || (_CSTD strcmp(_C_str(), "*") != 0 && _CSTD strcmp(_C_str(), _Loc._C_str()) == 0);
    }

#if !_HAS_CXX20
    _NODISCARD bool operator!=(const locale& _Right) const noexcept /* strengthened */ {
        return !(*this == _Right);
    }
#endif // !_HAS_CXX20

    static _MRTIMP2_PURE const locale& __CLRCALL_PURE_OR_CDECL classic(); // classic "C" locale

    static _MRTIMP2_PURE locale __CLRCALL_PURE_OR_CDECL global(const locale&); // current locale

    static _MRTIMP2_PURE locale __CLRCALL_PURE_OR_CDECL empty(); // empty (transparent) locale

private:
    struct _Secret_locale_construct_tag {
        explicit _Secret_locale_construct_tag() = default;
    };

    explicit locale(_Secret_locale_construct_tag, _Locimp* _Ptrimp) : _Ptr(_Ptrimp) {}

    static _MRTIMP2_PURE _Locimp* __CLRCALL_PURE_OR_CDECL _Init(bool _Do_incref = false); // initialize locale
    static _MRTIMP2_PURE _Locimp* __CLRCALL_PURE_OR_CDECL _Getgloballocale();
    static _MRTIMP2_PURE void __CLRCALL_PURE_OR_CDECL _Setgloballocale(void*);

    bool _Badname(const _Locinfo& _Lobj) { // test if name is "*"
        return _CSTD strcmp(_Lobj._Getname(), "*") == 0;
    }

    _Locimp* _Ptr; // pointer to locale implementation object
};

template <class _Facet>
struct _Facetptr { // store pointer to lazy facet for use_facet
    __PURE_APPDOMAIN_GLOBAL static const locale::facet* _Psave;
};

template <class _Facet>
__PURE_APPDOMAIN_GLOBAL const locale::facet* _Facetptr<_Facet>::_Psave = nullptr;

_EXPORT_STD template <class _Facet>
const _Facet& __CRTDECL use_facet(const locale& _Loc) { // get facet reference from locale
    _BEGIN_LOCK(_LOCK_LOCALE) // the thread lock, make get atomic
        const locale::facet* _Psave = _Facetptr<_Facet>::_Psave; // static pointer to lazy facet

    const size_t _Id = _Facet::id;
    const locale::facet* _Pf = _Loc._Getfacet(_Id);

    if (!_Pf) {
        if (_Psave) {
            _Pf = _Psave; // lazy facet already allocated
        }
        else if (_Facet::_Getcat(&_Psave, &_Loc) == static_cast<size_t>(-1)) {
#if _HAS_EXCEPTIONS
            _Throw_bad_cast(); // lazy disallowed
#else
            _CSTD abort(); // lazy disallowed
#endif
        }
        else { // queue up lazy facet for destruction
            auto _Pfmod = const_cast<locale::facet*>(_Psave);
            unique_ptr<_Facet_base> _Psave_guard(static_cast<_Facet_base*>(_Pfmod));

#if defined(_M_CEE)
            _Facet_Register_m(_Pfmod);
#else // ^^^ defined(_M_CEE) / !defined(_M_CEE) vvv
            _Facet_Register(_Pfmod);
#endif // ^^^ !defined(_M_CEE) ^^^

            _Pfmod->_Incref();
            _Facetptr<_Facet>::_Psave = _Psave;
            _Pf = _Psave;

            (void)_Psave_guard.release();
        }
    }

    return static_cast<const _Facet&>(*_Pf); // should be dynamic_cast
    _END_LOCK()
} // end of use_facet body

template <class _Elem>
char __CRTDECL _Maklocbyte(_Elem _Char, const _Locinfo::_Cvtvec&) {
    // convert _Elem to char using _Cvtvec
    return static_cast<char>(static_cast<unsigned char>(_Char));
}

template <>
inline char __CRTDECL _Maklocbyte(wchar_t _Char, const _Locinfo::_Cvtvec& _Cvt) {
    // convert wchar_t to char using _Cvtvec
    char _Byte = '\0';
    mbstate_t _Mbst1 = {};
    _Wcrtomb(&_Byte, _Char, &_Mbst1, &_Cvt);
    return _Byte;
}

#if defined(_NATIVE_WCHAR_T_DEFINED) && !_ENFORCE_FACET_SPECIALIZATIONS
template <>
inline char __CRTDECL _Maklocbyte(unsigned short _Char, const _Locinfo::_Cvtvec& _Cvt) {
    // convert unsigned short to char using _Cvtvec
    char _Byte = '\0';
    mbstate_t _Mbst1 = {};
    _Wcrtomb(&_Byte, static_cast<wchar_t>(_Char), &_Mbst1, &_Cvt);
    return _Byte;
}
#endif // defined(_NATIVE_WCHAR_T_DEFINED) && !_ENFORCE_FACET_SPECIALIZATIONS

template <class _Elem>
_Elem __CRTDECL _Maklocchr(char _Byte, _Elem*, const _Locinfo::_Cvtvec&) {
    // convert char to _Elem using _Cvtvec
    return static_cast<_Elem>(static_cast<unsigned char>(_Byte));
}

template <>
inline wchar_t __CRTDECL _Maklocchr(char _Byte, wchar_t*, const _Locinfo::_Cvtvec& _Cvt) {
    // convert char to wchar_t using _Cvtvec
    wchar_t _Wc = L'\0';
    mbstate_t _Mbst1 = {};
    _Mbrtowc(&_Wc, &_Byte, 1, &_Mbst1, &_Cvt);
    return _Wc;
}

#if defined(_NATIVE_WCHAR_T_DEFINED) && !_ENFORCE_FACET_SPECIALIZATIONS
template <>
inline unsigned short __CRTDECL _Maklocchr(char _Byte, unsigned short*, const _Locinfo::_Cvtvec& _Cvt) {
    // convert char to unsigned short using _Cvtvec
    unsigned short _Wc = 0;
    mbstate_t _Mbst1 = {};
    _Mbrtowc(reinterpret_cast<wchar_t*>(&_Wc), &_Byte, 1, &_Mbst1, &_Cvt);
    return _Wc;
}
#endif // defined(_NATIVE_WCHAR_T_DEFINED) && !_ENFORCE_FACET_SPECIALIZATIONS

template <class _Elem>
_Elem* __CRTDECL _Maklocstr(const char* _Ptr, _Elem*, const _Locinfo::_Cvtvec&) {
    // convert C string to _Elem sequence using _Cvtvec
    size_t _Count = _CSTD strlen(_Ptr) + 1;

    _Elem* _Ptrdest = static_cast<_Elem*>(_calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__));

    if (!_Ptrdest) {
        _Xbad_alloc();
    }

    for (_Elem* _Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr) {
        *_Ptrnext = static_cast<_Elem>(static_cast<unsigned char>(*_Ptr));
    }

    return _Ptrdest;
}

template <>
inline wchar_t* __CRTDECL _Maklocstr(const char* _Ptr, wchar_t*, const _Locinfo::_Cvtvec& _Cvt) {
    // convert C string to wchar_t sequence using _Cvtvec
    size_t _Count;
    size_t _Count1;
    size_t _Wchars;
    const char* _Ptr1;
    int _Bytes;
    wchar_t _Wc;
    mbstate_t _Mbst1 = {};

    _Count1 = _CSTD strlen(_Ptr) + 1;
    for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count; _Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars) {
        if ((_Bytes = _Mbrtowc(&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0) {
            break;
        }
    }

    ++_Wchars; // count terminating nul

    wchar_t* _Ptrdest = static_cast<wchar_t*>(_calloc_dbg(_Wchars, sizeof(wchar_t), _CRT_BLOCK, __FILE__, __LINE__));

    if (!_Ptrdest) {
        _Xbad_alloc();
    }

    wchar_t* _Ptrnext = _Ptrdest;
    mbstate_t _Mbst2 = {};

    for (; 0 < _Wchars; _Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext) {
        if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0) {
            break;
        }
    }

    *_Ptrnext = L'\0';

    return _Ptrdest;
}

#if defined(_NATIVE_WCHAR_T_DEFINED) && !_ENFORCE_FACET_SPECIALIZATIONS
template <>
inline unsigned short* __CRTDECL _Maklocstr(const char* _Ptr, unsigned short*, const _Locinfo::_Cvtvec& _Cvt) {
    // convert C string to unsigned short sequence using _Cvtvec
    size_t _Count;
    size_t _Count1;
    size_t _Wchars;
    const char* _Ptr1;
    int _Bytes;
    unsigned short _Wc;
    mbstate_t _Mbst1 = {};

    _Count1 = _CSTD strlen(_Ptr) + 1;
    for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count; _Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars) {
        if ((_Bytes = _Mbrtowc(reinterpret_cast<wchar_t*>(&_Wc), _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0) {
            break;
        }
    }

    ++_Wchars; // count terminating nul

    wchar_t* _Ptrdest = static_cast<wchar_t*>(_calloc_dbg(_Wchars, sizeof(wchar_t), _CRT_BLOCK, __FILE__, __LINE__));

    if (!_Ptrdest) {
        _Xbad_alloc();
    }

    wchar_t* _Ptrnext = _Ptrdest;
    mbstate_t _Mbst2 = {};
    for (; 0 < _Wchars; _Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext) {
        if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0) {
            break;
        }
    }

    *_Ptrnext = L'\0';
    return reinterpret_cast<unsigned short*>(_Ptrdest);
}
#endif // defined(_NATIVE_WCHAR_T_DEFINED) && !_ENFORCE_FACET_SPECIALIZATIONS

_EXPORT_STD extern "C++" class _CRTIMP2_PURE_IMPORT codecvt_base // base class for codecvt
    : public locale::facet // TRANSITION, ABI, shouldn't be derived from locale::facet
{
public:
    enum { // constants for different parse states
        ok,
        partial,
        error,
        noconv
    };
    using result = int;

    __CLR_OR_THIS_CALL codecvt_base(size_t _Refs = 0) noexcept // strengthened
        : locale::facet(_Refs) {}

    bool __CLR_OR_THIS_CALL always_noconv() const noexcept {
        // return true if conversions never change input (from codecvt)
        return do_always_noconv();
    }

    int __CLR_OR_THIS_CALL max_length() const noexcept {
        // return maximum length required for a conversion (from codecvt)
        return do_max_length();
    }

    int __CLR_OR_THIS_CALL encoding() const noexcept {
        return do_encoding();
    }

    __CLR_OR_THIS_CALL ~codecvt_base() noexcept {}

protected:
    virtual bool __CLR_OR_THIS_CALL do_always_noconv() const noexcept {
        // return true if conversions never change input (from codecvt)
        return false;
    }

    virtual int __CLR_OR_THIS_CALL do_max_length() const noexcept {
        // return maximum length required for a conversion (from codecvt)
        return 1;
    }

    virtual int __CLR_OR_THIS_CALL do_encoding() const noexcept {
        return 1; // -1 ==> state dependent, 0 ==> varying length
    }
};

template <class _Ty>
_INLINE_VAR constexpr bool _Is_one_byte_char_like_v = _Is_any_of_v<remove_cv_t<_Ty>, signed char, unsigned char,
#ifdef __cpp_lib_byte
    byte,
#endif // defined(__cpp_lib_byte)
#ifdef __cpp_char8_t
    char8_t,
#endif // defined(__cpp_char8_t)
    char>;

template <class _Elem, class _Byte>
_INLINE_VAR constexpr bool _Is_codecvt_do_always_noconv_v =
is_same_v<_Byte, _Elem> || (_Is_one_byte_char_like_v<_Byte> && _Is_one_byte_char_like_v<_Elem>);

_EXPORT_STD extern "C++" template <class _Elem, class _Byte, class _Statype>
class codecvt : public codecvt_base { // facet for converting between _Elem and _Byte sequences
public:
    // Explicitly specialized below:
    // codecvt<wchar_t, char, mbstate_t>
    // codecvt<unsigned short, char, mbstate_t> (extension)
    // codecvt<char16_t, char, mbstate_t>
    // codecvt<char32_t, char, mbstate_t>
    // codecvt<char16_t, char8_t, mbstate_t>
    // codecvt<char32_t, char8_t, mbstate_t>

    static_assert(!_ENFORCE_FACET_SPECIALIZATIONS || is_same_v<codecvt, codecvt<char, char, mbstate_t>>,
        _FACET_SPECIALIZATION_MESSAGE);

    using intern_type = _Elem;
    using extern_type = _Byte;
    using state_type = _Statype;

    result __CLR_OR_THIS_CALL in(_Statype& _State, const _Byte* _First1, const _Byte* _Last1, const _Byte*& _Mid1,
        _Elem* _First2, _Elem* _Last2, _Elem*& _Mid2) const { // convert bytes [_First1, _Last1) to [_First2, _Last2)
        return do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }

    result __CLR_OR_THIS_CALL out(_Statype& _State, const _Elem* _First1, const _Elem* _Last1, const _Elem*& _Mid1,
        _Byte* _First2, _Byte* _Last2, _Byte*& _Mid2) const { // convert [_First1, _Last1) to bytes [_First2, _Last2)
        return do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }

    result __CLR_OR_THIS_CALL unshift(_Statype& _State, _Byte* _First2, _Byte* _Last2, _Byte*& _Mid2) const {
        // generate bytes to return to default shift state
        return do_unshift(_State, _First2, _Last2, _Mid2);
    }

    int __CLR_OR_THIS_CALL length(_Statype& _State, const _Byte* _First1, const _Byte* _Last1, size_t _Count) const {
        // return p - _First1, for the largest value p in [_First1, _Last1] such that [_First1, p) successfully
        // converts to at most _Count _Elems
        return do_length(_State, _First1, _Last1, _Count);
    }

    __PURE_APPDOMAIN_GLOBAL static locale::id id; // unique facet id

    explicit __CLR_OR_THIS_CALL codecvt(size_t _Refs = 0) : codecvt_base(_Refs) {
        _Init(_Locinfo());
    }

    explicit __CLR_OR_THIS_CALL codecvt(const _Locinfo& _Lobj, size_t _Refs = 0) : codecvt_base(_Refs) {
        _Init(_Lobj);
    }

    static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        // return locale category mask and construct standard facet
        if (_Ppf && !*_Ppf) {
            *_Ppf = new codecvt(_Locinfo(_Ploc->_C_str()));
        }

        return _X_CTYPE;
    }

protected:
    __CLR_OR_THIS_CALL ~codecvt() noexcept override {}

    void __CLR_OR_THIS_CALL _Init(const _Locinfo&) {} // initialize from _Locinfo object

    bool __CLR_OR_THIS_CALL do_always_noconv() const noexcept override {
        // return true if conversions never change input (from codecvt)
        return _Is_codecvt_do_always_noconv_v<_Elem, _Byte>;
    }

    virtual result __CLR_OR_THIS_CALL do_in(_Statype&, const _Byte* _First1, const _Byte* _Last1, const _Byte*& _Mid1,
        _Elem* _First2, _Elem* _Last2, _Elem*& _Mid2) const { // convert bytes [_First1, _Last1) to [_First2, _Last2)
        _Mid1 = _First1;
        _Mid2 = _First2;
        if constexpr (_Is_codecvt_do_always_noconv_v<_Elem, _Byte>) {
            return noconv; // convert nothing
        }
        else {
            // types differ, copy one for one
            for (; _Mid1 != _Last1; ++_Mid1, ++_Mid2) {
                if (_Mid2 == _Last2) {
                    return partial;
                }
                *_Mid2 = static_cast<_Elem>(*_Mid1);
            }

            return ok;
        }
    }

    virtual result __CLR_OR_THIS_CALL do_out(_Statype&, const _Elem* _First1, const _Elem* _Last1, const _Elem*& _Mid1,
        _Byte* _First2, _Byte* _Last2, _Byte*& _Mid2) const { // convert [_First1, _Last1) to bytes [_First2, _Last2)
        _Mid1 = _First1;
        _Mid2 = _First2;
        if constexpr (_Is_codecvt_do_always_noconv_v<_Elem, _Byte>) {
            return noconv; // convert nothing
        }
        else {
            // types differ, copy one for one
            for (; _Mid1 != _Last1; ++_Mid1, ++_Mid2) {
                if (_Mid2 == _Last2) {
                    return partial;
                }
                *_Mid2 = static_cast<_Byte>(*_Mid1);
            }

            return ok;
        }
    }

    virtual result __CLR_OR_THIS_CALL do_unshift(_Statype&, _Byte* _First2, _Byte*, _Byte*& _Mid2) const {
        // generate bytes to return to default shift state
        _Mid2 = _First2;
        return noconv; // no termination required
    }

    virtual int __CLR_OR_THIS_CALL do_length(
        _Statype&, const _Byte* _First1, const _Byte* _Last1, size_t _Count) const {
        // return p - _First1, for the largest value p in [_First1, _Last1] such that [_First1, p) successfully
        // converts to at most _Count _Elems
        // assumes 1:1 conversion
        const auto _Dist = static_cast<size_t>((_STD min)(_Last1 - _First1, ptrdiff_t{ INT_MAX }));
        return static_cast<int>((_STD min)(_Count, _Dist));
    }
};

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdllimport-static-field-def"
#endif // defined(__clang__)

template <class _Elem, class _Byte, class _Statype>
__PURE_APPDOMAIN_GLOBAL locale::id codecvt<_Elem, _Byte, _Statype>::id;

#ifdef __clang__
#pragma clang diagnostic pop
#endif // defined(__clang__)

_EXPORT_STD /* TRANSITION, VSO-1538698 */ template <class _CvtTy, class _Byte, class _Statype>
_NODISCARD int _Codecvt_do_length(
    const _CvtTy& _Cvt, _Statype& _State, const _Byte* _First1, const _Byte* _Last1, size_t _Count) {
    // return p - _First1, for the largest value p in [_First1, _Last1] such that _Cvt will successfully convert
    // [_First1, p) to at most _Count wide characters

    _STL_DISABLE_DEPRECATED_WARNING
        using _Elem = typename _CvtTy::intern_type;
    _STL_RESTORE_DEPRECATED_WARNING

        _Adl_verify_range(_First1, _Last1);
    const auto _Old_first1 = _First1;

    while (_Count > 0 && _First1 != _Last1) { // convert another wide character
        const _Byte* _Mid1;
        _Elem* _Mid2;
        _Elem _Ch;

        // test result of single wide-char conversion

        _STL_DISABLE_DEPRECATED_WARNING
            const auto _Result = _Cvt._CvtTy::do_in(_State, _First1, _Last1, _Mid1, &_Ch, &_Ch + 1, _Mid2);
        _STL_RESTORE_DEPRECATED_WARNING

            if (_Result != codecvt_base::ok) {
                if (_Result == codecvt_base::noconv) {
                    _First1 += (_STD min)(static_cast<size_t>(_Last1 - _First1), _Count);
                }

                break; // error, noconv, or partial
            }

        if (_Mid2 == &_Ch + 1) {
            --_Count; // do_in converted an output character
        }

        _First1 = _Mid1;
    }

    return static_cast<int>((_STD min)(_First1 - _Old_first1, ptrdiff_t{ INT_MAX }));
}

enum _Codecvt_mode { _Consume_header = 4, _Generate_header = 2 };

extern "C++" template <>
class _CRTIMP2_PURE_IMPORT_UNLESS_CODECVT_ID_SATELLITE _CXX20_DEPRECATE_CODECVT_FACETS
    codecvt<char16_t, char, mbstate_t> : public codecvt_base{
    // facet for converting between char16_t and UTF-8 byte sequences
public:
    using intern_type = char16_t;
    using extern_type = char;
    using state_type = mbstate_t;

    result __CLR_OR_THIS_CALL in(mbstate_t& _State, const char* _First1, const char* _Last1, const char*& _Mid1,
        char16_t* _First2, char16_t* _Last2, char16_t*& _Mid2) const {
        // convert bytes [_First1, _Last1) to [_First2, _Last2)
        return do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }

    result __CLR_OR_THIS_CALL out(mbstate_t& _State, const char16_t* _First1, const char16_t* _Last1,
        const char16_t*& _Mid1, char* _First2, char* _Last2, char*& _Mid2) const {
        // convert [_First1, _Last1) to bytes [_First2, _Last2)
        return do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }

    result __CLR_OR_THIS_CALL unshift(mbstate_t& _State, char* _First2, char* _Last2, char*& _Mid2) const {
        // generate bytes to return to default shift state
        return do_unshift(_State, _First2, _Last2, _Mid2);
    }

    int __CLR_OR_THIS_CALL length(mbstate_t& _State, const char* _First1, const char* _Last1, size_t _Count) const {
        // return p - _First1, for the largest value p in [_First1, _Last1] such that [_First1, p) successfully
        // converts to at most _Count UTF-16 code units
        return do_length(_State, _First1, _Last1, _Count);
    }

    _CRT_SATELLITE_CODECVT_IDS_NOIMPORT static locale::id id;

    explicit __CLR_OR_THIS_CALL codecvt(size_t _Refs = 0)
        : codecvt_base(_Refs), _Maxcode(0x10ffff), _Mode(_Consume_header) {
        _BEGIN_LOCINFO(_Lobj)
        _Init(_Lobj);
        _END_LOCINFO()
    }

    explicit __CLR_OR_THIS_CALL codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
        : codecvt_base(_Refs), _Maxcode(0x10ffff), _Mode(_Consume_header) {
        _Init(_Lobj);
    }

    __CLR_OR_THIS_CALL codecvt(
        const _Locinfo& _Lobj, unsigned long _Maxcode_arg, _Codecvt_mode _Mode_arg, size_t _Refs = 0)
        : codecvt_base(_Refs), _Maxcode(_Maxcode_arg), _Mode(_Mode_arg) {
        _Init(_Lobj);
    }

    static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        // return locale category mask and construct standard facet
        if (_Ppf && !*_Ppf) {
            _STL_DISABLE_DEPRECATED_WARNING
            * _Ppf = new codecvt(_Locinfo(_Ploc->_C_str()));
            _STL_RESTORE_DEPRECATED_WARNING
        }

        return _X_CTYPE;
    }

protected:
    __CLR_OR_THIS_CALL ~codecvt() noexcept override {}

    void __CLR_OR_THIS_CALL _Init(const _Locinfo&) {} // initialize

    virtual result __CLR_OR_THIS_CALL do_in(mbstate_t& _State, const char* _First1, const char* _Last1,
        const char*& _Mid1, char16_t* _First2, char16_t* _Last2, char16_t*& _Mid2) const {
        // convert bytes [_First1, _Last1) to [_First2, _Last2)
        unsigned short* _Pstate = reinterpret_cast<unsigned short*>(&_State);
        _Mid1 = _First1;
        _Mid2 = _First2;

        while (_Mid1 != _Last1 && _Mid2 != _Last2) { // convert a multibyte sequence
            unsigned char _By = static_cast<unsigned char>(*_Mid1);
            unsigned long _Ch;
            int _Nextra;
            int _Nskip;

            if (*_Pstate > 1) {
                if (_By < 0x80 || 0xc0 <= _By) {
                    return codecvt::error; // not continuation byte
                }

                // deliver second half of two-word value
                ++_Mid1;
                *_Mid2++ = static_cast<char16_t>(*_Pstate | (_By & 0x3f));
                *_Pstate = 1;
                continue;
            }

            if (_By < 0x80u) {
                _Ch = _By;
                _Nextra = 0;
            }
 else if (_By < 0xc0u) { // 0x80-0xbf not first byte
  ++_Mid1;
  return codecvt::error;
}
else if (_By < 0xe0u) {
 _Ch = static_cast<unsigned long>(_By & 0x1f);
 _Nextra = 1;
}
else if (_By < 0xf0u) {
 _Ch = static_cast<unsigned long>(_By & 0x0f);
 _Nextra = 2;
}
else if (_By < 0xf8u) {
 _Ch = static_cast<unsigned long>(_By & 0x07);
 _Nextra = 3;
}
else {
 _Ch = static_cast<unsigned long>(_By & 0x03);
 _Nextra = _By < 0xfc ? 4 : 5;
}

_Nskip = _Nextra < 3 ? 0 : 1; // leave a byte for 2nd word
_First1 = _Mid1; // roll back point

if (_Nextra == 0) {
    ++_Mid1;
}
else if (_Last1 - _Mid1 < _Nextra + 1 - _Nskip) {
 break; // not enough input
}
else {
 for (++_Mid1; _Nskip < _Nextra; --_Nextra, ++_Mid1) {
     if ((_By = static_cast<unsigned char>(*_Mid1)) < 0x80u || 0xc0u <= _By) {
         return codecvt::error; // not continuation byte
     }
else {
 _Ch = _Ch << 6 | (_By & 0x3f);
}
}
}

if (0 < _Nskip) {
    _Ch <<= 6; // get last byte on next call
}

if ((_Maxcode < 0x10ffffu ? _Maxcode : 0x10ffffu) < _Ch) {
    return codecvt::error; // value too large
}

if (0xffffu < _Ch) { // deliver first half of two-word value, save second word
    unsigned short _Ch0 = static_cast<unsigned short>(0xd800 | (_Ch >> 10) - 0x0040);

    *_Mid2++ = static_cast<char16_t>(_Ch0);
    *_Pstate = static_cast<unsigned short>(0xdc00 | (_Ch & 0x03ff));
    continue;
}

if (_Nskip != 0) {
    if (_Mid1 == _Last1) { // not enough bytes, noncanonical value
        _Mid1 = _First1;
        break;
    }

    if ((_By = static_cast<unsigned char>(*_Mid1++)) < 0x80u || 0xc0u <= _By) {
        return codecvt::error; // not continuation byte
    }

    _Ch |= _By & 0x3f; // complete noncanonical value
}

if (*_Pstate == 0u) { // first time, maybe look for and consume header
    *_Pstate = 1;

    if ((_Mode & _Consume_header) != 0 && _Ch == 0xfeffu) { // drop header and retry
        const result _Ans = do_in(_State, _Mid1, _Last1, _Mid1, _First2, _Last2, _Mid2);

        if (_Ans == codecvt::partial) { // roll back header determination
            *_Pstate = 0;
            _Mid1 = _First1;
        }

        return _Ans;
    }
}

*_Mid2++ = static_cast<char16_t>(_Ch);
}

return _First1 == _Mid1 ? codecvt::partial : codecvt::ok;
}

virtual result __CLR_OR_THIS_CALL do_out(mbstate_t& _State, const char16_t* _First1, const char16_t* _Last1,
    const char16_t*& _Mid1, char* _First2, char* _Last2, char*& _Mid2) const {
    // convert [_First1, _Last1) to bytes [_First2, _Last2)
    unsigned short* _Pstate = reinterpret_cast<unsigned short*>(&_State);
    _Mid1 = _First1;
    _Mid2 = _First2;

    while (_Mid1 != _Last1 && _Mid2 != _Last2) { // convert and put a wide char
        unsigned long _Ch;
        const unsigned short _Ch1 = static_cast<unsigned short>(*_Mid1);
        bool _Save = false;

        if (1 < *_Pstate) { // get saved MS 11 bits from *_Pstate
            if (_Ch1 < 0xdc00u || 0xe000u <= _Ch1) {
                return codecvt::error; // bad second word
            }

            _Ch = static_cast<unsigned long>((*_Pstate << 10) | (_Ch1 - 0xdc00));
        }
else if (0xd800u <= _Ch1 && _Ch1 < 0xdc00u) { // get new first word
 _Ch = static_cast<unsigned long>((_Ch1 - 0xd800 + 0x0040) << 10);
 _Save = true; // put only first byte, rest with second word
}
else {
 _Ch = _Ch1; // not first word, just put it
}

char _By;
int _Nextra;

if (_Ch < 0x0080u) {
    _By = static_cast<char>(_Ch);
    _Nextra = 0;
}
else if (_Ch < 0x0800u) {
 _By = static_cast<char>(0xc0 | _Ch >> 6);
 _Nextra = 1;
}
else if (_Ch < 0x10000u) {
 _By = static_cast<char>(0xe0 | _Ch >> 12);
 _Nextra = 2;
}
else {
 _By = static_cast<char>(0xf0 | _Ch >> 18);
 _Nextra = 3;
}

int _Nput = _Nextra < 3 ? _Nextra + 1 : _Save ? 1 : 3;

if (_Last2 - _Mid2 < _Nput) {
    break; // not enough room, even without header
}

if (*_Pstate == 0u && (_Mode & _Generate_header) != 0) {
    if (_Last2 - _Mid2 < 3 + _Nput) {
        break; // not enough room for header + output
    }

    // prepend header
    *_Mid2++ = '\xef';
    *_Mid2++ = '\xbb';
    *_Mid2++ = '\xbf';
}

++_Mid1;
if (_Save || _Nextra < 3) { // put first byte of sequence, if not already put
    *_Mid2++ = _By;
    --_Nput;
}

for (; 0 < _Nput; --_Nput) {
    *_Mid2++ = static_cast<char>((_Ch >> 6 * --_Nextra & 0x3f) | 0x80);
}

*_Pstate = static_cast<unsigned short>(_Save ? _Ch >> 10 : 1);
}

return _First1 == _Mid1 ? codecvt::partial : codecvt::ok;
}

virtual result __CLR_OR_THIS_CALL do_unshift(mbstate_t& _State, char* _First2, char*, char*& _Mid2) const {
    // generate bytes to return to default shift state
    unsigned short* _Pstate = reinterpret_cast<unsigned short*>(&_State);
    _Mid2 = _First2;

    return 1u < *_Pstate ? codecvt::error : codecvt::ok; // fail if trailing first word
}

friend int _Codecvt_do_length<>(const codecvt&, mbstate_t&, const char*, const char*, size_t);

virtual int __CLR_OR_THIS_CALL do_length(
    mbstate_t& _State, const char* _First1, const char* _Last1, size_t _Count) const {
    return _Codecvt_do_length(*this, _State, _First1, _Last1, _Count);
}

bool __CLR_OR_THIS_CALL do_always_noconv() const noexcept override {
    // return true if conversions never change input
    return false;
}

int __CLR_OR_THIS_CALL do_max_length() const noexcept override {
    // return maximum length required for a conversion

    if ((_Mode & _Consume_header) != 0) {
        return 9; // header + max input
    }

    if ((_Mode & _Generate_header) != 0) {
        return 7; // header + max output
    }

    return 6; // 6-byte max input sequence, no 3-byte header
}

int do_encoding() const noexcept override {
    return 0; // 0 => varying length
}

private:
    unsigned long _Maxcode; // default: 0x10ffff
    _Codecvt_mode _Mode; // default: _Consume_header
};

extern "C++" template <>
class _CRTIMP2_PURE_IMPORT_UNLESS_CODECVT_ID_SATELLITE _CXX20_DEPRECATE_CODECVT_FACETS
    codecvt<char32_t, char, mbstate_t> : public codecvt_base{
    // facet for converting between char32_t and UTF-8 byte sequences
public:
    using intern_type = char32_t;
    using extern_type = char;
    using state_type = mbstate_t;

    result __CLR_OR_THIS_CALL in(mbstate_t& _State, const char* _First1, const char* _Last1, const char*& _Mid1,
        char32_t* _First2, char32_t* _Last2, char32_t*& _Mid2) const {
        // convert bytes [_First1, _Last1) to [_First2, _Last2)
        return do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }

    result __CLR_OR_THIS_CALL out(mbstate_t& _State, const char32_t* _First1, const char32_t* _Last1,
        const char32_t*& _Mid1, char* _First2, char* _Last2, char*& _Mid2) const {
        // convert [_First1, _Last1) to bytes [_First2, _Last2)
        return do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }

    result __CLR_OR_THIS_CALL unshift(mbstate_t& _State, char* _First2, char* _Last2, char*& _Mid2) const {
        // generate bytes to return to default shift state
        return do_unshift(_State, _First2, _Last2, _Mid2);
    }

    int __CLR_OR_THIS_CALL length(mbstate_t& _State, const char* _First1, const char* _Last1, size_t _Count) const {
        // return p - _First1, for the largest value p in [_First1, _Last1] such that [_First1, p) successfully
        // converts to at most _Count UTF-32 code units
        return do_length(_State, _First1, _Last1, _Count);
    }

    _CRT_SATELLITE_CODECVT_IDS_NOIMPORT static locale::id id;

    explicit __CLR_OR_THIS_CALL codecvt(size_t _Refs = 0)
        : codecvt_base(_Refs), _Maxcode(0xffffffff), _Mode(_Consume_header) {
        _BEGIN_LOCINFO(_Lobj)
        _Init(_Lobj);
        _END_LOCINFO()
    }

    explicit __CLR_OR_THIS_CALL codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
        : codecvt_base(_Refs), _Maxcode(0xffffffff), _Mode(_Consume_header) {
        _Init(_Lobj);
    }

    __CLR_OR_THIS_CALL codecvt(
        const _Locinfo& _Lobj, unsigned long _Maxcode_arg, _Codecvt_mode _Mode_arg, size_t _Refs = 0)
        : codecvt_base(_Refs), _Maxcode(_Maxcode_arg), _Mode(_Mode_arg) {
        _Init(_Lobj);
    }

    static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        // return locale category mask and construct standard facet
        if (_Ppf && !*_Ppf) {
            _STL_DISABLE_DEPRECATED_WARNING
            * _Ppf = new codecvt(_Locinfo(_Ploc->_C_str()));
            _STL_RESTORE_DEPRECATED_WARNING
        }

        return _X_CTYPE;
    }

protected:
    __CLR_OR_THIS_CALL ~codecvt() noexcept override {}

    void __CLR_OR_THIS_CALL _Init(const _Locinfo&) {} // initialize

    virtual result __CLR_OR_THIS_CALL do_in(mbstate_t& _State, const char* _First1, const char* _Last1,
        const char*& _Mid1, char32_t* _First2, char32_t* _Last2, char32_t*& _Mid2) const {
        // convert bytes [_First1, _Last1) to [_First2, _Last2)
        char* _Pstate = reinterpret_cast<char*>(&_State);
        _Mid1 = _First1;
        _Mid2 = _First2;

        while (_Mid1 != _Last1 && _Mid2 != _Last2) { // convert a multibyte sequence
            unsigned char _By = static_cast<unsigned char>(*_Mid1);
            unsigned long _Ch;
            int _Nextra;

            if (_By < 0x80u) {
                _Ch = _By;
                _Nextra = 0;
            }
 else if (_By < 0xc0u) { // 0x80-0xbf not first byte
  ++_Mid1;
  return codecvt::error;
}
else if (_By < 0xe0u) {
 _Ch = static_cast<unsigned long>(_By & 0x1f);
 _Nextra = 1;
}
else if (_By < 0xf0u) {
 _Ch = static_cast<unsigned long>(_By & 0x0f);
 _Nextra = 2;
}
else if (_By < 0xf8u) {
 _Ch = static_cast<unsigned long>(_By & 0x07);
 _Nextra = 3;
}
else {
 _Ch = static_cast<unsigned long>(_By & 0x03);
 _Nextra = _By < 0xfc ? 4 : 5;
}

if (_Nextra == 0) {
    ++_Mid1;
}
else if (_Last1 - _Mid1 < _Nextra + 1) {
 break; // not enough input
}
else {
 for (++_Mid1; 0 < _Nextra; --_Nextra, ++_Mid1) {
     if ((_By = static_cast<unsigned char>(*_Mid1)) < 0x80u || 0xc0u <= _By) {
         return codecvt::error; // not continuation byte
     }
else {
 _Ch = _Ch << 6 | (_By & 0x3f);
}
}
}

if (*_Pstate == 0) { // first time, maybe look for and consume header
    *_Pstate = 1;

    if ((_Mode & _Consume_header) != 0 && _Ch == 0xfeffu) { // drop header and retry
        const result _Ans = do_in(_State, _Mid1, _Last1, _Mid1, _First2, _Last2, _Mid2);

        if (_Ans == codecvt::partial) { // roll back header determination
            *_Pstate = 0;
            _Mid1 = _First1;
        }
        return _Ans;
    }
}

if (_Maxcode < _Ch) {
    return codecvt::error; // code too large
}

*_Mid2++ = static_cast<char32_t>(_Ch);
}

return _First1 == _Mid1 ? codecvt::partial : codecvt::ok;
}

virtual result __CLR_OR_THIS_CALL do_out(mbstate_t& _State, const char32_t* _First1, const char32_t* _Last1,
    const char32_t*& _Mid1, char* _First2, char* _Last2, char*& _Mid2) const {
    // convert [_First1, _Last1) to bytes [_First2, _Last2)
    char* _Pstate = reinterpret_cast<char*>(&_State);
    _Mid1 = _First1;
    _Mid2 = _First2;

    while (_Mid1 != _Last1 && _Mid2 != _Last2) { // convert and put a wide char
        char _By;
        int _Nextra;
        unsigned long _Ch = static_cast<unsigned long>(*_Mid1);

        if (_Maxcode < _Ch) {
            return codecvt::error;
        }

        if (_Ch < 0x0080u) {
            _By = static_cast<char>(_Ch);
            _Nextra = 0;
        }
else if (_Ch < 0x0800u) {
 _By = static_cast<char>(0xc0 | _Ch >> 6);
 _Nextra = 1;
}
else if (_Ch < 0x00010000u) {
 _By = static_cast<char>(0xe0 | _Ch >> 12);
 _Nextra = 2;
}
else if (_Ch < 0x00200000u) {
 _By = static_cast<char>(0xf0 | _Ch >> 18);
 _Nextra = 3;
}
else if (_Ch < 0x04000000u) {
 _By = static_cast<char>(0xf8 | _Ch >> 24);
 _Nextra = 4;
}
else {
 _By = static_cast<char>(0xfc | (_Ch >> 30 & 0x03));
 _Nextra = 5;
}

if (*_Pstate == 0) { // first time, maybe generate header
    *_Pstate = 1;
    if ((_Mode & _Generate_header) != 0) {
        if (_Last2 - _Mid2 < 3 + 1 + _Nextra) {
            return codecvt::partial; // not enough room for both
        }

        // prepend header
        *_Mid2++ = '\xef';
        *_Mid2++ = '\xbb';
        *_Mid2++ = '\xbf';
    }
}

if (_Last2 - _Mid2 < 1 + _Nextra) {
    break; // not enough room for output
}

++_Mid1;
for (*_Mid2++ = _By; 0 < _Nextra;) {
    *_Mid2++ = static_cast<char>((_Ch >> 6 * --_Nextra & 0x3f) | 0x80);
}
}
return _First1 == _Mid1 ? codecvt::partial : codecvt::ok;
}

virtual result __CLR_OR_THIS_CALL do_unshift(mbstate_t&, char* _First2, char*, char*& _Mid2) const {
    // generate bytes to return to default shift state
    _Mid2 = _First2;
    return codecvt::noconv;
}

friend int _Codecvt_do_length<>(const codecvt&, mbstate_t&, const char*, const char*, size_t);

virtual int __CLR_OR_THIS_CALL do_length(
    mbstate_t& _State, const char* _First1, const char* _Last1, size_t _Count) const {
    return _Codecvt_do_length(*this, _State, _First1, _Last1, _Count);
}

bool __CLR_OR_THIS_CALL do_always_noconv() const noexcept override {
    // return true if conversions never change input
    return false;
}

int __CLR_OR_THIS_CALL do_max_length() const noexcept override {
    // return maximum length required for a conversion
    return (_Mode & (_Consume_header | _Generate_header)) != 0 ? 9 : 6;
}

int __CLR_OR_THIS_CALL do_encoding() const noexcept override {
    // return length of code sequence (from codecvt)
    return (_Mode & (_Consume_header | _Generate_header)) != 0 ? -1
                                                               : 0; // -1 => state dependent, 0 => varying length
}

private:
    unsigned long _Maxcode; // default: 0xffffffff
    _Codecvt_mode _Mode; // default: _Consume_header
};

extern "C++" template <>
class _CRTIMP2_PURE_IMPORT codecvt<wchar_t, char, mbstate_t> : public codecvt_base {
    // facet for converting between wchar_t and char (_Byte) sequences
public:
    using intern_type = wchar_t;
    using extern_type = char;
    using state_type = mbstate_t;

    result __CLR_OR_THIS_CALL in(mbstate_t& _State, const char* _First1, const char* _Last1, const char*& _Mid1,
        wchar_t* _First2, wchar_t* _Last2, wchar_t*& _Mid2) const {
        // convert bytes [_First1, _Last1) to [_First2, _Last2)
        return do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }

    result __CLR_OR_THIS_CALL out(mbstate_t& _State, const wchar_t* _First1, const wchar_t* _Last1,
        const wchar_t*& _Mid1, char* _First2, char* _Last2, char*& _Mid2) const {
        // convert [_First1, _Last1) to bytes [_First2, _Last2)
        return do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }

    result __CLR_OR_THIS_CALL unshift(mbstate_t& _State, char* _First2, char* _Last2, char*& _Mid2) const {
        // generate bytes to return to default shift state
        return do_unshift(_State, _First2, _Last2, _Mid2);
    }

    int __CLR_OR_THIS_CALL length(mbstate_t& _State, const char* _First1, const char* _Last1, size_t _Count) const {
        // return p - _First1, for the largest value p in [_First1, _Last1] such that [_First1, p) successfully
        // converts to at most _Count wide characters
        return do_length(_State, _First1, _Last1, _Count);
    }

    __PURE_APPDOMAIN_GLOBAL static locale::id id;

    explicit __CLR_OR_THIS_CALL codecvt(size_t _Refs = 0) : codecvt_base(_Refs) {
        _BEGIN_LOCINFO(_Lobj)
            _Init(_Lobj);
        _END_LOCINFO()
    }

    explicit __CLR_OR_THIS_CALL codecvt(const _Locinfo& _Lobj, size_t _Refs = 0) : codecvt_base(_Refs) {
        _Init(_Lobj);
    }

    static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        // return locale category mask and construct standard facet
        if (_Ppf && !*_Ppf) {
            *_Ppf = new codecvt(_Locinfo(_Ploc->_C_str()));
        }

        return _X_CTYPE;
    }

protected:
    __CLR_OR_THIS_CALL ~codecvt() noexcept override {}

    void __CLR_OR_THIS_CALL _Init(const _Locinfo& _Lobj) { // initialize from _Lobj
        _Cvt = _Lobj._Getcvt();
    }

    virtual result __CLR_OR_THIS_CALL do_in(mbstate_t&, const char* _First1, const char* _Last1, const char*& _Mid1,
        wchar_t* _First2, wchar_t* _Last2, wchar_t*& _Mid2) const {
        // convert bytes [_First1, _Last1) to [_First2, _Last2)
        mbstate_t _Mystate{};
        _Adl_verify_range(_First1, _Last1);
        _Adl_verify_range(_First2, _Last2);
        _Mid1 = _First1;
        _Mid2 = _First2;
        for (;;) {
            if (_Mid1 == _Last1) {
                return ok;
            }

            if (_Mid2 == _Last2) {
                return partial;
            }

            int _Bytes = _Mbrtowc(_Mid2, _Mid1, static_cast<size_t>(_Last1 - _Mid1), &_Mystate, &_Cvt);
            switch (_Bytes) {
            case -2: // partial conversion
                return partial;

            case -1: // failed conversion
                return error;

            case 0: // converted NULL character, TRANSITION, VSO-654347
                _Bytes = 1;
                _FALLTHROUGH;

            default: // converted some other character
                _Mid1 += _Bytes;
                ++_Mid2;
                break;
            }
        }
    }

    virtual result __CLR_OR_THIS_CALL do_out(mbstate_t& _State, const wchar_t* _First1, const wchar_t* _Last1,
        const wchar_t*& _Mid1, char* _First2, char* _Last2, char*& _Mid2) const {
        // convert [_First1, _Last1) to bytes [_First2, _Last2)
        _Adl_verify_range(_First1, _Last1);
        _Adl_verify_range(_First2, _Last2);
        _Mid1 = _First1;
        _Mid2 = _First2;
        int _Bytes;

        while (_Mid1 != _Last1 && _Mid2 != _Last2) {
            if (MB_LEN_MAX <= _Last2 - _Mid2) {
                if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1, &_State, &_Cvt)) < 0) {
                    return error; // locale-specific wcrtomb failed
                }
                else {
                    ++_Mid1;
                    _Mid2 += _Bytes;
                }
            }
            else { // destination too small, convert into buffer
                char _Buf[MB_LEN_MAX];
                mbstate_t _Stsave = _State;

                if ((_Bytes = _Wcrtomb(_Buf, *_Mid1, &_State, &_Cvt)) < 0) {
                    return error; // locale-specific wcrtomb failed
                }
                else if (_Last2 - _Mid2 < _Bytes) { // converted too many, roll back and return previous
                    _State = _Stsave;
                    break;
                }
                else { // copy converted bytes from buffer
                    _CSTD memcpy(_Mid2, _Buf, static_cast<size_t>(_Bytes));
                    ++_Mid1;
                    _Mid2 += _Bytes;
                }
            }
        }

        return _Mid1 == _Last1 ? ok : partial;
    }

    virtual result __CLR_OR_THIS_CALL do_unshift(mbstate_t& _State, char* _First2, char* _Last2, char*& _Mid2) const {
        // generate bytes to return to default shift state
        _Adl_verify_range(_First2, _Last2);
        _Mid2 = _First2;
        result _Ans = ok;
        int _Bytes;
        char _Buf[MB_LEN_MAX];
        mbstate_t _Stsave = _State;

        if ((_Bytes = _Wcrtomb(_Buf, L'\0', &_State, &_Cvt)) <= 0) {
            _Ans = error; // locale-specific wcrtomb failed
        }
        else if (_Last2 - _Mid2 < --_Bytes) { // converted too many, roll back and return
            _State = _Stsave;
            _Ans = partial;
        }
        else if (0 < _Bytes) { // copy converted bytes from buffer
            _CSTD memcpy(_Mid2, _Buf, static_cast<size_t>(_Bytes));
            _Mid2 += _Bytes;
        }
        return _Ans;
    }

    virtual int __CLR_OR_THIS_CALL do_length(
        mbstate_t& _State, const char* _First1, const char* _Last1, size_t _Count) const {
        // return p - _First1, for the largest value p in [_First1, _Last1] such that [_First1, p) successfully
        // converts to at most _Count wide characters
        _Adl_verify_range(_First1, _Last1);
        const auto _Old_first1 = _First1;

        for (; _Count > 0u && _First1 != _Last1; --_Count) {
            wchar_t _Ch;
            int _Bytes = _Mbrtowc(&_Ch, _First1, static_cast<size_t>(_Last1 - _First1), &_State, &_Cvt);
            if (_Bytes < 0) { // partial or failed conversion
                break;
            }

            if (_Bytes == 0) { // converted NULL character, TRANSITION, VSO-654347
                _Bytes = 1;
            }

            // converted _Bytes bytes to a wide character
            _First1 += _Bytes;
        }

        return static_cast<int>((_STD min)(_First1 - _Old_first1, ptrdiff_t{ INT_MAX }));
    }

    bool __CLR_OR_THIS_CALL do_always_noconv() const noexcept override {
        // return true if conversions never change input
        return false;
    }

    int __CLR_OR_THIS_CALL do_max_length() const noexcept override {
        // return maximum length required for a conversion (from codecvt)
        return static_cast<int>(_Cvt._Mbcurmax);
    }

    int __CLR_OR_THIS_CALL do_encoding() const noexcept override {
        // return length of code sequence (from codecvt)
        return _Cvt._Mbcurmax == 1; // 0 => varying length, 1 => fixed length
    }

private:
    _Locinfo::_Cvtvec _Cvt; // locale info passed to _Mbrtowc, _Wcrtomb
};

#if defined(_NATIVE_WCHAR_T_DEFINED) && !_ENFORCE_FACET_SPECIALIZATIONS
extern "C++" template <>
class _CRTIMP2_PURE_IMPORT codecvt<unsigned short, char, mbstate_t> : public codecvt_base {
    // facet for converting between unsigned short and char sequences
public:
    using intern_type = unsigned short;
    using extern_type = char;
    using state_type = mbstate_t;

    result __CLR_OR_THIS_CALL in(mbstate_t& _State, const char* _First1, const char* _Last1, const char*& _Mid1,
        unsigned short* _First2, unsigned short* _Last2, unsigned short*& _Mid2) const {
        // convert bytes [_First1, _Last1) to [_First2, _Last2)
        return do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }

    result __CLR_OR_THIS_CALL out(mbstate_t& _State, const unsigned short* _First1, const unsigned short* _Last1,
        const unsigned short*& _Mid1, char* _First2, char* _Last2, char*& _Mid2) const {
        // convert [_First1, _Last1) to bytes [_First2, _Last2)
        return do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }

    result __CLR_OR_THIS_CALL unshift(mbstate_t& _State, char* _First2, char* _Last2, char*& _Mid2) const {
        // generate bytes to return to default shift state
        return do_unshift(_State, _First2, _Last2, _Mid2);
    }

    int __CLR_OR_THIS_CALL length(mbstate_t& _State, const char* _First1, const char* _Last1, size_t _Count) const {
        // return p - _First1, for the largest value p in [_First1, _Last1] such that [_First1, p) successfully
        // converts to at most _Count _Elems
        return do_length(_State, _First1, _Last1, _Count);
    }

    __PURE_APPDOMAIN_GLOBAL static locale::id id;

    explicit __CLR_OR_THIS_CALL codecvt(size_t _Refs = 0) : codecvt_base(_Refs) {
        _BEGIN_LOCINFO(_Lobj)
            _Init(_Lobj);
        _END_LOCINFO()
    }

    explicit __CLR_OR_THIS_CALL codecvt(const _Locinfo& _Lobj, size_t _Refs = 0) : codecvt_base(_Refs) {
        _Init(_Lobj);
    }

    static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        // return locale category mask and construct standard facet
        if (_Ppf && !*_Ppf) {
            *_Ppf = new codecvt(_Locinfo(_Ploc->_C_str()));
        }

        return _X_CTYPE;
    }

protected:
    __CLR_OR_THIS_CALL ~codecvt() noexcept override {}

    void __CLR_OR_THIS_CALL _Init(const _Locinfo& _Lobj) { // initialize from _Lobj
        _Cvt = _Lobj._Getcvt();
    }

    virtual result __CLR_OR_THIS_CALL do_in(mbstate_t&, const char* _First1, const char* _Last1, const char*& _Mid1,
        unsigned short* _First2, unsigned short* _Last2, unsigned short*& _Mid2) const {
        // convert bytes [_First1, _Last1) to [_First2, _Last2)
        mbstate_t _Mystate{};
        _Adl_verify_range(_First1, _Last1);
        _Adl_verify_range(_First2, _Last2);
        _Mid1 = _First1;
        _Mid2 = _First2;
        for (;;) {
            if (_Mid1 == _Last1) {
                return ok;
            }

            if (_Mid2 == _Last2) {
                return partial;
            }

            int _Bytes = _Mbrtowc(
                reinterpret_cast<wchar_t*>(_Mid2), _Mid1, static_cast<size_t>(_Last1 - _Mid1), &_Mystate, &_Cvt);
            switch (_Bytes) {
            case -2: // partial conversion
                return partial;

            case -1: // failed conversion
                return error;

            case 0: // converted NULL character, TRANSITION, VSO-654347
                _Bytes = 1;
                _FALLTHROUGH;

            default: // converted some other character
                _Mid1 += _Bytes;
                ++_Mid2;
                break;
            }
        }
    }

    virtual result __CLR_OR_THIS_CALL do_out(mbstate_t& _State, const unsigned short* _First1,
        const unsigned short* _Last1, const unsigned short*& _Mid1, char* _First2, char* _Last2, char*& _Mid2) const {
        // convert [_First1, _Last1) to bytes [_First2, _Last2)
        _Adl_verify_range(_First1, _Last1);
        _Adl_verify_range(_First2, _Last2);
        _Mid1 = _First1;
        _Mid2 = _First2;
        int _Bytes;

        while (_Mid1 != _Last1 && _Mid2 != _Last2) {
            if (MB_LEN_MAX <= _Last2 - _Mid2) {
                if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1, &_State, &_Cvt)) < 0) {
                    return error; // locale-specific wcrtomb failed
                }
                else {
                    ++_Mid1;
                    _Mid2 += _Bytes;
                }
            }
            else { // destination too small, convert into buffer
                char _Buf[MB_LEN_MAX];
                mbstate_t _Stsave = _State;

                if ((_Bytes = _Wcrtomb(_Buf, *_Mid1, &_State, &_Cvt)) < 0) {
                    return error; // locale-specific wcrtomb failed
                }
                else if (_Last2 - _Mid2 < _Bytes) { // converted too many, roll back and return previous
                    _State = _Stsave;
                    break;
                }
                else { // copy converted bytes from buffer
                    _CSTD memcpy(_Mid2, _Buf, static_cast<size_t>(_Bytes));
                    ++_Mid1;
                    _Mid2 += _Bytes;
                }
            }
        }

        return _Mid1 == _Last1 ? ok : partial;
    }

    virtual result __CLR_OR_THIS_CALL do_unshift(mbstate_t& _State, char* _First2, char* _Last2, char*& _Mid2) const {
        // generate bytes to return to default shift state
        _Adl_verify_range(_First2, _Last2);
        _Mid2 = _First2;
        result _Ans = ok;
        int _Bytes;
        char _Buf[MB_LEN_MAX];
        mbstate_t _Stsave = _State;

        if ((_Bytes = _Wcrtomb(_Buf, L'\0', &_State, &_Cvt)) <= 0) {
            _Ans = error; // locale-specific wcrtomb failed
        }
        else if (_Last2 - _Mid2 < --_Bytes) { // converted too many, roll back and return
            _State = _Stsave;
            _Ans = partial;
        }
        else if (0 < _Bytes) { // copy converted bytes from buffer
            _CSTD memcpy(_Mid2, _Buf, static_cast<size_t>(_Bytes));
            _Mid2 += _Bytes;
        }

        return _Ans;
    }

    virtual int __CLR_OR_THIS_CALL do_length(
        mbstate_t& _State, const char* _First1, const char* _Last1, size_t _Count) const {
        // return p - _First1, for the largest value p in [_First1, _Last1] such that [_First1, p) successfully
        // converts to at most _Count wide characters
        _Adl_verify_range(_First1, _Last1);
        const auto _Old_first1 = _First1;

        for (; _Count > 0u && _First1 != _Last1; --_Count) {
            wchar_t _Ch;
            int _Bytes = _Mbrtowc(&_Ch, _First1, static_cast<size_t>(_Last1 - _First1), &_State, &_Cvt);
            if (_Bytes < 0) { // partial or failed conversion
                break;
            }

            if (_Bytes == 0) { // converted NULL character, TRANSITION, VSO-654347
                _Bytes = 1;
            }

            // converted _Bytes bytes to a wide character
            _First1 += _Bytes;
        }

        return static_cast<int>((_STD min)(_First1 - _Old_first1, ptrdiff_t{ INT_MAX }));
    }

    bool __CLR_OR_THIS_CALL do_always_noconv() const noexcept override {
        // return true if conversions never change input
        return false;
    }

    int __CLR_OR_THIS_CALL do_max_length() const noexcept override {
        // return maximum length required for a conversion (from codecvt)
        return static_cast<int>(_Cvt._Mbcurmax);
    }

    int __CLR_OR_THIS_CALL do_encoding() const noexcept override {
        // return length of code sequence (from codecvt)
        return _Cvt._Mbcurmax == 1u; // 0 => varying length, 1 => fixed length
    }

private:
    _Locinfo::_Cvtvec _Cvt; // locale info passed to _Mbrtowc, _Wcrtomb
};
#endif // defined(_NATIVE_WCHAR_T_DEFINED) && !_ENFORCE_FACET_SPECIALIZATIONS

_EXPORT_STD template <class _Elem, class _Byte, class _Statype>
class codecvt_byname : public codecvt<_Elem, _Byte, _Statype> { // codecvt for named locale
public:
    static_assert(!_ENFORCE_FACET_SPECIALIZATIONS
        || _Is_any_of_v<codecvt_byname,
#ifdef __cpp_char8_t
        codecvt_byname<char16_t, char8_t, mbstate_t>, codecvt_byname<char32_t, char8_t, mbstate_t>,
#endif // defined(__cpp_char8_t)
        codecvt_byname<char, char, mbstate_t>, codecvt_byname<wchar_t, char, mbstate_t>>,
        _FACET_SPECIALIZATION_MESSAGE);

    explicit __CLR_OR_THIS_CALL codecvt_byname(const char* _Locname, size_t _Refs = 0)
        : codecvt<_Elem, _Byte, _Statype>(_Locinfo(_Locname), _Refs) {} // construct for named locale

    explicit __CLR_OR_THIS_CALL codecvt_byname(const string& _Str, size_t _Refs = 0)
        : codecvt<_Elem, _Byte, _Statype>(_Locinfo(_Str.c_str()), _Refs) {} // construct for named locale

protected:
    __CLR_OR_THIS_CALL ~codecvt_byname() noexcept override {}
};

#define _XA 0x100 // extra alphabetic
#define _BB _CONTROL // BEL, BS, etc.
#define _CN _SPACE // CR, FF, HT, NL, VT
#define _DI _DIGIT // '0'-'9'
#define _LO _LOWER // 'a'-'z'
#define _PU _PUNCT // punctuation
#define _SP _BLANK // space
#define _UP _UPPER // 'A'-'Z'
#define _XD _HEX // '0'-'9', 'A'-'F', 'a'-'f'

_EXPORT_STD extern "C++" struct _CRTIMP2_PURE_IMPORT ctype_base // base for ctype
    : locale::facet // TRANSITION, ABI, shouldn't be derived from locale::facet
{
    enum { // constants for character classifications
        alnum = _DI | _LO | _UP | _XA,
        alpha = _LO | _UP | _XA,
        cntrl = _BB,
        digit = _DI,
        graph = _DI | _LO | _PU | _UP | _XA,
        lower = _LO,
        print = _DI | _LO | _PU | _SP | _UP | _XA | _XD,
        punct = _PU,
        space = _CN | _SP,
        upper = _UP,
        xdigit = _XD,
        blank = _CN | _SP
    };
    using mask = short; // to match <ctype.h>

    __CLR_OR_THIS_CALL ctype_base(size_t _Refs = 0) noexcept // strengthened
        : locale::facet(_Refs) {}

    __CLR_OR_THIS_CALL ~ctype_base() noexcept override {}
};

#undef _XA
#undef _BB
#undef _CN
#undef _DI
#undef _LO
#undef _PU
#undef _SP
#undef _UP
#undef _XD

_EXPORT_STD extern "C++" template <class _Elem>
class ctype : public ctype_base { // facet for classifying elements, converting cases
public:
    // ctype<char>, ctype<wchar_t>, and ctype<unsigned short> are explicitly specialized below.
    static_assert(!_ENFORCE_FACET_SPECIALIZATIONS || _Always_false<_Elem>, _FACET_SPECIALIZATION_MESSAGE);

    using char_type = _Elem;

    bool __CLR_OR_THIS_CALL is(mask _Maskval, _Elem _Ch) const { // test if element fits any mask classifications
        return do_is(_Maskval, _Ch);
    }

    const _Elem* __CLR_OR_THIS_CALL is(const _Elem* _First, const _Elem* _Last,
        mask* _Dest) const { // get mask sequence for elements in [_First, _Last)
        return do_is(_First, _Last, _Dest);
    }

    const _Elem* __CLR_OR_THIS_CALL scan_is(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { // find first in [_First, _Last) that fits mask classification
        return do_scan_is(_Maskval, _First, _Last);
    }

    const _Elem* __CLR_OR_THIS_CALL scan_not(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { // find first in [_First, _Last) not fitting mask classification
        return do_scan_not(_Maskval, _First, _Last);
    }

    _Elem __CLR_OR_THIS_CALL tolower(_Elem _Ch) const { // convert element to lower case
        return do_tolower(_Ch);
    }

    const _Elem* __CLR_OR_THIS_CALL tolower(
        _Elem* _First, const _Elem* _Last) const { // convert [_First, _Last) in place to lower case
        return do_tolower(_First, _Last);
    }

    _Elem __CLR_OR_THIS_CALL toupper(_Elem _Ch) const { // convert element to upper case
        return do_toupper(_Ch);
    }

    const _Elem* __CLR_OR_THIS_CALL toupper(
        _Elem* _First, const _Elem* _Last) const { // convert [_First, _Last) in place to upper case
        return do_toupper(_First, _Last);
    }

    _Elem __CLR_OR_THIS_CALL widen(char _Byte) const { // widen char
        return do_widen(_Byte);
    }

    const char* __CLR_OR_THIS_CALL widen(const char* _First, const char* _Last,
        _Elem* _Dest) const { // widen chars in [_First, _Last)
        return do_widen(_First, _Last, _Dest);
    }

    char __CLR_OR_THIS_CALL narrow(_Elem _Ch, char _Dflt = '\0') const { // narrow element to char
        return do_narrow(_Ch, _Dflt);
    }

    const _Elem* __CLR_OR_THIS_CALL narrow(const _Elem* _First, const _Elem* _Last, char _Dflt,
        char* _Dest) const { // narrow elements in [_First, _Last) to chars
        return do_narrow(_First, _Last, _Dflt, _Dest);
    }

    __PURE_APPDOMAIN_GLOBAL static locale::id id;

    explicit __CLR_OR_THIS_CALL ctype(size_t _Refs = 0) : ctype_base(_Refs) {
        _BEGIN_LOCINFO(_Lobj)
            _Init(_Lobj);
        _END_LOCINFO()
    }

    __CLR_OR_THIS_CALL ctype(const _Locinfo& _Lobj, size_t _Refs = 0) : ctype_base(_Refs) {
        _Init(_Lobj);
    }

    static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        if (_Ppf && !*_Ppf) {
            *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->_C_str()));
        }

        return _X_CTYPE;
    }

protected:
    __CLR_OR_THIS_CALL ~ctype() noexcept override {
        if (_Ctype._Delfl) {
            _CSTD free(const_cast<short*>(_Ctype._Table));
        }

        _CSTD free(_Ctype._LocaleName);
    }

    void __CLR_OR_THIS_CALL _Init(const _Locinfo& _Lobj) { // initialize from _Lobj
        _Ctype = _Lobj._Getctype();
        _Cvt = _Lobj._Getcvt();
    }

    virtual bool __CLR_OR_THIS_CALL do_is(
        mask _Maskval, _Elem _Ch) const { // test if element fits any mask classifications
        return (_Ctype._Table[static_cast<unsigned char>(narrow(_Ch))] & _Maskval) != 0;
    }

    virtual const _Elem* __CLR_OR_THIS_CALL do_is(const _Elem* _First, const _Elem* _Last,
        mask* _Dest) const { // get mask sequence for elements in [_First, _Last)
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First, ++_Dest) {
            *_Dest = _Ctype._Table[static_cast<unsigned char>(narrow(*_First))];
        }

        return _First;
    }

    virtual const _Elem* __CLR_OR_THIS_CALL do_scan_is(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { // find first in [_First, _Last) that fits mask classification
        _Adl_verify_range(_First, _Last);
        while (_First != _Last && !is(_Maskval, *_First)) {
            ++_First;
        }

        return _First;
    }

    virtual const _Elem* __CLR_OR_THIS_CALL do_scan_not(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { // find first in [_First, _Last) not fitting mask classification
        _Adl_verify_range(_First, _Last);
        while (_First != _Last && is(_Maskval, *_First)) {
            ++_First;
        }

        return _First;
    }

    virtual _Elem __CLR_OR_THIS_CALL do_tolower(_Elem _Ch) const { // convert element to lower case
        unsigned char _Byte = static_cast<unsigned char>(narrow(_Ch, '\0'));
        if (_Byte == '\0') {
            return _Ch;
        }

        return widen(static_cast<char>(_Tolower(_Byte, &_Ctype)));
    }

    virtual const _Elem* __CLR_OR_THIS_CALL do_tolower(_Elem* _First,
        const _Elem* _Last) const { // convert [_First, _Last) in place to lower case
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First) { // convert *_First to lower case
            unsigned char _Byte = static_cast<unsigned char>(narrow(*_First, '\0'));
            if (_Byte != '\0') {
                *_First = (widen(static_cast<char>(_Tolower(_Byte, &_Ctype))));
            }
        }
        return _First;
    }

    virtual _Elem __CLR_OR_THIS_CALL do_toupper(_Elem _Ch) const { // convert element to upper case
        unsigned char _Byte = static_cast<unsigned char>(narrow(_Ch, '\0'));
        if (_Byte == '\0') {
            return _Ch;
        }

        return widen(static_cast<char>(_Toupper(_Byte, &_Ctype)));
    }

    virtual const _Elem* __CLR_OR_THIS_CALL do_toupper(_Elem* _First,
        const _Elem* _Last) const { // convert [_First, _Last) in place to upper case
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First) { // convert *_First to upper case
            unsigned char _Byte = static_cast<unsigned char>(narrow(*_First, '\0'));
            if (_Byte != '\0') {
                *_First = (widen(static_cast<char>(_Toupper(_Byte, &_Ctype))));
            }
        }

        return _First;
    }

    virtual _Elem __CLR_OR_THIS_CALL do_widen(char _Byte) const { // widen char
        return _Maklocchr(_Byte, static_cast<_Elem*>(nullptr), _Cvt);
    }

    virtual const char* __CLR_OR_THIS_CALL do_widen(
        const char* _First, const char* _Last, _Elem* _Dest) const { // widen chars in [_First, _Last)
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First, ++_Dest) {
            *_Dest = _Maklocchr(*_First, static_cast<_Elem*>(nullptr), _Cvt);
        }

        return _First;
    }

    char __CLR_OR_THIS_CALL _Donarrow(_Elem _Ch, char _Dflt) const { // narrow element to char
        char _Byte;
        if (_Ch == _Elem{}) {
            return '\0';
        }

        if ((_Byte = _Maklocbyte(_Ch, _Cvt)) == '\0') {
            return _Dflt;
        }

        return _Byte;
    }

    virtual char __CLR_OR_THIS_CALL do_narrow(_Elem _Ch, char _Dflt) const { // narrow element to char
        return _Donarrow(_Ch, _Dflt);
    }

    virtual const _Elem* __CLR_OR_THIS_CALL do_narrow(const _Elem* _First, const _Elem* _Last, char _Dflt,
        char* _Dest) const { // narrow elements in [_First, _Last) to chars
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First, ++_Dest) {
            *_Dest = _Donarrow(*_First, _Dflt);
        }

        return _First;
    }

private:
    _Locinfo::_Ctypevec _Ctype; // locale info passed to _Tolower, etc.
    _Locinfo::_Cvtvec _Cvt; // conversion information
};

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdllimport-static-field-def"
#endif // defined(__clang__)

template <class _Elem>
locale::id ctype<_Elem>::id;

#ifdef __clang__
#pragma clang diagnostic pop
#endif // defined(__clang__)

extern "C++" template <>
class _CRTIMP2_PURE_IMPORT ctype<char> : public ctype_base { // facet for classifying char elements, converting cases
public:
    using _Elem = char;
    using char_type = _Elem;

    bool __CLR_OR_THIS_CALL is(mask _Maskval, _Elem _Ch) const { // test if element fits any mask classifications
        return (_Ctype._Table[static_cast<unsigned char>(_Ch)] & _Maskval) != 0;
    }

    const _Elem* __CLR_OR_THIS_CALL is(const _Elem* _First, const _Elem* _Last,
        mask* _Dest) const { // get mask sequence for elements in [_First, _Last)
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First, ++_Dest) {
            *_Dest = _Ctype._Table[static_cast<unsigned char>(*_First)];
        }

        return _First;
    }

    const _Elem* __CLR_OR_THIS_CALL scan_is(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { // find first in [_First, _Last) that fits mask classification
        _Adl_verify_range(_First, _Last);
        while (_First != _Last && !is(_Maskval, *_First)) {
            ++_First;
        }

        return _First;
    }

    const _Elem* __CLR_OR_THIS_CALL scan_not(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { // find first in [_First, _Last) not fitting mask classification
        _Adl_verify_range(_First, _Last);
        while (_First != _Last && is(_Maskval, *_First)) {
            ++_First;
        }

        return _First;
    }

    _Elem __CLR_OR_THIS_CALL tolower(_Elem _Ch) const { // convert element to lower case
        return do_tolower(_Ch);
    }

    const _Elem* __CLR_OR_THIS_CALL tolower(
        _Elem* _First, const _Elem* _Last) const { // convert [_First, _Last) in place to lower case
        return do_tolower(_First, _Last);
    }

    _Elem __CLR_OR_THIS_CALL toupper(_Elem _Ch) const { // convert element to upper case
        return do_toupper(_Ch);
    }

    const _Elem* __CLR_OR_THIS_CALL toupper(
        _Elem* _First, const _Elem* _Last) const { // convert [_First, _Last) in place to upper case
        return do_toupper(_First, _Last);
    }

    _Elem __CLR_OR_THIS_CALL widen(char _Byte) const { // widen char
        return do_widen(_Byte);
    }

    const _Elem* __CLR_OR_THIS_CALL widen(const char* _First, const char* _Last,
        _Elem* _Dest) const { // widen chars in [_First, _Last)
        return do_widen(_First, _Last, _Dest);
    }

    _Elem __CLR_OR_THIS_CALL narrow(_Elem _Ch, char _Dflt = '\0') const { // narrow element to char
        return do_narrow(_Ch, _Dflt);
    }

    const _Elem* __CLR_OR_THIS_CALL narrow(const _Elem* _First, const _Elem* _Last, char _Dflt,
        char* _Dest) const { // narrow elements in [_First, _Last) to chars
        return do_narrow(_First, _Last, _Dflt, _Dest);
    }

    __PURE_APPDOMAIN_GLOBAL static locale::id id;

    explicit __CLR_OR_THIS_CALL ctype(const mask* _Table = nullptr, bool _Deletetable = false,
        size_t _Refs = 0)
        : ctype_base(_Refs) { // construct with specified table and delete flag for table
        _BEGIN_LOCINFO(_Lobj)
            _Init(_Lobj);
        _END_LOCINFO()

            _Tidy(); // free existing table, as needed
        if (_Table) { // replace existing char to mask table
            _Ctype._Table = _Table;
            _Ctype._Delfl = _Deletetable ? -1 : 0;
        }
        else { // use classic table
            _Ctype._Table = classic_table();
            _Ctype._Delfl = 0;
        }
    }

    __CLR_OR_THIS_CALL ctype(const _Locinfo& _Lobj, size_t _Refs = 0) : ctype_base(_Refs) {
        _Init(_Lobj);
    }

    static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        if (_Ppf && !*_Ppf) {
            *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->_C_str()));
        }

        return _X_CTYPE;
    }

    const mask* __CLR_OR_THIS_CALL table() const noexcept {
        return _Ctype._Table;
    }

    static const mask* __CLRCALL_OR_CDECL classic_table() noexcept {
        return _STD use_facet<ctype>(locale::classic()).table();
    }

    _PGLOBAL static const size_t table_size = 1 << CHAR_BIT; // size of ctype mapping table, typically 256

protected:
    __CLR_OR_THIS_CALL ~ctype() noexcept override {
        _Tidy();
    }

    void __CLR_OR_THIS_CALL _Init(const _Locinfo& _Lobj) { // initialize from _Lobj
        _Ctype = _Lobj._Getctype();
    }

    void __CLR_OR_THIS_CALL _Tidy() noexcept { // free any allocated storage
        if (0 < _Ctype._Delfl) {
            _CSTD free(const_cast<short*>(_Ctype._Table));
        }
        else if (_Ctype._Delfl < 0) {
            delete[] _Ctype._Table;
        }

        _CSTD free(_Ctype._LocaleName);
    }

    virtual _Elem __CLR_OR_THIS_CALL do_tolower(_Elem _Ch) const { // convert element to lower case
        return static_cast<_Elem>(_Tolower(static_cast<unsigned char>(_Ch), &_Ctype));
    }

    virtual const _Elem* __CLR_OR_THIS_CALL do_tolower(_Elem* _First,
        const _Elem* _Last) const { // convert [_First, _Last) in place to lower case
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First) {
            *_First = static_cast<_Elem>(_Tolower(static_cast<unsigned char>(*_First), &_Ctype));
        }

        return _First;
    }

    virtual _Elem __CLR_OR_THIS_CALL do_toupper(_Elem _Ch) const { // convert element to upper case
        return static_cast<_Elem>(_Toupper(static_cast<unsigned char>(_Ch), &_Ctype));
    }

    virtual const _Elem* __CLR_OR_THIS_CALL do_toupper(_Elem* _First,
        const _Elem* _Last) const { // convert [_First, _Last) in place to upper case
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First) {
            *_First = static_cast<_Elem>(_Toupper(static_cast<unsigned char>(*_First), &_Ctype));
        }

        return _First;
    }

    virtual _Elem __CLR_OR_THIS_CALL do_widen(char _Byte) const { // widen char
        return _Byte;
    }

    virtual const _Elem* __CLR_OR_THIS_CALL do_widen(
        const char* _First, const char* _Last, _Elem* _Dest) const { // widen chars in [_First, _Last)
        _Adl_verify_range(_First, _Last);
        _CSTD memcpy(_Dest, _First, static_cast<size_t>(_Last - _First));
        return _Last;
    }

    virtual _Elem __CLR_OR_THIS_CALL do_narrow(_Elem _Ch, char) const { // narrow char
        return _Ch;
    }

    virtual const _Elem* __CLR_OR_THIS_CALL do_narrow(const _Elem* _First, const _Elem* _Last, char,
        char* _Dest) const { // narrow elements in [_First, _Last) to chars
        _Adl_verify_range(_First, _Last);
        _CSTD memcpy(_Dest, _First, static_cast<size_t>(_Last - _First));
        return _Last;
    }

private:
    _Locinfo::_Ctypevec _Ctype; // information
};

extern "C++" template <>
class _CRTIMP2_PURE_IMPORT ctype<wchar_t>
    : public ctype_base { // facet for classifying wchar_t elements, converting cases
public:
    using _Elem = wchar_t;
    using char_type = _Elem;

    bool __CLR_OR_THIS_CALL is(mask _Maskval, _Elem _Ch) const { // test if element fits any mask classifications
        return do_is(_Maskval, _Ch);
    }

    const _Elem* __CLR_OR_THIS_CALL is(const _Elem* _First, const _Elem* _Last,
        mask* _Dest) const { // get mask sequence for elements in [_First, _Last)
        return do_is(_First, _Last, _Dest);
    }

    const _Elem* __CLR_OR_THIS_CALL scan_is(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { // find first in [_First, _Last) that fits mask classification
        return do_scan_is(_Maskval, _First, _Last);
    }

    const _Elem* __CLR_OR_THIS_CALL scan_not(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { // find first in [_First, _Last) not fitting mask classification
        return do_scan_not(_Maskval, _First, _Last);
    }

    _Elem __CLR_OR_THIS_CALL tolower(_Elem _Ch) const { // convert element to lower case
        return do_tolower(_Ch);
    }

    const _Elem* __CLR_OR_THIS_CALL tolower(
        _Elem* _First, const _Elem* _Last) const { // convert [_First, _Last) in place to lower case
        return do_tolower(_First, _Last);
    }

    _Elem __CLR_OR_THIS_CALL toupper(_Elem _Ch) const { // convert element to upper case
        return do_toupper(_Ch);
    }

    const _Elem* __CLR_OR_THIS_CALL toupper(
        _Elem* _First, const _Elem* _Last) const { // convert [_First, _Last) in place to upper case
        return do_toupper(_First, _Last);
    }

    _Elem __CLR_OR_THIS_CALL widen(char _Byte) const { // widen char
        return do_widen(_Byte);
    }

    const char* __CLR_OR_THIS_CALL widen(const char* _First, const char* _Last,
        _Elem* _Dest) const { // widen chars in [_First, _Last)
        return do_widen(_First, _Last, _Dest);
    }

    char __CLR_OR_THIS_CALL narrow(_Elem _Ch, char _Dflt = '\0') const { // narrow element to char
        return do_narrow(_Ch, _Dflt);
    }

    const _Elem* __CLR_OR_THIS_CALL narrow(const _Elem* _First, const _Elem* _Last, char _Dflt,
        char* _Dest) const { // narrow elements in [_First, _Last) to chars
        return do_narrow(_First, _Last, _Dflt, _Dest);
    }

    __PURE_APPDOMAIN_GLOBAL static locale::id id;

    explicit __CLR_OR_THIS_CALL ctype(size_t _Refs = 0) : ctype_base(_Refs) {
        _BEGIN_LOCINFO(_Lobj)
            _Init(_Lobj);
        _END_LOCINFO()
    }

    __CLR_OR_THIS_CALL ctype(const _Locinfo& _Lobj, size_t _Refs = 0) : ctype_base(_Refs) {
        _Init(_Lobj);
    }

    static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        if (_Ppf && !*_Ppf) {
            *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->_C_str()));
        }

        return _X_CTYPE;
    }

protected:
    __CLR_OR_THIS_CALL ~ctype() noexcept override {
        if (_Ctype._Delfl) {
            _CSTD free(const_cast<short*>(_Ctype._Table));
        }

        _CSTD free(_Ctype._LocaleName);
    }

    void __CLR_OR_THIS_CALL _Init(const _Locinfo& _Lobj) { // initialize from _Lobj
        _Ctype = _Lobj._Getctype();
        _Cvt = _Lobj._Getcvt();
    }

    virtual bool __CLR_OR_THIS_CALL do_is(
        mask _Maskval, _Elem _Ch) const { // test if element fits any mask classifications
        return (_CSTD _Getwctype(_Ch, &_Ctype) & _Maskval) != 0;
    }

    virtual const _Elem* __CLR_OR_THIS_CALL do_is(const _Elem* _First, const _Elem* _Last,
        mask* _Dest) const { // get mask sequence for elements in [_First, _Last)
        _Adl_verify_range(_First, _Last);
        return _CSTD _Getwctypes(_First, _Last, _Dest, &_Ctype);
    }

    virtual const _Elem* __CLR_OR_THIS_CALL do_scan_is(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { // find first in [_First, _Last) that fits mask classification
        _Adl_verify_range(_First, _Last);
        while (_First != _Last && !is(_Maskval, *_First)) {
            ++_First;
        }

        return _First;
    }

    virtual const _Elem* __CLR_OR_THIS_CALL do_scan_not(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { // find first in [_First, _Last) not fitting mask classification
        _Adl_verify_range(_First, _Last);
        while (_First != _Last && is(_Maskval, *_First)) {
            ++_First;
        }

        return _First;
    }

    virtual _Elem __CLR_OR_THIS_CALL do_tolower(_Elem _Ch) const { // convert element to lower case
        return _Towlower(_Ch, &_Ctype);
    }

    virtual const _Elem* __CLR_OR_THIS_CALL do_tolower(_Elem* _First,
        const _Elem* _Last) const { // convert [_First, _Last) in place to lower case
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First) {
            *_First = _Towlower(*_First, &_Ctype);
        }

        return _First;
    }

    virtual _Elem __CLR_OR_THIS_CALL do_toupper(_Elem _Ch) const { // convert element to upper case
        return _Towupper(_Ch, &_Ctype);
    }

    virtual const _Elem* __CLR_OR_THIS_CALL do_toupper(_Elem* _First,
        const _Elem* _Last) const { // convert [_First, _Last) in place to upper case
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First) {
            *_First = _Towupper(*_First, &_Ctype);
        }

        return _First;
    }

    _Elem __CLR_OR_THIS_CALL _Dowiden(char _Byte) const { // widen char
        mbstate_t _Mbst = {};
        wchar_t _Wc;
        return _Mbrtowc(&_Wc, &_Byte, 1, &_Mbst, &_Cvt) < 0 ? static_cast<wchar_t>(WEOF) : _Wc;
    }

    virtual _Elem __CLR_OR_THIS_CALL do_widen(char _Byte) const { // widen char
        return _Dowiden(_Byte);
    }

    virtual const char* __CLR_OR_THIS_CALL do_widen(
        const char* _First, const char* _Last, _Elem* _Dest) const { // widen chars in [_First, _Last)
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First, ++_Dest) {
            *_Dest = _Dowiden(*_First);
        }

        return _First;
    }

    char __CLR_OR_THIS_CALL _Donarrow(_Elem _Ch, char _Dflt) const { // narrow element to char
        char _Buf[MB_LEN_MAX];
        mbstate_t _Mbst = {};
        return _Wcrtomb(_Buf, _Ch, &_Mbst, &_Cvt) != 1 ? _Dflt : _Buf[0];
    }

    virtual char __CLR_OR_THIS_CALL do_narrow(_Elem _Ch, char _Dflt) const { // narrow element to char
        return _Donarrow(_Ch, _Dflt);
    }

    virtual const _Elem* __CLR_OR_THIS_CALL do_narrow(const _Elem* _First, const _Elem* _Last, char _Dflt,
        char* _Dest) const { // narrow elements in [_First, _Last) to chars
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First, ++_Dest) {
            *_Dest = _Donarrow(*_First, _Dflt);
        }

        return _First;
    }

private:
    _Locinfo::_Ctypevec _Ctype; // locale info passed to _Tolower, etc.
    _Locinfo::_Cvtvec _Cvt; // conversion information
};

#if defined(_NATIVE_WCHAR_T_DEFINED) && !_ENFORCE_FACET_SPECIALIZATIONS
extern "C++" template <>
class _CRTIMP2_PURE_IMPORT ctype<unsigned short>
    : public ctype_base { // facet for classifying unsigned short elements, converting cases
public:
    using _Elem = unsigned short;
    using char_type = _Elem;

    bool __CLR_OR_THIS_CALL is(mask _Maskval, _Elem _Ch) const { // test if element fits any mask classifications
        return do_is(_Maskval, _Ch);
    }

    const _Elem* __CLR_OR_THIS_CALL is(const _Elem* _First, const _Elem* _Last,
        mask* _Dest) const { // get mask sequence for elements in [_First, _Last)
        return do_is(_First, _Last, _Dest);
    }

    const _Elem* __CLR_OR_THIS_CALL scan_is(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { // find first in [_First, _Last) that fits mask classification
        return do_scan_is(_Maskval, _First, _Last);
    }

    const _Elem* __CLR_OR_THIS_CALL scan_not(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { // find first in [_First, _Last) not fitting mask classification
        return do_scan_not(_Maskval, _First, _Last);
    }

    _Elem __CLR_OR_THIS_CALL tolower(_Elem _Ch) const { // convert element to lower case
        return do_tolower(_Ch);
    }

    const _Elem* __CLR_OR_THIS_CALL tolower(
        _Elem* _First, const _Elem* _Last) const { // convert [_First, _Last) in place to lower case
        return do_tolower(_First, _Last);
    }

    _Elem __CLR_OR_THIS_CALL toupper(_Elem _Ch) const { // convert element to upper case
        return do_toupper(_Ch);
    }

    const _Elem* __CLR_OR_THIS_CALL toupper(
        _Elem* _First, const _Elem* _Last) const { // convert [_First, _Last) in place to upper case
        return do_toupper(_First, _Last);
    }

    _Elem __CLR_OR_THIS_CALL widen(char _Byte) const { // widen char
        return do_widen(_Byte);
    }

    const char* __CLR_OR_THIS_CALL widen(const char* _First, const char* _Last,
        _Elem* _Dest) const { // widen chars in [_First, _Last)
        return do_widen(_First, _Last, _Dest);
    }

    char __CLR_OR_THIS_CALL narrow(_Elem _Ch, char _Dflt = '\0') const { // narrow element to char
        return do_narrow(_Ch, _Dflt);
    }

    const _Elem* __CLR_OR_THIS_CALL narrow(const _Elem* _First, const _Elem* _Last, char _Dflt,
        char* _Dest) const { // narrow elements in [_First, _Last) to chars
        return do_narrow(_First, _Last, _Dflt, _Dest);
    }

    __PURE_APPDOMAIN_GLOBAL static locale::id id;

    explicit __CLR_OR_THIS_CALL ctype(size_t _Refs = 0) : ctype_base(_Refs) {
        _BEGIN_LOCINFO(_Lobj)
            _Init(_Lobj);
        _END_LOCINFO()
    }

    __CLR_OR_THIS_CALL ctype(const _Locinfo& _Lobj, size_t _Refs = 0) : ctype_base(_Refs) {
        _Init(_Lobj);
    }

    static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        if (_Ppf && !*_Ppf) {
            *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->_C_str()));
        }

        return _X_CTYPE;
    }

protected:
    __CLR_OR_THIS_CALL ~ctype() noexcept override {
        if (_Ctype._Delfl) {
            _CSTD free(const_cast<short*>(_Ctype._Table));
        }

        _CSTD free(_Ctype._LocaleName);
    }

    void __CLR_OR_THIS_CALL _Init(const _Locinfo& _Lobj) { // initialize from _Lobj
        _Ctype = _Lobj._Getctype();
        _Cvt = _Lobj._Getcvt();
    }

    virtual bool __CLR_OR_THIS_CALL do_is(
        mask _Maskval, _Elem _Ch) const { // test if element fits any mask classifications
        return (_CSTD _Getwctype(_Ch, &_Ctype) & _Maskval) != 0;
    }

    virtual const _Elem* __CLR_OR_THIS_CALL do_is(const _Elem* _First, const _Elem* _Last,
        mask* _Dest) const { // get mask sequence for elements in [_First, _Last)
        _Adl_verify_range(_First, _Last);
        return reinterpret_cast<const _Elem*>(_CSTD _Getwctypes(
            reinterpret_cast<const wchar_t*>(_First), reinterpret_cast<const wchar_t*>(_Last), _Dest, &_Ctype));
    }

    virtual const _Elem* __CLR_OR_THIS_CALL do_scan_is(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { // find first in [_First, _Last) that fits mask classification
        _Adl_verify_range(_First, _Last);
        while (_First != _Last && !is(_Maskval, *_First)) {
            ++_First;
        }

        return _First;
    }

    virtual const _Elem* __CLR_OR_THIS_CALL do_scan_not(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { // find first in [_First, _Last) not fitting mask classification
        _Adl_verify_range(_First, _Last);
        while (_First != _Last && is(_Maskval, *_First)) {
            ++_First;
        }

        return _First;
    }

    virtual _Elem __CLR_OR_THIS_CALL do_tolower(_Elem _Ch) const { // convert element to lower case
        return _Towlower(_Ch, &_Ctype);
    }

    virtual const _Elem* __CLR_OR_THIS_CALL do_tolower(_Elem* _First,
        const _Elem* _Last) const { // convert [_First, _Last) in place to lower case
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First) {
            *_First = _Towlower(*_First, &_Ctype);
        }

        return _First;
    }

    virtual _Elem __CLR_OR_THIS_CALL do_toupper(_Elem _Ch) const { // convert element to upper case
        return _Towupper(_Ch, &_Ctype);
    }

    virtual const _Elem* __CLR_OR_THIS_CALL do_toupper(_Elem* _First,
        const _Elem* _Last) const { // convert [_First, _Last) in place to upper case
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First) {
            *_First = _Towupper(*_First, &_Ctype);
        }

        return _First;
    }

    _Elem __CLR_OR_THIS_CALL _Dowiden(char _Byte) const { // widen char
        mbstate_t _Mbst = {};
        unsigned short _Wc;

        if (_Mbrtowc(reinterpret_cast<wchar_t*>(&_Wc), &_Byte, 1, &_Mbst, &_Cvt) < 0) {
            return static_cast<unsigned short>(WEOF);
        }

        return _Wc;
    }

    virtual _Elem __CLR_OR_THIS_CALL do_widen(char _Byte) const { // widen char
        return _Dowiden(_Byte);
    }

    virtual const char* __CLR_OR_THIS_CALL do_widen(
        const char* _First, const char* _Last, _Elem* _Dest) const { // widen chars in [_First, _Last)
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First, ++_Dest) {
            *_Dest = _Dowiden(*_First);
        }

        return _First;
    }

    char __CLR_OR_THIS_CALL _Donarrow(_Elem _Ch, char _Dflt) const { // narrow element to char
        char _Buf[MB_LEN_MAX];
        mbstate_t _Mbst = {};
        return _Wcrtomb(_Buf, _Ch, &_Mbst, &_Cvt) != 1 ? _Dflt : _Buf[0];
    }

    virtual char __CLR_OR_THIS_CALL do_narrow(_Elem _Ch, char _Dflt) const { // narrow element to char
        return _Donarrow(_Ch, _Dflt);
    }

    virtual const _Elem* __CLR_OR_THIS_CALL do_narrow(const _Elem* _First, const _Elem* _Last, char _Dflt,
        char* _Dest) const { // narrow elements in [_First, _Last) to chars
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First, ++_Dest) {
            *_Dest = _Donarrow(*_First, _Dflt);
        }

        return _First;
    }

private:
    _Locinfo::_Ctypevec _Ctype; // locale info passed to _Tolower, etc.
    _Locinfo::_Cvtvec _Cvt; // conversion information
};
#endif // defined(_NATIVE_WCHAR_T_DEFINED) && !_ENFORCE_FACET_SPECIALIZATIONS

_EXPORT_STD template <class _Elem>
class ctype_byname : public ctype<_Elem> { // ctype for named locale
public:
    static_assert(!_ENFORCE_FACET_SPECIALIZATIONS || _Is_any_of_v<_Elem, char, wchar_t>, _FACET_SPECIALIZATION_MESSAGE);

    explicit __CLR_OR_THIS_CALL ctype_byname(const char* _Locname, size_t _Refs = 0)
        : ctype<_Elem>(_Locinfo(_Locname), _Refs) {} // construct for named locale

    explicit __CLR_OR_THIS_CALL ctype_byname(const string& _Str, size_t _Refs = 0)
        : ctype<_Elem>(_Locinfo(_Str.c_str()), _Refs) {} // construct for named locale

protected:
    __CLR_OR_THIS_CALL ~ctype_byname() noexcept override {}
};

enum class _Case_sensitive : bool { _Nope, _Yes };

template <class _InIt, class _Elem>
int __CRTDECL _Getloctxt(
    _InIt& _First, _InIt& _Last, size_t _Numfields, const _Elem* _Ptr, const _Case_sensitive _Matching) {
    // find field at _Ptr that matches longest in [_First, _Last)
    for (size_t _Off = 0; _Ptr[_Off] != _Elem{}; ++_Off) {
        if (_Ptr[_Off] == _Ptr[0]) {
            ++_Numfields; // add fields with leading mark to initial count
        }
    }

    string _Str(_Numfields, '\0'); // one column counter for each field
    const ctype<_Elem>& _CType = _STD use_facet<ctype<_Elem>>(locale{});

    int _Ans = -2; // no candidates so far
    for (size_t _Column = 1;; ++_Column, (void) ++_First, _Ans = -1) { // test each element against all viable fields
        bool _Prefix = false; // seen at least one valid prefix
        size_t _Off = 0; // offset into fields
        size_t _Field = 0; // current field number

        for (; _Field < _Numfields; ++_Field) { // test element at _Column in field _Field
            while (_Ptr[_Off] != _Elem{} && _Ptr[_Off] != _Ptr[0]) { // find beginning of field
                ++_Off;
            }

            if (_Str[_Field] != '\0') {
                _Off += _Str[_Field]; // skip tested columns in field
            }
            else if (_Ptr[_Off += _Column] == _Ptr[0]
                || _Ptr[_Off] == _Elem{}) { // matched all of field, save as possible answer
                _Str[_Field] = static_cast<char>(_Column < 127 ? _Column : 127); // save skip count if small enough
                _Ans = static_cast<int>(_Field); // save answer
            }
            else if (_First == _Last
                || (_Matching == _Case_sensitive::_Yes
                    ? _Ptr[_Off] != *_First
                    : _CType.tolower(_Ptr[_Off]) != _CType.tolower(static_cast<_Elem>(*_First)))) {
                _Str[_Field] = static_cast<char>(_Column < 127 ? _Column : 127); // no match, just save skip count
            }
            else {
                _Prefix = true; // still a valid prefix
            }
        }

        if (!_Prefix || _First == _Last) {
            break; // no pending prefixes or no input, give up
        }
    }
    return _Ans; // return field number or negative value on failure
}

#if defined(_DLL_CPPLIB)
#if !defined(_CRTBLD) || defined(__FORCE_INSTANCE)
template class _CRTIMP2_PURE_IMPORT codecvt<char, char, mbstate_t>;
#endif // !defined(_CRTBLD) || defined(__FORCE_INSTANCE)
#endif // defined(_DLL_CPPLIB)
_STD_END
#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _XLOCALE_


#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_STD_BEGIN
template <class _Dummy>
class _Iosb { // define templatized bitmask/enumerated types, instantiate on demand
public:
    enum _Fmtflags { // constants for formatting options
        _Fmtmask = 0xffff,
        _Fmtzero = 0
    };

    static constexpr int skipws = 0x0001;
    static constexpr int unitbuf = 0x0002;
    static constexpr int uppercase = 0x0004;
    static constexpr int showbase = 0x0008;
    static constexpr int showpoint = 0x0010;
    static constexpr int showpos = 0x0020;
    static constexpr int left = 0x0040;
    static constexpr int right = 0x0080;
    static constexpr int internal = 0x0100;
    static constexpr int dec = 0x0200;
    static constexpr int oct = 0x0400;
    static constexpr int hex = 0x0800;
    static constexpr int scientific = 0x1000;
    static constexpr int fixed = 0x2000;

    static constexpr int boolalpha = 0x4000;
    static constexpr int adjustfield = left | right | internal;
    static constexpr int basefield = dec | oct | hex;
    static constexpr int floatfield = scientific | fixed;

    enum _Iostate { // constants for stream states
        _Statmask = 0x17
    };

    static constexpr int goodbit = 0x0;
    static constexpr int eofbit = 0x1;
    static constexpr int failbit = 0x2;
    static constexpr int badbit = 0x4;

    static constexpr int in = 0x01;
    static constexpr int out = 0x02;
    static constexpr int ate = 0x04;
    static constexpr int app = 0x08;
    static constexpr int trunc = 0x10;
    static constexpr int _Nocreate = 0x40;
    static constexpr int _Noreplace = 0x80;
    static constexpr int binary = 0x20;
    static constexpr int beg = 0;
    static constexpr int cur = 1;
    static constexpr int end = 2;

    static constexpr int _Default_open_prot = _SH_DENYNO; // constant for default file opening protection

    // TRANSITION, ABI: These enums don't appear in the STL DLL's export surface, but MaxMPDCompat
    // in the MSVC-internal build detects that they appear in the CompatibilityData baseline.
    enum _Dummy_enum { _Dummy_enum_val = 1 };
    enum _Openmode { _Openmask = 0xff };
    enum _Seekdir { _Seekbeg, _Seekcur, _Seekend };
    enum { _Openprot = _SH_DENYNO };
};

_EXPORT_STD extern "C++" class _CRTIMP2_PURE_IMPORT ios_base : public _Iosb<int> { // base class for ios
public:
    using fmtflags = int;
    using iostate = int;
    using openmode = int;
    using seekdir = int;

    enum event { // constants for ios events
        erase_event,
        imbue_event,
        copyfmt_event
    };

    using event_callback = void(__CLRCALL_OR_CDECL*)(event, ios_base&, int);

    class failure : public system_error { // base of all iostreams exceptions
    public:
        explicit failure(const string& _Message, const error_code& _Errcode = _STD make_error_code(io_errc::stream))
            : system_error(_Errcode, _Message) {} // construct with message

        explicit failure(const char* _Message, const error_code& _Errcode = _STD make_error_code(io_errc::stream))
            : system_error(_Errcode, _Message) {} // construct with message

    };

    class _CRTIMP2_PURE_IMPORT Init { // controller for standard-stream initialization
    public:
        __CLR_OR_THIS_CALL Init() { // initialize standard streams on first construction
            _Init_ctor(this);
        }

        __CLR_OR_THIS_CALL ~Init() noexcept { // flush standard streams on last destruction
            _Init_dtor(this);
        }

    private:
        static void __cdecl _Init_ctor(Init*);
        static void __cdecl _Init_dtor(Init*);

        __PURE_APPDOMAIN_GLOBAL static int _Init_cnt; // net ctor count

        static int& __cdecl _Init_cnt_func();
    };

    explicit __CLR_OR_THIS_CALL operator bool() const noexcept /* strengthened */ {
        return !fail();
    }

    _NODISCARD bool __CLR_OR_THIS_CALL operator!() const noexcept /* strengthened */ {
        return fail();
    }

    void __CLR_OR_THIS_CALL clear(iostate _State, bool _Reraise) { // set state, possibly reraise exception
        _State &= _Statmask;
        _Mystate = _State;
        const auto _Filtered = _State & _Except;
        if (_Filtered) {
            if (_Reraise) {
                _RERAISE;
            }

            const char* _Msg;
            if (_Filtered & ios_base::badbit) {
                _Msg = "ios_base::badbit set";
            }
            else if (_Filtered & ios_base::failbit) {
                _Msg = "ios_base::failbit set";
            }
            else {
                _Msg = "ios_base::eofbit set";
            }

            _THROW(failure(_Msg));
        }
    }

    void __CLR_OR_THIS_CALL clear(iostate _State = goodbit) { // set state to argument
        clear(_State, false);
    }

    _NODISCARD iostate __CLR_OR_THIS_CALL rdstate() const noexcept /* strengthened */ {
        return _Mystate;
    }

    void __CLR_OR_THIS_CALL setstate(
        iostate _State, bool _Exreraise) { // merge in state argument, possibly reraise exception
        clear(rdstate() | _State, _Exreraise);
    }

    void __CLR_OR_THIS_CALL setstate(iostate _State) { // merge in state argument
        clear(rdstate() | _State, false);
    }

    _NODISCARD bool __CLR_OR_THIS_CALL good() const noexcept /* strengthened */ {
        return rdstate() == ios_base::goodbit;
    }

    _NODISCARD bool __CLR_OR_THIS_CALL eof() const noexcept /* strengthened */ {
        return rdstate() & ios_base::eofbit;
    }

    _NODISCARD bool __CLR_OR_THIS_CALL fail() const noexcept /* strengthened */ {
        return rdstate() & (ios_base::badbit | ios_base::failbit);
    }

    _NODISCARD bool __CLR_OR_THIS_CALL bad() const noexcept /* strengthened */ {
        return rdstate() & ios_base::badbit;
    }

    _NODISCARD iostate __CLR_OR_THIS_CALL exceptions() const noexcept /* strengthened */ {
        return _Except;
    }

    void __CLR_OR_THIS_CALL exceptions(iostate _Newexcept) { // set exception mask to argument
        _Except = _Newexcept & _Statmask;
        clear(rdstate());
    }

#if _HAS_OLD_IOSTREAMS_MEMBERS
    void __CLR_OR_THIS_CALL exceptions(io_state _State) { // set exception mask to argument, old style
        exceptions(static_cast<iostate>(_State));
    }
#endif // _HAS_OLD_IOSTREAMS_MEMBERS

    _NODISCARD fmtflags __CLR_OR_THIS_CALL flags() const noexcept /* strengthened */ {
        return _Fmtfl;
    }

    fmtflags __CLR_OR_THIS_CALL flags(fmtflags _Newfmtflags) noexcept /* strengthened */ {
        // set format flags to argument
        const fmtflags _Oldfmtflags = _Fmtfl;
        _Fmtfl = _Newfmtflags & _Fmtmask;
        return _Oldfmtflags;
    }

    fmtflags __CLR_OR_THIS_CALL setf(fmtflags _Newfmtflags) noexcept /* strengthened */ {
        // merge in format flags argument
        const ios_base::fmtflags _Oldfmtflags = _Fmtfl;
        _Fmtfl |= _Newfmtflags & _Fmtmask;
        return _Oldfmtflags;
    }

    fmtflags __CLR_OR_THIS_CALL setf(fmtflags _Newfmtflags, fmtflags _Mask) noexcept /* strengthened */ {
        // merge in format flags argument under mask argument
        const ios_base::fmtflags _Oldfmtflags = _Fmtfl;
        _Fmtfl = (_Oldfmtflags & ~_Mask) | (_Newfmtflags & _Mask & _Fmtmask);
        return _Oldfmtflags;
    }

    void __CLR_OR_THIS_CALL unsetf(fmtflags _Mask) noexcept /* strengthened */ {
        // clear format flags under mask argument
        _Fmtfl &= ~_Mask;
    }

    _NODISCARD streamsize __CLR_OR_THIS_CALL precision() const noexcept /* strengthened */ {
        return _Prec;
    }

    streamsize __CLR_OR_THIS_CALL precision(streamsize _Newprecision) noexcept /* strengthened */ {
        // set precision to argument
        const streamsize _Oldprecision = _Prec;
        _Prec = _Newprecision;
        return _Oldprecision;
    }

    _NODISCARD streamsize __CLR_OR_THIS_CALL width() const noexcept /* strengthened */ {
        return _Wide;
    }

    streamsize __CLR_OR_THIS_CALL width(streamsize _Newwidth) noexcept /* strengthened */ {
        // set width to argument
        const streamsize _Oldwidth = _Wide;
        _Wide = _Newwidth;
        return _Oldwidth;
    }

    _NODISCARD locale __CLR_OR_THIS_CALL getloc() const noexcept /* strengthened */ { // get locale
        return *_Ploc;
    }

    locale __CLR_OR_THIS_CALL imbue(const locale& _Loc) { // set locale to argument
        locale _Oldlocale = *_Ploc;
        *_Ploc = _Loc;
        _Callfns(imbue_event);
        return _Oldlocale;
    }

    _NODISCARD static int __CLRCALL_OR_CDECL xalloc() { // allocate new iword/pword index
        _BEGIN_LOCK(_LOCK_STREAM) // lock thread to ensure atomicity
            return _Index++;
        _END_LOCK()
    }

    _NODISCARD long& __CLR_OR_THIS_CALL iword(int _Idx) {
        return _Findarr(_Idx)._Lo;
    }

    _NODISCARD void*& __CLR_OR_THIS_CALL pword(int _Idx) {
        return _Findarr(_Idx)._Vp;
    }

    void __CLR_OR_THIS_CALL register_callback(event_callback _Pfn, int _Idx) {
        // register event handler
        _Calls = new _Fnarray(_Idx, _Pfn, _Calls);
    }

    ios_base& __CLR_OR_THIS_CALL copyfmt(const ios_base& _Other) { // copy format stuff
        if (this != _STD addressof(_Other)) { // copy all but _Mystate
            _Tidy();
            *_Ploc = *_Other._Ploc;
            _Fmtfl = _Other._Fmtfl;
            _Prec = _Other._Prec;
            _Wide = _Other._Wide;
            _Iosarray* _Ptr = _Other._Arr;

            for (_Arr = nullptr; _Ptr; _Ptr = _Ptr->_Next) {
                if (_Ptr->_Lo != 0 || _Ptr->_Vp) { // copy over nonzero array values
                    iword(_Ptr->_Index) = _Ptr->_Lo;
                    pword(_Ptr->_Index) = _Ptr->_Vp;
                }
            }

            for (_Fnarray* _Pfa = _Other._Calls; _Pfa; _Pfa = _Pfa->_Next) {
                register_callback(_Pfa->_Pfn, _Pfa->_Index);
            }

            _Callfns(copyfmt_event); // call callbacks
            exceptions(_Other._Except); // cause any throw at end
        }
        return *this;
    }

    static bool __CLRCALL_OR_CDECL sync_with_stdio(bool _Newsync = true) {
        // set C/C++ synchronization flag from argument
        _BEGIN_LOCK(_LOCK_STREAM) // lock thread to ensure atomicity
            const bool _Oldsync = _Sync;
        _Sync = _Newsync;
        return _Oldsync;
        _END_LOCK()
    }

    void __CLR_OR_THIS_CALL swap(ios_base& _Right) noexcept /* strengthened */ {
        if (this != _STD addressof(_Right)) {
            _STD swap(_Mystate, _Right._Mystate);
            _STD swap(_Except, _Right._Except);
            _STD swap(_Fmtfl, _Right._Fmtfl);
            _STD swap(_Prec, _Right._Prec);
            _STD swap(_Wide, _Right._Wide);

            _STD swap(_Arr, _Right._Arr);
            _STD swap(_Calls, _Right._Calls);
            _STD swap(_Ploc, _Right._Ploc);
        }
    }

    virtual __CLR_OR_THIS_CALL ~ios_base() noexcept {
        _Ios_base_dtor(this);
    }

    static void __CLRCALL_PURE_OR_CDECL _Addstd(ios_base*); // add standard stream

    size_t _Stdstr{ 0 }; // if > 0 index of standard stream to suppress destruction

protected:
    __CLR_OR_THIS_CALL ios_base() {}

    void __CLR_OR_THIS_CALL _Init() { // initialize a new ios_base
        _Ploc = nullptr;
        _Stdstr = 0;
        _Except = goodbit;
        _Fmtfl = skipws | dec;
        _Prec = 6;
        _Wide = 0;
        _Arr = nullptr;
        _Calls = nullptr;
        clear(goodbit);
        _Ploc = new locale;
    }

private:
    struct _Iosarray : _Crt_new_delete { // list element for open-ended sparse array of longs/pointers
    public:
        __CLR_OR_THIS_CALL _Iosarray(int _Idx, _Iosarray* _Link)
            : _Next(_Link), _Index(_Idx), _Lo(0), _Vp(nullptr) {} // construct node for index _Idx and link it in

        _Iosarray* _Next; // pointer to next node
        int _Index; // index of this node
        long _Lo; // stored long value
        void* _Vp; // stored pointer value
    };

    struct _Fnarray : _Crt_new_delete { // list element for open-ended sparse array of event handlers
        __CLR_OR_THIS_CALL _Fnarray(int _Idx, event_callback _Pnew, _Fnarray* _Link)
            : _Next(_Link), _Index(_Idx), _Pfn(_Pnew) {} // construct node for index _Idx and link it in

        _Fnarray* _Next; // pointer to next node
        int _Index; // index of this node
        event_callback _Pfn; // pointer to event handler
    };

    void __CLR_OR_THIS_CALL _Callfns(event _Ev) { // call all event handlers, reporting event
        for (_Fnarray* _Pfa = _Calls; _Pfa; _Pfa = _Pfa->_Next) {
            (*_Pfa->_Pfn)(_Ev, *this, _Pfa->_Index);
        }
    }

    _Iosarray& __CLR_OR_THIS_CALL _Findarr(int _Idx) { // locate or make a variable array element
        _Iosarray* _Ptr1;
        _Iosarray* _Ptr2;

        for (_Ptr1 = _Arr, _Ptr2 = nullptr; _Ptr1; _Ptr1 = _Ptr1->_Next) {
            if (_Ptr1->_Index == _Idx) {
                return *_Ptr1; // found element, return it
            }
            else if (!_Ptr2 && _Ptr1->_Lo == 0 && !_Ptr1->_Vp) {
                _Ptr2 = _Ptr1; // found recycling candidate
            }
        }

        if (_Ptr2) { // recycle existing element
            _Ptr2->_Index = _Idx;
            return *_Ptr2;
        }

        _Arr = new _Iosarray(_Idx, _Arr); // make a new element
        return *_Arr;
    }

    void __CLR_OR_THIS_CALL _Tidy() noexcept { // discard storage for an ios_base
        _Callfns(erase_event);
        _Iosarray* _Ptr1;
        _Iosarray* _Ptr2;

        for (_Ptr1 = _Arr; _Ptr1; _Ptr1 = _Ptr2) { // delete array element
            _Ptr2 = _Ptr1->_Next;
            delete _Ptr1;
        }
        _Arr = nullptr;

        _Fnarray* _Pfa1;
        _Fnarray* _Pfa2;
        for (_Pfa1 = _Calls; _Pfa1; _Pfa1 = _Pfa2) { // delete callback element
            _Pfa2 = _Pfa1->_Next;
            delete _Pfa1;
        }
        _Calls = nullptr;
    }

    iostate _Mystate{}; // stream state
    iostate _Except{}; // exception mask
    fmtflags _Fmtfl{}; // format flags
    streamsize _Prec{}; // field precision
    streamsize _Wide{}; // field width
    _Iosarray* _Arr{ nullptr }; // pointer to first node of long/pointer array
    _Fnarray* _Calls{ nullptr }; // pointer to first node of call list
    locale* _Ploc{ nullptr }; // pointer to locale

    __PURE_APPDOMAIN_GLOBAL static int _Index;
    __PURE_APPDOMAIN_GLOBAL static bool _Sync;

    static void __CLRCALL_PURE_OR_CDECL _Ios_base_dtor(ios_base*);

public:
    ios_base(const ios_base&) = delete;
    ios_base& operator=(const ios_base&) = delete;
};
_STD_END
#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _XIOSBASE_


#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_STD_BEGIN
_EXPORT_STD extern "C++" template <class _Elem, class _Traits>
class basic_streambuf { // control read/write buffers
protected:
    __CLR_OR_THIS_CALL basic_streambuf() : _Plocale(new locale) {
        _Init();
    }

    __CLR_OR_THIS_CALL basic_streambuf(_Uninitialized) noexcept {}

    __CLR_OR_THIS_CALL basic_streambuf(const basic_streambuf& _Right) : _Plocale(new locale{ _Right.getloc() }) {
        _Init();
        setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
        setg(_Right.eback(), _Right.gptr(), _Right.egptr());
    }

    basic_streambuf& __CLR_OR_THIS_CALL operator=(const basic_streambuf& _Right) {
        if (this != _STD addressof(_Right)) {
            setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
            setg(_Right.eback(), _Right.gptr(), _Right.egptr());
            pubimbue(_Right.getloc());
        }
        return *this;
    }

    void __CLR_OR_THIS_CALL swap(basic_streambuf& _Right) noexcept /* strengthened */ {
        if (this != _STD addressof(_Right)) {
            _Elem* _Pfirst0 = pbase();
            _Elem* _Pnext0 = pptr();
            _Elem* _Pend = epptr();
            _Elem* _Gfirst0 = eback();
            _Elem* _Gnext0 = gptr();
            _Elem* _Gend = egptr();

            setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
            _Right.setp(_Pfirst0, _Pnext0, _Pend);

            setg(_Right.eback(), _Right.gptr(), _Right.egptr());
            _Right.setg(_Gfirst0, _Gnext0, _Gend);

            _STD swap(_Plocale, _Right._Plocale);
        }
    }

public:
    using char_type = _Elem;
    using traits_type = _Traits;

    virtual __CLR_OR_THIS_CALL ~basic_streambuf() noexcept {
        delete _Plocale;
    }

    using int_type = typename _Traits::int_type;
    using pos_type = typename _Traits::pos_type;
    using off_type = typename _Traits::off_type;

    pos_type __CLR_OR_THIS_CALL pubseekoff(off_type _Off, ios_base::seekdir _Way,
        ios_base::openmode _Mode = ios_base::in | ios_base::out) { // change position by _Off, according to _Way, _Mode
        return seekoff(_Off, _Way, _Mode);
    }

    pos_type __CLR_OR_THIS_CALL pubseekpos(pos_type _Pos,
        ios_base::openmode _Mode = ios_base::in | ios_base::out) { // change position to _Pos, according to _Mode
        return seekpos(_Pos, _Mode);
    }

    basic_streambuf* __CLR_OR_THIS_CALL pubsetbuf(_Elem* _Buffer,
        streamsize _Count) { // offer _Buffer to external agent
        return setbuf(_Buffer, _Count);
    }

    locale __CLR_OR_THIS_CALL pubimbue(const locale& _Newlocale) { // set locale to argument
        locale _Oldlocale = *_Plocale;
        imbue(_Newlocale);
        *_Plocale = _Newlocale;
        return _Oldlocale;
    }

    locale __CLR_OR_THIS_CALL getloc() const noexcept /* strengthened */ { // get locale
        return *_Plocale;
    }

    streamsize __CLR_OR_THIS_CALL in_avail() {
        streamsize _Res = _Gnavail();
        return 0 < _Res ? _Res : showmanyc();
    }

    int __CLR_OR_THIS_CALL pubsync() { // synchronize with external agent
        return sync();
    }

    int_type __CLR_OR_THIS_CALL sbumpc() { // get a character and point past it
        return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();
    }

    int_type __CLR_OR_THIS_CALL sgetc() { // get a character and don't point past it
        return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();
    }

    streamsize __CLR_OR_THIS_CALL sgetn(_Elem* _Ptr,
        streamsize _Count) { // get up to _Count characters into array beginning at _Ptr
        return xsgetn(_Ptr, _Count);
    }

    int_type __CLR_OR_THIS_CALL snextc() { // point to next character and return it
        return 1 < _Gnavail() ? _Traits::to_int_type(*_Gnpreinc())
            : _Traits::eq_int_type(_Traits::eof(), sbumpc()) ? _Traits::eof()
            : sgetc();
    }

    int_type __CLR_OR_THIS_CALL sputbackc(_Elem _Ch) { // put back _Ch
        if (gptr() && eback() < gptr() && _Traits::eq(_Ch, gptr()[-1])) {
            return _Traits::to_int_type(*_Gndec());
        }

        return pbackfail(_Traits::to_int_type(_Ch));
    }

#if _HAS_OLD_IOSTREAMS_MEMBERS
    void __CLR_OR_THIS_CALL stossc() { // point past a character
        if (0 < _Gnavail()) {
            _Gninc();
        }
        else {
            uflow();
        }
    }
#endif // _HAS_OLD_IOSTREAMS_MEMBERS

    int_type __CLR_OR_THIS_CALL sungetc() { // back up one position
        return gptr() && eback() < gptr() ? _Traits::to_int_type(*_Gndec()) : pbackfail();
    }

    int_type __CLR_OR_THIS_CALL sputc(_Elem _Ch) { // put a character
        return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));
    }

    streamsize __CLR_OR_THIS_CALL sputn(const _Elem* _Ptr,
        streamsize _Count) { // put _Count characters from array beginning at _Ptr
        return xsputn(_Ptr, _Count);
    }

    virtual void __CLR_OR_THIS_CALL _Lock() {} // set the thread lock (overridden by basic_filebuf)

    virtual void __CLR_OR_THIS_CALL _Unlock() {} // clear the thread lock (overridden by basic_filebuf)

protected:
    _Elem* __CLR_OR_THIS_CALL eback() const noexcept /* strengthened */ {
        return *_IGfirst;
    }

    _Elem* __CLR_OR_THIS_CALL gptr() const noexcept /* strengthened */ {
        return *_IGnext;
    }

    _Elem* __CLR_OR_THIS_CALL pbase() const noexcept /* strengthened */ {
        return *_IPfirst;
    }

    _Elem* __CLR_OR_THIS_CALL pptr() const noexcept /* strengthened */ {
        return *_IPnext;
    }

    _Elem* __CLR_OR_THIS_CALL egptr() const noexcept /* strengthened */ {
        return *_IGnext + *_IGcount;
    }

    void __CLR_OR_THIS_CALL gbump(int _Off) noexcept /* strengthened */ {
        // alter current position in read buffer by _Off
        *_IGcount -= _Off;
        *_IGnext += _Off;
    }

    void __CLR_OR_THIS_CALL setg(_Elem* _First, _Elem* _Next, _Elem* _Last) noexcept /* strengthened */ {
        // set pointers for read buffer
        *_IGfirst = _First;
        *_IGnext = _Next;
        *_IGcount = static_cast<int>(_Last - _Next);
    }

    _Elem* __CLR_OR_THIS_CALL epptr() const noexcept /* strengthened */ {
        return *_IPnext + *_IPcount;
    }

    _Elem* __CLR_OR_THIS_CALL _Gndec() noexcept { // decrement current position in read buffer
        ++*_IGcount;
        return -- * _IGnext;
    }

    _Elem* __CLR_OR_THIS_CALL _Gninc() noexcept { // increment current position in read buffer
        --*_IGcount;
        return (*_IGnext)++;
    }

    _Elem* __CLR_OR_THIS_CALL _Gnpreinc() noexcept { // preincrement current position in read buffer
        --*_IGcount;
        return ++(*_IGnext);
    }

    streamsize __CLR_OR_THIS_CALL _Gnavail() const noexcept { // count number of available elements in read buffer
        return *_IGnext ? *_IGcount : 0;
    }

    void __CLR_OR_THIS_CALL pbump(int _Off) noexcept /* strengthened */ {
        // alter current position in write buffer by _Off
        *_IPcount -= _Off;
        *_IPnext += _Off;
    }

    void __CLR_OR_THIS_CALL setp(_Elem* _First, _Elem* _Last) noexcept /* strengthened */ {
        // set pointers for write buffer
        *_IPfirst = _First;
        *_IPnext = _First;
        *_IPcount = static_cast<int>(_Last - _First);
    }

    void __CLR_OR_THIS_CALL setp(_Elem* _First, _Elem* _Next, _Elem* _Last) noexcept /* strengthened */ {
        // set pointers for write buffer, extended version
        *_IPfirst = _First;
        *_IPnext = _Next;
        *_IPcount = static_cast<int>(_Last - _Next);
    }

    _Elem* __CLR_OR_THIS_CALL _Pninc() noexcept { // increment current position in write buffer
        --*_IPcount;
        return (*_IPnext)++;
    }

    streamsize __CLR_OR_THIS_CALL _Pnavail() const noexcept { // count number of available positions in write buffer
        return *_IPnext ? *_IPcount : 0;
    }

    void __CLR_OR_THIS_CALL _Init() noexcept { // initialize buffer parameters for no buffers
        _IGfirst = &_Gfirst;
        _IPfirst = &_Pfirst;
        _IGnext = &_Gnext;
        _IPnext = &_Pnext;
        _IGcount = &_Gcount;
        _IPcount = &_Pcount;
        setp(nullptr, nullptr);
        setg(nullptr, nullptr, nullptr);
    }

    void __CLR_OR_THIS_CALL _Init(_Elem** _Gf, _Elem** _Gn, int* _Gc, _Elem** _Pf, _Elem** _Pn, int* _Pc) noexcept {
        // initialize buffer parameters as specified
        _IGfirst = _Gf;
        _IPfirst = _Pf;
        _IGnext = _Gn;
        _IPnext = _Pn;
        _IGcount = _Gc;
        _IPcount = _Pc;
    }

    virtual int_type __CLR_OR_THIS_CALL overflow(int_type = _Traits::eof()) { // put a character to stream (always fail)
        return _Traits::eof();
    }

    virtual int_type __CLR_OR_THIS_CALL pbackfail(int_type = _Traits::eof()) {
        // put a character back to stream (always fail)
        return _Traits::eof();
    }

    virtual streamsize __CLR_OR_THIS_CALL showmanyc() {
        return 0;
    }

    virtual int_type __CLR_OR_THIS_CALL underflow() { // get a character from stream, but don't point past it
        return _Traits::eof();
    }

    virtual int_type __CLR_OR_THIS_CALL uflow() { // get a character from stream, point past it
        return _Traits::eq_int_type(_Traits::eof(), underflow()) ? _Traits::eof() : _Traits::to_int_type(*_Gninc());
    }

    virtual streamsize __CLR_OR_THIS_CALL xsgetn(_Elem* _Ptr, streamsize _Count) { // get _Count characters from stream
        const streamsize _Start_count = _Count;

        while (0 < _Count) {
            streamsize _Size = _Gnavail();
            if (0 < _Size) { // copy from read buffer
                if (_Count < _Size) {
                    _Size = _Count;
                }

                _Traits::copy(_Ptr, gptr(), static_cast<size_t>(_Size));
                _Ptr += _Size;
                _Count -= _Size;
                gbump(static_cast<int>(_Size));
            }
            else {
                const int_type _Meta = uflow();
                if (_Traits::eq_int_type(_Traits::eof(), _Meta)) {
                    break; // end of file, quit
                }

                // get a single character
                *_Ptr++ = _Traits::to_char_type(_Meta);
                --_Count;
            }
        }

        return _Start_count - _Count;
    }

    virtual streamsize __CLR_OR_THIS_CALL xsputn(const _Elem* _Ptr, streamsize _Count) {
        // put _Count characters to stream
        const streamsize _Start_count = _Count;
        while (0 < _Count) {
            streamsize _Size = _Pnavail();
            if (0 < _Size) { // copy to write buffer
                if (_Count < _Size) {
                    _Size = _Count;
                }

                _Traits::copy(pptr(), _Ptr, static_cast<size_t>(_Size));
                _Ptr += _Size;
                _Count -= _Size;
                pbump(static_cast<int>(_Size));
            }
            else if (_Traits::eq_int_type(_Traits::eof(), overflow(_Traits::to_int_type(*_Ptr)))) {
                break; // single character put failed, quit
            }
            else { // count character successfully put
                ++_Ptr;
                --_Count;
            }
        }

        return _Start_count - _Count;
    }

    virtual pos_type __CLR_OR_THIS_CALL seekoff(
        off_type, ios_base::seekdir, ios_base::openmode = ios_base::in | ios_base::out) {
        // change position by offset, according to way and mode
        return pos_type{ off_type{-1} };
    }

    virtual pos_type __CLR_OR_THIS_CALL seekpos(pos_type, ios_base::openmode = ios_base::in | ios_base::out) {
        // change to specified position, according to mode
        return pos_type{ off_type{-1} };
    }

    virtual basic_streambuf* __CLR_OR_THIS_CALL setbuf(_Elem*, streamsize) {
        // offer buffer to external agent (do nothing)
        return this;
    }

    virtual int __CLR_OR_THIS_CALL sync() { // synchronize with external agent (do nothing)
        return 0;
    }

    virtual void __CLR_OR_THIS_CALL imbue(const locale&) {} // set locale to argument (do nothing)

private:
    _Elem* _Gfirst{}; // beginning of read buffer
    _Elem* _Pfirst{}; // beginning of write buffer
    _Elem** _IGfirst{}; // pointer to beginning of read buffer
    _Elem** _IPfirst{}; // pointer to beginning of write buffer
    _Elem* _Gnext{}; // current position in read buffer
    _Elem* _Pnext{}; // current position in write buffer
    _Elem** _IGnext{}; // pointer to current position in read buffer
    _Elem** _IPnext{}; // pointer to current position in write buffer

    int _Gcount{}; // length of read buffer
    int _Pcount{}; // length of write buffer
    int* _IGcount{}; // pointer to length of read buffer
    int* _IPcount{}; // pointer to length of write buffer

protected:
    locale* _Plocale{}; // pointer to imbued locale object
};

#if defined(_DLL_CPPLIB)

#if !defined(_CRTBLD) || defined(__FORCE_INSTANCE)
template class _CRTIMP2_PURE_IMPORT basic_streambuf<char, char_traits<char>>;
template class _CRTIMP2_PURE_IMPORT basic_streambuf<wchar_t, char_traits<wchar_t>>;
#endif // !defined(_CRTBLD) || defined(__FORCE_INSTANCE)

#ifdef __FORCE_INSTANCE
template class _CRTIMP2_PURE_IMPORT basic_streambuf<unsigned short, char_traits<unsigned short>>;
#endif // defined(__FORCE_INSTANCE)
#endif // defined(_DLL_CPPLIB)
_STD_END

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)


#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_EXTERN_C_UNLESS_PURE

_CRTIMP2_PURE long __CLRCALL_PURE_OR_CDECL _Stolx(
    const char*, _Out_opt_ _Deref_post_opt_valid_ char**, int, int*) noexcept;
_CRTIMP2_PURE unsigned long __CLRCALL_PURE_OR_CDECL _Stoulx(
    const char*, _Out_opt_ _Deref_post_opt_valid_ char**, int, int*) noexcept;
_CRTIMP2_PURE long long __CLRCALL_PURE_OR_CDECL _Stollx(
    const char*, _Out_opt_ _Deref_post_opt_valid_ char**, int, int*) noexcept;
_CRTIMP2_PURE unsigned long long __CLRCALL_PURE_OR_CDECL _Stoullx(
    const char*, _Out_opt_ _Deref_post_opt_valid_ char**, int, int*) noexcept;

_END_EXTERN_C_UNLESS_PURE

_STD_BEGIN

_INLINE_VAR constexpr size_t _Max_int_dig = 32; // integer properties

inline double _Stodx_v3(const char* _Str, char** _Endptr, int* _Perr) noexcept { // convert string to double
    int& _Errno_ref = errno; // Nonzero cost, pay it once
    const int _Orig = _Errno_ref;

    _Errno_ref = 0;
    double _Val = _CSTD strtod(_Str, _Endptr);
    *_Perr = _Errno_ref;
    _Errno_ref = _Orig;

    return _Val;
}

inline float _Stofx_v3(const char* _Str, char** _Endptr, int* _Perr) noexcept { // convert string to float
    int& _Errno_ref = errno; // Nonzero cost, pay it once
    const int _Orig = _Errno_ref;

    _Errno_ref = 0;
    float _Val = _CSTD strtof(_Str, _Endptr);
    *_Perr = _Errno_ref;
    _Errno_ref = _Orig;

    return _Val;
}

template <class _Elem, size_t _Base_size>
size_t _Find_elem(const _Elem(&_Base)[_Base_size], const _Elem _Ch) {
    // lookup _Ch in array storing NUL-terminated string _Base
    // pre: _Base contains no nulls except for _Base[_Base_size - 1]
    return static_cast<size_t>(_STD _Find_unchecked(_Base, _Base + (_Base_size - 1), _Ch) - _Base);
}

inline wchar_t* _Maklocwcs(const wchar_t* _Ptr) { // copy NTWCS to allocated storage
    const size_t _Count = _CSTD wcslen(_Ptr) + 1;

    wchar_t* _Ptrdest = static_cast<wchar_t*>(_calloc_dbg(_Count, sizeof(wchar_t), _CRT_BLOCK, __FILE__, __LINE__));

    if (!_Ptrdest) {
        _Xbad_alloc();
    }

    _CSTD wmemcpy(_Ptrdest, _Ptr, _Count);
    return _Ptrdest;
}

_EXPORT_STD template <class _Elem>
class numpunct : public locale::facet { // facet for defining numeric punctuation text
private:
    friend _Tidy_guard<numpunct>;

public:
    static_assert(!_ENFORCE_FACET_SPECIALIZATIONS || _Is_any_of_v<_Elem, char, wchar_t>, _FACET_SPECIALIZATION_MESSAGE);

    using string_type = basic_string<_Elem, char_traits<_Elem>, allocator<_Elem>>;
    using char_type = _Elem;

    __PURE_APPDOMAIN_GLOBAL _CRTIMP2_PURE_IMPORT static locale::id id; // unique facet id

    _Elem decimal_point() const {
        return do_decimal_point();
    }

    _Elem thousands_sep() const {
        return do_thousands_sep();
    }

    string grouping() const {
        return do_grouping();
    }

    string_type falsename() const {
        return do_falsename();
    }

    string_type truename() const {
        return do_truename();
    }

    explicit numpunct(size_t _Refs = 0) : locale::facet(_Refs) { // construct from current locale
        _BEGIN_LOCINFO(_Lobj)
            _Init(_Lobj);
        if (_Kseparator == 0) {
            _Kseparator = // NB: differs from "C" locale
                _Maklocchr(',', static_cast<_Elem*>(nullptr), _Lobj._Getcvt());
        }
        _END_LOCINFO()
    }

    numpunct(const _Locinfo& _Lobj, size_t _Refs = 0, bool _Isdef = false) : locale::facet(_Refs) {
        _Init(_Lobj, _Isdef);
    }

    static size_t _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        // return locale category mask and construct standard facet
        if (_Ppf && !*_Ppf) {
            *_Ppf = new numpunct<_Elem>(_Locinfo(_Ploc->_C_str()), 0, true);
        }
        return _X_NUMERIC;
    }

protected:
    __CLR_OR_THIS_CALL ~numpunct() noexcept override {
        _Tidy();
    }

    numpunct(const char* _Locname, size_t _Refs = 0, bool _Isdef = false) : locale::facet(_Refs) {
        _BEGIN_LOCINFO(_Lobj(_Locname))
            _Init(_Lobj, _Isdef);
        _END_LOCINFO()
    }

    template <class _Elem2>
    void _Getvals(_Elem2, const lconv* _Ptr, _Locinfo::_Cvtvec _Cvt) { // get values
        _Dp = _Maklocchr(_Ptr->decimal_point[0], static_cast<_Elem2*>(nullptr), _Cvt);
        _Kseparator = _Maklocchr(_Ptr->thousands_sep[0], static_cast<_Elem2*>(nullptr), _Cvt);
    }

    void _Getvals(wchar_t, const lconv* _Ptr, _Locinfo::_Cvtvec) { // get values
        _Dp = static_cast<_Elem>(_Ptr->_W_decimal_point[0]);
        _Kseparator = static_cast<_Elem>(_Ptr->_W_thousands_sep[0]);
    }

    void _Init(const _Locinfo& _Lobj, bool _Isdef = false) { // initialize from _Lobj
        const lconv* _Ptr = _Lobj._Getlconv();
        _Locinfo::_Cvtvec _Cvt = _Lobj._Getcvt(); // conversion information

        _Grouping = nullptr;
        _Falsename = nullptr;
        _Truename = nullptr;

        _Tidy_guard<numpunct> _Guard{ this };
        _Grouping = _Maklocstr(_Isdef ? "" : _Ptr->grouping, static_cast<char*>(nullptr), _Lobj._Getcvt());
        _Falsename = _Maklocstr(_Lobj._Getfalse(), static_cast<_Elem*>(nullptr), _Cvt);
        _Truename = _Maklocstr(_Lobj._Gettrue(), static_cast<_Elem*>(nullptr), _Cvt);
        _Guard._Target = nullptr;

        if (_Isdef) { // apply defaults for required facets
            // _Grouping = _Maklocstr("", static_cast<char *>(nullptr), _Cvt);
            _Dp = _Maklocchr('.', static_cast<_Elem*>(nullptr), _Cvt);
            _Kseparator = _Maklocchr(',', static_cast<_Elem*>(nullptr), _Cvt);
        }
        else {
            _Getvals(_Elem{}, _Ptr, _Cvt);
        }
    }

    virtual _Elem __CLR_OR_THIS_CALL do_decimal_point() const {
        return _Dp;
    }

    virtual _Elem __CLR_OR_THIS_CALL do_thousands_sep() const {
        return _Kseparator;
    }

    virtual string __CLR_OR_THIS_CALL do_grouping() const {
        return string{ _Grouping };
    }

    virtual string_type __CLR_OR_THIS_CALL do_falsename() const {
        return string_type{ _Falsename };
    }

    virtual string_type __CLR_OR_THIS_CALL do_truename() const {
        return string_type{ _Truename };
    }

private:
    void _Tidy() noexcept { // free all storage
        _CSTD free(const_cast<char*>(_Grouping));
        _CSTD free(const_cast<_Elem*>(_Falsename));
        _CSTD free(const_cast<_Elem*>(_Truename));
    }

    const char* _Grouping; // grouping string, "" for "C" locale
    _Elem _Dp; // decimal point, '.' for "C" locale
    _Elem _Kseparator; // thousands separator, '\0' for "C" locale
    const _Elem* _Falsename; // name for false, "false" for "C" locale
    const _Elem* _Truename; // name for true, "true" for "C" locale
};

_EXPORT_STD template <class _Elem>
class numpunct_byname : public numpunct<_Elem> { // numpunct for named locale
public:
    static_assert(!_ENFORCE_FACET_SPECIALIZATIONS || _Is_any_of_v<_Elem, char, wchar_t>, _FACET_SPECIALIZATION_MESSAGE);

    explicit numpunct_byname(const char* _Locname, size_t _Refs = 0)
        : numpunct<_Elem>(_Locname, _Refs) {} // construct for named locale

    explicit numpunct_byname(const string& _Str, size_t _Refs = 0)
        : numpunct<_Elem>(_Str.c_str(), _Refs) {} // construct for named locale

protected:
    __CLR_OR_THIS_CALL ~numpunct_byname() noexcept override {}
};

#if !defined(_CRTBLD) || defined(CRTDLL2) || !defined(_DLL) || defined(_M_CEE_PURE) // TRANSITION, VSO-578955
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdllimport-static-field-def"
#endif // defined(__clang__)

template <class _Elem>
__PURE_APPDOMAIN_GLOBAL locale::id numpunct<_Elem>::id;

#ifdef __clang__
#pragma clang diagnostic pop
#endif // defined(__clang__)
#endif // !defined(_CRTBLD) || defined(CRTDLL2) || !defined(_DLL) || defined(_M_CEE_PURE)

struct _Num_get_parse_result {
    // For integers: negative values mean parsing failure, while the "actual" base (used by _Getifld) is ~_Base.
    // Otherwise, 0, 8, 10, or 16.
    // For floating-point numbers: 0 for parsing failure, otherwise 10 or 16.
    int8_t _Base;
    bool _Bad_grouping;
};

_EXPORT_STD extern "C++" template <class _Elem, class _InIt = istreambuf_iterator<_Elem, char_traits<_Elem>>>
class num_get : public locale::facet { // facet for converting text to encoded numbers
public:
    static_assert(!_ENFORCE_FACET_SPECIALIZATIONS || _Is_any_of_v<_Elem, char, wchar_t>, _FACET_SPECIALIZATION_MESSAGE);

    static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        // return locale category mask and construct standard facet
        if (_Ppf && !*_Ppf) {
            *_Ppf = new num_get<_Elem, _InIt>(_Locinfo(_Ploc->_C_str()));
        }

        return _X_NUMERIC;
    }

    __PURE_APPDOMAIN_GLOBAL static locale::id id; // unique facet id

protected:
    __CLR_OR_THIS_CALL ~num_get() noexcept override {}

    void _Init(const _Locinfo&) {} // initialize from _Locinfo object

public:
    explicit __CLR_OR_THIS_CALL num_get(size_t _Refs = 0) : locale::facet(_Refs) { // construct from current locale
        _BEGIN_LOCINFO(_Lobj)
            _Init(_Lobj);
        _END_LOCINFO()
    }

    __CLR_OR_THIS_CALL num_get(const _Locinfo& _Lobj, size_t _Refs = 0) : locale::facet(_Refs) {
        _Init(_Lobj);
    }

    using char_type = _Elem;
    using iter_type = _InIt;

    _InIt __CLR_OR_THIS_CALL get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        bool& _Val) const { // get bool from [_First, _Last) into _Val
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }

    _InIt __CLR_OR_THIS_CALL get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        unsigned short& _Val) const { // get unsigned short from [_First, _Last) into _Val
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }

    _InIt __CLR_OR_THIS_CALL get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        unsigned int& _Val) const { // get unsigned int from [_First, _Last) into _Val
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }

    _InIt __CLR_OR_THIS_CALL get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        long& _Val) const { // get long from [_First, _Last) into _Val
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }

    _InIt __CLR_OR_THIS_CALL get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        unsigned long& _Val) const { // get unsigned long from [_First, _Last) into _Val
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }

    _InIt __CLR_OR_THIS_CALL get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        long long& _Val) const { // get long long from [_First, _Last) into _Val
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }

    _InIt __CLR_OR_THIS_CALL get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        unsigned long long& _Val) const { // get unsigned long long from [_First, _Last) into _Val
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }

    _InIt __CLR_OR_THIS_CALL get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        float& _Val) const { // get float from [_First, _Last) into _Val
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }

    _InIt __CLR_OR_THIS_CALL get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        double& _Val) const { // get double from [_First, _Last) into _Val
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }

    _InIt __CLR_OR_THIS_CALL get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        long double& _Val) const { // get long double from [_First, _Last) into _Val
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }

    _InIt __CLR_OR_THIS_CALL get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        void*& _Val) const { // get void pointer from [_First, _Last) into _Val
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }

protected:
    virtual _InIt __CLR_OR_THIS_CALL do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        bool& _Val) const { // get bool from [_First, _Last) into _Val
        _Adl_verify_range(_First, _Last);
        if (_Iosbase.flags() & ios_base::boolalpha) { // get false name or true name
            const auto& _Punct_fac = _STD use_facet<numpunct<_Elem>>(_Iosbase.getloc());
            basic_string<_Elem> _Str(static_cast<size_t>(1), _Elem{});
            _Str += _Punct_fac.falsename();
            _Str.push_back(_Elem{});
            _Str += _Punct_fac.truename(); // construct "\0false\0true"
            switch (_Getloctxt(_First, _Last, 2, _Str.c_str(), _Case_sensitive::_Yes)) {
            case 0:
                _Val = false;
                break;
            case 1:
                _Val = true;
                break;
            default:
                _Val = false;
                _State = ios_base::failbit;
                break;
            }
        }
        else { // get long value
            char _Ac[_Max_int_dig];
            const auto _Parse_result =
                _Parse_int_with_locale(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()); // gather field
            if (_Parse_result._Base < 0) {
                // N4950 [facet.num.get.virtuals]/3.9:
                //  "zero, if the conversion function does not convert the entire field."
                _Val = false;
                _State = ios_base::failbit;
            }
            else {
                char* _Ep;
                int _Errno;
                const long _Ans = _CSTD _Stolx(_Ac, &_Ep, _Parse_result._Base, &_Errno); // convert
                if (_Ep == _Ac || _Errno != 0 // N4950 [facet.num.get.virtuals]/3
                    || _Parse_result._Bad_grouping) { // N4950 [facet.num.get.virtuals]/4
                    _Val = true;
                    _State = ios_base::failbit;
                }
                else {
                    _Val = _Ans != 0;
                    if (_Ans != 0 && _Ans != 1) {
                        _State = ios_base::failbit;
                    }
                }
            }
        }

        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }

        return _First;
    }

    virtual _InIt __CLR_OR_THIS_CALL do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        unsigned short& _Val) const { // get unsigned short from [_First, _Last) into _Val
        _Adl_verify_range(_First, _Last);
        char _Ac[_Max_int_dig];
        const auto _Parse_result =
            _Parse_int_with_locale(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()); // gather field
        if (_Parse_result._Base < 0) { // ditto "fails to convert the entire field"
            _State = ios_base::failbit;
            _Val = 0;
        }
        else {
            const bool _Minus = _Ac[0] == '-';
            const char* _Digits = _Ac;
            // C11 7.22.1.4/5: the sequence of characters starting with the first digit
            // is interpreted as an integer constant according to the rules of 6.4.4.1
            if (_Minus) { // skip over minus to start with the first digit
                ++_Digits;
            }

            char* _Ep;
            int _Errno;
            const unsigned long _Tmp = _CSTD _Stoulx(_Digits, &_Ep, _Parse_result._Base, &_Errno); // convert
            _Val = static_cast<unsigned short>(_Tmp);
            if (_Ep == _Digits || _Errno != 0 || _Tmp > USHRT_MAX) { // N4950 [facet.num.get.virtuals]/3
                _State = ios_base::failbit;
                _Val = USHRT_MAX;
            }
            else if (_Minus) { // C11 7.22.1.4/5:  If the subject sequence begins with a minus sign,
                // the value resulting from the conversion is negated (in the return type).
                _Val = static_cast<unsigned short>(0 - _Val);
            }

            if (_Parse_result._Bad_grouping) { // N4950 [facet.num.get.virtuals]/4
                _State = ios_base::failbit;
            }
        }

        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }

        return _First;
    }

    virtual _InIt __CLR_OR_THIS_CALL do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        unsigned int& _Val) const { // get unsigned int from [_First, _Last) into _Val
        static_assert(sizeof(unsigned int) == sizeof(unsigned long),
            "Bad overflow assumptions due to sizeof(unsigned int) != sizeof(unsigned long)");
        unsigned long _Tmp;
        _First = num_get::do_get(_First, _Last, _Iosbase, _State, _Tmp); // avoid virtual call for perf
        _Val = _Tmp;
        return _First;
    }

    virtual _InIt __CLR_OR_THIS_CALL do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        long& _Val) const { // get long from [_First, _Last) into _Val
        _Adl_verify_range(_First, _Last);
        char _Ac[_Max_int_dig];
        const auto _Parse_result =
            _Parse_int_with_locale(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()); // gather field
        if (_Parse_result._Base < 0) { // ditto "fails to convert the entire field"
            _State = ios_base::failbit;
            _Val = 0;
        }
        else {
            char* _Ep;
            int _Errno;
            _Val = _CSTD _Stolx(_Ac, &_Ep, _Parse_result._Base, &_Errno); // convert
            if (_Ep == _Ac || _Errno != 0 // N4950 [facet.num.get.virtuals]/3
                || _Parse_result._Bad_grouping) { // N4950 [facet.num.get.virtuals]/4
                _State = ios_base::failbit;
            }
        }

        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }

        return _First;
    }

    virtual _InIt __CLR_OR_THIS_CALL do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        unsigned long& _Val) const { // get unsigned long from [_First, _Last) into _Val
        _Adl_verify_range(_First, _Last);
        char _Ac[_Max_int_dig];
        const auto _Parse_result =
            _Parse_int_with_locale(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()); // gather field
        if (_Parse_result._Base < 0) { // ditto "fails to convert the entire field"
            _State = ios_base::failbit;
            _Val = 0;
        }
        else {
            char* _Ep;
            int _Errno;
            _Val = _CSTD _Stoulx(_Ac, &_Ep, _Parse_result._Base, &_Errno); // convert
            if (_Ep == _Ac || _Errno != 0 // N4950 [facet.num.get.virtuals]/3
                || _Parse_result._Bad_grouping) { // N4950 [facet.num.get.virtuals]/4
                _State = ios_base::failbit;
            }
        }

        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }

        return _First;
    }

    virtual _InIt __CLR_OR_THIS_CALL do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        long long& _Val) const { // get long long from [_First, _Last) into _Val
        _Adl_verify_range(_First, _Last);
        char _Ac[_Max_int_dig];
        const auto _Parse_result =
            _Parse_int_with_locale(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()); // gather field
        if (_Parse_result._Base < 0) { // ditto "fails to convert the entire field"
            _State = ios_base::failbit;
            _Val = 0;
        }
        else {
            char* _Ep;
            int _Errno;
            _Val = _CSTD _Stollx(_Ac, &_Ep, _Parse_result._Base, &_Errno); // convert
            if (_Ep == _Ac || _Errno != 0 // N4950 [facet.num.get.virtuals]/3
                || _Parse_result._Bad_grouping) { // N4950 [facet.num.get.virtuals]/4
                _State = ios_base::failbit;
            }
        }

        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }

        return _First;
    }

    virtual _InIt __CLR_OR_THIS_CALL do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        unsigned long long& _Val) const { // get unsigned long long from [_First, _Last) into _Val
        _Adl_verify_range(_First, _Last);
        char _Ac[_Max_int_dig];
        const auto _Parse_result =
            _Parse_int_with_locale(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()); // gather field
        if (_Parse_result._Base < 0) { // ditto "fails to convert the entire field"
            _State = ios_base::failbit;
            _Val = 0;
        }
        else {
            int _Errno;
            char* _Ep;
            _Val = _CSTD _Stoullx(_Ac, &_Ep, _Parse_result._Base, &_Errno); // convert
            if (_Ep == _Ac || _Errno != 0 // N4950 [facet.num.get.virtuals]/3
                || _Parse_result._Bad_grouping) { // N4950 [facet.num.get.virtuals]/4
                _State = ios_base::failbit;
            }
        }

        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }

        return _First;
    }

#define _MAX_SIG_DIG_V2 768
#define _MAX_EXP_DIG    8 // for parsing floating-point numbers
    // Size of char buffer used by num_get::do_get() for float/double/long double
#define _FLOATING_BUFFER_SIZE (_MAX_EXP_DIG + _MAX_SIG_DIG_V2 + 16)

    virtual _InIt __CLR_OR_THIS_CALL do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        float& _Val) const { // get float from [_First, _Last) into _Val
        _Adl_verify_range(_First, _Last);
        char _Ac[_FLOATING_BUFFER_SIZE];
        const auto _Parse_result =
            _Parse_fp_with_locale(_Ac, _MAX_SIG_DIG_V2, _First, _Last, _Iosbase.getloc()); // gather field
        if (_Parse_result._Base == 0) { // ditto "fails to convert the entire field"
            _State = ios_base::failbit;
            _Val = 0.0f;
        }
        else {
            int _Errno;
            char* _Ep;
            _Val = _STD _Stofx_v3(_Ac, &_Ep, &_Errno); // convert
            if (_Ep == _Ac || _Errno != 0 // N4950 [facet.num.get.virtuals]/3
                || _Parse_result._Bad_grouping) { // N4950 [facet.num.get.virtuals]/4
                _State = ios_base::failbit;
            }
        }

        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }

        return _First;
    }

    virtual _InIt __CLR_OR_THIS_CALL do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        double& _Val) const { // get double from [_First, _Last) into _Val
        _Adl_verify_range(_First, _Last);
        char _Ac[_FLOATING_BUFFER_SIZE];
        const auto _Parse_result =
            _Parse_fp_with_locale(_Ac, _MAX_SIG_DIG_V2, _First, _Last, _Iosbase.getloc()); // gather field
        if (_Parse_result._Base == 0) { // ditto "fails to convert the entire field"
            _State = ios_base::failbit;
            _Val = 0.0;
        }
        else {
            int _Errno;
            char* _Ep;
            _Val = _STD _Stodx_v3(_Ac, &_Ep, &_Errno); // convert
            if (_Ep == _Ac || _Errno != 0 // N4950 [facet.num.get.virtuals]/3
                || _Parse_result._Bad_grouping) { // N4950 [facet.num.get.virtuals]/4
                _State = ios_base::failbit;
            }
        }

        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }

        return _First;
    }
#undef _FLOATING_BUFFER_SIZE
#undef _MAX_EXP_DIG

    virtual _InIt __CLR_OR_THIS_CALL do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        long double& _Val) const { // get long double from [_First, _Last) into _Val
        // Assumes sizeof(double) == sizeof(long double).
        // For 80-bit long double (which is not supported by MSVC in general), this will compile
        // but will not attempt to handle the increased precision at runtime.
        double _Result;
        _First = num_get::do_get(_First, _Last, _Iosbase, _State, _Result); // avoid virtual call for perf
        _Val = _Result;
        return _First;
    }

    virtual _InIt __CLR_OR_THIS_CALL do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        void*& _Val) const { // get void pointer from [_First, _Last) into _Val
        _Adl_verify_range(_First, _Last);
        char _Ac[_Max_int_dig];
        const auto _Parse_result =
            _Parse_int_with_locale(_Ac, _First, _Last, ios_base::hex, _Iosbase.getloc()); // gather field
        if (_Parse_result._Base < 0) { // ditto "fails to convert the entire field"
            _State = ios_base::failbit;
            _Val = nullptr;
        }
        else {
            int _Errno;
            char* _Ep;
#ifdef _WIN64
            _Val = reinterpret_cast<void*>(_CSTD _Stoullx(_Ac, &_Ep, _Parse_result._Base, &_Errno));
#else // ^^^ defined(_WIN64) / !defined(_WIN64) vvv
            _Val = reinterpret_cast<void*>(_CSTD _Stoulx(_Ac, &_Ep, _Parse_result._Base, &_Errno));
#endif // ^^^ !defined(_WIN64) ^^^
            if (_Ep == _Ac || _Errno != 0) { // N4950 [facet.num.get.virtuals]/3
                _State = ios_base::failbit;
                _Val = nullptr;
            }

            if (_Parse_result._Bad_grouping) { // N4950 [facet.num.get.virtuals]/4
                _State = ios_base::failbit;
            }
        }

        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }

        return _First;
    }

private:
    template <int = 0> // TRANSITION, ABI
    static _Num_get_parse_result _Parse_int_with_locale(
        char* const _Ac, _InIt& _First, _InIt& _Last, ios_base::fmtflags _Basefield, const locale& _Loc) {
        // get integer field from [_First, _Last) into _Ac
        const auto& _Punct_fac = _STD use_facet<numpunct<_Elem>>(_Loc);
        const string _Grouping = _Punct_fac.grouping();
        const _Elem _Kseparator = _Grouping.empty() ? _Elem{} : _Punct_fac.thousands_sep();

        constexpr int _Numget_signoff = 22;
        constexpr int _Numget_xoff = 24;
        static constexpr char _Src[] = "0123456789ABCDEFabcdef-+Xx";
        _Elem _Atoms[sizeof(_Src)];
        const ctype<_Elem>& _Ctype_fac = _STD use_facet<ctype<_Elem>>(_Loc);
        _Ctype_fac.widen(_STD begin(_Src), _STD end(_Src), _Atoms);

        bool _Bad_grouping = false;

        // skip leading separators before the sign
        if (_Kseparator != _Elem{}) {
            while (_First != _Last && *_First == _Kseparator) {
                ++_First;
                _Bad_grouping = true;
            }
        }

        char* _Ptr = _Ac;

        if (_First != _Last) {
            if (*_First == _Atoms[_Numget_signoff + 1]) { // gather plus sign
                *_Ptr++ = '+';
                ++_First;
            }
            else if (*_First == _Atoms[_Numget_signoff]) { // gather minus sign
                *_Ptr++ = '-';
                ++_First;
            }
        }

        // skip leading separators before digits
        if (_Kseparator != _Elem{}) {
            while (_First != _Last && *_First == _Kseparator) {
                ++_First;
                _Bad_grouping = true;
            }
        }

        _Basefield &= ios_base::basefield;

        int8_t _Base;
        if (_Basefield == ios_base::oct) {
            _Base = 8;
        }
        else if (_Basefield == ios_base::hex) {
            _Base = 16;
        }
        else if (_Basefield == ios_base::_Fmtzero) {
            _Base = 0;
        }
        else {
            _Base = 10;
        }

        bool _Seendigit = false; // seen a digit in input
        bool _Nonzero = false; // seen a nonzero digit in input

        if (_First != _Last && *_First == _Atoms[0]) { // leading zero, look for 0x, 0X
            _Seendigit = true;
            ++_First;
            if (_First != _Last && (*_First == _Atoms[_Numget_xoff + 1] || *_First == _Atoms[_Numget_xoff])
                && (_Base == 0 || _Base == 16)) {
                _Base = 16;
                _Seendigit = false;
                ++_First;
            }
            else if (_Base == 0) {
                _Base = 8;
            }
        }

        const auto _Dlen = static_cast<size_t>(_Base == 0 || _Base == 10 ? 10 : _Base == 8 ? 8 : 16 + 6);
        string _Groups(1, static_cast<char>(_Seendigit)); // Groups are detected in the reversed order of _Groups.
        size_t _Groups_arr_idx = 0;

        for (char* const _Pe = &_Ac[_Max_int_dig - 1]; _First != _Last; ++_First) { // look for digits and separators
            size_t _Idx = _STD _Find_elem(_Atoms, *_First);
            if (_Idx < _Dlen) { // got a digit, characterize it and add to group size
                *_Ptr = _Src[_Idx];
                if ((_Nonzero || *_Ptr != '0') && _Ptr < _Pe) {
                    ++_Ptr;
                    _Nonzero = true;
                }

                _Seendigit = true;
                if (_Groups[_Groups_arr_idx] != CHAR_MAX) {
                    ++_Groups[_Groups_arr_idx];
                }
            }
            else if (_Kseparator == _Elem{} || *_First != _Kseparator) {
                break; // not a group separator, done
            }
            else if (_Groups[_Groups_arr_idx] == '\0') {
                _Bad_grouping = true; // adjacent separators, fail
            }
            else { // add a new group to _Groups string
                _Groups.push_back('\0');
                ++_Groups_arr_idx;
            }
        }

        if (_Groups_arr_idx != 0) {
            if (_Groups[_Groups_arr_idx] > '\0') {
                ++_Groups_arr_idx; // add trailing group to group count
            }
            else {
                _Bad_grouping = true; // trailing separator, fail
            }
        }

        // skip trailing separators
        if (_Kseparator != _Elem{}) {
            while (_First != _Last && *_First == _Kseparator) {
                ++_First;
                _Bad_grouping = true;
            }
        }

        const char* _Grouping_iter = _Grouping.data();
        const char* const _Grouping_end = _Grouping_iter + _Grouping.size();
        for (char _Current_grouping_count = '\0'; _Seendigit && !_Bad_grouping && _Groups_arr_idx > 0;) {
            if (_Grouping_iter != _Grouping_end) { // keep the last value when _Grouping is exhausted
                _Current_grouping_count = *_Grouping_iter; // if _Grouping is empty, '\0' is used
                ++_Grouping_iter;
            }

            --_Groups_arr_idx;
            if ((_Current_grouping_count > '\0' && _Current_grouping_count != CHAR_MAX)
                && ((_Groups_arr_idx > 0 && _Groups[_Groups_arr_idx] != _Current_grouping_count)
                    || (_Groups_arr_idx == 0 && _Groups[_Groups_arr_idx] > _Current_grouping_count))) {
                _Bad_grouping = true; // bad group size, fail
            }
            // group size okay, advance to next test
        }

        if (!_Seendigit) {
            return { static_cast<int8_t>(~_Base), false };
        }

        if (!_Nonzero) {
            *_Ptr++ = '0'; // zero field, replace stripped zero(s)
        }

        *_Ptr = '\0';
        return { _Base, _Bad_grouping };
    }

    template <int = 0> // TRANSITION, ABI
    static _Num_get_parse_result _Parse_fp_with_locale(
        char* const _Ac, const int _Max_sig_dig, _InIt& _First, _InIt& _Last, const locale& _Loc) {
        // get floating-point field from [_First, _Last) into _Ac
        char* _Ptr = _Ac;

        constexpr size_t _Offset_dec_digit_end = 10;
        constexpr size_t _Offset_hex_digit_end = 22;
        constexpr size_t _Offset_neg_sign = 22;
        constexpr size_t _Offset_pos_sign = 23;
        constexpr size_t _Offset_upper_x = 24;
        constexpr size_t _Offset_lower_x = 25;
        constexpr size_t _Offset_upper_p = 26;
        constexpr size_t _Offset_lower_p = 27;
        constexpr size_t _Offset_upper_e = 14;
        constexpr size_t _Offset_lower_e = 20;
        static constexpr char _Src[] = "0123456789ABCDEFabcdef-+XxPp";
        _Elem _Atoms[sizeof(_Src)];
        const auto& _Ctype_fac = _STD use_facet<ctype<_Elem>>(_Loc);
        _Ctype_fac.widen(_STD begin(_Src), _STD end(_Src), _Atoms);

        const _Elem _Positive_sign = _Atoms[_Offset_pos_sign];
        const _Elem _Negative_sign = _Atoms[_Offset_neg_sign];
        const _Elem _Zero_wc = _Atoms[0];

        const auto& _Punct_fac = _STD use_facet<numpunct<_Elem>>(_Loc);
        const string _Grouping = _Punct_fac.grouping();
        const _Elem _Kseparator = _Grouping.empty() ? _Elem{} : _Punct_fac.thousands_sep();

        bool _Bad_grouping = false;

        // skip leading separators before the sign
        if (!_Grouping.empty()) {
            while (_First != _Last && *_First == _Kseparator) {
                ++_First;
                _Bad_grouping = true;
            }
        }

        if (_First != _Last) {
            if (*_First == _Positive_sign) { // gather plus sign
                *_Ptr++ = '+';
                ++_First;
            }
            else if (*_First == _Negative_sign) { // gather minus sign
                *_Ptr++ = '-';
                ++_First;
            }
        }

        *_Ptr++ = '0'; // backstop carries from sticky bit

        bool _Parse_hex = false;
        bool _Seendigit = false; // seen a digit in input
        char _Initial_dec_leading_zero = '\0';
        if (_First != _Last && *_First == _Zero_wc) {
            ++_First;
            if (_First == _Last) { // "0" only
                *_Ptr = '\0';
                return { 10, _Bad_grouping };
            }

            if (*_First == _Atoms[_Offset_lower_x] || *_First == _Atoms[_Offset_upper_x]) { // 0x or 0X
                _Parse_hex = true;
                ++_First; // discard 0x or 0X for further parsing
                *_Ptr++ = 'x';
            }
            else {
                _Seendigit = true;
                ++_Initial_dec_leading_zero;
            }
        }

        bool _Has_unaccumulated_digits = false;
        int _Significant = 0; // number of significant digits
        ptrdiff_t _Power_of_rep_base = 0; // power of 10 or 16

        const size_t _Offset_digit_end = _Parse_hex ? _Offset_hex_digit_end : _Offset_dec_digit_end;
        if (_Grouping.empty()) {
            for (size_t _Idx; _First != _Last && (_Idx = _STD _Find_elem(_Atoms, *_First)) < _Offset_digit_end;
                _Seendigit = true, (void) ++_First) {
                if (_Significant >= _Max_sig_dig) {
                    ++_Power_of_rep_base; // just scale by 10 or 16
                    if (_Idx > 0) {
                        _Has_unaccumulated_digits = true;
                    }
                }
                else if (_Idx != 0 || _Significant != 0) { // save a significant digit
                    *_Ptr++ = _Src[_Idx];
                    ++_Significant;
                }
            }
        }
        else {
            // skip leading separators before digits
            while (_First != _Last && *_First == _Kseparator) {
                ++_First;
                _Bad_grouping = true;
            }

            string _Groups(1, _Initial_dec_leading_zero); // Groups are detected in the reversed order of _Groups.
            size_t _Groups_arr_idx = 0;

            for (; _First != _Last; ++_First) {
                const size_t _Idx = _STD _Find_elem(_Atoms, *_First);
                if (_Idx < _Offset_digit_end) { // got a digit, add to group size
                    _Seendigit = true;
                    if (_Significant >= _Max_sig_dig) {
                        ++_Power_of_rep_base; // just scale by 10 or 16
                        if (_Idx > 0) {
                            _Has_unaccumulated_digits = true;
                        }
                    }
                    else if (_Idx != 0 || _Significant != 0) { // save a significant digit
                        *_Ptr++ = _Src[_Idx];
                        ++_Significant;
                    }

                    if (_Groups[_Groups_arr_idx] != CHAR_MAX) {
                        ++_Groups[_Groups_arr_idx];
                    }
                }
                else if (*_First != _Kseparator) {
                    break; // not a group separator, done
                }
                else if (_Groups[_Groups_arr_idx] == '\0') {
                    _Bad_grouping = true; // adjacent separators, fail
                }
                else { // add a new group to _Groups string
                    _Groups.push_back('\0');
                    ++_Groups_arr_idx;
                }
            }

            if (_Groups_arr_idx != 0) {
                if (_Groups[_Groups_arr_idx] > '\0') {
                    ++_Groups_arr_idx; // add trailing group to group count
                }
                else {
                    _Bad_grouping = true; // trailing separator, fail
                }
            }

            // skip trailing separators
            while (_First != _Last && *_First == _Kseparator) {
                ++_First;
                _Bad_grouping = true;
            }

            const char* _Grouping_iter = _Grouping.data();
            const char* const _Grouping_end = _Grouping_iter + _Grouping.size();
            char _Current_grouping_count = '\0';
            while (!_Bad_grouping && _Groups_arr_idx > 0) {
                if (_Grouping_iter != _Grouping_end) { // keep the last value when _Grouping is exhausted
                    _Current_grouping_count = *_Grouping_iter; // assign the variable at least once
                    ++_Grouping_iter;
                }

                --_Groups_arr_idx;
                if ((_Current_grouping_count > '\0' && _Current_grouping_count != CHAR_MAX)
                    && ((_Groups_arr_idx > 0 && _Groups[_Groups_arr_idx] != _Current_grouping_count)
                        || (_Groups_arr_idx == 0 && _Groups[_Groups_arr_idx] > _Current_grouping_count))) {
                    _Bad_grouping = true; // bad group size, fail
                }
                // group size okay, advance to next test
            }
        }

        if (_Parse_hex && _Seendigit && _Significant == 0) {
            // the condition is true when all of the digits after the 'x' and before the decimal point are zero
            *_Ptr++ = '0'; // save at least one leading digit for hex
        }

        const char _Decimal_point = _CSTD localeconv()->decimal_point[0];
        if (_First != _Last && *_First == _Punct_fac.decimal_point()) { // add .
            *_Ptr++ = _Decimal_point;
            ++_First;
        }

        if (_Significant == 0) { // 0000. so far
            for (; _First != _Last && *_First == _Zero_wc; _Seendigit = true, (void) ++_First) {
                --_Power_of_rep_base; // count leading fraction zeros without storing digits into buffer
            }
        }

        for (size_t _Idx; _First != _Last && (_Idx = _STD _Find_elem(_Atoms, *_First)) < _Offset_digit_end;
            _Seendigit = true, (void) ++_First) {
            if (_Significant < _Max_sig_dig) { // save a significant fraction digit
                *_Ptr++ = _Src[_Idx];
                ++_Significant;
            }
            else if (_Idx > 0) {
                _Has_unaccumulated_digits = true; // just update _Has_unaccumulated_digits
            }
        }

        if (_Has_unaccumulated_digits) { // increment last digit in memory of those lost
            char& _Last_got_digit = _Ptr[-1] == _Decimal_point ? _Ptr[-2] : _Ptr[-1];
            if (_Last_got_digit == '0' || _Last_got_digit == (_Parse_hex ? '8' : '5')) {
                ++_Last_got_digit;
            }
        }

        const _Elem _Lower_exp_wc = _Atoms[_Parse_hex ? _Offset_lower_p : _Offset_lower_e]; // 'e' for dec, 'p' for hex
        const _Elem _Upper_exp_wc = _Atoms[_Parse_hex ? _Offset_upper_p : _Offset_upper_e]; // 'E' for dec, 'P' for hex

        bool _Exponent_part_negative = false;
        ptrdiff_t _Exponent_part = 0;
        if (_Seendigit && _First != _Last
            && (*_First == _Lower_exp_wc || *_First == _Upper_exp_wc)) { // collect exponent
            ++_First;
            _Seendigit = false;
            _Significant = 0;

            if (_First != _Last) {
                if (*_First == _Positive_sign) { // gather plus sign
                    ++_First;
                }
                else if (*_First == _Negative_sign) { // gather minus sign
                    _Exponent_part_negative = true;
                    ++_First;
                }
            }

            for (; _First != _Last && *_First == _Zero_wc; ++_First) { // strip leading zeros
                _Seendigit = true;
            }

            for (size_t _Idx; _First != _Last && (_Idx = _STD _Find_elem(_Atoms, *_First)) < _Offset_dec_digit_end;
                _Seendigit = true, (void) ++_First) {
                if (_Exponent_part < PTRDIFF_MAX / 10
                    || (_Exponent_part == PTRDIFF_MAX / 10
                        && static_cast<ptrdiff_t>(_Idx) <= PTRDIFF_MAX % 10)) { // save a significant exponent digit
                    _Exponent_part = _Exponent_part * 10 + static_cast<ptrdiff_t>(_Idx);
                }
                else {
                    _Exponent_part = PTRDIFF_MAX; // saturated
                }
            }

            if (_Exponent_part_negative) {
                _Exponent_part = -_Exponent_part;
            }
        }

        if (!_Seendigit) {
            return { 0, false };
        }

        constexpr int _Dec_exp_abs_bound = 1100; // slightly greater than 324 + 768
        constexpr int _Hex_exp_abs_bound = 4200; // slightly greater than 1074 + 768 * 4

        const ptrdiff_t _Exp_abs_bound = _Parse_hex ? _Hex_exp_abs_bound : _Dec_exp_abs_bound;
        const ptrdiff_t _Exp_rep_abs_bound = _Parse_hex ? _Hex_exp_abs_bound / 4 : _Dec_exp_abs_bound;

        // basically _Exponent_part = _STD clamp(-_Exp_abs_bound,
        //     _Exponent_part + _Parse_hex ? _Power_of_rep_base * 4 : _Power_of_rep_base, _Exp_abs_bound)
        // but need to defend overflowing
        for (ptrdiff_t _Power_of_rep_adjusted = _Power_of_rep_base;;) {
            if (_Exponent_part >= 0 && _Power_of_rep_adjusted >= 0
                && (_Exponent_part >= _Exp_abs_bound || _Power_of_rep_adjusted >= _Exp_rep_abs_bound)) {
                _Exponent_part = _Exp_abs_bound;
                break;
            }
            else if (_Exponent_part <= 0 && _Power_of_rep_adjusted <= 0
                && (_Exponent_part <= -_Exp_abs_bound || _Power_of_rep_adjusted <= -_Exp_rep_abs_bound)) {
                _Exponent_part = -_Exp_abs_bound;
                break;
            }
            else if (_STD abs(_Exponent_part) <= _Exp_abs_bound
                && _STD abs(_Power_of_rep_adjusted) <= _Exp_rep_abs_bound) {
                // _Exponent_part and _Power_of_rep_base are of different signedness, both of which are small enough
                _Exponent_part += _Parse_hex ? _Power_of_rep_adjusted * 4 : _Power_of_rep_adjusted;
                if (_Exponent_part > _Exp_abs_bound) {
                    _Exponent_part = _Exp_abs_bound;
                }
                else if (_Exponent_part < -_Exp_abs_bound) {
                    _Exponent_part = -_Exp_abs_bound;
                }
                break;
            }
            else {
                // only enters once:
                // _Exponent_part and _Power_of_rep_base are of different signedness, but at least one is large
                const ptrdiff_t _Exponent_part_preadjustment_round_up =
                    _Parse_hex ? (_STD abs(_Exponent_part) - 1) / 4 + 1 : _STD abs(_Exponent_part);
                const ptrdiff_t _Exp_rep_adjustment =
                    (_STD min)(_Exponent_part_preadjustment_round_up, _STD abs(_Power_of_rep_base));

                if (_Exponent_part >= 0) {
                    _Exponent_part -= _Parse_hex ? _Exp_rep_adjustment * 4 : _Exp_rep_adjustment;
                    _Power_of_rep_adjusted += _Exp_rep_adjustment;
                }
                else {
                    _Exponent_part += _Parse_hex ? _Exp_rep_adjustment * 4 : _Exp_rep_adjustment;
                    _Power_of_rep_adjusted -= _Exp_rep_adjustment;
                }
            }
        }

        if (_Exponent_part != 0) {
            *_Ptr++ = _Parse_hex ? 'p' : 'e';
            if (_Exponent_part < 0) {
                *_Ptr++ = '-';
            }

            char* const _Rev_begin = _Ptr;
            for (ptrdiff_t _Exponent_part_abs = _STD abs(_Exponent_part); _Exponent_part_abs != 0;
                _Exponent_part_abs /= 10) {
                *_Ptr++ = static_cast<char>('0' + _Exponent_part_abs % 10);
            }
            _STD reverse(_Rev_begin, _Ptr);
        }

        *_Ptr = '\0';
        return { static_cast<int8_t>(_Parse_hex ? 16 : 10), _Bad_grouping };
    }

    // TRANSITION, ABI, unused now, tracked by VSO-591516.
    int __CLRCALL_OR_CDECL _Getifld(
        char* _Ac, _InIt& _First, _InIt& _Last, ios_base::fmtflags _Basefield, const locale& _Loc) const {
        // get integer field from [_First, _Last) into _Ac
        static constexpr char _Src[] = "0123456789ABCDEFabcdef-+Xx"; // TRANSITION, ABI, was implicitly dllexported
        const char* volatile _Ptr = _Src;
        (void)_Ptr;

        const auto _Parse_result = _Parse_int_with_locale(_Ac, _First, _Last, _Basefield, _Loc);
        if (_Parse_result._Base < 0 || _Parse_result._Bad_grouping) { // TRANSITION, ABI, old behavior
            *_Ac = '\0';
        }
        return _Parse_result._Base < 0 ? ~_Parse_result._Base : _Parse_result._Base;
    }

#define _MAX_SIG_DIG_V1 36 // TRANSITION, ABI
    // TRANSITION, ABI: Sentinel value used by num_get::do_get()
    // to enable correct "V2" behavior in _Getffld() and _Getffldx()
#define _ENABLE_V2_BEHAVIOR 1000000000

    // TRANSITION, ABI, unused now
    int __CLRCALL_OR_CDECL _Getffld(char* _Ac, _InIt& _First, _InIt& _Last, ios_base& _Iosbase, int* _Phexexp) const {
        // get floating-point field from [_First, _Last) into _Ac
        static constexpr char _Src[] = "0123456789-+Ee"; // TRANSITION, ABI, was implicitly dllexported
        const char* volatile _Ptr = &_Src[0];
        (void)_Ptr;
        const int _Max_sig_dig = (*_Phexexp == _ENABLE_V2_BEHAVIOR ? _MAX_SIG_DIG_V2 : _MAX_SIG_DIG_V1);
        const auto _Parse_result = _Parse_fp_with_locale(_Ac, _Max_sig_dig, _First, _Last, _Iosbase.getloc());
        if (_Parse_result._Base == 0 || _Parse_result._Bad_grouping) { // TRANSITION, ABI, old behavior
            *_Ac = '\0';
        }

        if (_Parse_result._Base == 16) {
            *_Phexexp = 0; // power of 16 multiplier, unnecessary now
        }
        return 0; // power of 10 multiplier, unnecessary now
    }

    // TRANSITION, ABI, unused now
    int __CLRCALL_OR_CDECL _Getffldx(char* _Ac, _InIt& _First, _InIt& _Last, ios_base& _Iosbase, int* _Phexexp) const {
        // get floating-point field from [_First, _Last) into _Ac
        static constexpr char _Src[] = "0123456789ABCDEFabcdef-+XxPp"; // TRANSITION, ABI, was implicitly dllexported
        const char* volatile _Ptr = &_Src[0];
        (void)_Ptr;
        const int _Max_sig_dig = (*_Phexexp == _ENABLE_V2_BEHAVIOR ? _MAX_SIG_DIG_V2 : _MAX_SIG_DIG_V1);
        const auto _Parse_result = _Parse_fp_with_locale(_Ac, _Max_sig_dig, _First, _Last, _Iosbase.getloc());
        if (_Parse_result._Base == 0 || _Parse_result._Bad_grouping) { // TRANSITION, ABI, old behavior
            *_Ac = '\0';
        }

        if (_Parse_result._Base == 16) {
            *_Phexexp = 0; // power of 16 multiplier, unnecessary now
        }
        return 0; // power of 10 multiplier, unnecessary now
    }

#undef _ENABLE_V2_BEHAVIOR
#undef _MAX_SIG_DIG_V1
#undef _MAX_SIG_DIG_V2
};

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdllimport-static-field-def"
#endif // defined(__clang__)

template <class _Elem, class _InIt>
__PURE_APPDOMAIN_GLOBAL locale::id num_get<_Elem, _InIt>::id;

#ifdef __clang__
#pragma clang diagnostic pop
#endif // defined(__clang__)

template <class _Ty>
int _Float_put_desired_precision(const streamsize _Precision, const ios_base::fmtflags _Float_flags) {
    // return the effective precision determined by N4950 [facet.num.put.virtuals]/2.1 and printf's rules
    const bool _Is_hex = _Float_flags == (ios_base::fixed | ios_base::scientific);
    if (_Is_hex) {
        // return the number of hexits needed (after the radix point) to represent the floating-point value exactly
        if constexpr (is_same_v<_Ty, double>) {
            return ((DBL_MANT_DIG - 1) + 3) / 4;
        }
        else if constexpr (is_same_v<_Ty, long double>) {
            return ((LDBL_MANT_DIG - 1) + 3) / 4;
        }
        else {
            static_assert(_Always_false<_Ty>, "Expected only double or long double here (not float).");
        }
    }

    if (_Precision > 0) {
        return static_cast<int>(_Precision);
    }
    else if (_Precision == 0) {
        const bool _Is_default_float = _Float_flags == 0;
        if (_Is_default_float) {
            return 1;
        }
        else {
            return 0;
        }
    }
    else {
        constexpr int _Default_precision = 6;
        return _Default_precision;
    }
}

_EXPORT_STD extern "C++" template <class _Elem, class _OutIt = ostreambuf_iterator<_Elem, char_traits<_Elem>>>
class num_put : public locale::facet { // facet for converting encoded numbers to text
public:
    static_assert(!_ENFORCE_FACET_SPECIALIZATIONS || _Is_any_of_v<_Elem, char, wchar_t>, _FACET_SPECIALIZATION_MESSAGE);

    static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        // return locale category mask and construct standard facet
        if (_Ppf && !*_Ppf) {
            *_Ppf = new num_put<_Elem, _OutIt>(_Locinfo(_Ploc->_C_str()));
        }

        return _X_NUMERIC;
    }

    __PURE_APPDOMAIN_GLOBAL static locale::id id; // unique facet id

protected:
    __CLR_OR_THIS_CALL ~num_put() noexcept override {}

    void __CLR_OR_THIS_CALL _Init(const _Locinfo&) {} // initialize from _Locinfo object

public:
    explicit __CLR_OR_THIS_CALL num_put(size_t _Refs = 0) : locale::facet(_Refs) { // construct from current locale
        _BEGIN_LOCINFO(_Lobj)
            _Init(_Lobj);
        _END_LOCINFO()
    }

    __CLR_OR_THIS_CALL num_put(const _Locinfo& _Lobj, size_t _Refs = 0) : locale::facet(_Refs) {
        _Init(_Lobj);
    }

    using char_type = _Elem;
    using iter_type = _OutIt;

    _OutIt __CLR_OR_THIS_CALL put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, bool _Val) const { // put formatted bool to _Dest
        return do_put(_Dest, _Iosbase, _Fill, _Val);
    }

    _OutIt __CLR_OR_THIS_CALL put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long _Val) const { // put formatted long to _Dest
        return do_put(_Dest, _Iosbase, _Fill, _Val);
    }

    _OutIt __CLR_OR_THIS_CALL put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill,
        unsigned long _Val) const { // put formatted unsigned long to _Dest
        return do_put(_Dest, _Iosbase, _Fill, _Val);
    }

    _OutIt __CLR_OR_THIS_CALL put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long long _Val) const { // put formatted long long to _Dest
        return do_put(_Dest, _Iosbase, _Fill, _Val);
    }

    _OutIt __CLR_OR_THIS_CALL put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill,
        unsigned long long _Val) const { // put formatted unsigned long long to _Dest
        return do_put(_Dest, _Iosbase, _Fill, _Val);
    }

    _OutIt __CLR_OR_THIS_CALL put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, double _Val) const { // put formatted double to _Dest
        return do_put(_Dest, _Iosbase, _Fill, _Val);
    }

    _OutIt __CLR_OR_THIS_CALL put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long double _Val) const { // put formatted long double to _Dest
        return do_put(_Dest, _Iosbase, _Fill, _Val);
    }

    _OutIt __CLR_OR_THIS_CALL put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, const void* _Val) const { // put formatted void pointer to _Dest
        return do_put(_Dest, _Iosbase, _Fill, _Val);
    }

protected:
    virtual _OutIt __CLR_OR_THIS_CALL do_put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, bool _Val) const { // put formatted bool to _Dest
        if (!(_Iosbase.flags() & ios_base::boolalpha)) {
            return do_put(_Dest, _Iosbase, _Fill, static_cast<long>(_Val));
        }
        else { // put "false" or "true"
            const auto& _Punct_fac = _STD use_facet<numpunct<_Elem>>(_Iosbase.getloc());
            basic_string<_Elem> _Str;
            if (_Val) {
                _Str.assign(_Punct_fac.truename());
            }
            else {
                _Str.assign(_Punct_fac.falsename());
            }

            size_t _Fillcount;
            if (_Iosbase.width() <= 0 || static_cast<size_t>(_Iosbase.width()) <= _Str.size()) {
                _Fillcount = 0;
            }
            else {
                _Fillcount = static_cast<size_t>(_Iosbase.width()) - _Str.size();
            }

            if ((_Iosbase.flags() & ios_base::adjustfield) != ios_base::left) { // put leading fill
                _Dest = _Rep(_Dest, _Fill, _Fillcount);
                _Fillcount = 0;
            }
            _Dest = _Put(_Dest, _Str.c_str(), _Str.size()); // put field
            _Iosbase.width(0);
            return _Rep(_Dest, _Fill, _Fillcount); // put trailing fill
        }
    }

#pragma warning(push)
#pragma warning(disable : 4774) // format string expected in argument N is not a string literal (/Wall)
    virtual _OutIt __CLR_OR_THIS_CALL do_put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long _Val) const { // put formatted long to _Dest
        char _Buf[2 * _Max_int_dig];
        char _Fmt[6];

        return _Iput(_Dest, _Iosbase, _Fill, _Buf,
            static_cast<size_t>(_CSTD sprintf_s(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "ld", _Iosbase.flags()), _Val)));
    }

    virtual _OutIt __CLR_OR_THIS_CALL do_put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill,
        unsigned long _Val) const { // put formatted unsigned long to _Dest
        char _Buf[2 * _Max_int_dig];
        char _Fmt[6];

        return _Iput(_Dest, _Iosbase, _Fill, _Buf,
            static_cast<size_t>(_CSTD sprintf_s(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "lu", _Iosbase.flags()), _Val)));
    }

    virtual _OutIt __CLR_OR_THIS_CALL do_put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long long _Val) const { // put formatted long long to _Dest
        char _Buf[2 * _Max_int_dig];
        char _Fmt[8];

        return _Iput(_Dest, _Iosbase, _Fill, _Buf,
            static_cast<size_t>(_CSTD sprintf_s(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "Ld", _Iosbase.flags()), _Val)));
    }

    virtual _OutIt __CLR_OR_THIS_CALL do_put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill,
        unsigned long long _Val) const { // put formatted unsigned long long to _Dest
        char _Buf[2 * _Max_int_dig];
        char _Fmt[8];

        return _Iput(_Dest, _Iosbase, _Fill, _Buf,
            static_cast<size_t>(_CSTD sprintf_s(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "Lu", _Iosbase.flags()), _Val)));
    }

    virtual _OutIt __CLR_OR_THIS_CALL do_put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, double _Val) const { // put formatted double to _Dest
        string _Buf;
        char _Fmt[8];
        const auto _Float_flags = _Iosbase.flags() & ios_base::floatfield;
        const bool _Is_fixed = _Float_flags == ios_base::fixed;
        const bool _Is_hex = _Float_flags == (ios_base::fixed | ios_base::scientific);
        const streamsize _Precision = _Is_hex ? -1 : _Iosbase.precision(); // precision setting
        const int _Desired_precision =
            _Float_put_desired_precision<double>(_Precision, _Float_flags); // desired precision
        size_t _Bufsize = static_cast<size_t>(_Desired_precision);
        if (_Is_fixed && 1e10 < _CSTD fabs(_Val)) { // f or F format
            int _Ptwo;
            (void)_CSTD frexp(_Val, &_Ptwo);
            _Bufsize += _CSTD abs(_Ptwo) * 30103L / 100000L;
        }

        _Buf.resize(_Bufsize + 50); // add fudge factor
        const bool _Is_finite = (_STD isfinite)(_Val);
        const auto _Adjusted_flags = // TRANSITION, DevCom-10519861
            _Is_finite ? _Iosbase.flags() : _Iosbase.flags() & ~ios_base::showpoint;
        const auto _Ngen = static_cast<size_t>(_CSTD sprintf_s(
            &_Buf[0], _Buf.size(), _Ffmt(_Fmt, 0, _Adjusted_flags), static_cast<int>(_Precision), _Val));

        return _Fput_v3(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen, _Is_finite);
    }

    virtual _OutIt __CLR_OR_THIS_CALL do_put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long double _Val) const { // put formatted long double to _Dest
        string _Buf;
        char _Fmt[8];
        const auto _Float_flags = _Iosbase.flags() & ios_base::floatfield;
        const bool _Is_fixed = _Float_flags == ios_base::fixed;
        const bool _Is_hex = _Float_flags == (ios_base::fixed | ios_base::scientific);
        const streamsize _Precision = _Is_hex ? -1 : _Iosbase.precision(); // precision setting
        const int _Desired_precision =
            _Float_put_desired_precision<long double>(_Precision, _Float_flags); // desired precision
        size_t _Bufsize = static_cast<size_t>(_Desired_precision);
        if (_Is_fixed && 1e10 < _CSTD fabsl(_Val)) { // f or F format
            int _Ptwo;
            (void)_CSTD frexpl(_Val, &_Ptwo);
            _Bufsize += _CSTD abs(_Ptwo) * 30103L / 100000L;
        }

        _Buf.resize(_Bufsize + 50); // add fudge factor
        const bool _Is_finite = (_STD isfinite)(_Val);
        const auto _Adjusted_flags = // TRANSITION, DevCom-10519861
            _Is_finite ? _Iosbase.flags() : _Iosbase.flags() & ~ios_base::showpoint;
        const auto _Ngen = static_cast<size_t>(_CSTD sprintf_s(
            &_Buf[0], _Buf.size(), _Ffmt(_Fmt, 'L', _Adjusted_flags), static_cast<int>(_Precision), _Val));

        return _Fput_v3(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen, _Is_finite);
    }
#pragma warning(pop)

    virtual _OutIt __CLR_OR_THIS_CALL do_put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, const void* _Val) const { // put formatted void pointer to _Dest
        char _Buf[2 * _Max_int_dig];

        return _Iput(
            _Dest, _Iosbase, _Fill, _Buf, static_cast<size_t>(_CSTD sprintf_s(_Buf, sizeof(_Buf), "%p", _Val)));
    }

private:
    char* __CLRCALL_OR_CDECL _Ffmt(
        char* _Fmt, char _Spec, ios_base::fmtflags _Flags) const { // generate sprintf format for floating-point
        char* _Ptr = _Fmt;
        *_Ptr++ = '%';

        if (_Flags & ios_base::showpos) {
            *_Ptr++ = '+';
        }

        if (_Flags & ios_base::showpoint) {
            *_Ptr++ = '#';
        }

        *_Ptr++ = '.';
        *_Ptr++ = '*'; // for precision argument
        if (_Spec != '\0') {
            *_Ptr++ = _Spec; // 'L' qualifier for long double only
        }

        char _Ch; // specifier
        ios_base::fmtflags _Ffl = _Flags & ios_base::floatfield;
        if (_Flags & ios_base::uppercase) {
            if (_Ffl == ios_base::fixed) {
                _Ch = 'f';
            }
            else if (_Ffl == (ios_base::scientific | ios_base::fixed)) {
                _Ch = 'A';
            }
            else if (_Ffl == ios_base::scientific) {
                _Ch = 'E';
            }
            else {
                _Ch = 'G';
            }
        }
        else {
            if (_Ffl == ios_base::fixed) {
                _Ch = 'f';
            }
            else if (_Ffl == (ios_base::scientific | ios_base::fixed)) {
                _Ch = 'a';
            }
            else if (_Ffl == ios_base::scientific) {
                _Ch = 'e';
            }
            else {
                _Ch = 'g';
            }
        }
        *_Ptr++ = _Ch;

        *_Ptr = '\0';
        return _Fmt;
    }

    _OutIt __CLRCALL_OR_CDECL _Fput(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, const char* _Buf,
        size_t _Count) const { // TRANSITION, ABI: preserved for binary compatibility
        return _Fput_v3(_Dest, _Iosbase, _Fill, _Buf, _Count, true);
    }

    template <int = 0> // TRANSITION, ABI
    _OutIt _Fput_v3(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, const char* _Buf, size_t _Count,
        bool _Is_finite_val) const { // put formatted floating-point to _Dest
        auto _Prefix = static_cast<size_t>(0 < _Count && (*_Buf == '+' || *_Buf == '-'));
        const char* _Exps;
        if ((_Iosbase.flags() & ios_base::floatfield) != (ios_base::scientific | ios_base::fixed)) {
            _Exps = "eE";
        }
        else { // correct for hexadecimal floating-point
            _Exps = "pP";
            if (_Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
                && (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X')) {
                _Prefix += 2;
            }
        }
        const size_t _Eoff = _CSTD strcspn(&_Buf[0], _Exps); // find exponent
        char _Dp[2] = { "." };
        _Dp[0] = _CSTD localeconv()->decimal_point[0];
        const size_t _Poff = _CSTD strcspn(&_Buf[0], &_Dp[0]); // find decimal point

        const ctype<_Elem>& _Ctype_fac = _STD use_facet<ctype<_Elem>>(_Iosbase.getloc());
        basic_string<_Elem> _Groupstring(_Count, _Elem(0)); // reserve space
        _Ctype_fac.widen(_Buf, _Buf + _Count, &_Groupstring[0]);

        const auto& _Punct_fac = _STD use_facet<numpunct<_Elem>>(_Iosbase.getloc());
        const string _Grouping = _Punct_fac.grouping();
        const _Elem _Kseparator = _Punct_fac.thousands_sep();

        if (_Poff != _Count) {
            _Groupstring[_Poff] = _Punct_fac.decimal_point();
        }

        if (_Is_finite_val) {
            size_t _Off = _Poff == _Count ? _Eoff : _Poff;
            const char* _Pg = &_Grouping[0];
            while (*_Pg != CHAR_MAX && '\0' < *_Pg && static_cast<size_t>(*_Pg) < _Off - _Prefix) {
                // add thousands separator
                _Groupstring.insert(_Off -= *_Pg, 1, _Kseparator);
                if ('\0' < _Pg[1]) {
                    ++_Pg; // not last group, advance
                }
            }
        }

        _Count = _Groupstring.size();

        size_t _Fillcount;
        if (_Iosbase.width() <= 0 || static_cast<size_t>(_Iosbase.width()) <= _Count) {
            _Fillcount = 0;
        }
        else {
            _Fillcount = static_cast<size_t>(_Iosbase.width()) - _Count;
        }

        ios_base::fmtflags _Adjustfield = _Iosbase.flags() & ios_base::adjustfield;
        if (_Adjustfield != ios_base::left && _Adjustfield != ios_base::internal) { // put leading fill
            _Dest = _Rep(_Dest, _Fill, _Fillcount);
            _Fillcount = 0;
            _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
        }
        else if (_Adjustfield == ios_base::internal) { // put internal fill
            _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
            _Dest = _Rep(_Dest, _Fill, _Fillcount);
            _Fillcount = 0;
        }
        else {
            _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
        }

        _Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);
        _Iosbase.width(0);
        return _Rep(_Dest, _Fill, _Fillcount); // put trailing fill
    }

    char* __CLRCALL_OR_CDECL _Ifmt(
        char* _Fmt, const char* _Spec, ios_base::fmtflags _Flags) const { // generate sprintf format for integer
        char* _Ptr = _Fmt;
        *_Ptr++ = '%';

        if (_Flags & ios_base::showpos) {
            *_Ptr++ = '+';
        }

        if (_Flags & ios_base::showbase) {
            *_Ptr++ = '#';
        }

        if (_Spec[0] != 'L') {
            *_Ptr++ = _Spec[0]; // qualifier
        }
        else { // change L to I64
            *_Ptr++ = 'I';
            *_Ptr++ = '6';
            *_Ptr++ = '4';
        }

        ios_base::fmtflags _Basefield = _Flags & ios_base::basefield;
        *_Ptr++ = _Basefield == ios_base::oct ? 'o'
            : _Basefield != ios_base::hex ? _Spec[1] // 'd' or 'u'
            : _Flags & ios_base::uppercase ? 'X'
            : 'x';
        *_Ptr = '\0';
        return _Fmt;
    }

    _OutIt __CLRCALL_OR_CDECL _Iput(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, char* _Buf,
        size_t _Count) const { // put formatted integer to _Dest
        auto _Prefix = static_cast<size_t>(0 < _Count && (*_Buf == '+' || *_Buf == '-'));
        if ((_Iosbase.flags() & ios_base::basefield) == ios_base::hex && _Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
            && (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X')) {
            _Prefix += 2;
        }

        const ctype<_Elem>& _Ctype_fac = _STD use_facet<ctype<_Elem>>(_Iosbase.getloc());
        basic_string<_Elem> _Groupstring(_Count, _Elem(0)); // reserve space
        _Ctype_fac.widen(_Buf, _Buf + _Count, &_Groupstring[0]);

        const auto& _Punct_fac = _STD use_facet<numpunct<_Elem>>(_Iosbase.getloc());
        const string _Grouping = _Punct_fac.grouping();
        const char* _Pg = &_Grouping[0];
        if (*_Pg != CHAR_MAX && '\0' < *_Pg) { // grouping specified, add thousands separators
            const _Elem _Kseparator = _Punct_fac.thousands_sep();
            while (*_Pg != CHAR_MAX && '\0' < *_Pg && static_cast<size_t>(*_Pg) < _Count - _Prefix) {
                // insert thousands separator
                _Count -= *_Pg;
                _Groupstring.insert(_Count, 1, _Kseparator);
                if ('\0' < _Pg[1]) {
                    ++_Pg; // not last group, advance
                }
            }
        }

        _Count = _Groupstring.size();

        size_t _Fillcount;
        if (_Iosbase.width() <= 0 || static_cast<size_t>(_Iosbase.width()) <= _Count) {
            _Fillcount = 0;
        }
        else {
            _Fillcount = static_cast<size_t>(_Iosbase.width()) - _Count;
        }

        ios_base::fmtflags _Adjustfield = _Iosbase.flags() & ios_base::adjustfield;
        if (_Adjustfield != ios_base::left && _Adjustfield != ios_base::internal) { // put leading fill
            _Dest = _Rep(_Dest, _Fill, _Fillcount);
            _Fillcount = 0;
            _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
        }
        else if (_Adjustfield == ios_base::internal) { // put internal fill
            _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
            _Dest = _Rep(_Dest, _Fill, _Fillcount);
            _Fillcount = 0;
        }
        else {
            _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
        }

        _Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);
        _Iosbase.width(0);
        return _Rep(_Dest, _Fill, _Fillcount); // put trailing fill
    }

    _OutIt __CLRCALL_OR_CDECL _Put(
        _OutIt _Dest, const _Elem* _Ptr, size_t _Count) const { // put [_Ptr, _Ptr + _Count) to _Dest
        for (; 0 < _Count; --_Count, (void) ++_Dest, ++_Ptr) {
            *_Dest = *_Ptr;
        }

        return _Dest;
    }

    _OutIt __CLRCALL_OR_CDECL _Rep(_OutIt _Dest, _Elem _Ch, size_t _Count) const { // put _Count * _Ch to _Dest
        for (; 0 < _Count; --_Count, (void) ++_Dest) {
            *_Dest = _Ch;
        }

        return _Dest;
    }
};

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdllimport-static-field-def"
#endif // defined(__clang__)

template <class _Elem, class _OutIt>
__PURE_APPDOMAIN_GLOBAL locale::id num_put<_Elem, _OutIt>::id;

#if defined(_DLL_CPPLIB)

#if !defined(_CRTBLD) || defined(__FORCE_INSTANCE)
template __PURE_APPDOMAIN_GLOBAL locale::id numpunct<char>::id;
template class _CRTIMP2_PURE_IMPORT num_get<char, istreambuf_iterator<char, char_traits<char>>>;
template class _CRTIMP2_PURE_IMPORT num_put<char, ostreambuf_iterator<char, char_traits<char>>>;

template __PURE_APPDOMAIN_GLOBAL locale::id numpunct<wchar_t>::id;
template class _CRTIMP2_PURE_IMPORT num_get<wchar_t, istreambuf_iterator<wchar_t, char_traits<wchar_t>>>;
template class _CRTIMP2_PURE_IMPORT num_put<wchar_t, ostreambuf_iterator<wchar_t, char_traits<wchar_t>>>;
#endif // !defined(_CRTBLD) || defined(__FORCE_INSTANCE)

#ifdef __FORCE_INSTANCE
template __PURE_APPDOMAIN_GLOBAL locale::id numpunct<unsigned short>::id;
template class _CRTIMP2_PURE_IMPORT
num_get<unsigned short, istreambuf_iterator<unsigned short, char_traits<unsigned short>>>;
template class _CRTIMP2_PURE_IMPORT
num_put<unsigned short, ostreambuf_iterator<unsigned short, char_traits<unsigned short>>>;
#endif // defined(__FORCE_INSTANCE)
#endif // defined(_DLL_CPPLIB)

#ifdef __clang__
#pragma clang diagnostic pop
#endif // defined(__clang__)
_STD_END
#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _XLOCNUM_


#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_STD_BEGIN
_EXPORT_STD extern "C++" template <class _Elem, class _Traits>
class basic_ios : public ios_base { // base class for basic_istream/basic_ostream
public:
    using _Myos = basic_ostream<_Elem, _Traits>;
    using _Mysb = basic_streambuf<_Elem, _Traits>;
    using _Ctype = ctype<_Elem>;
    using char_type = _Elem;
    using traits_type = _Traits;
    using int_type = typename _Traits::int_type;
    using pos_type = typename _Traits::pos_type;
    using off_type = typename _Traits::off_type;

    explicit __CLR_OR_THIS_CALL basic_ios(_Mysb* _Strbuf) {
        init(_Strbuf);
    }

    __CLR_OR_THIS_CALL ~basic_ios() noexcept override {}

    void __CLR_OR_THIS_CALL clear(iostate _State = goodbit, bool _Reraise = false) {
        // set state, possibly reraise exception
        ios_base::clear(_State | (_Mystrbuf ? ios_base::goodbit : ios_base::badbit), _Reraise);
    }

#if _HAS_OLD_IOSTREAMS_MEMBERS
    void __CLR_OR_THIS_CALL clear(io_state _State) { // set state to _State
        clear(static_cast<iostate>(_State));
    }
#endif // _HAS_OLD_IOSTREAMS_MEMBERS

    void __CLR_OR_THIS_CALL setstate(iostate _State, bool _Reraise = false) {
        // merge _State into state, possibly reraise exception
        clear(rdstate() | _State, _Reraise);
    }

#if _HAS_OLD_IOSTREAMS_MEMBERS
    void __CLR_OR_THIS_CALL setstate(io_state _State) { // merge _State into state
        setstate(static_cast<iostate>(_State));
    }
#endif // _HAS_OLD_IOSTREAMS_MEMBERS

    basic_ios& __CLR_OR_THIS_CALL copyfmt(const basic_ios& _Right) { // copy format parameters
        _Tiestr = _Right.tie();
        _Fillch = _Right.fill();
        ios_base::copyfmt(_Right);
        return *this;
    }

    _Myos* __CLR_OR_THIS_CALL tie() const noexcept /* strengthened */ {
        return _Tiestr;
    }

    _Myos* __CLR_OR_THIS_CALL tie(_Myos* _Newtie) noexcept /* strengthened */ { // set tie pointer
        _Myos* _Oldtie = _Tiestr;
        _Tiestr = _Newtie;
        return _Oldtie;
    }

    _NODISCARD _Mysb* __CLR_OR_THIS_CALL rdbuf() const noexcept /* strengthened */ {
        return _Mystrbuf;
    }

    _Mysb* __CLR_OR_THIS_CALL rdbuf(_Mysb* _Strbuf) { // set stream buffer pointer
        _Mysb* _Oldstrbuf = _Mystrbuf;
        _Mystrbuf = _Strbuf;
        clear();
        return _Oldstrbuf;
    }

    locale __CLR_OR_THIS_CALL imbue(const locale& _Loc) { // set locale to argument
        locale _Oldlocale = ios_base::imbue(_Loc);
        const auto _Rdbuf = rdbuf();
        if (_Rdbuf) {
            _Rdbuf->pubimbue(_Loc);
        }

        return _Oldlocale;
    }

    _Elem __CLR_OR_THIS_CALL fill() const noexcept /* strengthened */ {
        return _Fillch;
    }

    _Elem __CLR_OR_THIS_CALL fill(_Elem _Newfill) noexcept /* strengthened */ { // set fill character
        _Elem _Oldfill = _Fillch;
        _Fillch = _Newfill;
        return _Oldfill;
    }

    char __CLR_OR_THIS_CALL narrow(_Elem _Ch, char _Dflt = '\0') const { // convert _Ch to byte using imbued locale
        return _STD use_facet<_Ctype>(getloc()).narrow(_Ch, _Dflt);
    }

    _Elem __CLR_OR_THIS_CALL widen(char _Byte) const { // convert _Byte to character using imbued locale
        return _STD use_facet<_Ctype>(getloc()).widen(_Byte);
    }

    void __CLR_OR_THIS_CALL move(basic_ios& _Right) noexcept /* strengthened */ {
        if (this != _STD addressof(_Right)) {
            _Mystrbuf = nullptr;
            _Tiestr = nullptr;
            this->swap(_Right);
        }
    }

    void __CLR_OR_THIS_CALL move(basic_ios&& _Right) noexcept /* strengthened */ {
        if (this != _STD addressof(_Right)) {
            _Mystrbuf = nullptr;
            _Tiestr = nullptr;
            this->swap(_Right);
        }
    }

    void __CLR_OR_THIS_CALL swap(basic_ios& _Right) noexcept { // swap all but rdbuf() with right
        ios_base::swap(_Right);
        _STD swap(_Fillch, _Right._Fillch);
        _STD swap(_Tiestr, _Right._Tiestr);
    }

    void __CLR_OR_THIS_CALL set_rdbuf(_Mysb* _Strbuf) noexcept /* strengthened */ {
        // set stream buffer pointer without changing state
        _Mystrbuf = _Strbuf;
    }

protected:
    void __CLR_OR_THIS_CALL init(_Mysb* _Strbuf = nullptr, bool _Isstd = false) {
        // initialize with stream buffer pointer
        _Init(); // initialize ios_base
        _Mystrbuf = _Strbuf;
        _Tiestr = nullptr;
        _Fillch = widen(' ');

        if (!_Mystrbuf) {
            setstate(badbit);
        }

        if (_Isstd) {
            _Addstd(this); // special handling for standard streams
        }
    }

    __CLR_OR_THIS_CALL basic_ios() {}

private:
    _Mysb* _Mystrbuf{}; // pointer to stream buffer
    _Myos* _Tiestr{}; // pointer to tied output stream
    _Elem _Fillch{}; // the fill character

public:
    __CLR_OR_THIS_CALL basic_ios(const basic_ios&) = delete;
    basic_ios& __CLR_OR_THIS_CALL operator=(const basic_ios&) = delete;
};

#if defined(_DLL_CPPLIB)

#if !defined(_CRTBLD) || defined(__FORCE_INSTANCE)
template class _CRTIMP2_PURE_IMPORT basic_ios<char, char_traits<char>>;
template class _CRTIMP2_PURE_IMPORT basic_ios<wchar_t, char_traits<wchar_t>>;
#endif // !defined(_CRTBLD) || defined(__FORCE_INSTANCE)

#ifdef __FORCE_INSTANCE
template class _CRTIMP2_PURE_IMPORT basic_ios<unsigned short, char_traits<unsigned short>>;
#endif // defined(__FORCE_INSTANCE)
#endif // defined(_DLL_CPPLIB)

_EXPORT_STD inline ios_base& __CLRCALL_OR_CDECL boolalpha(ios_base& _Iosbase) { // set boolalpha
    _Iosbase.setf(ios_base::boolalpha);
    return _Iosbase;
}

_EXPORT_STD inline ios_base& __CLRCALL_OR_CDECL dec(ios_base& _Iosbase) { // set basefield to dec
    _Iosbase.setf(ios_base::dec, ios_base::basefield);
    return _Iosbase;
}

_EXPORT_STD inline ios_base& __CLRCALL_OR_CDECL defaultfloat(ios_base& _Iosbase) { // clear floatfield
    _Iosbase.unsetf(ios_base::floatfield);
    return _Iosbase;
}

_EXPORT_STD inline ios_base& __CLRCALL_OR_CDECL fixed(ios_base& _Iosbase) { // set floatfield to fixed
    _Iosbase.setf(ios_base::fixed, ios_base::floatfield);
    return _Iosbase;
}

_EXPORT_STD inline ios_base& __CLRCALL_OR_CDECL hex(ios_base& _Iosbase) { // set basefield to hex
    _Iosbase.setf(ios_base::hex, ios_base::basefield);
    return _Iosbase;
}

_EXPORT_STD inline ios_base& __CLRCALL_OR_CDECL hexfloat(ios_base& _Iosbase) { // set floatfield to (scientific | fixed)
    _Iosbase.setf(ios_base::scientific | ios_base::fixed, ios_base::floatfield);
    return _Iosbase;
}

_EXPORT_STD inline ios_base& __CLRCALL_OR_CDECL internal(ios_base& _Iosbase) { // set adjustfield to internal
    _Iosbase.setf(ios_base::internal, ios_base::adjustfield);
    return _Iosbase;
}

_EXPORT_STD inline ios_base& __CLRCALL_OR_CDECL left(ios_base& _Iosbase) { // set adjustfield to left
    _Iosbase.setf(ios_base::left, ios_base::adjustfield);
    return _Iosbase;
}

_EXPORT_STD inline ios_base& __CLRCALL_OR_CDECL noboolalpha(ios_base& _Iosbase) { // clear boolalpha
    _Iosbase.unsetf(ios_base::boolalpha);
    return _Iosbase;
}

_EXPORT_STD inline ios_base& __CLRCALL_OR_CDECL noshowbase(ios_base& _Iosbase) { // clear showbase
    _Iosbase.unsetf(ios_base::showbase);
    return _Iosbase;
}

_EXPORT_STD inline ios_base& __CLRCALL_OR_CDECL noshowpoint(ios_base& _Iosbase) { // clear showpoint
    _Iosbase.unsetf(ios_base::showpoint);
    return _Iosbase;
}

_EXPORT_STD inline ios_base& __CLRCALL_OR_CDECL noshowpos(ios_base& _Iosbase) { // clear showpos
    _Iosbase.unsetf(ios_base::showpos);
    return _Iosbase;
}

_EXPORT_STD inline ios_base& __CLRCALL_OR_CDECL noskipws(ios_base& _Iosbase) { // clear skipws
    _Iosbase.unsetf(ios_base::skipws);
    return _Iosbase;
}

_EXPORT_STD inline ios_base& __CLRCALL_OR_CDECL nounitbuf(ios_base& _Iosbase) { // clear unitbuf
    _Iosbase.unsetf(ios_base::unitbuf);
    return _Iosbase;
}

_EXPORT_STD inline ios_base& __CLRCALL_OR_CDECL nouppercase(ios_base& _Iosbase) { // clear uppercase
    _Iosbase.unsetf(ios_base::uppercase);
    return _Iosbase;
}

_EXPORT_STD inline ios_base& __CLRCALL_OR_CDECL oct(ios_base& _Iosbase) { // set oct in basefield
    _Iosbase.setf(ios_base::oct, ios_base::basefield);
    return _Iosbase;
}

_EXPORT_STD inline ios_base& __CLRCALL_OR_CDECL right(ios_base& _Iosbase) { // set right in adjustfield
    _Iosbase.setf(ios_base::right, ios_base::adjustfield);
    return _Iosbase;
}

_EXPORT_STD inline ios_base& __CLRCALL_OR_CDECL scientific(ios_base& _Iosbase) { // set scientific in floatfield
    _Iosbase.setf(ios_base::scientific, ios_base::floatfield);
    return _Iosbase;
}

_EXPORT_STD inline ios_base& __CLRCALL_OR_CDECL showbase(ios_base& _Iosbase) { // set showbase
    _Iosbase.setf(ios_base::showbase);
    return _Iosbase;
}

_EXPORT_STD inline ios_base& __CLRCALL_OR_CDECL showpoint(ios_base& _Iosbase) { // set showpoint
    _Iosbase.setf(ios_base::showpoint);
    return _Iosbase;
}

_EXPORT_STD inline ios_base& __CLRCALL_OR_CDECL showpos(ios_base& _Iosbase) { // set showpos
    _Iosbase.setf(ios_base::showpos);
    return _Iosbase;
}

_EXPORT_STD inline ios_base& __CLRCALL_OR_CDECL skipws(ios_base& _Iosbase) { // set skipws
    _Iosbase.setf(ios_base::skipws);
    return _Iosbase;
}

_EXPORT_STD inline ios_base& __CLRCALL_OR_CDECL unitbuf(ios_base& _Iosbase) { // set unitbuf
    _Iosbase.setf(ios_base::unitbuf);
    return _Iosbase;
}

_EXPORT_STD inline ios_base& __CLRCALL_OR_CDECL uppercase(ios_base& _Iosbase) { // set uppercase
    _Iosbase.setf(ios_base::uppercase);
    return _Iosbase;
}

#if _HAS_TR1_NAMESPACE
namespace _DEPRECATE_TR1_NAMESPACE tr1 {
    using _STD hexfloat;
}
#endif // _HAS_TR1_NAMESPACE

_STD_END

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_STD_BEGIN
#pragma vtordisp(push, 2) // compiler bug workaround

_EXPORT_STD extern "C++" template <class _Elem, class _Traits>
class basic_ostream : virtual public basic_ios<_Elem, _Traits> { // control insertions into a stream buffer
public:
    using _Myios = basic_ios<_Elem, _Traits>;
    using _Mysb = basic_streambuf<_Elem, _Traits>;
    using _Iter = ostreambuf_iterator<_Elem, _Traits>;
    using _Nput = num_put<_Elem, _Iter>;

    explicit __CLR_OR_THIS_CALL basic_ostream(basic_streambuf<_Elem, _Traits>* _Strbuf, bool _Isstd = false) {
        _Myios::init(_Strbuf, _Isstd);
    }

    __CLR_OR_THIS_CALL basic_ostream(_Uninitialized, bool _Addit = true) {
        if (_Addit) {
            this->_Addstd(this); // suppress for basic_iostream
        }
    }

protected:
    __CLR_OR_THIS_CALL basic_ostream(basic_ostream&& _Right) noexcept(false) {
        _Myios::init();
        _Myios::move(_STD move(_Right));
    }

    basic_ostream& __CLR_OR_THIS_CALL operator=(basic_ostream&& _Right) noexcept /* strengthened */ {
        this->swap(_Right);
        return *this;
    }

    void __CLR_OR_THIS_CALL swap(basic_ostream& _Right) noexcept /* strengthened */ {
        if (this != _STD addressof(_Right)) {
            _Myios::swap(_Right);
        }
    }

public:
    __CLR_OR_THIS_CALL basic_ostream(const basic_ostream&) = delete;
    basic_ostream& __CLR_OR_THIS_CALL operator=(const basic_ostream&) = delete;

    __CLR_OR_THIS_CALL ~basic_ostream() noexcept override {}

    using int_type = typename _Traits::int_type;
    using pos_type = typename _Traits::pos_type;
    using off_type = typename _Traits::off_type;

    class _Sentry_base { // stores thread lock and reference to output stream
    public:
        __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there
            const auto _Rdbuf = _Myostr.rdbuf();
            if (_Rdbuf) {
                _Rdbuf->_Lock();
            }
        }

        __CLR_OR_THIS_CALL ~_Sentry_base() noexcept { // destroy after unlocking
            const auto _Rdbuf = _Myostr.rdbuf();
            if (_Rdbuf) {
                _Rdbuf->_Unlock();
            }
        }

        basic_ostream& _Myostr; // the output stream, for _Unlock call at destruction

        _Sentry_base& operator=(const _Sentry_base&) = delete;
    };

    class sentry : public _Sentry_base {
    public:
        explicit __CLR_OR_THIS_CALL sentry(basic_ostream& _Ostr) : _Sentry_base(_Ostr) {
            if (!_Ostr.good()) {
                _Ok = false;
                return;
            }

            const auto _Tied = _Ostr.tie();
            if (!_Tied || _Tied == &_Ostr) {
                _Ok = true;
                return;
            }

            _Tied->flush();
            _Ok = _Ostr.good(); // store test only after flushing tie
        }

        _STL_DISABLE_DEPRECATED_WARNING
            __CLR_OR_THIS_CALL ~sentry() noexcept {
#if !_HAS_EXCEPTIONS
            const bool _Zero_uncaught_exceptions = true;
#elif _HAS_DEPRECATED_UNCAUGHT_EXCEPTION
            const bool _Zero_uncaught_exceptions = !_STD uncaught_exception(); // TRANSITION, ArchivedOS-12000909
#else // ^^^ _HAS_DEPRECATED_UNCAUGHT_EXCEPTION / !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION vvv
            const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;
#endif // ^^^ !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION ^^^

            if (_Zero_uncaught_exceptions) {
                this->_Myostr._Osfx();
            }
        }
        _STL_RESTORE_DEPRECATED_WARNING

            explicit __CLR_OR_THIS_CALL operator bool() const {
            return _Ok;
        }

        __CLR_OR_THIS_CALL sentry(const sentry&) = delete;
        sentry& __CLR_OR_THIS_CALL operator=(const sentry&) = delete;

    private:
        bool _Ok; // true if stream state okay at construction
    };

#pragma push_macro("opfx")
#pragma push_macro("osfx")
#undef opfx
#undef osfx
    // TRANSITION, ABI: non-Standard opfx() is preserved for binary compatibility
    _DEPRECATE_IO_PFX_SFX bool __CLR_OR_THIS_CALL opfx() { // test stream state and flush tie stream as needed
        if (!this->good()) {
            return false;
        }

        const auto _Tied = _Myios::tie();
        if (!_Tied || _Myios::tie() == this) {
            return true;
        }

        _Tied->flush();
        return this->good();
    }

    // TRANSITION, ABI: non-Standard osfx() is preserved for binary compatibility
    _DEPRECATE_IO_PFX_SFX void __CLR_OR_THIS_CALL osfx() noexcept { // perform any wrapup
        _Osfx();
    }
#pragma pop_macro("osfx")
#pragma pop_macro("opfx")

    void __CLR_OR_THIS_CALL _Osfx() noexcept { // perform any wrapup
        _TRY_BEGIN
            if (this->good() && this->flags() & ios_base::unitbuf) {
                if (_Myios::rdbuf()->pubsync() == -1) { // flush stream as needed
                    _Myios::setstate(ios_base::badbit);
                }
            }
        _CATCH_ALL
            _CATCH_END
    }

#ifdef _M_CEE_PURE
    basic_ostream& __CLR_OR_THIS_CALL operator<<(basic_ostream& (__clrcall* _Pfn)(basic_ostream&)) {
        // call basic_ostream manipulator
        return _Pfn(*this);
    }

    basic_ostream& __CLR_OR_THIS_CALL operator<<(_Myios& (__clrcall* _Pfn)(_Myios&)) {
        // call basic_ios manipulator
        _Pfn(*this);
        return *this;
    }

    basic_ostream& __CLR_OR_THIS_CALL operator<<(ios_base& (__clrcall* _Pfn)(ios_base&)) {
        // call ios_base manipulator
        _Pfn(*this);
        return *this;
    }
#endif // defined(_M_CEE_PURE)

    basic_ostream& __CLR_OR_THIS_CALL operator<<(basic_ostream& (__cdecl* _Pfn)(basic_ostream&)) {
        // call basic_ostream manipulator
        return _Pfn(*this);
    }

    basic_ostream& __CLR_OR_THIS_CALL operator<<(_Myios& (__cdecl* _Pfn)(_Myios&)) {
        // call basic_ios manipulator
        _Pfn(*this);
        return *this;
    }

    basic_ostream& __CLR_OR_THIS_CALL operator<<(ios_base& (__cdecl* _Pfn)(ios_base&)) {
        // call ios_base manipulator
        _Pfn(*this);
        return *this;
    }

    basic_ostream& __CLR_OR_THIS_CALL operator<<(bool _Val) { // insert a boolean
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { // state okay, use facet to insert
            const _Nput& _Nput_fac = _STD use_facet<_Nput>(this->getloc());

            _TRY_IO_BEGIN
                if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {
                    _State |= ios_base::badbit;
                }
            _CATCH_IO_END
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream& __CLR_OR_THIS_CALL operator<<(short _Val) { // insert a short
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { // state okay, use facet to insert
            const _Nput& _Nput_fac = _STD use_facet<_Nput>(this->getloc());
            ios_base::fmtflags _Bfl = this->flags() & ios_base::basefield;

            long _Tmp;
            if (_Bfl == ios_base::oct || _Bfl == ios_base::hex) {
                _Tmp = static_cast<long>(static_cast<unsigned short>(_Val));
            }
            else {
                _Tmp = static_cast<long>(_Val);
            }

            _TRY_IO_BEGIN
                if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Tmp).failed()) {
                    _State |= ios_base::badbit;
                }
            _CATCH_IO_END
        }

        _Myios::setstate(_State);
        return *this;
    }

    // NOTE:
    // If you are not using native wchar_t, the unsigned short inserter
    // is masked by an explicit specialization that treats an unsigned
    // short as a wide character.

    // To read or write unsigned shorts as integers with wchar_t streams,
    // make wchar_t a native type with the command line option /Zc:wchar_t.

    basic_ostream& __CLR_OR_THIS_CALL operator<<(unsigned short _Val) { // insert an unsigned short
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { // state okay, use facet to insert
            const _Nput& _Nput_fac = _STD use_facet<_Nput>(this->getloc());

            _TRY_IO_BEGIN
                if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), static_cast<unsigned long>(_Val))
                    .failed()) {
                    _State |= ios_base::badbit;
                }
            _CATCH_IO_END
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream& __CLR_OR_THIS_CALL operator<<(int _Val) { // insert an int
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { // state okay, use facet to insert
            const _Nput& _Nput_fac = _STD use_facet<_Nput>(this->getloc());
            ios_base::fmtflags _Bfl = this->flags() & ios_base::basefield;

            long _Tmp;
            if (_Bfl == ios_base::oct || _Bfl == ios_base::hex) {
                _Tmp = static_cast<long>(static_cast<unsigned int>(_Val));
            }
            else {
                _Tmp = static_cast<long>(_Val);
            }

            _TRY_IO_BEGIN
                if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Tmp).failed()) {
                    _State |= ios_base::badbit;
                }
            _CATCH_IO_END
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream& __CLR_OR_THIS_CALL operator<<(unsigned int _Val) { // insert an unsigned int
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { // state okay, use facet to insert
            const _Nput& _Nput_fac = _STD use_facet<_Nput>(this->getloc());

            _TRY_IO_BEGIN
                if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), static_cast<unsigned long>(_Val))
                    .failed()) {
                    _State |= ios_base::badbit;
                }
            _CATCH_IO_END
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream& __CLR_OR_THIS_CALL operator<<(long _Val) { // insert a long
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { // state okay, use facet to insert
            const _Nput& _Nput_fac = _STD use_facet<_Nput>(this->getloc());

            _TRY_IO_BEGIN
                if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {
                    _State |= ios_base::badbit;
                }
            _CATCH_IO_END
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream& __CLR_OR_THIS_CALL operator<<(unsigned long _Val) { // insert an unsigned long
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { // state okay, use facet to insert
            const _Nput& _Nput_fac = _STD use_facet<_Nput>(this->getloc());

            _TRY_IO_BEGIN
                if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {
                    _State |= ios_base::badbit;
                }
            _CATCH_IO_END
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream& __CLR_OR_THIS_CALL operator<<(long long _Val) { // insert a long long
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { // state okay, use facet to insert
            const _Nput& _Nput_fac = _STD use_facet<_Nput>(this->getloc());

            _TRY_IO_BEGIN
                if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {
                    _State |= ios_base::badbit;
                }
            _CATCH_IO_END
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream& __CLR_OR_THIS_CALL operator<<(unsigned long long _Val) { // insert an unsigned long long
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { // state okay, use facet to insert
            const _Nput& _Nput_fac = _STD use_facet<_Nput>(this->getloc());

            _TRY_IO_BEGIN
                if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {
                    _State |= ios_base::badbit;
                }
            _CATCH_IO_END
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream& __CLR_OR_THIS_CALL operator<<(float _Val) { // insert a float
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { // state okay, use facet to insert
            const _Nput& _Nput_fac = _STD use_facet<_Nput>(this->getloc());

            _TRY_IO_BEGIN
                if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), static_cast<double>(_Val)).failed()) {
                    _State |= ios_base::badbit;
                }
            _CATCH_IO_END
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream& __CLR_OR_THIS_CALL operator<<(double _Val) { // insert a double
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { // state okay, use facet to insert
            const _Nput& _Nput_fac = _STD use_facet<_Nput>(this->getloc());

            _TRY_IO_BEGIN
                if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {
                    _State |= ios_base::badbit;
                }
            _CATCH_IO_END
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream& __CLR_OR_THIS_CALL operator<<(long double _Val) { // insert a long double
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { // state okay, use facet to insert
            const _Nput& _Nput_fac = _STD use_facet<_Nput>(this->getloc());

            _TRY_IO_BEGIN
                if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {
                    _State |= ios_base::badbit;
                }
            _CATCH_IO_END
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream& __CLR_OR_THIS_CALL operator<<(const void* _Val) { // insert a void pointer
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { // state okay, use facet to insert
            const _Nput& _Nput_fac = _STD use_facet<_Nput>(this->getloc());

            _TRY_IO_BEGIN
                if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {
                    _State |= ios_base::badbit;
                }
            _CATCH_IO_END
        }

        _Myios::setstate(_State);
        return *this;
    }

#if _HAS_CXX17
    template <class = void> // TRANSITION, ABI
    basic_ostream& operator<<(nullptr_t) { // insert a null pointer
        return *this << "nullptr";
    }
#endif // _HAS_CXX17

    basic_ostream& __CLR_OR_THIS_CALL operator<<(_Mysb* _Strbuf) { // insert until end-of-file from a stream buffer
        ios_base::iostate _State = ios_base::goodbit;
        bool _Copied = false;
        const sentry _Ok(*this);

        if (_Ok && _Strbuf) {
            for (int_type _Meta = _Traits::eof();; _Copied = true) { // extract another character from stream buffer
                _TRY_BEGIN
                    _Meta = _Traits::eq_int_type(_Traits::eof(), _Meta) ? _Strbuf->sgetc() : _Strbuf->snextc();
                _CATCH_ALL
                    // N4971 [ostream.inserters]/9: "If an exception was thrown
                    // while extracting a character, the function sets failbit in the error state,
                    // and if failbit is set in exceptions() the caught exception is rethrown."
                    _Myios::setstate(ios_base::failbit, _Myios::exceptions() == ios_base::failbit);
                _CATCH_END

                    if (_Traits::eq_int_type(_Traits::eof(), _Meta)) {
                        break; // end of file, quit
                    }

                _TRY_IO_BEGIN
                    if (_Traits::eq_int_type(_Traits::eof(), _Myios::rdbuf()->sputc(_Traits::to_char_type(_Meta)))) {
                        _State |= ios_base::badbit; // insertion failed, quit
                        break;
                    }
                _CATCH_IO_END
            }
        }

        this->width(0);
        int _Setstate_with;
        if (_Strbuf) {
            if (_Copied) {
                _Setstate_with = _State;
            }
            else {
                _Setstate_with = _State | ios_base::failbit;
            }
        }
        else {
            _Setstate_with = ios_base::badbit;
        }

        _Myios::setstate(_Setstate_with);
        return *this;
    }

    basic_ostream& __CLR_OR_THIS_CALL put(_Elem _Ch) { // insert a character
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (!_Ok) {
            _State |= ios_base::badbit;
        }
        else { // state okay, insert character
            _TRY_IO_BEGIN
                if (_Traits::eq_int_type(_Traits::eof(), _Myios::rdbuf()->sputc(_Ch))) {
                    _State |= ios_base::badbit;
                }
            _CATCH_IO_END
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream& __CLR_OR_THIS_CALL write(const _Elem* _Str, streamsize _Count) {
        // insert _Count characters from array _Str
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (!_Ok) {
            _State |= ios_base::badbit;
        }
        else if (0 < _Count) { // state okay, insert characters
            _TRY_IO_BEGIN
                if (_Myios::rdbuf()->sputn(_Str, _Count) != _Count) {
                    _State |= ios_base::badbit;
                }
            _CATCH_IO_END
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream& __CLR_OR_THIS_CALL flush() { // flush output stream
        const auto _Rdbuf = _Myios::rdbuf();
        if (_Rdbuf) { // buffer exists, flush it
            const sentry _Ok(*this);

            if (_Ok) {
                ios_base::iostate _State = ios_base::goodbit;
                _TRY_IO_BEGIN
                    if (_Rdbuf->pubsync() == -1) {
                        _State |= ios_base::badbit; // sync failed
                    }
                _CATCH_IO_END
                    _Myios::setstate(_State);
            }
        }
        return *this;
    }

    basic_ostream& __CLR_OR_THIS_CALL seekp(pos_type _Pos) { // set output stream position to _Pos
        const sentry _Ok(*this);

        if (!this->fail()) {
            ios_base::iostate _State = ios_base::goodbit;
            _TRY_IO_BEGIN
                if (static_cast<off_type>(_Myios::rdbuf()->pubseekpos(_Pos, ios_base::out)) == -1) {
                    _State |= ios_base::failbit; // seek failed
                }
            _CATCH_IO_END
                _Myios::setstate(_State);
        }

        return *this;
    }

    basic_ostream& __CLR_OR_THIS_CALL seekp(off_type _Off, ios_base::seekdir _Way) {
        // change output stream position by _Off, according to _Way
        const sentry _Ok(*this);

        if (!this->fail()) {
            ios_base::iostate _State = ios_base::goodbit;
            _TRY_IO_BEGIN
                if (static_cast<off_type>(_Myios::rdbuf()->pubseekoff(_Off, _Way, ios_base::out)) == -1) {
                    _State |= ios_base::failbit; // seek failed
                }
            _CATCH_IO_END
                _Myios::setstate(_State);
        }

        return *this;
    }

    pos_type __CLR_OR_THIS_CALL tellp() {
        const sentry _Ok(*this);

        if (!this->fail()) {
            _TRY_IO_BEGIN
                return _Myios::rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
            _CATCH_IO_END
        }

        return pos_type{ off_type{-1} };
    }
};

#pragma vtordisp(pop) // compiler bug workaround

#ifndef _NATIVE_WCHAR_T_DEFINED
// NOTE:
// If you are not using native wchar_t, the following explicit
// specialization will mask the member function (above) that treats
// an unsigned short as an integer.

// To read or write unsigned shorts as integers with wchar_t streams,
// make wchar_t a native type with the command line option /Zc:wchar_t.

template <>
inline basic_ostream<unsigned short, char_traits<unsigned short>>& __CLR_OR_THIS_CALL basic_ostream<unsigned short,
    char_traits<unsigned short>>::operator<<(unsigned short _Ch) { // extract a character
    using _Traits = char_traits<unsigned short>;

    ios_base::iostate _State = ios_base::goodbit;
    const sentry _Ok(*this);

    if (_Ok) { // state okay, insert
        streamsize _Pad = this->width() <= 1 ? 0 : this->width() - 1;

        _TRY_IO_BEGIN
            if ((this->flags() & ios_base::adjustfield) != ios_base::left) {
                for (; _State == ios_base::goodbit && 0 < _Pad; --_Pad) { // pad on left
                    if (_Traits::eq_int_type(_Traits::eof(), this->rdbuf()->sputc(this->fill()))) {
                        _State |= ios_base::badbit;
                    }
                }
            }

        if (_State == ios_base::goodbit && _Traits::eq_int_type(_Traits::eof(), this->rdbuf()->sputc(_Ch))) {
            _State |= ios_base::badbit;
        }

        for (; _State == ios_base::goodbit && 0 < _Pad; --_Pad) { // pad on right
            if (_Traits::eq_int_type(_Traits::eof(), this->rdbuf()->sputc(this->fill()))) {
                _State |= ios_base::badbit;
            }
        }
        _CATCH_IO_END
    }

    this->width(0);
    _Myios::setstate(_State);
    return *this;
}
#endif // _NATIVE_WCHAR_T_DEFINED

#if defined(_DLL_CPPLIB)

#if !defined(_CRTBLD) || defined(__FORCE_INSTANCE)
template class _CRTIMP2_PURE_IMPORT basic_ostream<char, char_traits<char>>;
template class _CRTIMP2_PURE_IMPORT basic_ostream<wchar_t, char_traits<wchar_t>>;
#endif // !defined(_CRTBLD) || defined(__FORCE_INSTANCE)

#ifdef __FORCE_INSTANCE
template class _CRTIMP2_PURE_IMPORT basic_ostream<unsigned short, char_traits<unsigned short>>;
#endif // defined(__FORCE_INSTANCE)
#endif // defined(_DLL_CPPLIB)

_EXPORT_STD template <class _Elem, class _Traits>
basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr, const char* _Val) { // insert NTBS
    ios_base::iostate _State = ios_base::goodbit;
    streamsize _Count = static_cast<streamsize>(_CSTD strlen(_Val));
    streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;
    const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);

    if (!_Ok) {
        _State |= ios_base::badbit;
    }
    else { // state okay, insert characters
        _TRY_IO_BEGIN
            const ctype<_Elem>& _Ctype_fac = _STD use_facet<ctype<_Elem>>(_Ostr.getloc());
        if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {
            for (; 0 < _Pad; --_Pad) { // pad on left
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= ios_base::badbit; // insertion failed, quit
                    break;
                }
            }
        }

        for (; _State == ios_base::goodbit && 0 < _Count; --_Count, ++_Val) {
            if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ctype_fac.widen(*_Val)))) {
                _State |= ios_base::badbit;
            }
        }

        if (_State == ios_base::goodbit) {
            for (; 0 < _Pad; --_Pad) { // pad on right
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= ios_base::badbit; // insertion failed, quit
                    break;
                }
            }
        }

        _Ostr.width(0);
        _CATCH_IO_(ios_base, _Ostr)
    }

    _Ostr.setstate(_State);
    return _Ostr;
}

_EXPORT_STD template <class _Elem, class _Traits>
basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr, char _Ch) { // insert a character
    ios_base::iostate _State = ios_base::goodbit;
    const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);

    if (_Ok) { // state okay, insert
        const ctype<_Elem>& _Ctype_fac = _STD use_facet<ctype<_Elem>>(_Ostr.getloc());
        streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

        _TRY_IO_BEGIN
            if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {
                for (; _State == ios_base::goodbit && 0 < _Pad; --_Pad) { // pad on left
                    if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                        _State |= ios_base::badbit;
                    }
                }
            }

        if (_State == ios_base::goodbit
            && _Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ctype_fac.widen(_Ch)))) {
            _State |= ios_base::badbit;
        }

        for (; _State == ios_base::goodbit && 0 < _Pad; --_Pad) { // pad on right
            if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                _State |= ios_base::badbit;
            }
        }
        _CATCH_IO_(ios_base, _Ostr)
    }

    _Ostr.width(0);
    _Ostr.setstate(_State);
    return _Ostr;
}

_EXPORT_STD template <class _Traits>
basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>& _Ostr, const char* _Val) {
    // insert NTBS into char stream
    using _Elem = char;
    using _Myos = basic_ostream<_Elem, _Traits>;

    ios_base::iostate _State = ios_base::goodbit;
    streamsize _Count = static_cast<streamsize>(_Traits::length(_Val));
    streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;
    const typename _Myos::sentry _Ok(_Ostr);

    if (!_Ok) {
        _State |= ios_base::badbit;
    }
    else { // state okay, insert
        _TRY_IO_BEGIN
            if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {
                for (; 0 < _Pad; --_Pad) { // pad on left
                    if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                        _State |= ios_base::badbit; // insertion failed, quit
                        break;
                    }
                }
            }

        if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {
            _State |= ios_base::badbit;
        }

        if (_State == ios_base::goodbit) {
            for (; 0 < _Pad; --_Pad) { // pad on right
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= ios_base::badbit; // insertion failed, quit
                    break;
                }
            }
        }

        _Ostr.width(0);
        _CATCH_IO_(ios_base, _Ostr)
    }

    _Ostr.setstate(_State);
    return _Ostr;
}

_EXPORT_STD template <class _Traits>
basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>& _Ostr, char _Ch) {
    // insert a char into char stream
    using _Elem = char;
    using _Myos = basic_ostream<_Elem, _Traits>;

    ios_base::iostate _State = ios_base::goodbit;
    const typename _Myos::sentry _Ok(_Ostr);

    if (_Ok) { // state okay, insert
        streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

        _TRY_IO_BEGIN
            if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {
                for (; _State == ios_base::goodbit && 0 < _Pad; --_Pad) { // pad on left
                    if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                        _State |= ios_base::badbit;
                    }
                }
            }

        if (_State == ios_base::goodbit && _Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ch))) {
            _State |= ios_base::badbit;
        }

        for (; _State == ios_base::goodbit && 0 < _Pad; --_Pad) { // pad on right
            if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                _State |= ios_base::badbit;
            }
        }
        _CATCH_IO_(ios_base, _Ostr)
    }

    _Ostr.width(0);
    _Ostr.setstate(_State);
    return _Ostr;
}

_EXPORT_STD template <class _Elem, class _Traits>
basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr, const _Elem* _Val) { // insert NTCS
    using _Myos = basic_ostream<_Elem, _Traits>;

    ios_base::iostate _State = ios_base::goodbit;
    streamsize _Count = static_cast<streamsize>(_Traits::length(_Val));
    streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;
    const typename _Myos::sentry _Ok(_Ostr);

    if (!_Ok) {
        _State |= ios_base::badbit;
    }
    else { // state okay, insert
        _TRY_IO_BEGIN
            if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {
                for (; 0 < _Pad; --_Pad) { // pad on left
                    if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                        _State |= ios_base::badbit; // insertion failed, quit
                        break;
                    }
                }
            }

        if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {
            _State |= ios_base::badbit;
        }

        if (_State == ios_base::goodbit) {
            for (; 0 < _Pad; --_Pad) { // pad on right
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= ios_base::badbit; // insertion failed, quit
                    break;
                }
            }
        }

        _Ostr.width(0);
        _CATCH_IO_(ios_base, _Ostr)
    }

    _Ostr.setstate(_State);
    return _Ostr;
}

_EXPORT_STD template <class _Elem, class _Traits>
basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr, _Elem _Ch) { // insert a character
    using _Myos = basic_ostream<_Elem, _Traits>;

    ios_base::iostate _State = ios_base::goodbit;
    const typename _Myos::sentry _Ok(_Ostr);

    if (_Ok) { // state okay, insert
        streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

        _TRY_IO_BEGIN
            if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {
                for (; _State == ios_base::goodbit && 0 < _Pad; --_Pad) { // pad on left
                    if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                        _State |= ios_base::badbit;
                    }
                }
            }

        if (_State == ios_base::goodbit && _Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ch))) {
            _State |= ios_base::badbit;
        }

        for (; _State == ios_base::goodbit && 0 < _Pad; --_Pad) { // pad on right
            if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                _State |= ios_base::badbit;
            }
        }
        _CATCH_IO_(ios_base, _Ostr)
    }

    _Ostr.width(0);
    _Ostr.setstate(_State);
    return _Ostr;
}

_EXPORT_STD template <class _Traits>
basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>& _Ostr, const signed char* _Val) {
    // insert a signed char NTBS
    return _Ostr << reinterpret_cast<const char*>(_Val);
}

_EXPORT_STD template <class _Traits>
basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>& _Ostr, signed char _Ch) { // insert a signed char
    return _Ostr << static_cast<char>(_Ch);
}

_EXPORT_STD template <class _Traits>
basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>& _Ostr, const unsigned char* _Val) {
    // insert an unsigned char NTBS
    return _Ostr << reinterpret_cast<const char*>(_Val);
}

_EXPORT_STD template <class _Traits>
basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>& _Ostr, unsigned char _Ch) {
    // insert an unsigned char
    return _Ostr << static_cast<char>(_Ch);
}

#ifdef __cpp_char8_t // These deleted overloads are specified in P1423.
// don't insert a UTF-8 NTBS
_EXPORT_STD template <class _Traits>
basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>&, const char8_t*) = delete;
_EXPORT_STD template <class _Traits>
basic_ostream<wchar_t, _Traits>& operator<<(basic_ostream<wchar_t, _Traits>&, const char8_t*) = delete;

// don't insert a UTF-8 code unit
_EXPORT_STD template <class _Traits>
basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>&, char8_t) = delete;
_EXPORT_STD template <class _Traits>
basic_ostream<wchar_t, _Traits>& operator<<(basic_ostream<wchar_t, _Traits>&, char8_t) = delete;
#endif // defined(__cpp_char8_t)

#if !_HAS_STREAM_INSERTION_OPERATORS_DELETED_IN_CXX20
#ifdef _NATIVE_WCHAR_T_DEFINED
_EXPORT_STD template <class _Traits>
basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>&, wchar_t) = delete;

_EXPORT_STD template <class _Traits>
basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>&, const wchar_t*) = delete;
#endif // _NATIVE_WCHAR_T_DEFINED

_EXPORT_STD template <class _Traits>
basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>&, char16_t) = delete;
_EXPORT_STD template <class _Traits>
basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>&, char32_t) = delete;

_EXPORT_STD template <class _Traits>
basic_ostream<wchar_t, _Traits>& operator<<(basic_ostream<wchar_t, _Traits>&, char16_t) = delete;
_EXPORT_STD template <class _Traits>
basic_ostream<wchar_t, _Traits>& operator<<(basic_ostream<wchar_t, _Traits>&, char32_t) = delete;

_EXPORT_STD template <class _Traits>
basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>&, const char16_t*) = delete;
_EXPORT_STD template <class _Traits>
basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>&, const char32_t*) = delete;

_EXPORT_STD template <class _Traits>
basic_ostream<wchar_t, _Traits>& operator<<(basic_ostream<wchar_t, _Traits>&, const char16_t*) = delete;
_EXPORT_STD template <class _Traits>
basic_ostream<wchar_t, _Traits>& operator<<(basic_ostream<wchar_t, _Traits>&, const char32_t*) = delete;
#endif // !_HAS_STREAM_INSERTION_OPERATORS_DELETED_IN_CXX20

template <class _Ostr, class _Ty, class = void>
struct _Can_stream_out : false_type {};

template <class _Ostr, class _Ty>
struct _Can_stream_out<_Ostr, _Ty, void_t<decltype(_STD declval<_Ostr&>() << _STD declval<const _Ty&>())>> : true_type {
};

_EXPORT_STD template <class _Ostr, class _Ty,
    enable_if_t<conjunction_v<is_convertible<_Ostr*, ios_base*>, _Can_stream_out<_Ostr, _Ty>>, int> = 0>
    _Ostr&& operator<<(_Ostr&& _Os, const _Ty& _Val) { // insert to rvalue stream
    _Os << _Val;
    return _STD move(_Os);
}

_EXPORT_STD template <class _Elem, class _Traits>
basic_ostream<_Elem, _Traits>& __CLRCALL_OR_CDECL endl(
    basic_ostream<_Elem, _Traits>& _Ostr) { // insert newline and flush stream
    _Ostr.put(_Ostr.widen('\n'));
    _Ostr.flush();
    return _Ostr;
}

_EXPORT_STD template <class _Elem, class _Traits>
basic_ostream<_Elem, _Traits>& __CLRCALL_OR_CDECL ends(basic_ostream<_Elem, _Traits>& _Ostr) { // insert null character
    _Ostr.put(_Elem());
    return _Ostr;
}

_EXPORT_STD template <class _Elem, class _Traits>
basic_ostream<_Elem, _Traits>& __CLRCALL_OR_CDECL flush(basic_ostream<_Elem, _Traits>& _Ostr) { // flush stream
    _Ostr.flush();
    return _Ostr;
}

#if _HAS_CXX20
#ifdef _CPPRTTI
_EXPORT_STD template <class _Elem, class _Traits>
basic_ostream<_Elem, _Traits>& emit_on_flush(basic_ostream<_Elem, _Traits>& _Ostr) {
    const auto _Sync_buf_ptr = dynamic_cast<_Basic_syncbuf_impl<_Elem, _Traits>*>(_Ostr.rdbuf());
    if (_Sync_buf_ptr) {
        _Sync_buf_ptr->set_emit_on_sync(true);
    }
    return _Ostr;
}

_EXPORT_STD template <class _Elem, class _Traits>
basic_ostream<_Elem, _Traits>& noemit_on_flush(basic_ostream<_Elem, _Traits>& _Ostr) {
    const auto _Sync_buf_ptr = dynamic_cast<_Basic_syncbuf_impl<_Elem, _Traits>*>(_Ostr.rdbuf());
    if (_Sync_buf_ptr) {
        _Sync_buf_ptr->set_emit_on_sync(false);
    }
    return _Ostr;
}

_EXPORT_STD template <class _Elem, class _Traits>
basic_ostream<_Elem, _Traits>& flush_emit(basic_ostream<_Elem, _Traits>& _Ostr) {
    _Ostr.flush();
    const auto _Sync_buf_ptr = dynamic_cast<_Basic_syncbuf_impl<_Elem, _Traits>*>(_Ostr.rdbuf());
    if (_Sync_buf_ptr) {
        ios_base::iostate _State = ios_base::goodbit;
        const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);
        if (!_Ok) {
            _State |= ios_base::badbit;
        }
        else {
            _TRY_IO_BEGIN
                const bool _Emit_failed = !_Sync_buf_ptr->_Do_emit();
            if (_Emit_failed) {
                _State |= ios_base::badbit;
            }
            _CATCH_IO_(ios_base, _Ostr)
        }
        _Ostr.setstate(_State);
    }
    return _Ostr;
}
#else // ^^^ defined(_CPPRTTI) / !defined(_CPPRTTI) vvv
_EXPORT_STD template <class _Elem, class _Traits>
basic_ostream<_Elem, _Traits>& emit_on_flush(basic_ostream<_Elem, _Traits>&) = delete; // requires /GR option
_EXPORT_STD template <class _Elem, class _Traits>
basic_ostream<_Elem, _Traits>& noemit_on_flush(basic_ostream<_Elem, _Traits>&) = delete; // requires /GR option
_EXPORT_STD template <class _Elem, class _Traits>
basic_ostream<_Elem, _Traits>& flush_emit(basic_ostream<_Elem, _Traits>&) = delete; // requires /GR option
#endif // ^^^ !defined(_CPPRTTI) ^^^
#endif // _HAS_CXX20

_EXPORT_STD template <class _Elem, class _Traits>
basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr, const error_code& _Errcode) {
    // display error code
    return _Ostr << _Errcode.category().name() << ':' << _Errcode.value();
}

_STD_END

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)


#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_STD_BEGIN
#pragma vtordisp(push, 2) // compiler bug workaround

_EXPORT_STD extern "C++" template <class _Elem, class _Traits>
class basic_istream : virtual public basic_ios<_Elem, _Traits> { // control extractions from a stream buffer
public:
    using _Myios = basic_ios<_Elem, _Traits>;
    using _Mysb = basic_streambuf<_Elem, _Traits>;
    using _Iter = istreambuf_iterator<_Elem, _Traits>;
    using _Ctype = ctype<_Elem>;
    using _Nget = num_get<_Elem, _Iter>;

#if defined(__FORCE_INSTANCE)
    explicit __CLR_OR_THIS_CALL basic_istream(_Mysb* _Strbuf, bool _Isstd, bool _Skip_init) : _Chcount(0) {
        if (!_Skip_init) {
            _Myios::init(_Strbuf, _Isstd);
        }
    }
#endif // defined(__FORCE_INSTANCE)

    explicit __CLR_OR_THIS_CALL basic_istream(_Mysb* _Strbuf, bool _Isstd = false) : _Chcount(0) {
        _Myios::init(_Strbuf, _Isstd);
    }

    __CLR_OR_THIS_CALL basic_istream(_Uninitialized) {
        this->_Addstd(this);
    }

protected:
    __CLR_OR_THIS_CALL basic_istream(basic_istream&& _Right) noexcept(false) : _Chcount(_Right._Chcount) {
        _Myios::init();
        _Myios::move(_STD move(_Right));
        _Right._Chcount = 0;
    }

    basic_istream& __CLR_OR_THIS_CALL operator=(basic_istream&& _Right) noexcept /* strengthened */ {
        this->swap(_Right);
        return *this;
    }

    void __CLR_OR_THIS_CALL swap(basic_istream& _Right) noexcept /* strengthened */ {
        _Myios::swap(_Right);
        _STD swap(_Chcount, _Right._Chcount);
    }

public:
    __CLR_OR_THIS_CALL basic_istream(const basic_istream&) = delete;
    basic_istream& __CLR_OR_THIS_CALL operator=(const basic_istream&) = delete;

    __CLR_OR_THIS_CALL ~basic_istream() noexcept override {}

    using int_type = typename _Traits::int_type;
    using pos_type = typename _Traits::pos_type;
    using off_type = typename _Traits::off_type;

    class _Sentry_base {
    public:
        __CLR_OR_THIS_CALL _Sentry_base(basic_istream& _Istr) : _Myistr(_Istr) {
            const auto _Rdbuf = _Myistr.rdbuf();
            if (_Rdbuf) {
                _Rdbuf->_Lock();
            }
        }

        __CLR_OR_THIS_CALL ~_Sentry_base() noexcept {
            const auto _Rdbuf = _Myistr.rdbuf();
            if (_Rdbuf) {
                _Rdbuf->_Unlock();
            }
        }

        basic_istream& _Myistr;

        _Sentry_base& operator=(const _Sentry_base&) = delete;
    };

    class sentry : public _Sentry_base {
    public:
        explicit __CLR_OR_THIS_CALL sentry(basic_istream& _Istr, bool _Noskip = false)
            : _Sentry_base(_Istr), _Ok(_Sentry_base::_Myistr._Ipfx(_Noskip)) {}

        explicit __CLR_OR_THIS_CALL operator bool() const {
            return _Ok;
        }

        __CLR_OR_THIS_CALL sentry(const sentry&) = delete;
        sentry& __CLR_OR_THIS_CALL operator=(const sentry&) = delete;

    private:
        bool _Ok; // true if _Ipfx succeeded at construction
    };

    bool __CLR_OR_THIS_CALL _Ipfx(bool _Noskip = false) { // test stream state and skip whitespace as needed
        if (!this->good()) {
            _Myios::setstate(ios_base::failbit);
            return false;
        }

        // state okay, flush tied stream and skip whitespace
        const auto _Tied = _Myios::tie();
        if (_Tied) {
            _Tied->flush();
        }

        bool _Eof = false;
        if (!_Noskip && this->flags() & ios_base::skipws) { // skip whitespace
            const _Ctype& _Ctype_fac = _STD use_facet<_Ctype>(this->getloc());

            _TRY_IO_BEGIN
                int_type _Meta = _Myios::rdbuf()->sgetc();

            for (;; _Meta = _Myios::rdbuf()->snextc()) {
                if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { // end of file, quit
                    _Eof = true;
                    break;
                }
                else if (!_Ctype_fac.is(_Ctype::space, _Traits::to_char_type(_Meta))) {
                    break; // not whitespace, quit
                }
            }
            _CATCH_IO_END
        }

        if (_Eof) {
            _Myios::setstate(ios_base::eofbit | ios_base::failbit);
        }

        return this->good();
    }

#pragma push_macro("ipfx")
#pragma push_macro("isfx")
#undef ipfx
#undef isfx
    // TRANSITION, ABI: non-Standard ipfx() is preserved for binary compatibility
    _DEPRECATE_IO_PFX_SFX bool __CLR_OR_THIS_CALL ipfx(bool _Noskip = false) {
        // test stream state and skip whitespace as needed
        return _Ipfx(_Noskip);
    }

    // TRANSITION, ABI: non-Standard isfx() is preserved for binary compatibility
    _DEPRECATE_IO_PFX_SFX void __CLR_OR_THIS_CALL isfx() {} // perform any wrapup
#pragma pop_macro("isfx")
#pragma pop_macro("ipfx")

#ifdef _M_CEE_PURE
    basic_istream& __CLR_OR_THIS_CALL operator>>(basic_istream& (__clrcall* _Pfn)(basic_istream&)) {
        // call basic_istream manipulator
        return _Pfn(*this);
    }

    basic_istream& __CLR_OR_THIS_CALL operator>>(_Myios& (__clrcall* _Pfn)(_Myios&)) { // call basic_ios manipulator
        _Pfn(*this);
        return *this;
    }

    basic_istream& __CLR_OR_THIS_CALL operator>>(ios_base& (__clrcall* _Pfn)(ios_base&)) { // call ios_base manipulator
        _Pfn(*this);
        return *this;
    }
#endif // defined(_M_CEE_PURE)

    basic_istream& __CLR_OR_THIS_CALL operator>>(basic_istream& (__cdecl* _Pfn)(basic_istream&)) {
        // call basic_istream manipulator
        return _Pfn(*this);
    }

    basic_istream& __CLR_OR_THIS_CALL operator>>(_Myios& (__cdecl* _Pfn)(_Myios&)) { // call basic_ios manipulator
        _Pfn(*this);
        return *this;
    }

    basic_istream& __CLR_OR_THIS_CALL operator>>(ios_base& (__cdecl* _Pfn)(ios_base&)) { // call ios_base manipulator
        _Pfn(*this);
        return *this;
    }

private:
    template <class _Ty>
    basic_istream& _Common_extract_with_num_get(_Ty& _Val) { // formatted extract with num_get
        ios_base::iostate _Err = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { // state okay, use facet to extract
            _TRY_IO_BEGIN
                _STD use_facet<_Nget>(this->getloc()).get(*this, {}, *this, _Err, _Val);
            _CATCH_IO_END
        }

        _Myios::setstate(_Err);
        return *this;
    }

    template <class = void>
    void _Increment_gcount() noexcept {
        if (_Chcount != (numeric_limits<streamsize>::max)()) {
            ++_Chcount;
        }
    }

public:
    basic_istream& __CLR_OR_THIS_CALL operator>>(bool& _Val) { // extract a boolean
        return _Common_extract_with_num_get(_Val);
    }

    basic_istream& __CLR_OR_THIS_CALL operator>>(short& _Val) { // extract a short
        ios_base::iostate _Err = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { // state okay, use facet to extract
            _TRY_IO_BEGIN
                long _Lval;
            _STD use_facet<_Nget>(this->getloc()).get(*this, {}, *this, _Err, _Lval);
            if (_Lval < SHRT_MIN) {
                _Err |= ios_base::failbit;
                _Val = SHRT_MIN;
            }
            else if (_Lval > SHRT_MAX) {
                _Err |= ios_base::failbit;
                _Val = SHRT_MAX;
            }
            else {
                _Val = static_cast<short>(_Lval);
            }
            _CATCH_IO_END
        }

        _Myios::setstate(_Err);
        return *this;
    }

    // NOTE:
    // If you are not using native wchar_t, the unsigned short extractor
    // is masked by an explicit specialization that treats an unsigned
    // short as a wide character.

    // To read or write unsigned shorts as integers with wchar_t streams,
    // make wchar_t a native type with the command line option /Zc:wchar_t.

    basic_istream& __CLR_OR_THIS_CALL operator>>(unsigned short& _Val) { // extract an unsigned short
        return _Common_extract_with_num_get(_Val);
    }

    basic_istream& __CLR_OR_THIS_CALL operator>>(int& _Val) { // extract an int
        static_assert(sizeof(int) == sizeof(long), "Bad overflow assumptions due to sizeof(int) != sizeof(long)");
        long _Result = _Val;
        _Common_extract_with_num_get(_Result);
        _Val = _Result;
        return *this;
    }

    basic_istream& __CLR_OR_THIS_CALL operator>>(unsigned int& _Val) { // extract an unsigned int
        return _Common_extract_with_num_get(_Val);
    }

    basic_istream& __CLR_OR_THIS_CALL operator>>(long& _Val) { // extract a long
        return _Common_extract_with_num_get(_Val);
    }

    basic_istream& __CLR_OR_THIS_CALL operator>>(unsigned long& _Val) { // extract an unsigned long
        return _Common_extract_with_num_get(_Val);
    }

    basic_istream& __CLR_OR_THIS_CALL operator>>(long long& _Val) { // extract a long long
        return _Common_extract_with_num_get(_Val);
    }

    basic_istream& __CLR_OR_THIS_CALL operator>>(unsigned long long& _Val) { // extract an unsigned long long
        return _Common_extract_with_num_get(_Val);
    }

    basic_istream& __CLR_OR_THIS_CALL operator>>(float& _Val) { // extract a float
        return _Common_extract_with_num_get(_Val);
    }

    basic_istream& __CLR_OR_THIS_CALL operator>>(double& _Val) { // extract a double
        return _Common_extract_with_num_get(_Val);
    }

    basic_istream& __CLR_OR_THIS_CALL operator>>(long double& _Val) { // extract a long double
        return _Common_extract_with_num_get(_Val);
    }

    basic_istream& __CLR_OR_THIS_CALL operator>>(void*& _Val) { // extract a void pointer
        return _Common_extract_with_num_get(_Val);
    }

    basic_istream& __CLR_OR_THIS_CALL operator>>(_Mysb* _Strbuf) { // extract until end-of-file into a stream buffer
        _Chcount = 0; // behaves as an unformatted input function
        const sentry _Ok(*this, true);
        ios_base::iostate _State = ios_base::goodbit;
        if (_Ok && _Strbuf) { // state okay, extract characters
            _TRY_IO_BEGIN
                for (int_type _Meta = _Myios::rdbuf()->sgetc();; _Meta = _Myios::rdbuf()->snextc()) {
                    if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { // end of file, quit
                        _State |= ios_base::eofbit;
                        break;
                    }
                    // got a character, insert it into buffer
                    _TRY_BEGIN
                        if (_Traits::eq_int_type(_Traits::eof(), _Strbuf->sputc(_Traits::to_char_type(_Meta)))) {
                            break;
                        }

                    _CATCH_ALL
                        break;
                    _CATCH_END

                        _Increment_gcount();
                }
            _CATCH_IO_END
        }

        if (_Chcount == 0) { // If the function inserts no characters, it calls setstate(failbit)
            _State |= ios_base::failbit;
        }

        _Myios::setstate(_State);
        return *this;
    }

    int_type __CLR_OR_THIS_CALL get() { // extract a metacharacter
        int_type _Meta = 0;
        ios_base::iostate _State = ios_base::goodbit;
        _Chcount = 0;
        const sentry _Ok(*this, true);

        if (!_Ok) {
            _Meta = _Traits::eof(); // state not okay, return EOF
        }
        else { // state okay, extract a character
            _TRY_IO_BEGIN
                _Meta = _Myios::rdbuf()->sgetc();

            if (_Traits::eq_int_type(_Traits::eof(), _Meta)) {
                _State |= ios_base::eofbit | ios_base::failbit; // end of file
            }
            else { // got a character, count it
                _Myios::rdbuf()->sbumpc();
                _Chcount = 1;
            }
            _CATCH_IO_END
        }

        _Myios::setstate(_State);
        return _Meta;
    }

    basic_istream& __CLR_OR_THIS_CALL get(_Elem* _Str, streamsize _Count) { // get up to _Count characters into NTCS
        return get(_Str, _Count, _Myios::widen('\n'));
    }

    basic_istream& __CLR_OR_THIS_CALL get(_Elem* _Str, streamsize _Count, _Elem _Delim) {
        // get up to _Count characters into NTCS, stop before _Delim
        ios_base::iostate _State = ios_base::goodbit;
        _Chcount = 0;
        const sentry _Ok(*this, true);

        if (_Ok && 0 < _Count) { // state okay, extract characters
            _TRY_IO_BEGIN
                int_type _Meta = _Myios::rdbuf()->sgetc();

            for (; 0 < --_Count; _Meta = _Myios::rdbuf()->snextc()) {
                if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { // end of file, quit
                    _State |= ios_base::eofbit;
                    break;
                }
                else if (_Traits::to_char_type(_Meta) == _Delim) {
                    break; // got a delimiter, quit
                }
                else { // got a character, add it to string
                    *_Str++ = _Traits::to_char_type(_Meta);
                    _Increment_gcount();
                }
            }
            _CATCH_IO_END
        }

        _Myios::setstate(_Chcount == 0 ? _State | ios_base::failbit : _State);
        *_Str = _Elem(); // add terminating null character
        return *this;
    }

    basic_istream& __CLR_OR_THIS_CALL get(_Elem& _Ch) { // get a character
        int_type _Meta = get();
        if (!_Traits::eq_int_type(_Traits::eof(), _Meta)) {
            _Ch = _Traits::to_char_type(_Meta);
        }

        return *this;
    }

    basic_istream& __CLR_OR_THIS_CALL get(_Mysb& _Strbuf) { // extract up to newline and insert into stream buffer
        return get(_Strbuf, _Myios::widen('\n'));
    }

    basic_istream& __CLR_OR_THIS_CALL get(_Mysb& _Strbuf, _Elem _Delim) {
        // extract up to delimiter and insert into stream buffer
        ios_base::iostate _State = ios_base::goodbit;
        _Chcount = 0;
        const sentry _Ok(*this, true);

        if (_Ok) { // state okay, use facet to extract
            _TRY_IO_BEGIN
                int_type _Meta = _Myios::rdbuf()->sgetc();

            for (;; _Meta = _Myios::rdbuf()->snextc()) {
                if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { // end of file, quit
                    _State |= ios_base::eofbit;
                    break;
                }
                else { // got a character, insert it into stream buffer
                    _TRY_BEGIN
                        _Elem _Ch = _Traits::to_char_type(_Meta);
                    if (_Ch == _Delim || _Traits::eq_int_type(_Traits::eof(), _Strbuf.sputc(_Ch))) {
                        break;
                    }
                    _CATCH_ALL
                        break;
                    _CATCH_END
                        _Increment_gcount();
                }
            }
            _CATCH_IO_END
        }

        if (_Chcount == 0) {
            _State |= ios_base::failbit;
        }
        _Myios::setstate(_State);
        return *this;
    }

    basic_istream& __CLR_OR_THIS_CALL getline(_Elem* _Str, streamsize _Count) {
        // get up to _Count characters into NTCS, discard newline
        return getline(_Str, _Count, _Myios::widen('\n'));
    }

    basic_istream& __CLR_OR_THIS_CALL getline(_Elem* _Str, streamsize _Count, _Elem _Delim) {
        // get up to _Count characters into NTCS, discard _Delim
        ios_base::iostate _State = ios_base::goodbit;
        _Chcount = 0;
        const sentry _Ok(*this, true);

        if (_Ok && 0 < _Count) { // state okay, use facet to extract
            int_type _Metadelim = _Traits::to_int_type(_Delim);

            _TRY_IO_BEGIN
                int_type _Meta = _Myios::rdbuf()->sgetc();

            for (;; _Meta = _Myios::rdbuf()->snextc()) {
                if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { // end of file, quit
                    _State |= ios_base::eofbit;
                    break;
                }
                else if (_Meta == _Metadelim) { // got a delimiter, discard it and quit
                    _Increment_gcount();
                    _Myios::rdbuf()->sbumpc();
                    break;
                }
                else if (--_Count <= 0) { // buffer full, quit
                    _State |= ios_base::failbit;
                    break;
                }
                else { // got a character, add it to string
                    *_Str++ = _Traits::to_char_type(_Meta);
                    _Increment_gcount();
                }
            }
            _CATCH_IO_END
        }

        *_Str = _Elem(); // add terminating null character
        _Myios::setstate(_Chcount == 0 ? _State | ios_base::failbit : _State);
        return *this;
    }

    basic_istream& __CLR_OR_THIS_CALL ignore(streamsize _Count = 1, int_type _Metadelim = _Traits::eof()) {
        // ignore up to _Count characters, discarding delimiter
        ios_base::iostate _State = ios_base::goodbit;
        _Chcount = 0;
        const sentry _Ok(*this, true);

        if (_Ok && 0 < _Count) { // state okay, use facet to extract
            _TRY_IO_BEGIN
                for (;;) { // get a metacharacter if more room in buffer
                    int_type _Meta;
                    if (_Count != (numeric_limits<streamsize>::max)() && --_Count < 0) {
                        break; // buffer full, quit
                    }
                    else if (_Traits::eq_int_type(_Traits::eof(),
                        _Meta = _Myios::rdbuf()->sbumpc())) { // end of file, quit
                        _State |= ios_base::eofbit;
                        break;
                    }
                    else { // got a character, count it
                        _Increment_gcount();
                        if (_Meta == _Metadelim) {
                            break; // got a delimiter, quit
                        }
                    }
                }
            _CATCH_IO_END
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_istream& __CLR_OR_THIS_CALL read(_Elem* _Str, streamsize _Count) { // read up to _Count characters into buffer
        ios_base::iostate _State = ios_base::goodbit;
        _Chcount = 0;
        const sentry _Ok(*this, true);

        if (_Ok && 0 < _Count) { // state okay, use facet to extract
            _TRY_IO_BEGIN
                const streamsize _Num = _Myios::rdbuf()->sgetn(_Str, _Count);
            _Chcount = _Num;

            if (_Num != _Count) {
                _State |= ios_base::eofbit | ios_base::failbit; // short read
            }
            _CATCH_IO_END
        }

        _Myios::setstate(_State);
        return *this;
    }

    streamsize __CLR_OR_THIS_CALL readsome(_Elem* _Str, streamsize _Count) {
        // read up to _Count characters into buffer, without blocking
        ios_base::iostate _State = ios_base::goodbit;
        _Chcount = 0;
        const sentry _Ok(*this, true);
        streamsize _Num;

        if (!_Ok) {
            _State |= ios_base::failbit; // no buffer, fail
        }
        else if ((_Num = _Myios::rdbuf()->in_avail()) < 0) {
            _State |= ios_base::eofbit; // no characters available
        }
        else if (0 < _Count && 0 < _Num) { // read available
            read(_Str, _Num < _Count ? _Num : _Count);
        }

        _Myios::setstate(_State);
        return gcount();
    }

    int_type __CLR_OR_THIS_CALL peek() {
        ios_base::iostate _State = ios_base::goodbit;
        _Chcount = 0;
        int_type _Meta = 0;
        const sentry _Ok(*this, true);

        if (!_Ok) {
            _Meta = _Traits::eof(); // state not okay, return EOF
        }
        else { // state okay, read a character
            _TRY_IO_BEGIN
                if (_Traits::eq_int_type(_Traits::eof(), _Meta = _Myios::rdbuf()->sgetc())) {
                    _State |= ios_base::eofbit;
                }
            _CATCH_IO_END
        }

        _Myios::setstate(_State);
        return _Meta;
    }

    basic_istream& __CLR_OR_THIS_CALL putback(_Elem _Ch) { // put back a character
        _Chcount = 0;
        ios_base::iostate _State = ios_base::goodbit;
        ios_base::iostate _Oldstate = _Myios::rdstate();
        _Myios::clear(_Oldstate & ~ios_base::eofbit);
        const sentry _Ok(*this, true);

        if (_Ok) { // state okay, put character back
            _TRY_IO_BEGIN
                if (_Traits::eq_int_type(_Traits::eof(), _Myios::rdbuf()->sputbackc(_Ch))) {
                    _State |= ios_base::badbit | _Oldstate;
                }
            _CATCH_IO_END
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_istream& __CLR_OR_THIS_CALL unget() { // put back last read character
        _Chcount = 0;
        ios_base::iostate _State = ios_base::goodbit;
        ios_base::iostate _Oldstate = _Myios::rdstate();
        _Myios::clear(_Oldstate & ~ios_base::eofbit);
        const sentry _Ok(*this, true);

        if (_Ok) { // state okay, put character back
            _TRY_IO_BEGIN
                if (_Traits::eq_int_type(_Traits::eof(), _Myios::rdbuf()->sungetc())) {
                    _State |= ios_base::badbit | _Oldstate;
                }
            _CATCH_IO_END
        }

        _Myios::setstate(_State);
        return *this;
    }

    _NODISCARD streamsize __CLR_OR_THIS_CALL gcount() const noexcept /* strengthened */ {
        // get count from last extraction
        return _Chcount;
    }

    int __CLR_OR_THIS_CALL sync() { // synchronize with input source
        const sentry _Ok(*this, true);

        const auto _Rdbuf = _Myios::rdbuf();
        if (!_Rdbuf) {
            return -1;
        }

        ios_base::iostate _State = ios_base::goodbit;
        _TRY_BEGIN
            if (_Rdbuf->pubsync() == -1) {
                _State |= ios_base::badbit;
            }
        _CATCH_ALL
            _Myios::setstate(ios_base::badbit, true);
        return -1;
        _CATCH_END

            if (_State & ios_base::badbit) {
                _Myios::setstate(ios_base::badbit);
                return -1;
            }

        return 0;
    }

    basic_istream& __CLR_OR_THIS_CALL seekg(pos_type _Pos) { // set input stream position to _Pos
        ios_base::iostate _State = ios_base::goodbit;
        ios_base::iostate _Oldstate = _Myios::rdstate();
        _Myios::clear(_Oldstate & ~ios_base::eofbit);
        const sentry _Ok(*this, true);

        if (!this->fail()) {
            _TRY_IO_BEGIN
                if (static_cast<off_type>(_Myios::rdbuf()->pubseekpos(_Pos, ios_base::in)) == -1) {
                    _State |= ios_base::failbit;
                }
            _CATCH_IO_END
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_istream& __CLR_OR_THIS_CALL seekg(off_type _Off, ios_base::seekdir _Way) {
        // change input stream position by _Off, according to _Way
        ios_base::iostate _State = ios_base::goodbit;
        ios_base::iostate _Oldstate = _Myios::rdstate();
        _Myios::clear(_Oldstate & ~ios_base::eofbit);
        const sentry _Ok(*this, true);

        if (!this->fail()) {
            _TRY_IO_BEGIN
                if (static_cast<off_type>(_Myios::rdbuf()->pubseekoff(_Off, _Way, ios_base::in)) == -1) {
                    _State |= ios_base::failbit;
                }
            _CATCH_IO_END
        }

        _Myios::setstate(_State);
        return *this;
    }

    pos_type __CLR_OR_THIS_CALL tellg() {
        const sentry _Ok(*this, true);

        if (!this->fail()) {
            _TRY_IO_BEGIN
                return _Myios::rdbuf()->pubseekoff(0, ios_base::cur, ios_base::in);
            _CATCH_IO_END
        }

        return pos_type{ off_type{-1} };
    }

private:
    streamsize _Chcount{}; // the character count
};

#pragma vtordisp(pop) // compiler bug workaround

#ifndef _NATIVE_WCHAR_T_DEFINED
template <class _Elem, class _Traits>
basic_istream<_Elem, _Traits>& operator>>(basic_istream<_Elem, _Traits>& _Istr, _Elem& _Ch);

// NOTE:
// If you are not using native wchar_t, the following explicit
// specialization will mask the member function (above) that treats
// an unsigned short as an integer.

// To read or write unsigned shorts as integers with wchar_t streams,
// make wchar_t a native type with the command line option /Zc:wchar_t.

template <>
inline basic_istream<unsigned short, char_traits<unsigned short>>& __CLR_OR_THIS_CALL basic_istream<unsigned short,
    char_traits<unsigned short>>::operator>>(unsigned short& _Ch) { // extract a character
    return _STD operator>>(*this, _Ch);
}
#endif // !defined(_NATIVE_WCHAR_T_DEFINED)

#if defined(_DLL_CPPLIB)

#if !defined(_CRTBLD) || defined(__FORCE_INSTANCE)
template class _CRTIMP2_PURE_IMPORT basic_istream<char, char_traits<char>>;
template class _CRTIMP2_PURE_IMPORT basic_istream<wchar_t, char_traits<wchar_t>>;
#endif // !defined(_CRTBLD) || defined(__FORCE_INSTANCE)

#ifdef __FORCE_INSTANCE
template class _CRTIMP2_PURE_IMPORT basic_istream<unsigned short, char_traits<unsigned short>>;
#endif // defined(__FORCE_INSTANCE)
#endif // defined(_DLL_CPPLIB)

_EXPORT_STD extern "C++" template <class _Elem, class _Traits>
class basic_iostream : public basic_istream<_Elem, _Traits>,
    public basic_ostream<_Elem, _Traits> { // control insertions and extractions from a stream buffer
public:
    using _Myis = basic_istream<_Elem, _Traits>;
    using _Myos = basic_ostream<_Elem, _Traits>;
    using _Myios = basic_ios<_Elem, _Traits>;
    using char_type = _Elem;
    using traits_type = _Traits;
    using int_type = typename _Traits::int_type;
    using pos_type = typename _Traits::pos_type;
    using off_type = typename _Traits::off_type;

    explicit __CLR_OR_THIS_CALL basic_iostream(basic_streambuf<_Elem, _Traits>* _Strbuf)
        : _Myis(_Strbuf, false), _Myos(_Noinit, false) {}

protected:
    __CLR_OR_THIS_CALL basic_iostream(basic_iostream&& _Right) noexcept(false)
        : _Myis(_Right.rdbuf(), false), _Myos(_Noinit, false) {
        _Myios::init();
        _Myios::move(_STD move(_Right));
    }

    basic_iostream& __CLR_OR_THIS_CALL operator=(basic_iostream&& _Right) noexcept /* strengthened */ {
        this->swap(_Right);
        return *this;
    }

    void __CLR_OR_THIS_CALL swap(basic_iostream& _Right) noexcept /* strengthened */ {
        if (this != _STD addressof(_Right)) {
            _Myios::swap(_Right);
        }
    }

public:
    __CLR_OR_THIS_CALL basic_iostream(const basic_iostream&) = delete;
    basic_iostream& __CLR_OR_THIS_CALL operator=(const basic_iostream&) = delete;

    __CLR_OR_THIS_CALL ~basic_iostream() noexcept override {}
};

#if defined(_DLL_CPPLIB)

#if !defined(_CRTBLD) || defined(__FORCE_INSTANCE)
template class _CRTIMP2_PURE_IMPORT basic_iostream<char, char_traits<char>>;
template class _CRTIMP2_PURE_IMPORT basic_iostream<wchar_t, char_traits<wchar_t>>;
#endif // !defined(_CRTBLD) || defined(__FORCE_INSTANCE)

#ifdef __FORCE_INSTANCE
template class _CRTIMP2_PURE_IMPORT basic_iostream<unsigned short, char_traits<unsigned short>>;
#endif // defined(__FORCE_INSTANCE)
#endif // defined(_DLL_CPPLIB)

template <class _Elem, class _Traits>
basic_istream<_Elem, _Traits>& _Istream_extract_into_buffer(
    basic_istream<_Elem, _Traits>& _Istr, size_t _Size, _Elem* _Str) {
    using _Myis = basic_istream<_Elem, _Traits>;
    using _Ctype = ctype<_Elem>;
    ios_base::iostate _State = ios_base::goodbit;
    size_t _Current = 0;
    const typename _Myis::sentry _Ok(_Istr);

    if (_Ok) { // state okay, extract characters
        const _Ctype& _Ctype_fac = _STD use_facet<_Ctype>(_Istr.getloc());

        _TRY_IO_BEGIN
            size_t _Count = _Size;
        const size_t _Width = static_cast<size_t>(_Istr.width());
        if (_Width > 0 && _Width < _Size) {
            _Count = _Width;
        }

        typename _Myis::int_type _Meta = _Istr.rdbuf()->sgetc();
        _Elem _Ch;

        for (; _Current < _Count - 1; _Meta = _Istr.rdbuf()->snextc(), (void) ++_Current) {
            if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { // end of file, quit
                _State |= ios_base::eofbit;
                break;
            }
            else if (_Ctype_fac.is(_Ctype::space, _Ch = _Traits::to_char_type(_Meta)) || _Ch == _Elem()) {
                break; // whitespace or nul, quit
            }
            else {
                _Str[_Current] = _Traits::to_char_type(_Meta); // add it to string
            }
        }
        _CATCH_IO_(ios_base, _Istr)
    }
    _Analysis_assume_(static_cast<size_t>(_Current) < _Size); // TRANSITION, VSO-860375
    _Str[_Current] = _Elem(); // add terminating null character
    _Istr.width(0);
    if (_Current == 0) {
        _State |= ios_base::failbit;
    }
    _Istr.setstate(_State);
    return _Istr;
}

#if _HAS_CXX20 // P0487R1 Fixing operator>>(basic_istream&, CharT*)
#pragma warning(push)
#pragma warning(disable : 6001) // Using uninitialized memory '_Str'.
_EXPORT_STD template <class _Elem, class _Traits, size_t _Size>
basic_istream<_Elem, _Traits>& operator>>(
    basic_istream<_Elem, _Traits>& _Istr, _Out_writes_z_(_Size) _Elem(&_Str)[_Size]) {
    return _Istream_extract_into_buffer(_Istr, _Size, _Str);
}

_EXPORT_STD template <class _Traits, size_t _Size>
basic_istream<char, _Traits>& operator>>(
    basic_istream<char, _Traits>& _Istr, _Out_writes_z_(_Size) signed char(&_Str)[_Size]) {
    return _Istream_extract_into_buffer(_Istr, _Size, reinterpret_cast<char*>(_Str));
}

_EXPORT_STD template <class _Traits, size_t _Size>
basic_istream<char, _Traits>& operator>>(
    basic_istream<char, _Traits>& _Istr, _Out_writes_z_(_Size) unsigned char(&_Str)[_Size]) {
    return _Istream_extract_into_buffer(_Istr, _Size, reinterpret_cast<char*>(_Str));
}
#pragma warning(pop)
#else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
template <class _Elem, class _Traits>
basic_istream<_Elem, _Traits>& operator>>(basic_istream<_Elem, _Traits>& _Istr, _Elem* _Str) {
    return _Istream_extract_into_buffer(_Istr, SIZE_MAX, _Str);
}

template <class _Traits>
basic_istream<char, _Traits>& operator>>(basic_istream<char, _Traits>& _Istr, signed char* _Str) {
    return _Istream_extract_into_buffer(_Istr, SIZE_MAX, reinterpret_cast<char*>(_Str));
}

template <class _Traits>
basic_istream<char, _Traits>& operator>>(basic_istream<char, _Traits>& _Istr, unsigned char* _Str) {
    return _Istream_extract_into_buffer(_Istr, SIZE_MAX, reinterpret_cast<char*>(_Str));
}
#endif // ^^^ !_HAS_CXX20 ^^^

_EXPORT_STD template <class _Elem, class _Traits>
basic_istream<_Elem, _Traits>& operator>>(basic_istream<_Elem, _Traits>& _Istr, _Elem& _Ch) { // extract a character
    using _Myis = basic_istream<_Elem, _Traits>;

    typename _Myis::int_type _Meta;
    ios_base::iostate _State = ios_base::goodbit;
    const typename _Myis::sentry _Ok(_Istr);

    if (_Ok) { // state okay, extract characters
        _TRY_IO_BEGIN
            _Meta = _Istr.rdbuf()->sbumpc();
        if (_Traits::eq_int_type(_Traits::eof(), _Meta)) {
            _State |= ios_base::eofbit | ios_base::failbit; // end of file
        }
        else {
            _Ch = _Traits::to_char_type(_Meta); // got a character
        }
        _CATCH_IO_(ios_base, _Istr)
    }

    _Istr.setstate(_State);
    return _Istr;
}

_EXPORT_STD template <class _Traits>
basic_istream<char, _Traits>& operator>>(basic_istream<char, _Traits>& _Istr, signed char& _Ch) {
    // extract a signed char
    return _Istr >> reinterpret_cast<char&>(_Ch);
}

_EXPORT_STD template <class _Traits>
basic_istream<char, _Traits>& operator>>(basic_istream<char, _Traits>& _Istr, unsigned char& _Ch) {
    // extract an unsigned char
    return _Istr >> reinterpret_cast<char&>(_Ch);
}

template <class _Istr, class _Ty, class = void>
struct _Can_stream_in : false_type {};

template <class _Istr, class _Ty>
struct _Can_stream_in<_Istr, _Ty, void_t<decltype(_STD declval<_Istr&>() >> _STD declval<_Ty>())>> : true_type {};

_EXPORT_STD template <class _Istr, class _Ty,
    enable_if_t<conjunction_v<is_convertible<_Istr*, ios_base*>, _Can_stream_in<_Istr, _Ty>>, int> = 0>
    _Istr&& operator>>(_Istr&& _Is, _Ty&& _Val) { // extract from rvalue stream
    _Is >> _STD forward<_Ty>(_Val);
    return _STD move(_Is);
}

_EXPORT_STD template <class _Elem, class _Traits>
basic_istream<_Elem, _Traits>& __CLRCALL_OR_CDECL ws(basic_istream<_Elem, _Traits>& _Istr) { // consume whitespace
    const typename basic_istream<_Elem, _Traits>::sentry _Ok(_Istr, true);

    if (_Ok) { // state okay, extract characters
        ios_base::iostate _State = ios_base::goodbit;
        const auto& _Ctype_fac = _STD use_facet<ctype<_Elem>>(_Istr.getloc());

        _TRY_IO_BEGIN
            for (typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();; _Meta = _Istr.rdbuf()->snextc()) {
                if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { // end of file, quit
                    _State |= ios_base::eofbit;
                    break;
                }
                else if (!_Ctype_fac.is(ctype<_Elem>::space, _Traits::to_char_type(_Meta))) {
                    break; // not whitespace, quit
                }
            }
        _CATCH_IO_(ios_base, _Istr)
            _Istr.setstate(_State);
    }

    return _Istr;
}
_STD_END

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)


#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new
_STD_BEGIN
#ifdef _M_CEE_PURE
__PURE_APPDOMAIN_GLOBAL extern istream cin;
__PURE_APPDOMAIN_GLOBAL extern ostream cout;
__PURE_APPDOMAIN_GLOBAL extern ostream cerr;
__PURE_APPDOMAIN_GLOBAL extern ostream clog;
__PURE_APPDOMAIN_GLOBAL extern istream* _Ptr_cin;
__PURE_APPDOMAIN_GLOBAL extern ostream* _Ptr_cout;
__PURE_APPDOMAIN_GLOBAL extern ostream* _Ptr_cerr;
__PURE_APPDOMAIN_GLOBAL extern ostream* _Ptr_clog;

__PURE_APPDOMAIN_GLOBAL extern wistream wcin;
__PURE_APPDOMAIN_GLOBAL extern wostream wcout;
__PURE_APPDOMAIN_GLOBAL extern wostream wcerr;
__PURE_APPDOMAIN_GLOBAL extern wostream wclog;
__PURE_APPDOMAIN_GLOBAL extern wistream* _Ptr_wcin;
__PURE_APPDOMAIN_GLOBAL extern wostream* _Ptr_wcout;
__PURE_APPDOMAIN_GLOBAL extern wostream* _Ptr_wcerr;
__PURE_APPDOMAIN_GLOBAL extern wostream* _Ptr_wclog;
#else // ^^^ defined(_M_CEE_PURE) / !defined(_M_CEE_PURE) vvv
_EXPORT_STD extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT istream cin;
_EXPORT_STD extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT ostream cout;
_EXPORT_STD extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT ostream cerr;
_EXPORT_STD extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT ostream clog;
extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT istream* _Ptr_cin;
extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT ostream* _Ptr_cout;
extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT ostream* _Ptr_cerr;
extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT ostream* _Ptr_clog;

_EXPORT_STD extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT wistream wcin;
_EXPORT_STD extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT wostream wcout;
_EXPORT_STD extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT wostream wcerr;
_EXPORT_STD extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT wostream wclog;
extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT wistream* _Ptr_wcin;
extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT wostream* _Ptr_wcout;
extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT wostream* _Ptr_wcerr;
extern "C++" __PURE_APPDOMAIN_GLOBAL _CRTDATA2_IMPORT wostream* _Ptr_wclog;

#ifdef _CRTBLD // TRANSITION, ABI: _Winit appears to be unused
class _CRTIMP2_PURE_IMPORT _Winit {
public:
    __thiscall _Winit();
    __thiscall ~_Winit() noexcept;

private:
    __PURE_APPDOMAIN_GLOBAL static int _Init_cnt;
};
#endif // defined(_CRTBLD)

#endif // ^^^ !defined(_M_CEE_PURE) ^^^
_STD_END
#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)


int main()
{
    std::cout << "Hello World!\n";
}
