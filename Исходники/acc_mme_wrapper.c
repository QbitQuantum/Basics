MME_ERROR acc_MME_SendCommand(MME_TransformerHandle_t Handle, MME_Command_t *CmdInfo_p)
{
	MME_ERROR mme_status;
	FILE *fcmd = NULL;
	int i, j, nbuf;
	if (log_enable == ACC_TRUE)
	{
		// log the command;
		int hdl_idx = handles_search(Handle);
		fcmd = cmd_log_lock();
		FWRITE(cmd_str[CMD_SEND], strlen(cmd_str[CMD_SEND]) + 1, 1, fcmd);
		FWRITE(&hdl_idx, sizeof(int), 1, fcmd);
		FWRITE(CmdInfo_p, sizeof(MME_Command_t), 1, fcmd);
		FWRITE(CmdInfo_p->Param_p, CmdInfo_p->ParamSize, 1, fcmd);
		// printk("Param: %d\n", ((int*)CmdInfo_p->Param_p)[2]);
		nbuf = CmdInfo_p->NumberInputBuffers + CmdInfo_p->NumberOutputBuffers;
		for (i = 0; i < nbuf; i++)
		{
			MME_DataBuffer_t *db = CmdInfo_p->DataBuffers_p[i];
			MME_ScatterPage_t *sc;
			FWRITE(db, sizeof(MME_DataBuffer_t), 1, fcmd);
			if (db->NumberOfScatterPages == 0)
			{
				// check whether a buffer is sent without any pages !! should never happen.
				//acc_warning(ACC_WARNING_NO_SCATTERPAGE_IN_BUFFER);
			}
			for (j = 0; j < db->NumberOfScatterPages; j++)
			{
				sc = &db->ScatterPages_p[j];
				FWRITE(sc, sizeof(MME_ScatterPage_t), 1, fcmd);
				if (sc->Size != 0)
				{
					if (i < CmdInfo_p->NumberInputBuffers)
					{
						FWRITE(sc->Page_p, sizeof(unsigned char), sc->Size, fcmd);
					}
				}
			}
		}
	}
	// send the command to get back the ID generated by Multicom
	mme_status = MME_SendCommand(Handle, CmdInfo_p);
	if (log_enable == ACC_TRUE)
	{
		// replace the ID in the local copy
		FWRITE(&CmdInfo_p->CmdStatus.CmdId, sizeof(unsigned int), 1, fcmd);
		cmd_log_release(fcmd);
	}
	return mme_status;
}