 const int32_t s1Len_PAD = s1Len+PAD;
 const int32_t s2Len_PAD = s2Len+PAD;
 int16_t * const restrict s1 = parasail_memalign_int16_t(16, s1Len+PAD);
 int16_t * const restrict s2B= parasail_memalign_int16_t(16, s2Len+PAD2);
 int16_t * const restrict _H_pr = parasail_memalign_int16_t(16, s2Len+PAD2);
 int16_t * const restrict _F_pr = parasail_memalign_int16_t(16, s2Len+PAD2);
 int16_t * const restrict s2 = s2B+PAD; /* will allow later for negative indices */
 int16_t * const restrict H_pr = _H_pr+PAD;
 int16_t * const restrict F_pr = _F_pr+PAD;
 parasail_result_t *result = parasail_result_new_trace(s1Len, s2Len, 16, sizeof(int8_t));
 int32_t i = 0;
 int32_t j = 0;
 int32_t end_query = s1Len-1;
 int32_t end_ref = s2Len-1;
 int16_t score = NEG_INF;
 __m128i vNegInf = _mm_set1_epi16(NEG_INF);
 __m128i vOpen = _mm_set1_epi16(open);
 __m128i vGap  = _mm_set1_epi16(gap);
 __m128i vOne = _mm_set1_epi16(1);
 __m128i vN = _mm_set1_epi16(N);
 __m128i vGapN = _mm_set1_epi16(gap*N);
 __m128i vNegOne = _mm_set1_epi16(-1);
 __m128i vI = _mm_set_epi16(0,1,2,3,4,5,6,7);
 __m128i vJreset = _mm_set_epi16(0,-1,-2,-3,-4,-5,-6,-7);
 __m128i vMax = vNegInf;
 __m128i vILimit = _mm_set1_epi16(s1Len);
 __m128i vILimit1 = _mm_sub_epi16(vILimit, vOne);
 __m128i vJLimit = _mm_set1_epi16(s2Len);
 __m128i vJLimit1 = _mm_sub_epi16(vJLimit, vOne);
 __m128i vIBoundary = _mm_set_epi16(
         -open-0*gap,