bool WglBitmapBufferedContext::createOffScreenBitmap(const int colorBitCount, const int colorPlaneCount)
{
#if 0
	// method #1
	memBmp_ = CreateCompatibleBitmap(hDC_, drawRegion_.getWidth(), drawRegion_.getHeight());
	//memBmp_ = CreateCompatibleBitmap(hDC_, (int)std::floor(viewingRegion_.getWidth() + 0.5), (int)std::floor(viewingRegion_.getHeight() + 0.5));
#else
	// method #2
	const size_t bufSize = !isPaletteUsed_ ? sizeof(BITMAPINFO) : sizeof(BITMAPINFO) + sizeof(RGBQUAD) * 255;
	const boost::scoped_array<unsigned char> buf(new unsigned char [bufSize]);
	memset(buf.get(), 0, bufSize);
	BITMAPINFO &bmiDIB = *(BITMAPINFO *)buf.get();

	// Following routine aligns given value to 4 bytes boundary.
	// The current implementation of DIB rendering in Windows 95/98/NT seems to be free from this alignment
	// but old version compatibility is needed.
#if 1
	const int width = ((drawRegion_.getWidth() + 3) / 4 * 4 > 0) ? drawRegion_.getWidth() : 4;
	const int height = (0 == drawRegion_.getHeight()) ? 1 : drawRegion_.getHeight();
#else
	const int viewingWidth = (int)std::floor(viewingRegion_.getWidth() + 0.5);
	const int viewingHeight = (int)std::floor(viewingRegion_.getHeight() + 0.5);
	const int width = ((viewingWidth + 3) / 4 * 4 > 0) ? viewingWidth : 4;
	const int height = (0 == viewingHeight) ? 1 : viewingHeight;
#endif

	bmiDIB.bmiHeader.biSize			= sizeof(BITMAPINFOHEADER);
	bmiDIB.bmiHeader.biWidth		= width;
	bmiDIB.bmiHeader.biHeight		= height;
	bmiDIB.bmiHeader.biPlanes		= colorPlaneCount;
	bmiDIB.bmiHeader.biBitCount		= colorBitCount;
	if (!isPaletteUsed_)
	{
		bmiDIB.bmiHeader.biCompression	= BI_RGB;
		bmiDIB.bmiHeader.biSizeImage	= 0;  // for BI_RGB

	   // offscreen surface generated by the DIB section
		memBmp_ = CreateDIBSection(memDC_, &bmiDIB, DIB_RGB_COLORS, &dibBits_, NULL, 0);
	}
	else
	{
		// FIXME [check] >>
		bmiDIB.bmiHeader.biCompression	= colorBitCount > 4 ? BI_RLE8 : BI_RLE4;
		bmiDIB.bmiHeader.biSizeImage	= width * height * 3;

		// when using 256 color
		PALETTEENTRY paletteEntry[256];
		GetPaletteEntries(shPalette_, 0, 256, paletteEntry);
		for (int i = 0; i < 256; ++i)
		{
			bmiDIB.bmiColors[i].rgbRed = paletteEntry[i].peRed;
			bmiDIB.bmiColors[i].rgbGreen = paletteEntry[i].peGreen;
			bmiDIB.bmiColors[i].rgbBlue = paletteEntry[i].peBlue;
			bmiDIB.bmiColors[i].rgbReserved = 0;
		}

		// offscreen surface generated by the DIB section
		memBmp_ = CreateDIBSection(memDC_, &bmiDIB, DIB_PAL_COLORS, &dibBits_, NULL, 0);
	}
	if (NULL == memBmp_ || NULL == dibBits_) return false;
	oldBmp_ = (HBITMAP)SelectObject(memDC_, memBmp_);
#endif

	return true;
}