/*! This function determines how many particles there are in a given block,
 *  based on the information in the header-structure.  It also flags particle
 *  types that are present in the block in the typelist array. If one wants to
 *  add a new output-block, this function should be augmented accordingly.
 */
int get_particles_in_block(enum iofields blocknr, int *typelist)
{
  int i, nall, ntot_withmasses, ngas, nstars;

  nall = 0;
  ntot_withmasses = 0;

  for(i = 0; i < numtype; i++)
    {
      typelist[i] = 0;

      if(header.npart[i] > 0)
	{
	  nall += header.npart[i];
	  typelist[i] = 1;
	}

      if(All.MassTable[i] == 0)
	ntot_withmasses += header.npart[i];
    }

  ngas = header.npart[0];
  nstars = header.npart[4];


  switch (blocknr)
    {
    case IO_POS:
    case IO_VEL:
    case IO_ACCEL:
    case IO_TSTP:
    case IO_ID:
    case IO_POT:

      return nall;
      break;

    case IO_MASS:
      for(i = 0; i < numtype; i++)
	{
	  typelist[i] = 0;
	  if(All.MassTable[i] == 0 && header.npart[i] > 0)
	    typelist[i] = 1;
	}
      return ntot_withmasses;
      break;

    case IO_U:
    case IO_RHO:
    case IO_HSML:
    case IO_DTENTR:
#ifdef POLYTROPE
    case IO_PRESSURE:
#endif
#ifdef CHEMCOOL
    case IO_CHEM:
    case IO_GAMMA:
#endif
#ifdef METALS_TG
    case IO_METALLICITY:
#endif
#ifdef SINKVAL
     case IO_SINK:
#endif
#ifdef RAYTRACE
    case IO_COLUMN:
#endif
      for(i = 1; i < numtype; i++)
	typelist[i] = 0;
      return ngas;
      break;
    }

  exit(212);
  return 0;
}