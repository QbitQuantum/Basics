/**
\details GOST_BASIC_STEP_CRYPT
Осуществляет основой шаг криптопреобразования.
Основной шаг криптообразования по своей сути является оператором, определяющим преобразование 64-битового блока данных.
Дополнительным параметром этого оператора является 32-битовый блок, в качестве которого используется какой-либо элемент ключа.
Предусматривает 7 шагов.
ШАГ 0. Определяет исходные данные для основного шага криптопреобразования.
ШАГ 1. Сложение с ключом.
ШАГ 2. Поблочная замена.
ШАГ 3. Циклический сдвиг на 11 бит влево.
ШАГ 4. Побитовое сложение.
ШАГ 5. Сдвиг по цепочке.
ШАГ 6. Полученное значение возвращается как результат выполнения алгоритма основго шага криптопреобразования.
параметры:
\param[in] *DATA Указатель на данные для зашифрования в формате GOST_PART_DATA.
\param[in] *GOST_Table Указатель на таблицу замены ГОСТ в 64 байтном формате
\param[in] GOST_Key - 32х битная часть ключа
\param[in] LastStep - Является ли шаг криптопреобразования последним?
TRUE - заносим результат в 32х битный накопитель N2
FALSE - предыдущее значение N1 сохраняется в N2, а результат пишем в N1.
DWORD - unsigned int 32 bit type
BYTE - unsigned int 8 bit type
*/
void GOST_BASIC_STEP_CRYPT(GOST_PART_DATA *DATA, BYTE *GOST_Table, DWORD GOST_Key, bool LastStep){
	typedef union{
		DWORD full;																	//Полное представление данных
		BYTE parts[_GOST_NODE_REPLACE_TABLE / 2];										//Часть представления данных - 8/2 = 4
	} GOST_PART_DATA_SUM;
	BYTE m;																			//Для поблочной замены
	BYTE tmp;																		//m=0..7, tmp - временная переменная
	/**
	\details
	Шаг 0. N - преобразуемый 64-битовый блока данных, в ходе выполнения шага, его младшая и старшая части (N1 и N2 соответственно)
	обрабатываются как отдельные 32-битовые целые числа без знака: N = (N1,N2); X - 32-битовый элемент ключа.
	N1 = LOW(DATA), N2 = HI(DATA)
	*/
	GOST_PART_DATA_SUM S;																//Для оператора S = (N1+X)mod32^2
	/**
	Шаг 1. Сложение с ключом. Младшая половина преобразуемого блока складывается по модулю 2^32 с используемым на шаге
	элементом ключа, результат передается на слудющий шаг.
	*/
	S.full = (DWORD)((*DATA).half[_GOST_PART_DATA_N1_HALF] + GOST_Key);				 //S = (N1 + X)mod32 ^ 2
	/**
	Шаг 2. Поблочная замена. 32-битовое значение, полученное на предыдущем шаге интерпретируется как массив из восьми 4-битовых блоков кода:
	S=(S0,S1,...S7,S8). Далее значение каждого из восьми блоков заменяется новым, которое выбирается по таблице замен следующим образом:
	значение блока Si меняется на Si-тый по порядку элемент (нумерация с 0) i-го узла замен (т.е. i-той строки таблицы замен, нумерация так же с 0).
	Другими словами, в качестве замены для значения блока выбирается элемент из таблицы замен с номером строки, равным номеру заменяемого блока как 4-битового
	целого неотрицательного числа. Тепер ьстановится понятным размер таблицы замен: число строк в ней равно числу 4-битовых элементов в 32-битовом блоке данных,
	т.е. 8, а число столбцов равно числу различных значений 4-битового блока данных, равному как известно 2^4 - 16.
	*/
	for (m = 0; m < (_GOST_NODE_REPLACE_TABLE / 2); m++)									//m=0..7
	{
		//S(m) = H(m,S(m)) H - Таблица замен
		//Битовые сдвиги - умножение или деление на 2 в какой-то степени.
		tmp = S.parts[m];
		S.parts[m] = *(GOST_Table + (tmp & 0x0F));										//LOW VALUE (tmp "побитовое И" 0x0F - 15) 
		GOST_Table += _GOST_MAX_NUMBER_OF_ELEMENTS_NODE_TABLE;							//Следующая строка таблицы замен
		S.parts[m] |= (*(GOST_Table + ((tmp & 0x0F) >> 4))) << 4;						//HI VALUE (|= - побитовое ИЛИ с присваиванием; <<,>> - побитовые сдвиги)
		GOST_Table += _GOST_MAX_NUMBER_OF_ELEMENTS_NODE_TABLE;							//Следующая строка таблицы замен
	}
	/**
	Шаг 3. Циклический сдвиг на 11 бит влево. Результат предыдущего шага сдвигается циклически на 11 бит в сторону старших разряодв и передается
	на следующий шаг.
	Шаг 4. Побитовое сложение. Значение полученное на шаге 3, побитно складывается по модулю 2 со старшей половиной преобразуемого блока.
	Шаг 5. Свдиг по цепочке: младшая часть преобразуемого блока сдвигается на место старшей, а на её место помещается результат выполнения предыдущего шага.
	Шаг 6. Полученное значение преобразуемого блока возвращается как результат выполнения алгоритма основого шага криптопреобразования.
	*/
	S.full = (*DATA).half[_GOST_PART_DATA_N2_HALF] ^ _lrotl(S.full, 11);				//S=<-R(11,S) S= XOR N2
	if (LastStep){																		//Если шаг преобразования последний,
		(*DATA).half[_GOST_PART_DATA_N2_HALF] = S.full;									//то в DATA пишем S.full (Шаг 6)
	}
	else{																				//Иначе Шаг 5
		(*DATA).half[_GOST_PART_DATA_N2_HALF] = (*DATA).half[_GOST_PART_DATA_N1_HALF];	//N2 = N1,
		(*DATA).half[_GOST_PART_DATA_N1_HALF] = S.full;									//N1 = S
	}
}