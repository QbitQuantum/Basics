	inline V3 Contact::calculate_friction_impulse(M3* inv_inertia_tensor)
	{

		F inverse_mass = bodies[0]->get_inverse_mass();
		auto o = relative_contact_position[0];

		//Usually you get a torque from an impulse by a cross product with the relative distance.
		//If we build a M3 from the relative distance in this way, we have a matrix
		//that goes from impulse to torque
		M3 impulse_to_torque = -M3(
			0, -o.z, o.y,
			o.z, 0, -o.x,
			-o.y, o.x, 0
			);
		M3 delta_vel_world = impulse_to_torque;
		delta_vel_world *= inv_inertia_tensor[0];	//Rotation generated by unit torque
		delta_vel_world *= impulse_to_torque;		//Same as crossing the relative contact pos. Gives linear vel generated by torque only
		delta_vel_world *= -1;						//M1 x M2 = - M2 x M1, thus the minus


		// Check if we need to the second body's data
		if (bodies[1])
		{
			auto o = relative_contact_position[1];
			impulse_to_torque = -M3(
				0, -o.z, o.y,
				o.z, 0, -o.x,
				-o.y, o.x, 0
				);

			M3 delta_vel_world_2 = impulse_to_torque;
			delta_vel_world_2 *= inv_inertia_tensor[1];	//Rotation generated by unit torque
			delta_vel_world_2 *= impulse_to_torque;		//Same as crossing the relative contact pos. Gives linear vel generated by torque only
			delta_vel_world_2 *= -1;						//M1 x M2 = - M2 x M1, thus the minus

			//combine velocities and masses
			delta_vel_world += delta_vel_world_2;
			inverse_mass += bodies[1]->get_inverse_mass();
		}

		//change base of matrix (B x M x B^-1) to get velocity in contact coords
		M3 delta_velocity = transpose(contact_to_world) * delta_vel_world * contact_to_world;

		//Add the linear velocity. Need to build a matrix like this:
		//m,0,0
		//0,m,0
		//0,0,m
		delta_velocity[0].x += inverse_mass;
		delta_velocity[1].y += inverse_mass;
		delta_velocity[2].z += inverse_mass;


		//From: 
		//unit velocity generated by impulse
		//To:
		//Impulse requires to generate unit velocity
		M3 impulse_matrix = inverse(delta_velocity);

		//Velocities to kill. The x element is the same as the frictionless impulse
		//and must be completely null out
		V3 vel_kill(desired_delta_velocity, -contact_velocity.y, -contact_velocity.z);

		//Get impulse necessary to kill the velocities
		V3 impulse_contact = impulse_matrix * vel_kill;

		//Get only the planar impulse
		F planar_impulse = sqrt(impulse_contact.y*impulse_contact.y + impulse_contact.z * impulse_contact.z);


		//The X of the impulse is the one along the normal.
		//This impulse, multiplied by friction, is the amount to overcome.
		//If the planar is greater, than there is enough force for dynamic friction
		if (planar_impulse > impulse_contact.x * friction) {
			impulse_contact.y /= planar_impulse;
			impulse_contact.z /= planar_impulse;

			//Recalculate delta_velocity (and store it in impulse_contact.X just for caching)
			impulse_contact.x =
				delta_velocity[0].x +
				delta_velocity[1].x * impulse_contact.y * friction +
				delta_velocity[2].x * impulse_contact.z * friction;
			impulse_contact.x = desired_delta_velocity / impulse_contact.x;
			impulse_contact.y *= friction * impulse_contact.x;
			impulse_contact.z *= friction * impulse_contact.x;

		}

		return impulse_contact;

	}