void NPmxExport::doExport() {
	int i, j;
	NVoice *voice_elem;
	NStaff *staff_elem;
	NTimeSig *timesig;
	NKeySig  *keysig;
	NClef *clef;
	QPtrList<QString> lyrNames;
	QString *lyrName;
	QString lyricslist[NUM_LYRICS];
	property_type kind;
	int count;
	int acr;
	bool staffsWritten, first;
	const char *endOfLine;
	int voice_count;
	int barpos;
	int count_of_lyrics;
	int idx;
	int multistaffnr;
	int numOfStaffsInMultistaff;
#if GCC_MAJ_VERS > 2
	ostringstream os;
	ostringstream *pmxout[2];
#else
	char obuffer[2][OBLONG];
	char buffer[BUFLONG];
	ostrstream os(buffer, 100);
	ostrstream *pmxout[2];
#endif
	badmeasure *bad;
	lastTone_ = 1000;
	lastLength_ = 1000;
	openSpecialEnding_ = 0;
	pendingSpecialEnd_ = 0;
	pendingEndSpecialEnd_ = false;
	tupletBase_ = 0;

	countof128th_ = 128;
	barNr_ = 1;
	tiePool_ = 0;
	slurPool_ = 0;
	vaPool_ = 0;
	pendingTimeSig_ = 0;
	pendingKeySig_ = 0;
	pendingSpecialEnd_ = 0;
	drum_problem_written_ = false;
	exportDialog_->getPMXOptions( pmxOpts_ );

	specialCharList_.clear();
	badlist_.clear();
	if (fileName.isNull())
		return;
	if (NResource::staffSelExport_ == 0) {
		NResource::staffSelExport_ = new bool[staffList_->count()];
		for (i = 0; i < (int)staffList_->count(); NResource::staffSelExport_[i++] = true);
		staffsToExport_ = staffList_->count();
	}
	else {
		staffsToExport_ = 0;
		for (i = 0; i < (int)staffList_->count(); i++) {
			if (NResource::staffSelExport_[i]) {
				staffsToExport_++;
			}
		}
	}
	out_.open(fileName);
	if (!out_) {
		os << "error opening file " << fileName << '\0';
#if GCC_MAJ_VERS > 2
		KMessageBox::sorry
		  (0, QString(os.str().c_str()), kapp->makeStdCaption(i18n("PMX export")));
#else
		KMessageBox::sorry
		  (0, QString(os.str()), kapp->makeStdCaption(i18n("PMX export")));
#endif
		return;
	}
#if GCC_MAJ_VERS > 2
	pmxout[0] = new ostringstream();
	pmxout[1] = new ostringstream();
#else
	pmxout[0] = new ostrstream(obuffer[0], OBLONG);
	pmxout[1] = new ostrstream(obuffer[1], OBLONG);
#endif
	va_descr_ = (struct trill_descr_str *) alloca(staffsToExport_ * sizeof(struct trill_descr_str));
	for (i = 0; i < staffsToExport_; i++) {
		va_descr_[i].trill_nr = -1;
	}
	LastPMXfile_ = fileName;
	voice_elem = staffList_->first()->getVoiceNr(0);
	keysig = voice_elem->getFirstKeysig();
	if (!keysig) {	
		keysig = new NKeySig(0, 0);
	}
	timesig = voice_elem->getFirstTimeSig();
	if (!timesig) {
		timesig = new NTimeSig(0, &NResource::nullprops_);
		timesig->setSignature(4, 4);
	}
	countof128th_ = timesig->numOf128th();
	mStaffInf_ = new NMultistaffInfo(mainWidget_, staffList_, staffList_->count());
	if (mStaffInf_->hasDisconnectedPianoBars()) {
		bad = new badmeasure(PMX_ERR_DISCONT_PIANO, 1 /*dummy */, 0 /* dummy */, 3 /*dummy */,  128 /*dummy */);
		badlist_.append(bad);
	}

	
	out_ << "%-----------------------------------------%" << endl;
	out_ << "%                                         %" << endl;
	out_ << "% PMX output generated by \"NoteEdit\"    %" << endl;
	out_ << "%                                         %" << endl;
	out_ << "%-----------------------------------------%" << endl;
	if (pmxOpts_.mLyr) {
		out_ << "---" << endl;
		out_ << "\\input musixtex" << endl;
		out_ << "\\input pmx" << endl;
		out_ << "\\input musixlyr" << endl << endl;
		lyrNames.setAutoDelete(true);
		for (i = 0, staff_elem = staffList_->first(); staff_elem; staff_elem = staffList_->next(), i++) {
			if (!NResource::staffSelExport_[i]) continue;
			voice_elem = staff_elem->getVoiceNr(0);
			if (!(count_of_lyrics = voice_elem->countOfLyricsLines())) continue;
			voice_elem->collectLyrics(lyricslist);
			lyrNames.clear();
			for (j = 0; j < NUM_LYRICS; j++) {
				if (!lyricslist[j].isEmpty()) {
					lyrName = new QString();
					if (count_of_lyrics < 2) {
						lyrName->sprintf("lyrstaff%d", staffsToExport_ - i);
					}
					else {
						lyrName->sprintf("lyrstaff%dverse%d", staffsToExport_ - i, j+1);
					}
					lyrNames.append(lyrName);
					out_ << "\\setlyrics{" << (*lyrName) << "}{" << lyrics2TeX(&(lyricslist[j])) << "}" << endl;
				}
			}
	
			out_ << "\\assignlyrics{" << (staffsToExport_ - i) << "}{";
			while(!lyrNames.isEmpty()) {
				out_ << *(lyrNames.first());
				lyrNames.remove();
				if (!lyrNames.isEmpty()) out_ << ',';
			}
			out_ << '}' << endl << endl;
		}
		out_ << "---" << endl;
	}
/*
	out_ << "---" << endl;
	out_ << "\\def\\mtxInterInstrument#1#2{\\setinterinstrument{#1}{#2\\Interligne}}" << endl;
	out_ << "\\def\\mtxStaffBottom#1{\\staffbotmarg #1\\Interligne}" << endl;
	out_ << "---" << endl << endl;
*/

	out_ << "% nv,noinst,mtrnuml,mtrdenl,mtrnump,mtrdenp,xmtrnum0,isig," << endl;
	out_ << "   " << staffsToExport_ << "    ";
	if (staffsToExport_ == mStaffInf_->getMultiStaffCount()) {
		out_ << staffsToExport_ << "      ";
	}
	else {
		out_ << '-' << mStaffInf_->getMultiStaffCount() << ' ';
		for (i = 0; i < mStaffInf_->getMultiStaffCount(); i++) {
			out_ << mStaffInf_->getStaffCount(mStaffInf_->getMultiStaffCount()-i-1) << ' ';
		}
	}
        out_ << timesig->getNumerator() << "      " <<  timesig->getDenominator() << "        " <<
		timesig->getNumerator() << "      " <<  timesig->getDenominator();
	acr = voice_elem->determineAnacrusis();
	if (acr>0) {
		out_ << "        " << ((double) acr / (128.0 / (double) timesig->getDenominator())) << "      ";
	}
	else {
		out_ << "        0      ";
	}
	if (keysig->isRegular(&kind, &count)) {
		if (kind == PROP_FLAT) count = -count;
		out_ << count << endl;
	}
	else {
		out_ << "0" << endl;
	}
	out_ << "% npages,nsyst,musicsize,fracindent" << endl;
	out_ << "    " << pmxOpts_.num << "    " << pmxOpts_.system << "      20       0.07" << endl;
	out_ << "%" << endl;

	for (i = 0; i < mStaffInf_->getMultiStaffCount(); i++) {
		if ((staff_elem = staffList_->at(mStaffInf_->getfirstStaffInMultistaff(mStaffInf_->getMultiStaffCount()-i-1))) == 0) {
			NResource::abort("NPmxExport::doExport: internal error", 1);
		}
		if (!staff_elem->staffName_.isEmpty()) {
			out_ << staff_elem->staffName_ << endl;
		}
		else {
			out_ << endl;
		}
	}
	for (i = 0, staff_elem = staffList_->last(); staff_elem; staff_elem = staffList_->prev(), i++) {
		if (!NResource::staffSelExport_[staffList_->count() - i - 1]) continue;
		if ((voice_count = staff_elem->voiceCount()) > 2) {
			bad = new badmeasure(PMX_ERR_MULTIPLE_VOICES, i+1, 0, 3 /*dummy */,  128 /*dummy */);
			badlist_.append(bad);
		}
		voice_elem = staff_elem->getVoiceNr(0);
		clef = voice_elem->getFirstClef();
		switch (clef->getSubType()) {
			case BASS_CLEF: out_ << "b"; break;
			case SOPRANO_CLEF: out_ << "s"; break;
			case ALTO_CLEF: out_ << "a"; break;
			case TENOR_CLEF: out_ << "n"; break;
			case DRUM_CLEF: if (!drum_problem_written_) {
						drum_problem_written_ = true;
						bad = new badmeasure(PMX_ERR_DRUM_STAFF, i+1, 0, 3 /*dummy */,  128 /*dummy */);
						badlist_.append(bad);
					}
			case DRUM_BASS_CLEF: if (!drum_problem_written_) {
						drum_problem_written_ = true;
						bad = new badmeasure(PMX_ERR_DRUM_STAFF, i+1, 0, 3 /*dummy */,  128 /*dummy */);
						badlist_.append(bad);
					    }
			default: out_ << "t"; break;
		}
		for (j = 0; j < voice_count && j < 2; j++)  {
			voice_elem = staff_elem->getVoiceNr(j);
			voice_elem->prepareForWriting();
		}
	}
	out_ << endl << "./" << endl;
	mStaffInf_->writeAkkoladen(&out_, true);
	if (!mStaffInf_->ContinuedBarLines()) {
		if (mStaffInf_->DiscontOutsidePiano()) {
			bad = new badmeasure(PMX_ERR_INDIV_BAR, 1 /* dummy */, 0 /* dummy */, 3 /*dummy */,  128 /*dummy */);
			badlist_.append(bad);
			out_ << "\\\\input musixdbr.tex\\relax\\" << endl;
			out_ << "\\\\indivbarrules\\" << endl << "\\\\allbarrules\\sepbarrule";
			for (i = 0; i < (int)staffList_->count(); i++) {
				if (mainWidget_->barCont_[i].valid) {
					for (j = mainWidget_->barCont_[i].beg; j < mainWidget_->barCont_[i].end; j++) {
						idx = mStaffInf_->multistaffIdxOfStaff(j, &multistaffnr, &numOfStaffsInMultistaff);
						if (idx == numOfStaffsInMultistaff - 1) {
							out_ << "\\conbarrule{" << (mStaffInf_->getMultiStaffCount() - multistaffnr) << '}';
						}
					}
				}
			}
		}
		else {
			out_ << "\\\\sepbarrules";
		}
		out_ << "\\" << endl;
	}
	out_ << "w" << pmxOpts_.width << "m" << endl;
	out_ << "h" << pmxOpts_.height << "m" << endl;
	if (!mainWidget_->scTitle_.isEmpty()) {
		out_ << "Tt" << endl << '{' << mainWidget_->scTitle_ << '}' << endl;
	}
	if (!mainWidget_->scAuthor_.isEmpty()) {
		out_ << "Tc" << endl << '{' << mainWidget_->scAuthor_ << '}' << endl;
	}
/*
	out_ << endl << "\\\\mtxStaffBottom{2}\\" << endl;
	for (i = 0; i < staffsToExport_; i++) {
		out_ << "\\\\mtxInterInstrument{" << (i+1) << "}{-1}\\" << endl;
	}
*/
	do {
		staffsWritten = false;
		first = true;
		out_ << endl << "% Measure " << barNr_ << " - " <<
			  barNr_ + pmxOpts_.measure - 1 << endl;
		for (i = staffList_->count(), staff_elem = staffList_->last(); staff_elem; staff_elem = staffList_->prev(), i--) {
			if (!NResource::staffSelExport_[i-1]) continue;
			voice_count = staff_elem->voiceCount();
			for (j = 0; j < voice_count && j < 2; j++)  {
				voice_elem = staff_elem->getVoiceNr(j);
				endOfLine = j == 0 ? "/" : "//";
				pmxout_ = pmxout[j];
				if (j == 0) barpos = (1 << 30); /* infinity */
				lastLength_ = 1000; /* invalidate */
				lastTone_ = 1000; /* invalidate */
				if (writeTrack(voice_elem, i, j, 
					voice_count, pmxOpts_.measure, first, endOfLine, &barpos)) {
					staffsWritten = true;
				}
			}
			first = false;
			if (staffsWritten) {
				for (j = voice_count > 1 ? 1 : 0; j >= 0; j--)  {
					lineOut(pmxout[j]);
#if GCC_MAJ_VERS > 2
					delete pmxout[j];
					pmxout[j] = new ostringstream();
#else
					pmxout[j]->seekp(0);
#endif
				}
			}
		}
		barNr_ += pmxOpts_.measure;
	}
	while (staffsWritten);
	out_.close();
	if (NResource::staffSelExport_ != 0) {
		delete [] NResource::staffSelExport_;
		NResource::staffSelExport_ = 0;
	}
	delete mStaffInf_;
	if (!badlist_.isEmpty()) {
		QString output;
		output = i18n
			("NoteEdit has exported the score to PMX format but there are some problems which can prevent successful PostScript/PDF output or can change the final score layout.\n");
		output += i18n("-----------------------------------------------------\n");
		for (bad = badlist_.first(); bad; bad = badlist_.next()) {
			switch (bad->kind) {
				case PMX_ERR_BAD_NOTE_COUNT :
				      output += i18n
					( "Staff %1, measure %2: %3 128th, should be: %4\n").
					arg(bad->track).arg(bad->measure).arg(bad->realcount).arg(bad->shouldbe);
				      break;
				case PMX_ERR_MULTIREST :
				      output += i18n
					( "Staff %1, measure %2: PMX cannot deal with multi rests if more than 1 staff is exported").
					arg(bad->track).arg(bad->measure);
				      break;
				case PMX_ERR_TOO_MANY_TIES:
					output += i18n
					( "measure %1: Too many opened ties\n").arg(bad->measure);
					break;
				case PMX_ERR_TOO_MANY_SLURS:
					output += i18n
					( "measure %1: Too many opened slurs\n").arg(bad->measure);
					break;
				case PMX_ERR_NOT_NUM_TUMPLET:
					output += i18n
					("Staff %1, measure %2: PMX can only deal with equal tuplet members or members in ratio 2:1\n").
					arg(bad->track).arg(bad->measure);
					break;
				case PMX_ERR_TUPLET_ENDS_REST:
					output += i18n
					("Staff %1, measure %2: In PMX tuplet cannot end with a rest\n").
					arg(bad->track).arg(bad->measure);
					break;
				case PMX_ERR_MULTIPLE_VOICES:
					output += i18n
						("PMX cannot deal with more than 2 voices per staff\n");
					break;
				case PMX_ERR_DRUM_STAFF:
					output += i18n
						("Staff %1 contains drum staff. This cannot be expressed in PMX.\n")
						.arg(bad->track);
					break;
				case PMX_WARN_MIXED_GRACES:
					output += i18n
					("Staff %1, measure %2: PMX cannot deal with mixed graces\n").
					arg(bad->track).arg(bad->measure);
					break;
				case PMX_ERR_GRACES:
					output += i18n
					("Staff %1, measure %2: grace has no main note. PMX will not work\n").
					arg(bad->track).arg(bad->measure);
					break;
				case PMX_TUPLET_LENGTH:
					output += i18n
					("Staff %1, measure %2: Tuplet must be expressible by on (ev. dotted) note. PMX will not work\n").
					arg(bad->track).arg(bad->measure);
					break;
				case PMX_ERR_INDIV_BAR:
					output += i18n
					("The score has individual bar layout (partial continued and partial discontinued)\nPlease install \"musixdbr.tex\" by  Rainer Dunker\n");
					break;
				case PMX_ERR_DISCONT_PIANO:
					output += i18n
					("The score has piano staffs with discontinued bar rules. This cannot be expressed in PMX\n");
					break;
				case PMX_ERR_NESTED_VAS:
					output += i18n
					("Nested trills in measure: %1 ;\n").arg(bad->measure);
					break;
				case PMX_ERR_TOO_MANY_VAS:
					output += i18n
					("Too many va lines in measure: %1: maximum = 6\n").arg(bad->measure);
					break;
			}
		}
		NResource::exportWarning_->setOutput(i18n ("PMX produced. But there are some problems."), &output);
		NResource::exportWarning_->show();
	}
}