/*
* getopt_internal --
*  Parse argc/argv argument vector.  Called by user level routines.
*/
static int
getopt_internal(int nargc, char * const *nargv, const char *options,
const struct option *long_options, int *idx, int flags)
{
    const char *oli;                /* option letter list index */
    int optchar, short_too;
    static int posixly_correct = -1;

    if (options == NULL)
        return (-1);

    /*
    * XXX Some GNU programs (like cvs) set optind to 0 instead of
    * XXX using optreset.  Work around this braindamage.
    */
    if (optind == 0)
        optind = optreset = 1;

    /*
    * Disable GNU extensions if POSIXLY_CORRECT is set or options
    * string begins with a '+'.
    */
	if (posixly_correct == -1 || optreset){
		char *p;
		size_t len;
		auto ret=_dupenv_s(&p, &len, "POSIXLY_CORRECT");
		posixly_correct = (ret == 0);
	}
    if (*options == '-')
        flags |= FLAG_ALLARGS;
    else if (posixly_correct || *options == '+')
        flags &= ~FLAG_PERMUTE;
    if (*options == '+' || *options == '-')
        options++;

    optarg = NULL;
    if (optreset)
        nonopt_start = nonopt_end = -1;
start:
    if (optreset || !*place) {      /* update scanning pointer */
        optreset = 0;
        if (optind >= nargc) {          /* end of argument vector */
            place = EMSG;
            if (nonopt_end != -1) {
                /* do permutation, if we have to */
                permute_args(nonopt_start, nonopt_end,
                    optind, nargv);
                optind -= nonopt_end - nonopt_start;
            }
            else if (nonopt_start != -1) {
                /*
                * If we skipped non-options, set optind
                * to the first of them.
                */
                optind = nonopt_start;
            }
            nonopt_start = nonopt_end = -1;
            return (-1);
        }
        if (*(place = nargv[optind]) != '-' ||
            (place[1] == '\0' && strchr(options, '-') == NULL)) {
            place = EMSG;       /* found non-option */
            if (flags & FLAG_ALLARGS) {
                /*
                * GNU extension:
                * return non-option as argument to option 1
                */
                optarg = nargv[optind++];
                return (INORDER);
            }
            if (!(flags & FLAG_PERMUTE)) {
                /*
                * If no permutation wanted, stop parsing
                * at first non-option.
                */
                return (-1);
            }
            /* do permutation */
            if (nonopt_start == -1)
                nonopt_start = optind;
            else if (nonopt_end != -1) {
                permute_args(nonopt_start, nonopt_end,
                    optind, nargv);
                nonopt_start = optind -
                    (nonopt_end - nonopt_start);
                nonopt_end = -1;
            }
            optind++;
            /* process next argument */
            goto start;
        }
        if (nonopt_start != -1 && nonopt_end == -1)
            nonopt_end = optind;

        /*
        * If we have "-" do nothing, if "--" we are done.
        */
        if (place[1] != '\0' && *++place == '-' && place[1] == '\0') {
            optind++;
            place = EMSG;
            /*
            * We found an option (--), so if we skipped
            * non-options, we have to permute.
            */
            if (nonopt_end != -1) {
                permute_args(nonopt_start, nonopt_end,
                    optind, nargv);
                optind -= nonopt_end - nonopt_start;
            }
            nonopt_start = nonopt_end = -1;
            return (-1);
        }
    }

    /*
    * Check long options if:
    *  1) we were passed some
    *  2) the arg is not just "-"
    *  3) either the arg starts with -- we are getopt_long_only()
    */
    if (long_options != NULL && place != nargv[optind] &&
        (*place == '-' || (flags & FLAG_LONGONLY))) {
        short_too = 0;
        if (*place == '-')
            place++;        /* --foo long option */
        else if (*place != ':' && strchr(options, *place) != NULL)
            short_too = 1;      /* could be short option too */

        optchar = parse_long_options(nargv, options, long_options,
            idx, short_too);
        if (optchar != -1) {
            place = EMSG;
            return (optchar);
        }
    }

    if ((optchar = (int)*place++) == (int)':' ||
        (optchar == (int)'-' && *place != '\0') ||
        (oli = strchr(options, optchar)) == NULL) {
        /*
        * If the user specified "-" and  '-' isn't listed in
        * options, return -1 (non-option) as per POSIX.
        * Otherwise, it is an unknown option character (or ':').
        */
        if (optchar == (int)'-' && *place == '\0')
            return (-1);
        if (!*place)
            ++optind;
        if (PRINT_ERROR)
            warnx(illoptchar, optchar);
        optopt = optchar;
        return (BADCH);
    }
    if (long_options != NULL && optchar == 'W' && oli[1] == ';') {
        /* -W long-option */
        if (*place)         /* no space */
            /* NOTHING */;
        else if (++optind >= nargc) {   /* no arg */
            place = EMSG;
            if (PRINT_ERROR)
                warnx(recargchar, optchar);
            optopt = optchar;
            return (BADARG);
        }
        else              /* white space */
            place = nargv[optind];
        optchar = parse_long_options(nargv, options, long_options,
            idx, 0);
        place = EMSG;
        return (optchar);
    }
    if (*++oli != ':') {            /* doesn't take argument */
        if (!*place)
            ++optind;
    }
    else {                /* takes (optional) argument */
        optarg = NULL;
        if (*place)         /* no white space */
            optarg = place;
        else if (oli[1] != ':') {   /* arg not optional */
            if (++optind >= nargc) {    /* no arg */
                place = EMSG;
                if (PRINT_ERROR)
                    warnx(recargchar, optchar);
                optopt = optchar;
                return (BADARG);
            }
            else
                optarg = nargv[optind];
        }
        place = EMSG;
        ++optind;
    }
    /* dump back option letter */
    return (optchar);
}